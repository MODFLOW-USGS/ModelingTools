{@abstract(The main purpose of @name is to define
 @link(TfrmScreenObjectProperties) which is
 used to edit one or more
 @link(ScreenObjectUnit.TScreenObject)s.)

@author(Richard B. Winston <rbwinst@usgs.gov>)
}

{When adding new places where PEST can be used, EnablePestCells
 and GetPestParameterAllowed need to be updated. EnablePestCells is assigned
 in FormCreate
 }
unit frmScreenObjectPropertiesUnit;      

interface

uses System.UITypes, Windows,
  SysUtils, Types, Classes, Graphics, Controls, Forms, Dialogs, StdCtrls,
  frmCustomGoPhastUnit, ExtCtrls, Buttons, ScreenObjectUnit, ClassificationUnit,
  Grids, RbwDataGrid4, ComCtrls, RbwParser, DataSetUnit, Contnrs,
  GoPhastTypes, PhastDataSets, framePhastInterpolationUnit, ModflowBoundaryUnit,
  RealListUnit, ArgusDataEntry, RbwEdit, FastGEO, OrderedCollectionUnit,
  JvPageList, JvExExtCtrls, JvNetscapeSplitter, JvExControls,
  JvExComCtrls, JvPageListTreeView, JvxCheckListBox, frameScreenObjectParamUnit,
  ImgList, UndoItemsScreenObjects, frameScreenObjectCondParamUnit,
  frameScreenObjectNoParamUnit, frameScreenObjectLAK_Unit, FluxObservationUnit,
  frameScreenObjectSFR_Unit, JvComCtrls,
  frameHeadObservationsUnit, frameHfbScreenObjectUnit, Mask, JvExMask, JvSpin,
  ValueArrayStorageUnit, frameIfaceUnit, frameModpathParticlesUnit,
  frameFluxObsUnit, ModflowPackageSelectionUnit, frameScreenObjectMNW2Unit,
  frameScreenObjectHydmodUnit, CheckLst, frameScreenObjectUnit,
  frameScreenObjectSsmUnit, frameCustomCellObservationUnit,
  frameConcentrationObservationUnit, CustomFrameFluxObsUnit,
  frameMt3dmsFluxObsUnit, frameCustomSutraFeatureUnit, frameScreenObjectWelUnit,
  frameSutraObservationsUnit, frameSutraBoundaryUnit, frameScreenObjectStrUnit,
  frameScreenObjectFhbHeadUnit, frameScreenObjectFhbFlowUnit,
  frameScreenObjectFmpBoundaryUnit,
  frameScreenObjectFmpPrecipUnit, frameScreenObjectFmpEvapUnit,
  frameScreenObjectCropIDUnit, frameScreenObjectCfpPipesUnit,
  frameScreenObjectCfpFixedUnit, frameScreenObjectSwrUnit,
  frameScreenObjectSwrReachUnit, ModflowSwrReachUnit, frameScreenObjectMnw1Unit,
  frameScreenObjectFarmIDUnit, frameScreenObjectFootprintWellUnit,
  frameSwiObsInterpolatedUnit, frameScreenObjectRIPUnit, frameSutraLakeUnit,
  frameActivatibleFeatureUnit, SutraBoundaryUnit,
  frameSutraGeneralizedFlowBoundaryUnit, frameSutraGeneralizeTransBoundaryUnit,
  System.Generics.Collections, frameScreenObjectSfr6Unit, System.ImageList,
  frameScreenObjectMawUnit, GrayTabs, frameScreenObjectObsMf6Unit,
  frameScreenObjectHfbMf6Unit, ModflowHfbUnit, frameScreenObjectLakMf6Unit,
  frameScreenObjectMvrUnit, ModflowMvrUnit, frameScreenObjectUzfMf6Unit,
  frameScreenObjectLktUnit, frameScreenObjectMt3dSftUnit,
  frameScreenObjectTabbedUnit, frameScreenObjectCSubUnit, framePestObsUnit,
  frameSubPestObsUnit, framePestObsCaptionedUnit, SutraPestObsUnit,
  frameScreenObjectCncUnit, frameCustomGwtBoundaryUnit, frameScreenObjectSrcUnit,
  frameScreenObjectCustomFmp4BoundaryUnit, frameScreenObjectFmp4EfficiencyUnit,
  frameScreenObjectFmp4EfficiencyImprovementUnit,
  frameScreenObjectBareRunoffFractionUnit,
  frameScreenObjectFmp4BarePrecipitationConsumptionFractionUnit,
  frameScreenObjectFmp4BareEvapUnit, frameScreenObjectFmp4DirectRechargeUnit,
  frameScreenObjectFmp4PrecipPotConsumptionUnit,
  frameScreenObjectFmp4NrdInfilLocUnit,
  frameScreenObjectCustomFmp4IntBoundaryUnit,
  frameScreenObjectFmp4CropCoefficientUnit,
  frameScreenObjectLandUseAreaFractionUnit,
  frameScreenObjectCustomFmp4MultBoundaryUnit,
  frameScreenObjectMultLandUseAreaFractionUnit,
  frameScreenObjectMultCropCoefficientsUnit,
  frameScreenObjectFmp4ConsumptiveUseUnit,
  frameScreenObjectMultConsumptiveUseUnit, frameScreenObjectFmp4IrrigationUnit,
  frameScreenObjectMultIrrigationUnit, frameScreenObjectFmp4RootDepthUnit,
  frameScreenObjectMultRootDepthUnit,
  frameScreenObjectFmp4TranspirationFractionUnit,
  frameScreenObjectMultTranspirationFractionUnit,
  frameScreenObjectFmp4EvaporationIrrigationFractionUnit,
  frameScreenObjectMultEvaporationIrrigationFractionUnit,
  frameScreenObjectFmp4FractionOfPrecipToSurfaceWaterUnit,
  frameScreenObjectMultFractionOfPrecipToSurfaceWaterUnit,
  frameScreenObjectFmp4FractionOfIrrigToSurfaceWaterUnit,
  frameScreenObjectMultFractionOfIrrigToSurfaceWaterUnit,
  frameScreenObjectFmp4AddedDemandUnit, frameScreenObjectMultAddedDemandUnit,
  frameScreenObjectFmp4CropHasSalinityRequirementUnit,
  frameScreenObjectMultCropHasSalinityDemandUnit,
  frameScreenObjectAddedDemandRunoffSplitUnit,
  frameDynamicScreenObjectsContainerUnit, Modflow6DynamicTimeSeriesUnit,
  frameScreenObjectCfpRechargeFractionUnit, frameScreenObjectTransientKUnit,
  frameScreenObjectTransientSUnit;

  { TODO : Consider making this a property sheet like the Object Inspector that
  could stay open at all times.  Boundary conditions and vertices might be
  accessed through an property editor. }

  { TODO : Consider using a non-modal window here. }

type
  // @name is used in storing values for MODFLOW parameters.
  TTimeValues = record
    TimeOK: boolean;
    StartTime: double;
    EndTime: double;
  end;

  TTimeArray = array of TTimeValues;

  TParameterTime = class(TObject)
  public
    StartTime: double;
    EndTime: double;
  end;

  TGetBoundaryCollectionEvent =
    function (Boundary: TModflowBoundary): TCustomMF_BoundColl of Object;

  TParameterTimeList = class(TObject)
  private
    FList: TList;
    FSorted: boolean;
    function GetCount: integer;
    function GetItems(Index: integer): TParameterTime;
    procedure SetItems(Index: integer; const Value: TParameterTime);
    procedure SetSorted(const Value: boolean);
  public
    procedure Add(Item: TParameterTime);
    property Count: integer read GetCount;
    constructor Create;
    procedure Delete(Index: integer);
    Destructor Destroy; override;
    property Items[Index: integer]: TParameterTime read GetItems write SetItems; default;
    procedure Sort;
    property Sorted: boolean read FSorted write SetSorted;
    function IndexOfTime(const StartTime, EndTime: double): integer;
  end;

  // @name represents the columns for the grid used for the well intervals
  // in the well boundary condition
  // (TfrmScreenObjectProperties.@link(
  // TfrmScreenObjectProperties.dgWellElevations)).
  TWellIntervalColumns = (wicNone, wicFirst, wicSecond);

  {@abstract(@name is used to edit one or more
   @link(ScreenObjectUnit.TScreenObject)s.)  When a
   @link(ScreenObjectUnit.TScreenObject)
   is first created, @link(GetData) is called to read
   the @link(ScreenObjectUnit.TScreenObject) properties
   and TfrmScreenObjectProperties.@link(
   TfrmScreenObjectProperties.SetData) is called to set the
   @link(ScreenObjectUnit.TScreenObject) properties.  When one or
   more @link(ScreenObjectUnit.TScreenObject)s are being edited,
   @link(GetDataForMultipleScreenObjects) is called
   to read the data and @link(SetMultipleScreenObjectData)
   is called to set the
   @link(ScreenObjectUnit.TScreenObject) properties.}
  TfrmScreenObjectProperties = class(TfrmCustomGoPhast)
    // @name is the parent of controls related to MODFLOW packages.
    tabModflowBoundaryConditions: TTabSheet;
    jvtlModflowBoundaryNavigator: TJvPageListTreeView;
    jvplModflowBoundaries: TJvPageList;
    splttrModflowFeature: TJvNetscapeSplitter;
    jvspCHD: TJvStandardPage;
    frameChdParam: TframeScreenObjectParam;
    // @name stores the checkbox images for @link(jvtlModflowBoundaryNavigator).
    ilCheckImages: TImageList;
    jvspGHB: TJvStandardPage;
    frameGhbParam: TframeScreenObjectCondParam;
    jvspWell: TJvStandardPage;
    frameWellParam: TframeScreenObjectWel;
    jvspRIV: TJvStandardPage;
    frameRivParam: TframeScreenObjectCondParam;
    jvspDRN: TJvStandardPage;
    frameDrnParam: TframeScreenObjectCondParam;
    jvspDRT: TJvStandardPage;
    frameDrtParam: TframeScreenObjectCondParam;
    pnlDrtLocation: TPanel;
    comboDrtLocationChoice: TComboBox;
    lblReturnLocationMethod: TLabel;
    pcDrtReturnLChoice: TJvPageControl;
    tabDrtNone: TTabSheet;
    tabDrtObject: TTabSheet;
    tabDrtLocation: TTabSheet;
    tabDrtCell: TTabSheet;
    comboDrtReturnObject: TComboBox;
    rdeDrtX: TRbwDataEntry;
    rdeDrtY: TRbwDataEntry;
    rdeDrtZ: TRbwDataEntry;
    lblDrtX: TLabel;
    lblDrtY: TLabel;
    lblDrtZ: TLabel;
    lblDrtCol: TLabel;
    lblDrtRow: TLabel;
    lblDrtLay: TLabel;
    rdeDrtLay: TRbwDataEntry;
    rdeDrtRow: TRbwDataEntry;
    rdeDrtCol: TRbwDataEntry;
    jvspRCH: TJvStandardPage;
    frameRchParam: TframeScreenObjectParam;
    jvspBlank: TJvStandardPage;
    jvspEVT: TJvStandardPage;
    frameEvtParam: TframeScreenObjectParam;
    jvspETS: TJvStandardPage;
    frameEtsParam: TframeScreenObjectParam;
    jvspRES: TJvStandardPage;
    frameRes: TframeScreenObjectNoParam;
    jvspLAK: TJvStandardPage;
    frameLak: TframeScreenObjectLAK;
    jvspSFR: TJvStandardPage;
    frameScreenObjectSFR: TframeScreenObjectSFR;
    jvspUZF: TJvStandardPage;
    frameScreenObjectUZF: TframeScreenObjectNoParam;
    pnlUzfGage: TPanel;
    cbUzfGage1: TCheckBox;
    cbUzfGage2: TCheckBox;
    cbUzfGage3: TCheckBox;
    pnlDataSets: TPanel;
    JvNetscapeSplitter2: TJvNetscapeSplitter;
    Panel1: TPanel;
    lblDataSetFormula: TLabel;
    // @name is used to edit the formula of a data set when the user
    // clicks the button in above @link(reDataSetFormula).
    btnDataSetFormula: TButton;
    Panel2: TPanel;
    tvDataSets: TTreeView;
    jvspHOB: TJvStandardPage;
    frameHeadObservations: TframeHeadObservations;
    jvspHFB: TJvStandardPage;
    frameHfbBoundary: TframeHfbScreenObject;
    jvplObjectInfo: TJvPageList;
    jvspSingleObject: TJvStandardPage;
    jvspMultipleObjects: TJvStandardPage;
    lblNames: TLabel;
    memoNames: TMemo;
    tabImportedData: TTabSheet;
    rdgImportedData: TRbwDataGrid4;
    gbObjectInfo: TGroupBox;
    lblObjectLength: TLabel;
    edObjectLength: TEdit;
    lblObjectArea: TLabel;
    edObjectArea: TEdit;
    lblObjectOrder: TLabel;
    edObjectOrder: TEdit;
    jvspModpath: TJvStandardPage;
    frameIface: TframeIface;
    frameModpathParticles: TframeModpathParticles;
    jvspCHOB: TJvStandardPage;
    frameCHOB: TframeFluxObs;
    jvspDROB: TJvStandardPage;
    frameDROB: TframeFluxObs;
    jvspGBOB: TJvStandardPage;
    frameGBOB: TframeFluxObs;
    jvspRVOB: TJvStandardPage;
    frameRVOB: TframeFluxObs;
    Panel3: TPanel;
    reDataSetComment: TRichEdit;
    lblDataComment: TLabel;
    lblAssociatedModelDataSets: TLabel;
    reAssocModDataSets: TRichEdit;
    jvspGAGE: TJvStandardPage;
    cbGageStandard: TCheckBox;
    cbGage1: TCheckBox;
    cbGage2: TCheckBox;
    cbGage3: TCheckBox;
    cbGage5: TCheckBox;
    cbGage6: TCheckBox;
    cbGage7: TCheckBox;
    lblGageCaption: TLabel;
    btnCopyVertices: TButton;
    jvspMNW2: TJvStandardPage;
    frameMNW2: TframeScreenObjectMNW2;
    tabComments: TTabSheet;
    memoComments: TMemo;
    lblComments: TLabel;
    jvspHYDMOD: TJvStandardPage;
    frameHydmod: TframeScreenObjectHydmod;
    tabLGR: TTabSheet;
    tabVertexValues: TTabSheet;
    rdgVertexValues: TRbwDataGrid4;
    pnlLgrTop: TPanel;
    pnlLgrBottom: TPanel;
    clbChildModels: TJvxCheckListBox;
    lblLgrChildModel: TLabel;
    Splitter1: TSplitter;
    lblObjectUsedWithModels: TLabel;
    cbLgrAllModels: TCheckBox;
    clbLgrUsedModels: TCheckListBox;
    cbLock: TCheckBox;
    jvspMT3DMS_SSM: TJvStandardPage;
    frameMT3DMS_SSM: TframeScreenObjectSsm;
    jvspMT3DMS_TOB_Conc: TJvStandardPage;
    frameMt3dmsTobConc: TframeConcentrationObservation;
    jvspMT3DMS_TOB_Flux: TJvStandardPage;
    frameMt3dmsFluxObs: TframeMt3dmsFluxObs;
    reDataSetFormula: TRichEdit;
    tabSutraFeatures: TTabSheet;
    jvplSutraFeatures: TJvPageList;
    jvpltvSutraFeatures: TJvPageListTreeView;
    splttrSutraFeatures: TJvNetscapeSplitter;
    jvspSutraObservations: TJvStandardPage;
    frameSutraObservations: TframeSutraObservations;
    jvspSutraSpecifiedPressure: TJvStandardPage;
    jvspSutraSpecTempConc: TJvStandardPage;
    jvspSutraFluidFlux: TJvStandardPage;
    jvspSutraMassEnergyFlux: TJvStandardPage;
    frameSutraSpecifiedPressure: TframeSutraBoundary;
    frameSutraSpecTempConc: TframeSutraBoundary;
    frameSutraFluidFlux: TframeSutraBoundary;
    frameSutraMassEnergyFlux: TframeSutraBoundary;
    jvspSutraBlank: TJvStandardPage;
    cbDuplicatesAllowed: TCheckBox;
    jvspSTR: TJvStandardPage;
    frameScreenObjectSTR: TframeScreenObjectStr;
    jvspSTOB: TJvStandardPage;
    frameSTOB: TframeFluxObs;
    jvspFhbHeads: TJvStandardPage;
    frameFhbHead: TframeScreenObjectFhbHead;
    jvspFhbFlows: TJvStandardPage;
    frameFhbFlow: TframeScreenObjectFhbFlow;
    jvspFarmWell: TJvStandardPage;
    frameFarmWell: TframeScreenObjectCondParam;
    jvspFarmPrecip: TJvStandardPage;
    frameFarmPrecip: TframeScreenObjectFmpPrecip;
    jvspFarmRefEvap: TJvStandardPage;
    frameFarmRefEvap: TframeScreenObjectFmpEvap;
    jvspFarmCropID: TJvStandardPage;
    frameFarmCropID: TframeScreenObjectCropID;
    jvspCfpPipes: TJvStandardPage;
    frameCfpPipes: TframeScreenObjectCfpPipes;
    jvspCfpFixedHeads: TJvStandardPage;
    frameCfpFixedHeads: TframeScreenObjectCfpFixed;
    jvspCfpRechargeFraction: TJvStandardPage;
    jvspSWR_Rain: TJvStandardPage;
    frameSWR_Rain: TframeScreenObjectNoParam;
    jvspSWR_Evap: TJvStandardPage;
    frameSWR_Evap: TframeScreenObjectNoParam;
    jvspSwr_LatInfl: TJvStandardPage;
    jvspSWR_Stage: TJvStandardPage;
    frameSWR_LatInfl: TframeScreenObjectSwr;
    frameSWR_Stage: TframeScreenObjectNoParam;
    jvspSWR_DirectRunoff: TJvStandardPage;
    frameSWR_DirectRunoff: TframeScreenObjectNoParam;
    jvspSwrReaches: TJvStandardPage;
    frameSwrReach: TframeScreenObjectSwrReach;
    splComment: TSplitter;
    cbCaptionVisible: TCheckBox;
    lblCaptionX: TLabel;
    lblCaptionY: TLabel;
    memoCaption: TMemo;
    rdeCaptionX: TRbwDataEntry;
    rdeCaptionY: TRbwDataEntry;
    dlgFontCaption: TFontDialog;
    btnCaptionFont: TButton;
    grpCaption: TGroupBox;
    grpComment: TGroupBox;
    jvspMNW1: TJvStandardPage;
    frameMNW1: TframeScreenObjectMnw1;
    jvspFarmID: TJvStandardPage;
    frameFarmID: TframeScreenObjectFarmID;
    btnConvertTimeUnits: TButton;
    btnEditFeatureFormulas: TButton;
    tabFootprintFeatures: TTabSheet;
    frameScreenObjectFootprintWell: TframeScreenObjectFootprintWell;
    pnlText: TPanel;
    grpLabelVertices: TGroupBox;
    lblVertexXOffset: TLabel;
    lblVertexYOffset: TLabel;
    btnVertexFont: TButton;
    rdeVertexXOffset: TRbwDataEntry;
    rdeVertexYOffset: TRbwDataEntry;
    cbVertexLabelVisible: TCheckBox;
    rdeMinimumCellFraction: TRbwDataEntry;
    lblMinimumCellFraction: TLabel;
    jvspSWI_Obs: TJvStandardPage;
    frameSwiObs: TframeSwiObsInterpolated;
    jvspRIP: TJvStandardPage;
    frameRIP: TframeScreenObjectRIP;
    jvspSutraLake: TJvStandardPage;
    frameSutraLake: TframeSutraLake;
    jvspGeneralizedFlow: TJvStandardPage;
    frameSutraGeneralizedFlowBoundary: TframeSutraGeneralizedFlowBoundary;
    jvspGeneralizedTransport: TJvStandardPage;
    frameSutraGeneralizeTransBoundary: TframeSutraGeneralizeTransBoundary;
    comboVertexValueLabels: TComboBox;
    lblVertexValueLabels: TLabel;
    jvspMT3D_UZT_Rech: TJvStandardPage;
    frameMt3d_UZT_Rech: TframeScreenObjectNoParam;
    jvspMT3D_UZT_Unsat: TJvStandardPage;
    jvspMT3D_UZT_Sat: TJvStandardPage;
    frameMt3d_UZT_Sat: TframeScreenObjectNoParam;
    frameMt3d_UZT_Unsat: TframeScreenObjectNoParam;
    jvspMT3D_Uzf_Ssm_Conc: TJvStandardPage;
    frameMT3D_Uzf_Ssm_Conc: TframeScreenObjectNoParam;
    jvspSFR6: TJvStandardPage;
    frameScreenObjectSfr6: TframeScreenObjectSfr6;
    btnCopyImportedData: TButton;
    jvspMAW: TJvStandardPage;
    frameMAW: TframeScreenObjectMAW;
    lblQuadTreeRefinement: TLabel;
    rdeQuadTreeRefinement: TRbwDataEntry;
    jvspMf6Obs: TJvStandardPage;
    frameObsMf6: TframeScreenObjectObsMf6;
    jvspHFB_MF6: TJvStandardPage;
    frameHfbMf6: TframeScreenObjectHfbMf6;
    jvspLakMf6: TJvStandardPage;
    frameLakMf6: TframeScreenObjectLakMf6;
    jvspMVR: TJvStandardPage;
    frameMVR: TframeScreenObjectMvr;
    jvspUzfMf6: TJvStandardPage;
    frameScreenObjectUzfMf6: TframeScreenObjectUzfMf6;
    pnl1: TPanel;
    lblLayerElevationExplaination: TLabel;
    jvspMTD_Lkt: TJvStandardPage;
    frameMT3D_LKT: TframeScreenObjectLkt;
    jvspMT3D_SFT: TJvStandardPage;
    frameMT3D_SFT: TframeScreenObjectMt3dSft;
    jvspCSUB: TJvStandardPage;
    frameCSUB: TframeScreenObjectCSub;
    pnlGageTop: TPanel;
    pcGage: TPageControl;
    tabGageTypes: TTabSheet;
    tabGageObservations: TTabSheet;
    frameGagePestObs: TframePestObs;
    jvspSubPestObs: TJvStandardPage;
    framePestObsSub: TframeSubPestObs;
    jvspSwtPestObs: TJvStandardPage;
    framePestObsSwt: TframeSubPestObs;
    jvspSutraStateObs: TJvStandardPage;
    frameSutraPestObsState: TframePestObsCaptioned;
    jvspSutraSpecPresObs: TJvStandardPage;
    frameSutraSpecPresObs: TframeFluxObs;
    jvspSutraSpecFlowObs: TJvStandardPage;
    frameSutraSpecifiedFluidFlowObs: TframeFluxObs;
    jvspSutraSpecUObs: TJvStandardPage;
    jvspSutraGenFlowObs: TJvStandardPage;
    jvspSutraGenTransObs: TJvStandardPage;
    frameSutraGenFlowObs: TframeFluxObs;
    frameSutraGenTransObs: TframeFluxObs;
    frameSutraSpecUObs: TframeFluxObs;
    jvspGwtCNC: TJvStandardPage;
    frameGwtCnc: TframeScreenObjectCnc;
    jvspGwtSRC: TJvStandardPage;
    frameGwtSRC: TframeScreenObjectSrc;
    jvspFmp4Efficiency: TJvStandardPage;
    frameFmp4Efficiency: TframeScreenObjectFmp4Efficiency;
    jvspFmp4EfficiencyImprovement: TJvStandardPage;
    frameFmp4EfficiencyImprovement: TframeScreenObjectFmp4EfficiencyImprovement;
    jvspFmp4BareRunoffFraction: TJvStandardPage;
    frameFmp4BareRunoffFraction: TframeScreenObjectBareRunoffFraction;
    jvspFmp4BarePrecipitationConsumptionFraction: TJvStandardPage;
    frameFmp4BarePrecipitationConsumptionFraction: TframeScreenObjectFmp4BarePrecipitationConsumptionFraction;
    jvspFmp4BareEvap: TJvStandardPage;
    frameFmp4BareEvap: TframeScreenObjectFmp4BareEvap;
    jvspFmp4DirectRecharge: TJvStandardPage;
    frameFmp4DirectRecharge: TframeScreenObjectFmp4DirectRecharge;
    jvspFmp4PrecipPotConsumption: TJvStandardPage;
    frameFmp4PrecipPotConsumption: TframeScreenObjectFmp4PrecipPotConsumption;
    jvspFmp4NrdInfilLoc: TJvStandardPage;
    frameFmp4NrdInfilLocation: TframeScreenObjectFmp4NrdInfilLoc;
    jvspFmp4LandUseAreaFraction: TJvStandardPage;
    frameFmp4LandUseAreaFraction: TframeScreenObjectLandUseAreaFraction;
    jvspFmp4LandUseAreaFractionMult: TJvStandardPage;
    frameMultLandUseAreaFraction: TframeScreenObjectMultLandUseAreaFraction;
    jvspFmp4CropCoefficient: TJvStandardPage;
    frameFmp4CropCoefficient: TframeScreenObjectFmp4CropCoefficient;
    jvspFmp4CropCoefficientMult: TJvStandardPage;
    frameFmp4MultCropCoefficients: TframeScreenObjectMultCropCoefficients;
    jvspFmp4ConsumptiveUse: TJvStandardPage;
    frameFmp4ConsumptiveUse: TframeScreenObjectFmp4ConsumptiveUse;
    jvspFmp4ConsumptiveUseMult: TJvStandardPage;
    frameFmp4MultConsumptiveUse: TframeScreenObjectMultConsumptiveUse;
    jvspFmp4Irrigation: TJvStandardPage;
    frameFmp4Irrigation: TframeScreenObjectFmp4Irrigation;
    jvspFmp4IrrigationMult: TJvStandardPage;
    frameFmp4MultIrrigation: TframeScreenObjectMultIrrigation;
    jvspFmp4RootDepth: TJvStandardPage;
    frameFmp4RootDepth: TframeScreenObjectFmp4RootDepth;
    jvspFmp4RootDepthMult: TJvStandardPage;
    frameFmp4MultRootDepth: TframeScreenObjectMultRootDepth;
    jvspFmp4TranspirationFraction: TJvStandardPage;
    frameFmp4TranspirationFraction: TframeScreenObjectFmp4TranspirationFraction;
    jvspFmp4TranspirationFractionMult: TJvStandardPage;
    frameFmp4MultTranspirationFraction: TframeScreenObjectMultTranspirationFraction;
    Panel4: TPanel;
    btnImportVertexValues: TButton;
    Panel5: TPanel;
    Button1: TButton;
    jvspFmp4EvaporationIrrigationFraction: TJvStandardPage;
    jvspFmp4EvaporationIrrigationFractionMult: TJvStandardPage;
    frameFmp4EvaporationIrrigationFraction: TframeScreenObjectFmp4EvaporationIrrigationFraction;
    frameFmp4MultEvaporationIrrigationFraction: TframeScreenObjectMultEvaporationIrrigationFraction;
    jvspFmp4FractionOfPrecipToSurfaceWater: TJvStandardPage;
    frameFmp4FractionOfPrecipToSurfaceWater: TframeScreenObjectFmp4FractionOfPrecipToSurfaceWater;
    jvspFmp4FractionOfPrecipToSurfaceWaterMult: TJvStandardPage;
    frameFmp4MultFractionOfPrecipToSurfaceWater: TframeScreenObjectMultFractionOfPrecipToSurfaceWater;
    jvspFmp4FractionOfIrrigToSurfaceWater: TJvStandardPage;
    jvspFmp4FractionOfIrrigToSurfaceWaterMult: TJvStandardPage;
    frameFmp4FractionOfIrrigToSurfaceWater: TframeScreenObjectFmp4FractionOfIrrigToSurfaceWater;
    frameFmp4MultFractionOfIrrigToSurfaceWater: TframeScreenObjectMultFractionOfIrrigToSurfaceWater;
    jvspFmp4AddedDemand: TJvStandardPage;
    jvspFmp4AddedDemandMult: TJvStandardPage;
    frameFmp4AddedDemand: TframeScreenObjectFmp4AddedDemand;
    frameFmp4MultAddedDemand: TframeScreenObjectMultAddedDemand;
    jvspFmp4CropHasSalinityDemand: TJvStandardPage;
    jvspFmp4CropHasSalinityDemandMult: TJvStandardPage;
    frameFmp4CropHasSalinityDemand: TframeScreenObjectFmp4CropHasSalinityRequirement;
    frameFmp4MultCropHasSalinityDemand: TframeScreenObjectMultCropHasSalinityDemand;
    jvspFmp4AddedDemandRunoffSplit: TJvStandardPage;
    frameFmp4AddedDemandRunoffSplit: TframeScreenObjectAddedDemandRunoffSplit;
    tabDynamicTimeSeries: TTabSheet;
    frameDynamicTimeSeries: TframeDynamicScreenObjectsContainer;
    frameCfpRechargeFraction1: TframeScreenObjectCfpRechargeFraction;
    jvspTvk: TJvStandardPage;
    frameScreenObjectTvk: TframeScreenObjectTransientK;
    jvspTvs: TJvStandardPage;
    frameScreenObjectTvs: TframeScreenObjectTransientS;
    Panel6: TPanel;
    gbSectionLabels: TGroupBox;
    lblSectionXOffset: TLabel;
    lblSectionYOffset: TLabel;
    btnSectionFont: TButton;
    rdeSectionXOffset: TRbwDataEntry;
    rdeSectionYOffset: TRbwDataEntry;
    cbSectionLabelVisible: TCheckBox;
    // @name changes which check image is displayed for the selected item
    // in @link(jvtlModflowBoundaryNavigator).
    procedure jvtlModflowBoundaryNavigatorMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure frameChdParamdgModflowBoundaryButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure dgVerticiesBeforeDrawCell(Sender: TObject; ACol, ARow: Integer);
    procedure frameChdParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameChdParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameGhbParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure comboGhbConductanceInterpChange(Sender: TObject);
    procedure frameWellParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameWellParamcomboFormulaInterpChange(Sender: TObject);
    procedure frameRivParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameRivParamcomboFormulaInterpChange(Sender: TObject);
    procedure frameDrnParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameDrnParamcomboFormulaInterpChange(Sender: TObject);
    procedure comboDrtLocationChoiceChange(Sender: TObject);
    procedure frameDrtParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameDrtParamcomboFormulaInterpChange(Sender: TObject);
    procedure rdeDrtLocationControlExit(Sender: TObject);
    procedure frameRchParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameRchParamcomboFormulaInterpChange(Sender: TObject);
    procedure frameEvtParamcomboFormulaInterpChange(Sender: TObject);
    procedure frameEvtParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameEtsParamdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameEtsParamcomboFormulaInterpChange(Sender: TObject);
    procedure frameResdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameLakdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameLakrdeLakeIDChange(Sender: TObject);
    procedure frameLakrdeInitialStageChange(Sender: TObject);
    procedure frameLakrdeSillChange(Sender: TObject);
    procedure frameLakrdeCenterLakeChange(Sender: TObject);
    procedure frameResdgModflowBoundaryButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure frameEtsParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameDrnParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameDrtParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameEvtParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameGhbParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameRchParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameRivParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameWellParamclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure FormShow(Sender: TObject);
    procedure frameScreenObjectSFRjceButtonClick(Sender: TObject);
    procedure frameScreenObjectUZFdgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure cbUzfGage1Click(Sender: TObject);
    procedure cbUzfGage2Click(Sender: TObject);
    procedure cbUzfGage3Click(Sender: TObject);
    procedure comboDrtReturnObjectChange(Sender: TObject);
    procedure frameScreenObjectSFRpcSFRChange(Sender: TObject);
    procedure jvplModflowBoundariesChange(Sender: TObject);
    procedure frameLakcbGagStandardClick(Sender: TObject);
    procedure frameLakcbGagFluxAndCondClick(Sender: TObject);
    procedure frameLakcbGagDeltaClick(Sender: TObject);
    procedure tvDataSetsChange(Sender: TObject; Node: TTreeNode);
    procedure btnDataSetFormulaClick(Sender: TObject);
    procedure reDataSetFormulaEnter(Sender: TObject);
    procedure tvDataSetsMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure reDataSetFormulaChange(Sender: TObject);
    procedure reDataSetFormulaExit(Sender: TObject);
    procedure frameHfbBoundarybtnEditHfbHydraulicConductivityFormulaClick(
      Sender: TObject);
    procedure frameHfbBoundarybtnEditHfbThicknessyFormulaClick(Sender: TObject);
    procedure dgBoundaryFluxDistributeTextProgress(Sender: TObject; Position,
      Max: Integer);
    procedure dgBoundaryLeakyDistributeTextProgress(Sender: TObject; Position,
      Max: Integer);
    procedure dgBoundaryRiverDistributeTextProgress(Sender: TObject; Position,
      Max: Integer);
    procedure dgSpecifiedHeadDistributeTextProgress(Sender: TObject; Position,
      Max: Integer);
    procedure dgWellDistributeTextProgress(Sender: TObject; Position,
      Max: Integer);
    procedure dgWellElevationsDistributeTextProgress(Sender: TObject; Position,
      Max: Integer);
    procedure frameGhbParamcomboFormulaInterpChange(Sender: TObject);
    procedure frameChdParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameWellParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameDrnParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameDrtParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameEtsParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameEvtParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameGhbParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameLakdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameRchParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameResdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameRivParamdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameScreenObjectUZFdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameIfacerbHorizontalClick(Sender: TObject);
    procedure frameModpathParticlesrgChoiceClick(Sender: TObject);
    procedure frameModpathParticlesgbParticlesCheckBoxClick(Sender: TObject);
    procedure frameModpathParticlescbLeftFaceClick(Sender: TObject);
    procedure frameModpathParticlesseXChange(Sender: TObject);
    procedure frameModpathParticlesrgCylinderOrientationClick(Sender: TObject);
    procedure frameModpathParticlesseSpecificParticleCountChange(
      Sender: TObject);
    procedure frameModpathParticlesrdgSpecificSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameModpathParticlesseTimeCountChange(Sender: TObject);
    procedure frameModpathParticlesseCylRadiusClick(Sender: TObject);
    procedure frameChdParamseNumberOfTimesChange(Sender: TObject);
    procedure frameDrnParamseNumberOfTimesChange(Sender: TObject);
    procedure frameDrtParamseNumberOfTimesChange(Sender: TObject);
    procedure frameEtsParamseNumberOfTimesChange(Sender: TObject);
    procedure frameEvtParamseNumberOfTimesChange(Sender: TObject);
    procedure frameGhbParamseNumberOfTimesChange(Sender: TObject);
    procedure frameLakseNumberOfTimesChange(Sender: TObject);
    procedure frameRchParamseNumberOfTimesChange(Sender: TObject);
    procedure frameResseNumberOfTimesChange(Sender: TObject);
    procedure frameRivParamseNumberOfTimesChange(Sender: TObject);
    procedure frameScreenObjectUZFseNumberOfTimesChange(Sender: TObject);
    procedure frameWellParamseNumberOfTimesChange(Sender: TObject);
    procedure frameCHOBrdgObservationGroupsStateChange(Sender: TObject; ACol,
      ARow: Integer; const Value: TCheckBoxState);
    procedure frameCHOBrdgObservationGroupsSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameDROBrdgObservationGroupsStateChange(Sender: TObject; ACol,
      ARow: Integer; const Value: TCheckBoxState);
    procedure frameDROBrdgObservationGroupsSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameGBOBrdgObservationGroupsStateChange(Sender: TObject; ACol,
      ARow: Integer; const Value: TCheckBoxState);
    procedure frameGBOBrdgObservationGroupsSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameRVOBrdgObservationGroupsStateChange(Sender: TObject; ACol,
      ARow: Integer; const Value: TCheckBoxState);
    procedure frameRVOBrdgObservationGroupsSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure rdgImportedDataSetEditText(Sender: TObject; ACol, ARow: Integer;
      const Value: string);
    procedure frameScreenObjectSFRrdgNetworkButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure frameFluxObsbtnAddOrRemoveFluxObservationsClick(Sender: TObject);
    procedure jvtlModflowBoundaryNavigatorChanging(Sender: TObject;
      Node: TTreeNode; var AllowChange: Boolean);
    procedure jvtlModflowBoundaryNavigatorCustomDrawItem(
      Sender: TCustomTreeView; Node: TTreeNode; State: TCustomDrawState;
      var DefaultDraw: Boolean);
    procedure cbGageStandardClick(Sender: TObject);
    procedure frameHeadObservationsrdgHeadsSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure btnCopyVerticesClick(Sender: TObject);
    procedure dgVerticiesEndUpdate(Sender: TObject);
    procedure frameLakcbGage4Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure frameMNW2pcMnw2Change(Sender: TObject);
    procedure dgVerticiesStateChange(Sender: TObject; ACol, ARow: Integer;
      const Value: TCheckBoxState);
    procedure dgVerticiesEnter(Sender: TObject);
    procedure frameHydmodclbBasicClickCheck(Sender: TObject);
    procedure frameHydmodclbSubClickCheck(Sender: TObject);
    procedure frameHydmodclbSFRClickCheck(Sender: TObject);
    procedure clbChildModelsClickCheck(Sender: TObject);
    procedure cbLgrAllModelsClick(Sender: TObject);
    procedure clbLgrUsedModelsClickCheck(Sender: TObject);
    procedure cbLockClick(Sender: TObject);
    procedure frameMT3DMSdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameMT3DMSdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMT3DMSseNumberOfTimesChange(Sender: TObject);
    procedure frameMT3DMScbSpecifiedConcentrationClick(Sender: TObject);
    procedure frameMT3DMScbMassLoadingClick(Sender: TObject);
    procedure frameMt3dmsTobConcrdgObservationsSetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameMt3dmsTobConcseTimesChange(Sender: TObject);
    procedure frameHeadObservationsseTimesChange(Sender: TObject);
    procedure frameMt3dmsFluxObsrdgObservationGroupsSetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameMt3dmsFluxObsrdgObservationGroupsStateChange(Sender: TObject;
      ACol, ARow: Integer; const Value: TCheckBoxState);
    procedure frameHydmodcomboLayerGroupChange(Sender: TObject);
    procedure frameHydmodcomboNoDelayBedChange(Sender: TObject);
    procedure jvpltvSutraFeaturesMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure frameSutraObservationsbtnDeleteClick(Sender: TObject);
    procedure frameSutraObservationsbtnInsertClick(Sender: TObject);
    procedure frameSutraObservationsedNameExit(Sender: TObject);
    procedure SutraBoundaryButtonClick(
      Sender: TObject; ACol, ARow: Integer);
    procedure cbDuplicatesAllowedClick(Sender: TObject);
    procedure frameSTOBrdgObservationGroupsSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameSTOBrdgObservationGroupsStateChange(Sender: TObject; ACol,
      ARow: Integer; const Value: TCheckBoxState);
    procedure frameScreenObjectSTRdgModflowBoundaryButtonClick(Sender: TObject;
      ACol, ARow: Integer);
    procedure frameLakrdgLakeTableEndUpdate(Sender: TObject);
    procedure frameLakfeLakeBathymetryChange(Sender: TObject);
    procedure frameLakrgBathChoiceClick(Sender: TObject);
    procedure jvplSutraFeaturesChange(Sender: TObject);
    procedure frameFarmWellclbParametersStateChange(Sender: TObject;
      Index: Integer);
    procedure frameFarmWelldgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameFarmWelldgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameFarmWellseNumberOfTimesChange(Sender: TObject);
    procedure frameFarmWellcomboFormulaInterpChange(Sender: TObject);
    procedure jvpltvSutraFeaturesCustomDrawItem(Sender: TCustomTreeView;
      Node: TTreeNode; State: TCustomDrawState; var DefaultDraw: Boolean);
    procedure frameSWR_RaindgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameSWR_RaindgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameSWR_RainseNumberOfTimesChange(Sender: TObject);
    procedure frameSWR_EvapdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameSWR_EvapseNumberOfTimesChange(Sender: TObject);
    procedure frameSWR_EvapdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameSWR_LatInfldgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameSWR_LatInflseNumberOfTimesChange(Sender: TObject);
    procedure frameSWR_LatInflcomboFormulaInterpChange(Sender: TObject);
    procedure frameSWR_LatInfldgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameSWR_StagedgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameSWR_StagedgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameSWR_StageseNumberOfTimesChange(Sender: TObject);
    procedure frameSWR_DirectRunoffdgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameSWR_DirectRunoffseNumberOfTimesChange(Sender: TObject);
    procedure frameSWR_DirectRunoffdgModflowBoundaryEndUpdate(Sender: TObject);
    procedure frameSwrdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure cbCaptionVisibleClick(Sender: TObject);
    procedure memoCaptionChange(Sender: TObject);
    procedure btnCaptionFontClick(Sender: TObject);
    procedure btnConvertTimeUnitsClick(Sender: TObject);
    procedure btnEditFeatureFormulasClick(Sender: TObject);
    procedure cbVertexLabelVisibleClick(Sender: TObject);
    procedure btnVertexFontClick(Sender: TObject);
    procedure rdeMinimumCellFractionChange(Sender: TObject);
    procedure frameSwiObsGridSetEditText(Sender: TObject; ACol, ARow: Integer;
      const Value: string);
    procedure frameWellParamfedTabfileChange(Sender: TObject);
    procedure frameMt3d_UZTdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMt3d_UZT_UnsatdgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameMt3d_UZT_SatdgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameMT3D_Uzf_SeepagedgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure btnCopyImportedDataClick(Sender: TObject);
    procedure frmgrdDownstreamSegmentsGridButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure frmgrdDiversionsGridButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure frameHfbMf6rdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameHfbMf6rdgModflowBoundaryButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure frameHfbMf6seNumberOfTimesChange(Sender: TObject);
    procedure frameHfbMf6rgAngleAdjustmentClick(Sender: TObject);
    procedure frameFlowTable1dgSfrTableSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameFlowTable1btnDeleteFlowTableRowClick(Sender: TObject);
    procedure frameFlowTable1btnInsertFlowTableRowClick(Sender: TObject);
    procedure frameFlowTable1seTableCountChange(Sender: TObject);
    procedure frameMT3D_LKTrdgRunoffConcSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMT3D_LKTrdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMT3D_SFTrdgSftInitConcAndDispSetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameMT3D_SFTrdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMT3D_SFTrdgPrecipSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMT3D_SFTrdgRunoffSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMT3D_SFTrdgConstConcSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameMVRrdgModflowBoundaryButtonClick(Sender: TObject; ACol,
      ARow: Integer);
    procedure frameMVRseNumberOfTimesChange(Sender: TObject);
    procedure frameChdParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameDrnParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameEtsParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameGhbParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameRchParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameRivParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameWellParamcomboTimeSeriesInterpolationChange(Sender: TObject);
    procedure frameSutraUObsbtnAddOrRemoveFluxObservationsClick(
      Sender: TObject);
    procedure frameSutraSpecPresObsrdgObservationGroupsStateChange(Sender: TObject;
      ACol, ARow: Integer; const Value: TCheckBoxState);
    procedure frameSutraSpecifiedFluidFlowObsrdgObservationGroupsStateChange(Sender: TObject;
      ACol, ARow: Integer; const Value: TCheckBoxState);
    procedure frameSutraGenFlowObsrdgObservationGroupsStateChange(
      Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
    procedure frameSutraGenTransObsrdgObservationGroupsStateChange(
      Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
    procedure frameSutraSpecUObsrdgObservationGroupsStateChange(Sender: TObject;
      ACol, ARow: Integer; const Value: TCheckBoxState);
    procedure frameChdParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure frameMT3D_SFTrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure dgVerticiesExit(Sender: TObject);
    procedure jvspSutraSpecFlowObsShow(Sender: TObject);
    procedure jvspSutraGenFlowObsShow(Sender: TObject);
    procedure jvspSutraGenTransObsShow(Sender: TObject);
    procedure jvspSutraSpecPresObsShow(Sender: TObject);
    procedure jvspSutraSpecUObsShow(Sender: TObject);
    procedure jvspCSUBShow(Sender: TObject);
    procedure tabModflowBoundaryConditionsShow(Sender: TObject);
    procedure frameGwtCncrdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameGwtCnccomboChemSpeciesChange(Sender: TObject);
    procedure frameGwtSRCrdgModflowBoundarySetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameGwtSRCcomboChemSpeciesChange(Sender: TObject);
    procedure frameObsMf6pgcMainChange(Sender: TObject);
    procedure frameFmp4EfficiencyrdgModflowBoundarySetEditText(Sender: TObject;
      ACol, ARow: Integer; const Value: string);
    procedure frameFmp4EfficiencyseNumberOfTimesChange(Sender: TObject);
    procedure btnImportVertexValuesClick(Sender: TObject);
    procedure frameDynamicTimeSeriesbtnAddGroupClick(Sender: TObject);
    procedure frameScreenObjectTvkrdgModflowBoundarySetEditText(Sender: TObject;
        ACol, ARow: Integer; const Value: string);
    procedure frameScreenObjectTvsrdgModflowBoundarySetEditText(Sender: TObject;
        ACol, ARow: Integer; const Value: string);
    procedure frameScreenObjectSFRdgFlowTimesSetEditText(Sender: TObject; ACol,
      ARow: Integer; const Value: string);
    procedure frameDrnParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure btnSectionFontClick(Sender: TObject);
    procedure frameWellParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure frameRivParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure frameGhbParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure frameRchParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure frameEtsParamrdgModflowBoundarySelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
  published
    // Clicking @name closes the @classname without changing anything.
    // See @link(btnCancelClick),
    btnCancel: TBitBtn;

    // @name is used to change the color used to draw the interior of
    // @link(ScreenObjectUnit.TScreenObject)s.
    // See @link(btnColorClick)
    btnFillColor: TButton;

    // Clicking name displays help on the active page in @link(pageMain).
    btnHelp: TBitBtn;

    // @name is used to edit the formula for the higher elevation
    // in @link(edHighZ).
    // See @link(btnFormulaClick).
    btnHighZ: TButton;

    // @name is used to edit the formula for the leaky hydraulic conductivity
    // in @link(edLeakyHydraulicConductivity).
    // See @link(btnFormulaClick).
    btnLeakyHydraulicConductivity: TButton;

    // @name is used to edit the formula for the
    // thickness of the leaky boundary
    // in @link(edLeakyThickness).
    // See @link(btnFormulaClick).
    btnLeakyThickness: TButton;

    // @name is used to change the color used to draw the lines of
    // @link(ScreenObjectUnit.TScreenObject)s.
    // See @link(btnColorClick)
    btnLineColor: TButton;

    // @name is used to edit the formula for the lower elevation
    // in @link(edLowZ).
    // See @link(btnFormulaClick).
    btnLowZ: TButton;

    // See @link(btnOKClick).
    btnOK: TBitBtn;

    // @name is used to edit the formula for the
    // thickness of the bed in the river boundary
    // in @link(edRiverBedThickness).
    // See @link(btnFormulaClick).
    btnRiverBedThickness: TButton;

    // @name is used to edit the formula for the
    // depth of the river in the river boundary
    // in @link(edRiverDepth).
    // See @link(btnFormulaClick).
    btnRiverDepth: TButton;

    // @name is used to edit the formula for the
    // hydraulic conductivity of the river bed in the river boundary
    // in @link(edRiverHydraulicConductivity).
    // See @link(btnFormulaClick).
    btnRiverHydraulicConductivity: TButton;

    // @name is used to edit the formula for the
    // width of the river in the river boundary
    // in @link(edRiverWidth).
    // See @link(btnFormulaClick).
    btnRiverWidth: TButton;

    // @name is used to edit the formula for the single elevation
    // in @link(edZ).
    // See @link(btnFormulaClick).
    btnZ: TButton;

    { TODO : Change name to remove "cell". }
    // @name specifies whether the values of cells or elements
    // enclosed by the @link(TScreenObject) will be set by the
    // @link(TScreenObject)
    // @seealso(cbEnclosedCellsClick).
    // @seealso(TScreenObject.SetValuesOfEnclosedCells)
    cbEnclosedCells: TCheckBox;

    // @name specifies whether the interior of
    // @link(ScreenObjectUnit.TScreenObject)s
    // will be colored.
    // See @link(cbFillColorClick).
    cbFillColor: TCheckBox;

    // @name specifies whether the values of cells or elements
    // will be set by interpolation using this
    // @link(ScreenObjectUnit.TScreenObject).
    // See @link(cbInterpolationClick).
    cbInterpolation: TCheckBox;

    { TODO : Change name to remove "cell". }
    // @name: TCheckBox;
    // @name specifies whether the values of cells or elements
    // intersected by the @link(TScreenObject) will be set by the
    // @link(TScreenObject)
    // See @link(cbIntersectedCellsClick).
    cbIntersectedCells: TCheckBox;

    // @name specifies whether the lines of
    // @link(ScreenObjectUnit.TScreenObject)s
    // will be colored.
    // See @link(cbLineColorClick).
    cbLineColor: TCheckBox;

    { TODO : Change name to remove "cell". }
    // @name specifies whether this
    // @link(ScreenObjectUnit.TScreenObject) will be used
    // to set the size of elements in the @link(TPhastGrid).
    // See @link(cbSetGridCellSizeClick).
    cbSetGridCellSize: TCheckBox;

    // @name specifies whether the well boundary condition specified by
    // this @link(ScreenObjectUnit.TScreenObject)
    // will allocate pumping by pressure and
    // mobility.
    // See @link(cbWellPumpAllocationClick).
    cbWellPumpAllocation: TCheckBox;

    // @name is used in @link(btnColorClick) to pick a color for the
    // lines or interior of @link(ScreenObjectUnit.TScreenObject)s.
    coldlgColors: TColorDialog;

    // @name is used to specify whether the solution in a specified state
    // boundary is a specified solution or an associated solution.
    // See @link(comboSolutionTypeChange).
    comboSolutionType: TComboBox;

    // @name specifies whether the open intervals in a well boundary are
    // specified in terms of absolute elevation or depth below a datum.
    // See @link(comboWellIntervalStyleChange).
    comboWellIntervalStyle: TComboBox;

    // @name stores the PHAST specified flux boundary values.
    dgBoundaryFlux: TRbwDataGrid4;

    // @name stores the PHAST leaky boundary values.
    dgBoundaryLeaky: TRbwDataGrid4;

    // @name stores the PHAST river boundary values.
    dgBoundaryRiver: TRbwDataGrid4;

    // @name stores the PHAST specified head boundary values.
    dgSpecifiedHead: TRbwDataGrid4;

    // @name stores the locations of the points for a single
    // @link(TScreenObject).
    dgVerticies: TRbwDataGrid4;

    // @name stores the PHAST well boundary values.
    dgWell: TRbwDataGrid4;

    // @name stores the PHAST well open interval elevations
    dgWellElevations: TRbwDataGrid4;

    // @name holds the formula for the higher elevation formula.
    // See @link(edHighZExit).
    // See @link(btnHighZ) and @link(btnFormulaClick).
    edHighZ: TRbwEdit;

    // @name holds the formula for the hydraulic conductivity of a
    // leaky boundary.
    // See @link(edLeakyHydraulicConductivityExit)
    // and @link(btnLeakyHydraulicConductivity).
    edLeakyHydraulicConductivity: TEdit;

    // @name holds the formula for the thickness of a
    // leaky boundary.
    // See @link(edLeakyHydraulicConductivityExit)
    // and @link(btnLeakyThickness).
    edLeakyThickness: TEdit;

    // @name holds the formula for the lower of two elevations.
    // See @link(edLowZExit),
    // @link(btnLowZ) and @link(btnFormulaClick).
    edLowZ: TRbwEdit;

    // @name holds the name of the @link(ScreenObjectUnit.TScreenObject).
    // See @link(edNameExit).
    edName: TEdit;

    // @name holds the formula for the thickness of a
    // river boundary.
    // See @link(edRiverExit)
    // and @link(btnRiverBedThickness).
    edRiverBedThickness: TEdit;

    // @name holds the formula for the depth of a
    // river boundary.
    // See @link(edRiverExit)
    // and @link(btnRiverDepth).
    edRiverDepth: TEdit;

    // @name holds the the name of a
    // river boundary.
    // See @link(edRiverDescriptonExit).
    edRiverDescripton: TEdit;

    // @name holds the formula for the hydraulic conductivity of a
    // river boundary.
    // See @link(edRiverExit)
    // and @link(btnRiverHydraulicConductivity).
    edRiverHydraulicConductivity: TEdit;

    // @name holds the formula for the width of a
    // river boundary.
    // See @link(edRiverExit)
    // and @link(btnRiverWidth).
    edRiverWidth: TEdit;

    // @name holds the the name of a
    // well boundary.
    // See @link(edWellExit).
    edWellDescription: TEdit;

    // @name is for editing the @link(TScreenObject.ElevationFormula).
    edZ: TRbwEdit;

    // @name is used to specify PHAST-style interpolation
    // for boundary conditions. See @link(TPhastInterpolationValues).
    framePhastInterpolationBoundaries: TframePhastInterpolation;

    // @name is used to specify PHAST-style interpolation
    // for @link(TDataArray)s. See @link(TPhastInterpolationValues).
    framePhastInterpolationData: TframePhastInterpolation;

    // @name holds and labels @link(framePhastInterpolationBoundaries).
    gbBoundaryPhastInterpolation: TGroupBox;

    // @name holds and labels @link(framePhastInterpolationData).
    gbPhastInterpolation: TGroupBox;

    // @name displays "Number of times".
    lblBoundaryTimes: TLabel;

    { TODO : remove "cell" from name. }
    // @name displays "Grid element size".
    lblGridCellSize: TLabel;

    // @name displays "Higher X-coordinate", "Higher Y-coordinate",
    // or "Higher Z-coordinate".
    // The text is changed in @link(GetData) depending the the
    // TScreenObject.@link(ScreenObjectUnit.TScreenObject.ViewDirection).
    lblHighZ: TLabel;

    // @name displays "Hydraulic Conductivity".
    lblLeakyHydraulicConductivity: TLabel;

    // @name displays "Thickness".
    lblLeakyThickness: TLabel;

    // @name displays "Lower X-coordinate", "Lower Y-coordinate",
    // or "Lower Z-coordinate".
    // The text is changed in @link(GetData) depending the the
    // TScreenObject.@link(ScreenObjectUnit.TScreenObject.ViewDirection).
    lblLowZ: TLabel;

    // @name displays "Name". It labels @link(edName).
    lblName: TLabel;

    // @name displays "Bed Thickness".
    lblRiverBedThickness: TLabel;

    // @name displays "Depth".
    lblRiverDepth: TLabel;

    // @name displays "Name".
    lblRiverDescripton: TLabel;

    // @name displays "Hydraulic Conductivity".
    lblRiverHydraulicConductivity: TLabel;

    // @name displays "Width".
    lblRiverWidth: TLabel;

    // @name displays "Type of Solution".
    lblSolutionType: TLabel;

    // @name displays "Name".
    lblWellDescription: TLabel;

    // @name displays "Diameter".
    lblWellDiameter: TLabel;

    // @name displays "Number of intervals".
    lblWellIntervals: TLabel;

    // @name displays "Specify interval by".
    lblWellIntervalStyle: TLabel;

    // @name displays "Land surface datum".
    lblWellLandSurfaceDatum: TLabel;

    // @name displays "X-coordinate", "Y-coordinate", or "Z-coordinate".
    // The text is changed in @link(GetData) depending the the
    // TScreenObject.@link(ScreenObjectUnit.TScreenObject.ViewDirection).
    lblZ: TLabel;

    // @name holds @link(tabBoundaryNone), @link(tabBoundarySpecifiedHead),
    // @link(tabBoundaryFlux), and @link(tabBoundaryLeaky),
    // @link(tabBoundaryRiver), and @link(tabBoundaryWell).
    // See @link(pcPhastBoundariesChange).
    pcPhastBoundaries: TJvPageList;

    // @name holds @link(tabProperties), @link(tabDataSets),
    // @link(tabBoundaries), and @link(tabNodes).
    // See @link(pageMainChange).
    pageMain: TPageControl;

    // @name holds the buttons at the bottom of @classname.
    pnlBottom: TPanel;

    // @name holds the controls on the left side of @link(tabBoundaries).
    pnlBoundaries: TPanel;

    // @name holds the controls on the top of @link(tabBoundaryLeaky).
    pnlLeaky: TPanel;

    // @name holds the controls on the top of @link(tabBoundaryRiver).
    pnlRiver: TPanel;

    // @name holds the controls on the top of @link(tabBoundarySpecifiedHead).
    pnlSolutionType: TPanel;

    // @name holds the controls on the top of @link(tabBoundaryWell).
    pnlWellBoundary: TPanel;

    { TODO : remove "cell" from name. }
    // @name is used to hold the size of elements in the @link(TPhastGrid) to
    // be generated using the @link(TScreenObject) being edited in @classname.
    rdeGridCellSize: TRbwDataEntry;

    // @name is used to specify the diameter of a well in a well boundary.
    // See @link(edWellExit).
    rdeWellDiameter: TRbwDataEntry;

    // @name is used to specify the land surface data in a well boundary.
    // See @link(edWellExit).
    rdeWellLandSurfaceDatum: TRbwDataEntry;

    // @name is used to specify the type of boundary specified by the
    // @link(TScreenObject) that is being edited.  The items in @name
    // must correspond to the elements in @link(TBoundaryTypes).
    // See @link(rgBoundaryTypeClick).
    rgBoundaryType: TRadioGroup;

    // @name is used to specify the number of elevations associated with
    // the @link(TScreenObject) being edited.
    // The items in @name must correspond with the elements in
    // @link(TElevationCount).
    // See @link(rgElevationCountClick).
    rgElevationCount: TRadioGroup;

    // @name specifies whether the @link(TScreenObject) being edited is
    // evaluated at elements or at nodes.
    // The items in @name must correspond with the elements in
    // @link(TEvaluatedAt).
    rgEvaluatedAt: TRadioGroup;

    // @name is used to compile formulas that will be evaluated at elements
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dsoTop.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserFrontFormulaElements: TRbwParser;

    // @name is used to compile formulas that will be evaluated at nodes
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dsoTop.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserFrontFormulaNodes: TRbwParser;

    // @name is used to compile formulas that will be evaluated at elements
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dsoSide.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserSideFormulaElements: TRbwParser;

    // @name is used to compile formulas that will be evaluated at nodes
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dsoSide.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserSideFormulaNodes: TRbwParser;

    // @name is used to compile formulas that will be evaluated at elements
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dso3D.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserThreeDFormulaElements: TRbwParser;

    // @name is used to compile formulas that will be evaluated at nodes
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dso3D.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserThreeDFormulaNodes: TRbwParser;

    // @name is used to compile formulas that will be evaluated at elements
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dsoTop.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserTopFormulaElements: TRbwParser;

    // @name is used to compile formulas that will be evaluated at nodes
    // for @link(TDataArray)s whose @link(TDataArray.Orientation) is dsoTop.
    // See @link(TDataSetOrientation).
    // The primary purpose of @name is to ensure that formulas are valid.
    rparserTopFormulaNodes: TRbwParser;

    // @name is used to specify how many times are associated with the
    // boundary condition of the @link(TScreenObject) that is being edited.
    // See @link(seBoundaryTimesChange).
    seBoundaryTimes: TJvSpinEdit;

    // @name has the number of open intervals in a well boundary.
    seWellIntervals: TJvSpinEdit;

    // @name displays a preview of the color used to draw the interior
    // of the @link(TScreenObject) that is being edited.
    shpFillColor: TShape;

    // @name displays a preview of the color used to draw the lines
    // of the @link(TScreenObject) that is being edited.
    shpLineColor: TShape;

    // @name is used to change the relative sizes of  @link(dgWell)
    // and @link(dgWellElevations) on @link(tabBoundaryWell).
    splitterWell: TSplitter;

    // @name is used to hold controls related to boundary conditions on
    // @link(pageMain).
    tabBoundaries: TTabSheet;

    // @name is used to hold controls related to specified flux boundaries on
    // @link(pcPhastBoundaries).
    tabBoundaryFlux: TJvStandardPage;

    // @name is used to hold controls related to leaky boundaries on
    // @link(pcPhastBoundaries).
    tabBoundaryLeaky: TJvStandardPage;

    // @name is used as a place-holder for @link(TScreenObject)s that
    // do not specify any boundary condition on
    // @link(pcPhastBoundaries).
    tabBoundaryNone: TJvStandardPage;

    // @name is used to hold controls related to river boundaries on
    // @link(pcPhastBoundaries).
    tabBoundaryRiver: TJvStandardPage;

    // @name is used to hold controls related to specified head boundaries on
    // @link(pcPhastBoundaries).
    tabBoundarySpecifiedHead: TJvStandardPage;

    // @name is used to hold controls related to well boundaries on
    // @link(pcPhastBoundaries).
    tabBoundaryWell: TJvStandardPage;

    // @name is used to hold controls related to @link(TDataArray)s on
    // @link(pageMain).
    tabDataSets: TTabSheet;

    // @name is used to hold controls related to the vertices of the
    // @link(TScreenObject) being edited on
    // @link(pageMain).
    tabNodes: TTabSheet;

    // @name is used to hold controls related to miscellaneous properties on
    // @link(pageMain).
    tabProperties: TTabSheet;

    // If the user hasn't changed anything, don't force the user
    // to save the model.
    procedure btnCancelClick(Sender: TObject);

    // allow the user to edit the line or fill color of a
    // @link(ScreenObjectUnit.TScreenObject).
    // See @link(btnLineColor) and @link(btnFillColor).
    procedure btnColorClick(Sender: TObject);

    // @name is used to edit a formula that is not part of a @link(TDataArray)
    // or boundary condition @link(TDataArray).
    // Examples include the formulas for the elevations associated with
    // a @link(TScreenObject).
    procedure btnFormulaClick(Sender: TObject);

    // @name warns user about potential problems and gives the user
    // a chance to correct them.
    // It then applies the changes to the @link(ScreenObjectUnit.TScreenObject)
    // or @link(ScreenObjectUnit.TScreenObject)s
    // using @link(SetMultipleScreenObjectData),
    // or @link(SetData).
    procedure btnOKClick(Sender: TObject);

    { TODO : remove "cell" from name. }
    // @name marks all used @link(TDataArray)s affected by the
    // @link(TScreenObject)s being edited as in need of updating when this
    // check box is checked.
    // @name sets (TScreenObject.SetValuesOfEnclosedCells
    //  TScreenObject.SetValuesOfEnclosedCells)
    procedure cbEnclosedCellsClick(Sender: TObject);

    // @name responds to the user checking the @link(cbFillColor)
    // check box by enabling the associated button (@link(btnFillColor)).
    // @name sets @link(TScreenObject.FillScreenObject
    // TScreenObject.FillScreenObject)
    procedure cbFillColorClick(Sender: TObject);

    // @name responds to the user checking the
    // @link(cbInterpolation) check box by
    // marking all @link(TDataArray)s affected by the @link(TScreenObject)
    // being edited as in need of updating.
    // @name sets @link(TScreenObject.SetValuesByInterpolation
    // TScreenObject.SetValuesByInterpolation).
    procedure cbInterpolationClick(Sender: TObject);

    // @name responds to the user checking the @link(cbIntersectedCells)
    // check box by
    // marking all @link(TDataArray)s affected by the @link(TScreenObject)
    // being edited as in need of updating.
    // @name sets @link(TScreenObject.SetValuesOfIntersectedCells
    // TScreenObject.SetValuesOfIntersectedCells).
    procedure cbIntersectedCellsClick(Sender: TObject);

    // @name responds to the user checking the @link(cbLineColor)
    // check box by enabling
    // the associated button (@link(btnLineColor)).
    procedure cbLineColorClick(Sender: TObject);

    // @name enables controls related to setting the grid cell size and
    // sets @link(TScreenObject.CellSizeUsed).
    procedure cbSetGridCellSizeClick(Sender: TObject);

    // @name calls @link(StorePhastWellBoundary)
    procedure cbWellPumpAllocationClick(Sender: TObject);

    // @name responds to a change in @link(comboSolutionType)
    // by changing a title in @link(dgSpecifiedHead).
    // @name calls @link(StorePhastSpecifiedHeads)
    procedure comboSolutionTypeChange(Sender: TObject);

    // @name changes the captions on the table that shows the well intervals
    // depending on the selection in @link(comboWellIntervalStyle).
    // @name calls @link(StorePhastWellBoundary).
    procedure comboWellIntervalStyleChange(Sender: TObject);

    // Allow the user to edit a formula with the formula editor in
    // one of the boundary condition grids (@link(dgSpecifiedHead),
    // @link(dgBoundaryFlux), @link(dgBoundaryLeaky), @link(dgBoundaryRiver),
    // and @link(dgWell)).
    procedure dgBoundaryButtonClick(Sender: TObject; ACol, ARow:
      Integer);

    // with Grids that represent boundary conditions, @name shows the cell at
    // (1,1) as gray because the user shouldn't be able to edit it.
    // (@link(dgSpecifiedHead),
    // @link(dgBoundaryFlux), @link(dgBoundaryLeaky), @link(dgBoundaryRiver),
    // and @link(dgWell))
    procedure dgBoundaryDrawCell(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState);

    // @name Doesn't allow a row to be moved to the top of the grid because
    // the cell at (1,1) shouldn't be edited.
    // (@link(dgSpecifiedHead),
    // @link(dgBoundaryFlux), @link(dgBoundaryLeaky), @link(dgBoundaryRiver),
    // and @link(dgWell))
    procedure dgBoundaryRowMoving(Sender: TObject; const Origin,
      Destination: Integer; var CanMove: Boolean);

    // Show the @link(TPhastInterpolationValues) when the user clicks on a cell
    // in a boundary grid.
    // (@link(dgSpecifiedHead),
    // @link(dgBoundaryFlux), @link(dgBoundaryLeaky), @link(dgBoundaryRiver),
    // and @link(dgWell))
    procedure dgBoundarySelectCell(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);

    // When the user edits text in one of the grids for
    // PHAST boundary conditions,
    // record that the data was changed (@link(StorePhastBoundary)).
    // @Seealso(dgSpecifiedHead)
    // @Seealso(dgBoundaryFlux)
    // @Seealso(dgBoundaryLeaky)
    // @Seealso(dgBoundaryRiver)
    // @Seealso(dgWell)
    procedure dgBoundarySetEditText(Sender: TObject; ACol, ARow: Integer;
      const Value: string);

    // update the displayed @link(TPhastInterpolationValues)
    // when the use clicks one of the
    // check boxes in a boundary table.
    // (@link(dgSpecifiedHead),
    // @link(dgBoundaryFlux), @link(dgBoundaryLeaky), @link(dgBoundaryRiver),
    // and @link(dgWell))
    procedure dgBoundaryStateChanged(Sender: TObject; ACol, ARow: Integer;
      const Value: TCheckBoxState);

    // If the user has changed the value displayed in @link(dgWellElevations),
    // @link(StorePhastWellBoundary) for later use in
    // @link(SetMultipleScreenObjectData).
    procedure dgWellElevationsSetEditText(Sender: TObject; ACol, ARow: Integer;
      const Value: string);

    // @name validates the upper formula and stores
    // @link(TScreenObject.HigherElevationFormula).
    procedure edHighZExit(Sender: TObject);

    // @name validates the leaky hydraulic conductivity formula
    // and calls @link(StorePhastLeakyBoundary).
    procedure edLeakyHydraulicConductivityExit(Sender: TObject);

    // @name validates the lower Z formula and stores
    // @link(TScreenObject.LowerElevationFormula).
    procedure edLowZExit(Sender: TObject);

    // @name ensures that the value given for the name of a
    // @link(ScreenObjectUnit.TScreenObject)
    // is valid.
    procedure edNameExit(Sender: TObject);

    // @name calls @link(StorePhastRiverBoundary).
    procedure edRiverDescriptonExit(Sender: TObject);

    // @name validates a river formula and calls @link(StorePhastRiverBoundary).
    procedure edRiverExit(Sender: TObject);

    // @name calls @link(StorePhastWellBoundary).
    procedure edWellExit(Sender: TObject);
    // @name validates the formula for the Z.

    procedure edZExit(Sender: TObject);
    // @name create variables and initialize the form.

    procedure FormCreate(Sender: TObject); override;
    // @name destroy variables.

    procedure FormDestroy(Sender: TObject); override;

    // See @link(FInitialWidth).
    procedure FormResize(Sender: TObject);

    // Respond to the user activating or deactivating PHAST-style Interpolation
    // for a boundary condition. See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariescbPhastInterpolationClick(Sender:
      TObject);

    // @name responds to the user finishing editing the
    // PHAST-style Interpolation mixture formula
    // for a boundary condition by storing the value.
    // See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariesedMixFormulaExit(
      Sender: TObject);

    // @name calls @link(StorePhastBoundary).
    procedure framePhastInterpolationBoundariesExit(Sender: TObject);

    // @name responds to the user finishing editing the
    // PHAST-style Interpolation Distance 1
    // for a boundary condition by storing the value.
    // See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariesrdeDistance1Exit(Sender:
      TObject);

    // @name responds to the user finishing editing the
    // PHAST-style Interpolation Distance 2
    // for a boundary condition by storing the value.
    // See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariesrdeDistance2Exit(Sender:
      TObject);

    // @name responds to the user finishing editing the
    // PHAST-style Interpolation Value 1
    // for a boundary condition by storing the value.
    // See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariesrdeValue1Exit(Sender: TObject);

    // @name responds to the user finishing editing the
    // PHAST-style Interpolation Value 2
    // for a boundary condition by storing the value.
    // See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariesrdeValue2Exit(Sender: TObject);

    // @name responds to the user changing the interpolation direction
    // for a boundary condition by storing the value.
    // See @link(TPhastInterpolationValues).
    procedure framePhastInterpolationBoundariesrgInterpolationDirectionClick(
      Sender: TObject);

    // @name responds to the user clicking the button for editing the
    // mixture formula by displaying the @link(TfrmFormula).
    procedure framePhastInterpolationDatabtnEditMixtureFormulaClick(
      Sender: TObject);

    // @name responds to the user activating or
    // deactivating PHAST-Interpolation for a
    // @link(TDataArray).
    procedure framePhastInterpolationDatacbPhastInterpolationClick(Sender:
      TObject);

    // @name stores a copy of the mixture formula in case it
    // needs to be restored later.
    procedure framePhastInterpolationDataedMixFormulaEnter(
      Sender: TObject);

    // @name checks that the mixture formula is valid.
    procedure framePhastInterpolationDataedMixFormulaExit(Sender: TObject);

    // @name responds to the user having finished editing the
    // PHAST-Interpolation distance 1 by storing the new value.
    // See @link(TPhastInterpolationValues).
    // @name calls @link(AssignPhastInterpolation)
    procedure framePhastInterpolationDatardeDistance1Exit(Sender: TObject);

    // @name responds to the user having finished editing the
    // PHAST-Interpolation distance 2 by storing the new value.
    // See @link(TPhastInterpolationValues).
    // @name calls @link(AssignPhastInterpolation)
    procedure framePhastInterpolationDatardeDistance2Exit(Sender: TObject);

    // @name responds to the user having finished editing the
    // PHAST-Interpolation Value 1 by storing the new value.
    // See @link(TPhastInterpolationValues).
    // @name calls @link(AssignPhastInterpolation)
    procedure framePhastInterpolationDatardeValue1Exit(Sender: TObject);

    // @name responds to the user having finished editing the
    // PHAST-Interpolation Value 2 by storing the new value.
    // See @link(TPhastInterpolationValues).
    // @name calls @link(AssignPhastInterpolation)
    procedure framePhastInterpolationDatardeValue2Exit(Sender: TObject);

    // @name responds to the user having edited the
    // PHAST-Interpolation interpolation direction by storing the new value.
    // See @link(TPhastInterpolationValues).
    // @name calls @link(AssignPhastInterpolation)
    procedure framePhastInterpolationDatargInterpolationDirectionClick(Sender:
      TObject);

    // @name updates @link(seBoundaryTimes).Value based
    // on the active page in @link(pcPhastBoundaries).
    procedure pcPhastBoundariesChange(Sender: TObject);

    // @name sets @link(btnHelp).HelpKeyword to
    // @link(pageMain).ActivePage.HelpKeyword
    procedure pageMainChange(Sender: TObject);

    // @name stores @link(TScreenObject.CellSize).
    procedure rdeGridCellSizeExit(Sender: TObject);

    // @name responds to the user selecting a different type of boundary
    // condition to use with the @link(ScreenObjectUnit.TScreenObject)
    // by setting @link(pcPhastBoundaries).ActivePageIndex
    // to the appropriate value.
    procedure rgBoundaryTypeClick(Sender: TObject);

    // @name responds to the user changing the number of elevations for the
    // @link(ScreenObjectUnit.TScreenObject).
    // @name sets @link(cbFillColor).Enabled as well as the enabled
    // property of other controls.
    // Some @link(TDataArray)s may no longer be affected by the
    // @link(TScreenObject) being edited. due to a change in the number of
    // elevations used.
    procedure rgElevationCountClick(Sender: TObject);

    // respond to the user changing where the
    // @link(ScreenObjectUnit.TScreenObject) is to be evaluated.
    // @name changes the captions of @link(cbEnclosedCells),
    // @link(cbIntersectedCells), and @link(cbInterpolation).
    procedure rgEvaluatedAtClick(Sender: TObject);

    // @name responds to the user changing the number of boundary times
    // by changing the number of rows in one of the grids related to
    // boundary conditions.
    // (@link(dgSpecifiedHead),
    // @link(dgBoundaryFlux), @link(dgBoundaryLeaky), @link(dgBoundaryRiver),
    // and @link(dgWell))
    procedure seBoundaryTimesChange(Sender: TObject);

    // @name responds to the user changing
    // the number of open intervals in a well
    // by changing the number of rows in @link(dgWellElevations).
    procedure seWellIntervalsChange(Sender: TObject);

    // See @link(FInitialWidth).
    procedure splitterBoundaryMoved(Sender: TObject);
  private
    FWellTabFileChanged: Boolean;
    FCHD_Node: TJvPageIndexNode;
    FGHB_Node: TJvPageIndexNode;
    FWEL_Node: TJvPageIndexNode;
    FRIV_Node: TJvPageIndexNode;
    FDRN_Node: TJvPageIndexNode;
    FDRT_Node: TJvPageIndexNode;
    FRCH_Node: TJvPageIndexNode;
    FEVT_Node: TJvPageIndexNode;
    FETS_Node: TJvPageIndexNode;
    FRES_Node: TJvPageIndexNode;
    FLAK_Node: TJvPageIndexNode;
    FLAKMf6_Node: TJvPageIndexNode;
    FMNW2_Node: TJvPageIndexNode;
    FMNW1_Node: TJvPageIndexNode;
    FMVR_Node: TJvPageIndexNode;
    FSFR_Node: TJvPageIndexNode;
    FSTR_Node: TJvPageIndexNode;
    FUZF_Node: TJvPageIndexNode;
    FUZF_Mf6_Node: TJvPageIndexNode;

    FChob_Node: TJvPageIndexNode;
    FDrob_Node: TJvPageIndexNode;
    FGbob_Node: TJvPageIndexNode;
    FRvob_Node: TJvPageIndexNode;
    FStob_Node: TJvPageIndexNode;
    FGage_Node: TJvPageIndexNode;
    FFhbHead_Node: TJvPageIndexNode;
    FFhbFlow_Node: TJvPageIndexNode;
    FMt3dmsSsm_Node: TJvPageIndexNode;
    FMt3d_UZT_Rech_Node: TJvPageIndexNode;
    FMt3d_UZT_Sat_Node: TJvPageIndexNode;
    FMt3d_UZT_Unsat_Node: TJvPageIndexNode;
    FMt3d_Uzf_Seep_Node: TJvPageIndexNode;
    FMt3d_LKT_Node: TJvPageIndexNode;
    FMt3d_SFT_Node: TJvPageIndexNode;
    FMt3dmsTobConc_Node: TJvPageIndexNode;
    FMt3dmsTobFlux_Node: TJvPageIndexNode;
    FFarmWell_Node: TJvPageIndexNode;
    FFarmPrecip_Node: TJvPageIndexNode;
    FFarmRefEvap_Node: TJvPageIndexNode;
    FFarmCropID_Node: TJvPageIndexNode;
    FFarmID_Node: TJvPageIndexNode;
    FCfpPipe_Node: TJvPageIndexNode;
    FCfpFixedHead_Node: TJvPageIndexNode;
    FCRCH_Node: TJvPageIndexNode;
    FSWR_Rain_Node: TJvPageIndexNode;
    FSWR_Evap_Node: TJvPageIndexNode;
    FSWR_LatInflow_Node: TJvPageIndexNode;
    FSWR_Stage_Node: TJvPageIndexNode;
    FSWR_DirectRunoff_Node: TJvPageIndexNode;
    FSWR_Reach_Node: TJvPageIndexNode;
    FMAW_Node: TJvPageIndexNode;
    FCSUB_Node: TJvPageIndexNode;
    FMf6Obs_Node: TJvPageIndexNode;
    FSubPestObs_Node: TJvPageIndexNode;
    FSwtPestObs_Node: TJvPageIndexNode;
    FTvkNode: TJvPageIndexNode;
    FTvsNode: TJvPageIndexNode;
    // @name is used to store the column that the user last selected
    // in one of the grids for boundary-condition, time-varying stress.
    // For boundary conditions that allow PHAST-style interpolation,
    // @name is adjusted to be the column with the checkbox for
    // turning on or off PHAST-style interpolation.
    // See @link(TPhastInterpolationValues).
    FBoundaryCol: integer;

    // @name is the TRbwDataGrid4 that is being used to specify
    // boundary conditions for the current @link(TScreenObject).
    // @name is one of the following:
    // @nil, @link(dgSpecifiedHead), @link(dgBoundaryFlux),
    // @link(dgBoundaryLeaky), @link(dgBoundaryRiver), or
    // @link(dgWell).
    FBoundaryGrid: TRbwDataGrid4;

    // @name holds @link(TInterpValuesCollection)s.
    // The @link(TInterpValuesCollection)s are also stored in the Objects
    // property of the related TRbwDataGrid4.  @name is used to ensure that
    // they are destroyed when the @classname is destroyed.
    FBoundaryPhastInterpolationList: TObjectList;

    // @name is the selected row in the grid used to specify boundary
    // conditions for the current @link(TScreenObject).
    FBoundaryRow: integer;

    // @name is the @link(TExpression) that represents the formula in @link(edHighZ).
    // If @name is @nil, btnOK.Enabled may be set to @false.
    FHighZFormula: TExpression;

    // @name is set to Width - pnlBoundaries.Width in @link(FormCreate).
    // It is used in @link(splitterBoundaryMoved) and @link(FormResize)
    // to make sure that
    // the panels on @link(pcPhastBoundaries) don't get too small.
    FInitialWidth: integer;

    // @name is used in event handlers to decide
    // whether or not anything should be done.
    FIsLoaded: boolean;

    // @name is the @link(TExpression) that represents the formula in @link(edLowZ).
    // If @name is @nil, btnOK.Enabled may be set to @false.
    FLowZFormula: TExpression;

    // See @link(MultipleScreenObjects).
    FMultipleScreenObjects: boolean;

    // @name is used to store a copy of the @link(TScreenObject)s being edited.
    // Those @link(TScreenObject)s are then edited in @classname.  They
    // are used to set the properties of the @link(TScreenObject)s
    // in @link(TUndoSetScreenObjectProperties.DoCommand
    // TUndoSetScreenObjectProperties.DoCommand).
    FNewProperties: TScreenObjectEditCollection;

    // @name is set to @link(framePhastInterpolationData).edMixFormula.Text
    // @link(framePhastInterpolationDataedMixFormulaEnter)
    // It is used in @link(framePhastInterpolationDataedMixFormulaExit)
    // to restore the formula if the user enters an invalid formula.
    FOldMixFormula: string;

    // @name is used to store a copy of the @link(TScreenObject)s being edited.
    // They are used to restore the properties of the @link(TScreenObject)s
    // in @link(TUndoSetScreenObjectProperties.Undo
    // TUndoSetScreenObjectProperties.Undo).
    FOldProperties: TScreenObjectEditCollection;

    // @name is set to frmGoPhast.Model.@link(TBaseModel.UpToDate)
    // in @link(FormCreate).  If @link(btnCancel) is clicked,
    // frmGoPhast.Model.@link(TBaseModel.UpToDate) is restored to @name.
    FPriorModelUpToDate: boolean;

    // If only a single @link(TScreenObject) is being edited, @name is that
    //  @link(TScreenObject). If more than one is being edited, @name is @nil.
    // @seealso(FScreenObjectList);
    FScreenObject: TScreenObject;

    // If multiple @link(TScreenObject)s are being editted, @name holds the
    // @link(TScreenObject)s that are being edited.
    // @seealso(FScreenObject);
    FScreenObjectList: TList;

    // @name is set to @true to indicate that the colors of the cells will
    // need to be recalculated.
    FSetCellsColor: boolean;

    // @name is used to set or undo the setting of the properties
    // of a @link(TScreenObject).
    FUndoSetScreenObjectProperties: TUndoSetScreenObjectProperties;

    // @name is the @link(TViewDirection) of the @link(TScreenObject)(s)
    // that are being edited.
    FViewDirection: TViewDirection;

    // @name is the @link(TExpression) that represents the formula in @link(edZ).
    // If @name is @nil, btnOK.Enabled may be set to @false.
    FZFormula: TExpression;
    FStoredCanSetPoints: boolean;
    FCanSetPointsOutOfDate: Boolean;
    FDataEdits: TList;
    FFillingDataSetTreeView: Boolean;
    FCurrentEdit: TScreenObjectDataEdit;
    FUpdatingCurrentEdit: Boolean;
    FFormulaEdit: TScreenObjectDataEdit;
    FSelectedDataArrayName: string;
    FHOB_Node: TJvPageIndexNode;
    FHFB_Node: TJvPageIndexNode;
    FHydmod_Node: TJvPageIndexNode;
    FDeletingPhastTime: Boolean;
    FPriorElevationCount: integer;
    FModpath_Node: Pointer;
    FCanFillTreeView: Boolean;
    FSettingVerticies: Boolean;
    FVertexRowCount: Integer;
    FFilledDataSetTreeView: Boolean;
    FChildModels: TList;
    FChildModelsScreenObjects: TList;
    FSutraObs_Node: TJvPageIndexNode;
    FSutraSpecPressure_Node: TJvPageIndexNode;
    FSutraSpecTempConc_Node: TJvPageIndexNode;
    FSutraFluidFlux_Node: TJvPageIndexNode;
    FSutraMassEnergyFlux_Node: TJvPageIndexNode;
    FSutraGeneralizedFlowNode: TJvPageIndexNode;
    FSutraLake_Node: TJvPageIndexNode;
    FCaptionFontChanged: Boolean;
    FCaptionTextChanged: Boolean;
    FCaptionFont: TFont;
    FVertexCaptionFontChanged: Boolean;
    FVertexCaptionFont: TFont;
    FSectionCaptionFontChanged: Boolean;
    FSectionCaptionFont: TFont;
    FSWiObs_Node: TJvPageIndexNode;
    FRipNode: TJvPageIndexNode;
    FSutraGeneralizedTransportNode: TJvPageIndexNode;
    FSutraStateObsNode: TJvPageIndexNode;
    FSFR6_Node: TJvPageIndexNode;
    FObjectCount: Integer;
    FVertexCount: Integer;
    FSutraSpecPresObs_Node: TJvPageIndexNode;
    FSutraSpecFluidFlowObs_Node: TJvPageIndexNode;
    FSutraSpecConcObs_Node: TJvPageIndexNode;
    FSutraGenFlowObs_Node: TJvPageIndexNode;
    FSutraGenTransObs_Node: TJvPageIndexNode;
    FPestMethods: TStringList;
    FPestBlockParametersAndDataSets: TStringList;
    FPestNodeParametersAndDataSets: TStringList;
    FPestParameters: TStringList;
    FGwtCnc_Node: TJvPageIndexNode;
    FGwtSrc_Node: TJvPageIndexNode;
    FFmp4EfficiencyNode: TJvPageIndexNode;
    FFmp4EfficiencyImprovementNode: TJvPageIndexNode;
    FFmp4BareRunoffFractionNode: TJvPageIndexNode;
    FFmp4BarePrecipitationConsumptionFractionNode: TJvPageIndexNode;
    FFmp4BareEvapNode: TJvPageIndexNode;
    FFmp4DirectRechargeNode: TJvPageIndexNode;
    FFmp4PrecipPotConsumptionNode: TJvPageIndexNode;
    FFmp4NrdInfilLocationNode: TJvPageIndexNode;
    FFmp4LandUseAreaFractionNode: TJvPageIndexNode;
    FFmp4MultLandUseAreaFractionNode: TJvPageIndexNode;
    FFmp4CropCoefficientNode: TJvPageIndexNode;
    FFmp4MultCropCoefficientNode: TJvPageIndexNode;
    FFmp4ConsumptiveUseNode: TJvPageIndexNode;
    FFmp4MultConsumptiveUseNode: TJvPageIndexNode;
    FFmp4IrrigationNode: TJvPageIndexNode;
    FFmp4MultIrrigationNode: TJvPageIndexNode;
    FFmp4RootDepthNode: TJvPageIndexNode;
    FFmp4MultRootDepthNode: TJvPageIndexNode;
    FFmp4TranspirationFractionNode: TJvPageIndexNode;
    FFmp4MultTranspirationFractionNode: TJvPageIndexNode;
    FFmp4EvaporationIrrigationFractionNode: TJvPageIndexNode;
    FFmp4MultEvaporationIrrigationFractionNode: TJvPageIndexNode;
    FFmp4FractionOfPrecipToSurfaceWaterNode: TJvPageIndexNode;
    FFmp4MultFractionOfPrecipToSurfaceWaterNode: TJvPageIndexNode;
    FFmp4FractionOfIrrigToSurfaceWaterNode: TJvPageIndexNode;
    FFmp4MultFractionOfIrrigToSurfaceWaterNode: TJvPageIndexNode;
    FFmp4AddedDemandNode: TJvPageIndexNode;
    FFmp4MultAddedDemandNode: TJvPageIndexNode;
    FFmp4CropHasSalinityDemandNode: TJvPageIndexNode;
    FFmp4MultCropHasSalinityDemandNode: TJvPageIndexNode;
    FFmp4AddedDemandRunoffSplitNode: TJvPageIndexNode;
    FTooFewError: Boolean;
    FTooManyError: Boolean;
    procedure Mf6ObsChanged(Sender: TObject);
    procedure EnableModpathObjectChoice;
    Function GenerateNewDataSetFormula(DataArray: TDataArray): string;
    // @name assigns new formulas for @link(TDataArray)s for each
    // @link(TScreenObject) in @link(FNewProperties).
    procedure AssignNewDataSetFormula(DSIndex: Integer;
      const NewFormula: string);

    // @name assigns the TInterpValuesItem for @link(TDataArray DataArray)
    // based on the values in @link(framePhastInterpolationData).
    procedure AssignPhastInterpolation(DataArray: TDataArray);

    {@name tests whether the boundary specified in Grid is
     identical to the one in Boundary.}
    function PhastBoundaryIsIdentical(const Grid: TRbwDataGrid4;
      const UsedTimes: TRealList;
      const Boundary: TCustomPhastBoundaryCollection;
      const ExpressionCol, PhastInterpolateCol: integer): boolean;

    {@name checks to see if Expression uses itself. If it does, it tries
     to restore the old formula for it using OldFormula,
     OldFormulaOK, and EditIndex.  DSetName is the name of the @link(TDataArray)
     to which Expression applies.}
    procedure CheckForCircularReference(const Expression: TExpression;
      const DSetName: string; const EditIndex: integer;
      const OldFormulaOK: boolean; const OldFormula: string);

    {@name checks to see if Expression uses itself. If it does, it tries
     to restore the old formula for it using OldFormula,
     and ARow.  DSetName is the name of the @link(TDataArray)
     to whose mixture formula Expression applies.}
    procedure CheckForCircularReferencesInMixtureFormulas(
      var Expression: TExpression; const DSName, OldFormula: string;
      const EditIndex: integer);

    // @name creates an @link(TExpression) for a boundary condition
    // based on the text in DataGrid at ACol, ARow.
    // Orientation, and EvaluatedAt
    // are used to chose the TRbwParser.
    procedure CreateBoundaryFormula(const DataGrid: TCustomRBWDataGrid;
      const ACol, ARow: integer; Formula: string;
      const Orientation: TDataSetOrientation; const EvaluatedAt: TEvaluatedAt);

    // @name creates a @link(TExpression) for a @link(TScreenObjectDataEdit).
    procedure CreateFormula(const DataSetIndex: integer;
      const NewFormula: string; const ShowError: boolean = True);

    // @name attempts to create a @link(TExpression) for the mixture
    // the the @link(TDataArray) identified by DataSetIndex.
    function CreateMixtureFormula(const DataSetIndex: integer): TExpression;

    // @name creates a TCustomVariable to represent the @link(TDataArray)
    //  specified by @link(TScreenObjectDataEdit Edit) in
    // each TRbwParser that needs it.
    procedure CreateVariable(const Edit: TScreenObjectDataEdit);

    // @name changes the appearances of @link(cbSetGridCellSize),
    // @link(cbEnclosedCells),
    // @link(cbIntersectedCells), and @link(cbInterpolation) so that if none
    // of them is checked, their appearance is emphasized.
    procedure EmphasizeValueChoices;

    // @name allows the OK button to be pressed if all of the
    // formulas for the data sets and elevation formulas are valid.
    procedure EnableOK_Button;

    // @name is used to store copies of the @link(TScreenObject)s in List.
    // The copies are stored in Collection.
    // @param(Collection Collection will hold copies of the
    // @link(TScreenObject)s in List)
    // @param(List List contains a series of @link(TScreenObject)s that are
    // being edited.  Copies of those @link(TScreenObject)s will be placed in
    // Collection.)
    // See also @link(TfrmEditFeatureFormula.FillPropertyCollection).
    procedure FillPropertyCollection(Collection: TScreenObjectEditCollection;
      List: TList);

    // @name stores the appropriate MODFLOW parameters for each MODFLOW package
    // in the appropriate @link(TframeScreenObjectParam).
    procedure GetAvailableParameters;

    // @name stores the times of MODFLOW stress periods in
    // @link(TframeScreenObjectParam).
    procedure GetAvailableTimes;

    // @name fills Times with all the times in Boundaries.
    procedure GetBoundaryTimes(
      const Boundaries: array of TCustomPhastBoundaryCollection;
      const Times: TRealList);

    // @name returns the appropriate TRbwParser based on the
    // combination of Orientation and EvaluatedAt.
    function GetCompiler(const Orientation: TDataSetOrientation; const
      EvaluatedAt: TEvaluatedAt): TRbwParser;

    // @name determines the @link(TDataArray.Orientation) and
    // @link(TDataArray.EvaluatedAt) of the data set
    // at Index and returns the appropriate compiler based on that combination.
    function GetCompilerByIndex(const Index: integer): TRbwParser;

    // @name returns the position of the @link(TScreenObjectDataEdit)
    // whose @link(TScreenObjectDataEdit.DataArray) has the same name as
    // DataSetName in @link(FDataEdits).
    // If such a @link(TScreenObjectDataEdit) isn't in @link(FDataEdits),
    // @name returns -1.  
    function GetDataSetIndexByName(const DataSetName: string): integer;

    // @name returns the TRbwParser that is appropriate
    // for specifying the elevation formula for a
    // @link(TScreenObject) based on the
    // direction from which the @link(TScreenObject)
    // is viewed and whether it is evaluated
    // by blocks or nodes.
    function GetElevationCompiler: TRbwParser;

    // @name stores the @link(TCustomVariable)s that can be used
    // in the formula for the @link(TDataArray) whose name is DSetName.
    procedure GetListOfOkVariables(EvaluatedAt: TEvaluatedAt;
      Orientation: TDataSetOrientation; VariableList: TList;
      DataSetIndex: Integer; DSEdit: TScreenObjectDataEdit);

    // @name sets the data stored in controls in @classname to default values
    // and otherwise prepares the @classname to edit objects.
    procedure InitializeControls(AScreenObject: TScreenObject);

    // @name initializes the grids.  It sets the Objects property corresponding
    // to each cell to nil and sets each cell that isn't a fixed cell to a
    // blank.  The cell at [1,1] for boundary conditions is set to hold a
    // '0' as required by boundary conditions.
    procedure InitializeGridObjects;

    // @name resets the data displayed in @link(dgBoundaryFlux).
    // It is called by @link(GetDataForMultipleScreenObjects) when two
    // @link(TScreenObject)s have Flux
    // boundaries that differ.
    procedure ResetFluxGrid;

    // @name resets the data displayed in @link(dgBoundaryLeaky).
    // It is called by @link(GetDataForMultipleScreenObjects) when two
    // @link(TScreenObject)s have Leaky
    // boundaries that differ.
    procedure ResetLeakyGrid;

    // @name resets the data displayed in @link(dgBoundaryRiver).
    // It is called by @link(GetDataForMultipleScreenObjects) when two
    // @link(TScreenObject)s have River
    // boundaries that differ.
    procedure ResetRiverGrid;

    // @name resets the data displayed in @link(dgSpecifiedHead).
    // It is called by @link(GetDataForMultipleScreenObjects)
    // when two @link(TScreenObject)s have
    // Specified Head boundaries that differ.
    procedure ResetSpecifiedHeadGrid;

    // @name resets the data displayed in @link(dgWellElevations).
    // It is called by @link(GetDataForMultipleScreenObjects)
    // when two @link(TScreenObject)s have
    // Well boundaries with well elevations that differ.
    procedure ResetWellElevationGrid;

    // @name resets the data displayed in  @link(dgWell).
    // It is called by @link(GetDataForMultipleScreenObjects)
    // when two @link(TScreenObject)s have
    // Well boundaries that differ.
    procedure ResetWellGrid;

    // @name calls @link(dgBoundaryStateChanged) for the first check box
    // in the TRbwDataGrid4 for the selected boundary condition that is
    // checked.
    procedure SelectBoundaryCell;

    { Set the captions of @link(cbEnclosedCells), @link(cbIntersectedCells),
      and @link(cbInterpolation) based on @link(rgEvaluatedAt).ItemIndex.}
    procedure SetCheckBoxCaptions;

    // @name is used to set the data for a single @link(TScreenObject)
    // when it is first created.
    // See @Link(SetMultipleScreenObjectData)
    // if there is more than one @link(TScreenObject) being edited.
    procedure SetData;

    // @name sets @link(FIsLoaded) and sets
    // @link(TframeScreenObject.FrameLoaded
    // TframeScreenObject.FrameLoaded).
    procedure SetIsLoaded(const Value: boolean);

    // @name is called when the user press the @link(btnOK) button
    // after editing the properties of one or more
    // @link(TScreenObject)s.
    // It set up a @link(TUndoSetScreenObjectProperties)
    // based on the data that the
    // user has changed.  @SeeAlso(SetData)
    procedure SetMultipleScreenObjectData;

    // @name is the setter for @link(MultipleScreenObjects);
    // It sets AllowGrayed for several check boxes.
    procedure SetMultipleScreenObjects(const Value: boolean);

    // @name shows or hides the tab for PHAST boundaries as appropriate.
    procedure ShowOrHideTabs;

    // @name stores time-varying values for PHAST boundary conditions
    // of the @link(TScreenObject)s begin edited.
    procedure StoreInterpolatedBoundary(Boundary: TCustomInterpolatedBoundary;
      DataGrid: TRbwDataGrid4);

    // @name stores the time-varying values of the Well and river boundaries.
    procedure StoreNonInterpolatedBoundary(
      Boundary: TCustomInterpolatedBoundary; DataGrid: TRbwDataGrid4);

    // @name stores the PHAST boundary condition for the @link(TScreenObject).
    procedure StorePhastBoundary;

    // @name assigns the PHAST leaky boundary conditions to the
    // @link(TScreenObject)s in @link(FNewProperties) based in the values
    // shown on @link(tabBoundaryRiver).
    procedure StorePhastLeakyBoundary;

    // @name assigns the PHAST river boundary conditions to the
    // @link(TScreenObject)s in @link(FNewProperties) based in the values
    // shown on @link(tabBoundaryLeaky).
    procedure StorePhastRiverBoundary;

    // @name assigns the PHAST specified flux boundary conditions to the
    // @link(TScreenObject)s in @link(FNewProperties) based in the values
    // shown on @link(tabBoundaryFlux).
    procedure StorePhastSpecifiedFlux;

    // @name assigns the PHAST specified head boundary conditions to the
    // @link(TScreenObject)s in @link(FNewProperties) based in the values
    // shown on @link(tabBoundarySpecifiedHead).
    procedure StorePhastSpecifiedHeads;

    // @name assigns the PHAST well boundary conditions to the
    // @link(TScreenObject)s in @link(FNewProperties) based in the values
    // shown on @link(tabBoundaryWell).
    procedure StorePhastWellBoundary;

    // @name returns @True if all the times recorded in Grid
    // in column TimeCol are identical to those in UsedTimes.
    function TimesIdentical(const Grid: TRbwDataGrid4;
      const UsedTimes: TRealList; const TimeCol: integer): boolean;

    // @name ensures that when a formula has been entered at
    // one of the elevation edit boxes, that the formula is valid.
    // See @link(edZ), @link(edHighZ), and @link(edLowZ).
    procedure ValidateEdFormula(const Ed: TEdit);
    procedure FillDataSetsTreeView(ListOfScreenObjects: TList);
    function AssignPoint(const Row: integer; out APoint: TPoint2D): boolean;
    procedure StoreChdBoundary;
    procedure GetChdBoundary(ScreenObjectList: TList);
    procedure StoreGhbBoundary;
    procedure GetGhbBoundary(ScreenObjectList: TList);
    procedure StoreWellBoundary;
    procedure GetWellBoundary(ScreenObjectList: TList);
    procedure StoreFarmWell;
    procedure GetFarmWell(ScreenObjectList: TList);
    procedure GetRivBoundary(ScreenObjectList: TList);
    procedure StoreRivBoundary;
    procedure GetDrnBoundary(ScreenObjectList: TList);
    procedure StoreDrnBoundary;
    procedure GetDrtBoundary(ScreenObjectList: TList);
    procedure StoreDrtBoundary;
    procedure StoreRchBoundary;
    procedure GetRchBoundary(ScreenObjectList: TList);
    function GetBoundaryValues(Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetRechargeLayers(Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetEvapLayers(Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetEvapSurfaceDepth(Boundary: TModflowBoundary): TCustomMF_BoundColl;
    procedure GetEvtBoundary(ScreenObjectList: TList);
    procedure StoreEvtBoundary;
    procedure GetEtsBoundary(ScreenObjectList: TList);
    function GetEtsLayers(Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetEtsSurfaceDepth(
      Boundary: TModflowBoundary): TCustomMF_BoundColl;
    procedure StoreEtsBoundary;
    procedure GetResBoundary(ScreenObjectList: TList);
    procedure GetReservoirBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure StoreResBoundary;

    procedure GetSwrRainBoundary(ScreenObjectList: TList);
    procedure GetSwrRainBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure StoreSwrRainBoundary;
    procedure GetSwrEvapBoundary(ScreenObjectList: TList);
    procedure StoreSwrEvapBoundary;
    procedure CreateSWR_Reach_Node(AScreenObject: TScreenObject);
    procedure CreateSWR_Rain_Node(AScreenObject: TScreenObject);
    procedure CreateSWR_Evap_Node(AScreenObject: TScreenObject);
    procedure CreateMf6Obs_Node(AScreenObject: TScreenObject);
    procedure GetSwrEvapBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure CreateSWR_LatInflow_Node(AScreenObject: TScreenObject);
    procedure GetSwrLatInflowBoundary(ScreenObjectList: TList);
    procedure StoreSwrLatInflowBoundary;
    procedure GetSwrLatInflowBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure CreateSWR_Stage_Node(AScreenObject: TScreenObject);
    procedure GetSwrStageBoundary(ScreenObjectList: TList);
    procedure GetSwrStageBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure StoreSwrStageBoundary;

    procedure GetGlobalVariables;
    procedure GetLakBoundary(ScreenObjectList: TList);
    procedure GetLakeBoundaryCollection(
      ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure StoreLakBoundary;
    procedure StoreUzfBoundary;
    procedure GetUzfBoundary(ScreenObjectList: TList);
    function GetUzfEtRate(Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetUzfInfiltrationRate(
      Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetUzfEtExtinctionDepth(
      Boundary: TModflowBoundary): TCustomMF_BoundColl;
    function GetUzfEtExtinctionWaterContent(
      Boundary: TModflowBoundary): TCustomMF_BoundColl;
    procedure UpdateSfrNode(Sender: TObject);
    // @name validates the cell formula in @link(reDataSetFormula)
    // of @link(FCurrentEdit).
    // @name ensures that a formula entered
    // in @link(reDataSetFormula) is valid.
    procedure ValidateDataSetFormula(ShowError: boolean = True);
    // @name updates the list of which variables depend on which
    // others.
    procedure UpdateDataSetLinkages(const Expression: TExpression;
      const DataSetIndex: integer; const DSName: string);
    procedure CheckIfDataSetCanBeEdited(var CanEdit: boolean;
      Edit: TScreenObjectDataEdit; ListOfScreenObjects: TList);
    procedure GetHeadObservations(const ScreenObjectList: TList);
    procedure CreateHobNode(AScreenObject: TScreenObject);
    procedure GetHfbBoundary(const ScreenObjectList: TList);
    procedure CreateHfbNode(AScreenObject: TScreenObject);
    procedure CreateModpathNode;
    procedure StoreModPath;
    procedure CreateChobNode;
    procedure CreateDrobNode;
    procedure CreateGbobNode;
    procedure CreateRvobNode;
    procedure CreateSutraSpecPresObsNode;
    procedure CreateSutraSpecifiedFluidFlowObsNode;
    procedure CreateSutraSpecConcObsNode;
    procedure CreateSutraGenFlowObsNode;
    procedure CreateSutraGenTransObsNode;
    procedure CreateMt3dmsSsmNode;
    procedure GetDrainFluxObservations(const AScreenObjectList: TList);
    procedure GetGhbFluxObservations(const AScreenObjectList: TList);
    procedure GetRiverFluxObservations(const AScreenObjectList: TList);
    procedure GetSutraSpecPresObservations(const AScreenObjectList: TList);
    procedure GetSutraSpecFlowObservations(const AScreenObjectList: TList);
    procedure GetSutraSpecConcObservations(const AScreenObjectList: TList);
    procedure GetSutraGenPresObservations(const AScreenObjectList: TList);
    procedure GetSutraGenTransObservations(const AScreenObjectList: TList);
    procedure CreateGageNode;
    procedure GetGages(ListOfScreenObjects: TList);
    procedure SetGages(List: TList); overload;
    procedure SetGages(Collection: TScreenObjectEditCollection); overload;
    procedure CreateMnw2Node;
    procedure CreateMnw1Node;
    procedure GetMnw2Boundary(const ScreenObjectList: TList);
    procedure Mnw2Changed(Sender: TObject);
    procedure GetMnw1Boundary(const ScreenObjectList: TList);
    procedure Mnw1Changed(Sender: TObject);
    procedure CreateHydmodNode(AScreenObject: TScreenObject);
    procedure CreateGwtCncNode;
    procedure CreateGwtSrcNode;
    procedure GetHydmod(const ScreenObjectList: TList);
    procedure GetChildModels(const ScreenObjectList: TList);
    procedure UpdateNonParamCheckBox(Frame: TframeScreenObjectParam; ParamCol,
      ACol, ARow: Integer; const Value: string);
    procedure GetMt3dmsChemBoundary(ScreenObjectList: TList);
    procedure GetMt3dmsChemBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure GetMt3dmsUztRechBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure StoreMt3dmsChemBoundary;
    procedure CreateMt3dmsTobConcNode(AScreenObject: TScreenObject);
    procedure GetMt3dConcObservations(const ScreenObjectList: TList);
    procedure GetMt3dmsFluxObservations(const AScreenObjectList: TList);
    procedure CreateMt3dmsTobFluxNode;
    procedure SetMt3dFluxObs(List: TList);
    procedure CreateSutraObsNode;
    procedure ActivateSutraFeature(Sender: TObject; CheckState: TCheckBoxState);
    procedure UpdateSutraStateObsNode(Sender: TObject);
    procedure CreateSutraSpecPressNode;
    procedure CreateSutraSpecTempConcNode;
    procedure CreateSutraFluidFluxNode;
    procedure CreateSutraMassEnergyFluxNode;
    procedure SetSelectedSutraBoundaryNode;
    procedure GetDuplicatesAllowedForAdditionalObject(
      AScreenObject: TScreenObject);
    procedure GetStrBoundary(const ScreenObjectList: TList);
    procedure UpdateStrNode(Sender: TObject);
    procedure GetStreamFluxObservations(const AScreenObjectList: TList);
    procedure CreateStobNode;
    procedure GetFhbHeadBoundary(const ScreenObjectList: TList);
    procedure FhbHeadChanged(Sender: TObject);
    procedure FhbFlowChanged(Sender: TObject);
    procedure CreateFhbFlowNode;
    procedure GetFhbFlowBoundary(const ScreenObjectList: TList);
    procedure FarmPrecipChanged(Sender: TObject);
    procedure FarmRefEvapChanged(Sender: TObject);
    procedure FarmCropIDChanged(Sender: TObject);
    procedure FarmIDChanged(Sender: TObject);
    procedure GetFarmPrecip(const ScreenObjectList: TList);
    procedure GetFarmRefEvap(const ScreenObjectList: TList);
    procedure GetFarmCropID(const ScreenObjectList: TList);
    procedure GetFarmID(const ScreenObjectList: TList);
    procedure CreateCfpPipeNode(AScreenObject: TScreenObject);
    procedure CfpPipesChanged(Sender: TObject);
    procedure GetCfpPipes(const ScreenObjectList: TList);
    procedure CreateCfpFixedHeadNode(AScreenObject: TScreenObject);
    procedure CfpFixedHeadsChanged(Sender: TObject);
    procedure GetCfpFixedHeads(const ScreenObjectList: TList);
    procedure CreateCfpRechargeNode;
    procedure CfpRchargeOnChange(Sender: TObject);
    procedure GetCfpRechargeBoundary(ScreenObjectList: TList);
    procedure CreateSWR_DirectRunoff_Node(AScreenObject: TScreenObject);
    procedure GetSwrDirectRunoffBoundary(ScreenObjectList: TList);
    procedure StoreSwrDirectRunoffBoundary;
    procedure GetSwrDirectRunoffBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure GetSwrReaches(const ScreenObjectList: TList);
    procedure GetMf6Obs(const ScreenObjectList: TList);
    procedure GetFootprintWells;
    procedure CreateSwiObsNode(AScreenObject: TScreenObject);
    procedure GetSwiObsBoundary(const ScreenObjectList: TList);
    procedure CreateRipNode(AScreenObject: TScreenObject);
    procedure GetRip(const ScreenObjectList: TList);
    procedure RipChanged(Sender: TObject);
    procedure CreateSutraLakeNode;
    procedure UpdateWellNodeState;
    procedure CreateSutraGeneralizedFlowNode;
    function ShouldCreateSutraLakeBoundary : Boolean;
    function ShouldCreateSutraGeneralBoundary: Boolean;
    procedure CreateSutraGeneralizedTransportNode;
    procedure CreateSutraStateObsNode(AScreenObject: TScreenObject);
    procedure GetVertexLabels(ScreenObjects: TList);
    procedure RemoveLayerDataArraysFrom3DObject(AScreenObject: TScreenObject;
      DataSetList: TDataArrayList);
    procedure CreateSfr6Node(AScreenObject: TScreenObject);
    procedure CreateMt3d_UztRechNode;
    procedure GetMt3d_UztRechBoundary(ScreenObjectList: TList);
    procedure StoreMt3d_UztRechBoundary;
    procedure GetMt3dmsUztSatBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure GetMt3dmsUztUnsatBoundaryCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure GetMt3d_UztSatBoundary(ScreenObjectList: TList);
    procedure GetMt3d_UztUnsatBoundary(ScreenObjectList: TList);
    procedure StoreMt3d_UztSatBoundary;
    procedure StoreMt3d_UztUnsatBoundary;
    procedure CreateMt3d_UztSatNode;
    procedure CreateMt3d_UztUnsatNode;
    procedure CreateMt3d_Uzf_Seep_Node;
    procedure GetMt3dUzfSeepageConcCollection(DataGrid: TRbwDataGrid4;
      ColumnOffset: Integer; ScreenObjectList: TList;
      TimeList: TParameterTimeList);
    procedure GetMt3dUzfSeepageConcBoundary(ScreenObjectList: TList);
    procedure StoreMt3dUzfSeepageConcBoundary;
    procedure CreateMt3d_LktNode;
    procedure GetMt3dLktBoundary(ScreenObjectList: TList);
    procedure CreateMt3d_SftNode;
    procedure GetMt3dSftBoundary(ScreenObjectList: TList);
    procedure GetSfr6Boundary(const ScreenObjectList: TList);
    procedure UpdateSfr6Node(Sender: TObject);
    procedure GetMawBoundary(const ScreenObjectList: TList);
    procedure GetCSubBoundary(const ScreenObjectList: TList);
    procedure GetCncBoundary(const ScreenObjectList: TList);
    procedure GetSrcBoundary(const ScreenObjectList: TList);
    procedure MawChanged(Sender: TObject);
    procedure CSubChanged(Sender: TObject);
    procedure AssignTransientHfbFormulas(const Row, Col: Integer);
    procedure UpdateHfbBoundaryState(Boundary: THfbBoundary;
      ScreenObjectIndex: Integer; var State: TCheckBoxState);
    procedure LakeMf6Changed(Sender: TObject);
    procedure GetLakeMf6Boundary(const ScreenObjectList: TList);
    procedure ShowOrHideObsTabs;
    procedure GetMvrBoundary(const ScreenObjectList: TList);
    procedure MvrChanged(Sender: TObject);
    procedure CreateMvrNode;
    procedure CreateUzMf6fNode(AScreenObject: TScreenObject);
    procedure UzfMf6Changed(Sender: TObject);
    procedure GetUzMf6Boundary(const ScreenObjectList: TList);
    function GetPestMethod(Grid: TRbwDataGrid4;
      ACol: Integer): TPestParamMethod;
    procedure SetPestMethod(Grid: TRbwDataGrid4; ACol: Integer;
      const Value: TPestParamMethod);
    function GetPestModifier(Grid: TRbwDataGrid4; ACol: Integer): string;
    procedure SetPestModifier(Grid: TRbwDataGrid4; ACol: Integer;
      const Value: string);
    function GetPestParameterAllowed(DataGrid: TCustomRBWDataGrid; ACol: Integer): boolean;
    function GetModflow6TimeSeriesAllowed(DataGrid: TCustomRBWDataGrid; ACol: Integer): boolean;
    function GetPestModifierAssigned(Grid: TRbwDataGrid4;
      ACol: Integer): Boolean;
    function GwtColumnCount: integer;
    function IsChdEndHeadColumn(ACol: Integer): Boolean;
    function IsChdActiveColumn(ACol: Integer): Boolean;
    function IsChdMultiplierColumn(ACol: Integer): Boolean;
    procedure UpdateUzfScrollWidth;
    procedure CreateFmp4EfficiencyNode;
    procedure Fmp4EfficiencyChanged(Sender: TObject);
    procedure GetFmp4EfficiencyBoundary(const ScreenObjectList: TList);
    procedure CreateFmp4EfficiencyImprovementNode;
    procedure Fmp4EfficiencyImprovementChanged(Sender: TObject);
    procedure GetFmp4EfficiencyImprovementBoundary(const ScreenObjectList: TList);
    procedure CreateFmp4BareRunoffFractionNode;
    procedure Fmp4BareRunoffFractionChanged(Sender: TObject);
    procedure GetFmp4BareRunoffFractionBoundary(const ScreenObjectList: TList);
    procedure CreateFmp4BarePrecipitationConsumptionFractionNode;
    procedure Fmp4BarePrecipitationConsumptionFractionChanged(Sender: TObject);
    procedure GetFmp4BarePrecipitationConsumptionFractionBoundary(const ScreenObjectList: TList);
    procedure Fmp4BareEvapChanged(Sender: TObject);
    procedure CreateFmp4BareEvapNode;
    procedure GetFmp4BareEvapBoundary(const ScreenObjectList: TList);
    procedure Fmp4DirectRechargeChanged(Sender: TObject);
    procedure CreateFmp4DirectRechargeNode;
    procedure GetFmp4DirectRechargeBoundary(const ScreenObjectList: TList);

    procedure Fmp4PrecipPotConsumptionChanged(Sender: TObject);
    procedure CreateFmp4PrecipPotConsumptionNode;
    procedure GetFmp4PrecipPotConsumptionBoundary(const ScreenObjectList: TList);

    procedure Fmp4NrdInfilLocationChanged(Sender: TObject);
    procedure CreateFmp4NrdInfilLocationNode;
    procedure GetFmp4NrdInfilLocationBoundary(const ScreenObjectList: TList);

    procedure Fmp4LandUseAreaFractionChanged(Sender: TObject);
    procedure CreateFmp4LandUseAreaFractionNode;
    procedure GetFmp4LandUseAreaFractionBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultLandUseAreaFractionChanged(Sender: TObject);
    procedure CreateFmp4MultLandUseAreaFractionNode;
    procedure GetFmp4MultLandUseAreaFractionBoundary(const ScreenObjectList: TList);

    procedure Fmp4CropCoefficientChanged(Sender: TObject);
    procedure CreateFmp4CropCoefficientNode;
    procedure GetFmp4CropCoefficientBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultCropCoefficientChanged(Sender: TObject);
    procedure CreateFmp4MultCropCoefficientNode;
    procedure GetFmp4MultCropCoefficientBoundary(const ScreenObjectList: TList);

    procedure Fmp4ConsumptiveUseChanged(Sender: TObject);
    procedure CreateFmp4ConsumptiveUseNode;
    procedure GetFmp4ConsumptiveUseBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultConsumptiveUseChanged(Sender: TObject);
    procedure CreateFmp4MultConsumptiveUseNode;
    procedure GetFmp4MultConsumptiveUseBoundary(const ScreenObjectList: TList);

    procedure Fmp4IrrigationChanged(Sender: TObject);
    procedure CreateFmp4IrrigationNode;
    procedure GetFmp4IrrigationBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultIrrigationChanged(Sender: TObject);
    procedure CreateFmp4MultIrrigationNode;
    procedure GetFmp4MultIrrigationBoundary(const ScreenObjectList: TList);

    procedure Fmp4RootDepthChanged(Sender: TObject);
    procedure CreateFmp4RootDepthNode;
    procedure GetFmp4RootDepthBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultRootDepthChanged(Sender: TObject);
    procedure CreateFmp4MultRootDepthNode;
    procedure GetFmp4MultRootDepthBoundary(const ScreenObjectList: TList);

    procedure Fmp4TranspirationFractionChanged(Sender: TObject);
    procedure CreateFmp4TranspirationFractionNode;
    procedure GetFmp4TranspirationFractionBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultTranspirationFractionChanged(Sender: TObject);
    procedure CreateFmp4MultTranspirationFractionNode;
    procedure GetFmp4MultTranspirationFractionBoundary(const ScreenObjectList: TList);

    procedure Fmp4EvaporationIrrigationFractionChanged(Sender: TObject);
    procedure CreateFmp4EvaporationIrrigationFractionNode;
    procedure GetFmp4EvaporationIrrigationFractionBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultEvaporationIrrigationFractionChanged(Sender: TObject);
    procedure CreateFmp4MultEvaporationIrrigationFractionNode;
    procedure GetFmp4MultEvaporationIrrigationFractionBoundary(const ScreenObjectList: TList);

    procedure Fmp4FractionOfPrecipToSurfaceWaterChanged(Sender: TObject);
    procedure CreateFmp4FractionOfPrecipToSurfaceWaterNode;
    procedure GetFmp4FractionOfPrecipToSurfaceWaterBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultFractionOfPrecipToSurfaceWaterChanged(Sender: TObject);
    procedure CreateFmp4MultFractionOfPrecipToSurfaceWaterNode;
    procedure GetFmp4MultFractionOfPrecipToSurfaceWaterBoundary(const ScreenObjectList: TList);

    procedure Fmp4FractionOfIrrigToSurfaceWaterChanged(Sender: TObject);
    procedure CreateFmp4FractionOfIrrigToSurfaceWaterNode;
    procedure GetFmp4FractionOfIrrigToSurfaceWaterBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultFractionOfIrrigToSurfaceWaterChanged(Sender: TObject);
    procedure CreateFmp4MultFractionOfIrrigToSurfaceWaterNode;
    procedure GetFmp4MultFractionOfIrrigToSurfaceWaterBoundary(const ScreenObjectList: TList);

    procedure Fmp4AddedDemandChanged(Sender: TObject);
    procedure CreateFmp4AddedDemandNode;
    procedure GetFmp4AddedDemandBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultAddedDemandChanged(Sender: TObject);
    procedure CreateFmp4MultAddedDemandNode;
    procedure GetFmp4MultAddedDemandBoundary(const ScreenObjectList: TList);

    procedure Fmp4CropHasSalinityDemandChanged(Sender: TObject);
    procedure CreateFmp4CropHasSalinityDemandNode;
    procedure GetFmp4CropHasSalinityDemandBoundary(const ScreenObjectList: TList);

    procedure Fmp4MultCropHasSalinityDemandChanged(Sender: TObject);
    procedure CreateFmp4MultCropHasSalinityDemandNode;
    procedure GetFmp4MultCropHasSalinityDemandBoundary(const ScreenObjectList: TList);

    procedure Fmp4AddedDemandRunoffSplitChanged(Sender: TObject);
    procedure CreateFmp4AddedDemandRunoffSplitNode;
    procedure GetFmp4AddedDemandRunoffSplitBoundary(const ScreenObjectList: TList);

    procedure GetTvkBoundary(const ScreenObjectList: TList);
    procedure GetTvsBoundary(const ScreenObjectList: TList);

    // @name is set to @true when the @classname has stored values of the
    // @link(TScreenObject)s being edited.
    property IsLoaded: boolean read FIsLoaded write SetIsLoaded;

    // @name is set to @true if more than one @link(TScreenObject)s are
    // being edited at one time. Also AllowGrayed is set to @name for
    //  @link(cbLineColor), @link(cbInterpolation), @link(cbIntersectedCells),
    // @link(cbEnclosedCells), and @link(cbFillColor).
    property MultipleScreenObjects: boolean read FMultipleScreenObjects
      write SetMultipleScreenObjects;

    function CanSetPoints: Boolean;
    procedure InitializeModflowBoundaryFrames(const AScreenObject:
      TScreenObject);
    procedure StoreModflowBoundary(Frame: TframeScreenObjectParam;
      ParamType: TParameterType; Node: TJvPageIndexNode);
    procedure GetModflowBoundary(Frame: TframeScreenObjectParam;
      Parameter: TParameterType; ScreenObjectList: TList;
      Node: TJvPageIndexNode);
    procedure StoreModflowTimeInterpolation(Frame: TframeScreenObjectParam;
      ParamType: TParameterType; Node: TJvPageIndexNode);
    procedure GetModflowTimeInterpolation(Frame: TframeScreenObjectParam;
      Parameter: TParameterType; ScreenObjectList: TList;
      Node: TJvPageIndexNode);
    procedure StoreFormulaInterpretation(Frame: TframeScreenObjectCondParam;
      ParamType: TParameterType);
    procedure GetFormulaInterpretation(Frame: TframeScreenObjectCondParam;
      Parameter: TParameterType; ScreenObjectList: TList);
    procedure GetModflowBoundaries(const AScreenObjectList: TList);
    procedure GetSutraObservations(const AScreenObjectList: TList);
    procedure StoreModflowBoundaryParameters(Boundary: TModflowParamBoundary;
      Times: TTimeArray; Frame: TframeScreenObjectParam);
    procedure StoreModflowBoundaryValues(Frame: TframeScreenObjectNoParam;
      Times: TTimeArray; Boundary: TModflowBoundary);
    procedure StoreMF_BoundColl(ColumnOffset: Integer;
      BoundaryValues: TCustomMF_BoundColl; const Times: TTimeArray;
      Frame: TframeScreenObjectNoParam);
    procedure GetMF_BoundaryTimes(var Times: TTimeArray;
      Frame: TframeScreenObjectNoParam);
    procedure GetModflowBoundaryParameters(Parameter: TParameterType;
      ScreenObjectList: TList; Frame: TframeScreenObjectParam;
      TimeList: TParameterTimeList);
    procedure GetModflowBoundaryValues(Parameter: TParameterType;
      ScreenObjectList: TList; TimeList: TParameterTimeList;
      DataGrid: TRbwDataGrid4);
    procedure GetModflowBoundaryTimes(ScreenObjectList: TList;
      Parameter: TParameterType; TimeList: TParameterTimeList);
    procedure GetModflowBoundaryCollection(DataGrid: TRbwDataGrid4;
      ValuesFunction: TGetBoundaryCollectionEvent; ColumnOffset: Integer;
      ScreenObjectList: TList; Parameter: TParameterType;
      TimeList: TParameterTimeList);
    function DataSetsSpecified: Boolean;
    Function GetSfrParser(Sender: TObject): TRbwParser;
    procedure GetUzfCollection(TimeList: TParameterTimeList;
      ScreenObjectList: TList; ColumnOffset: Integer; DataGrid: TRbwDataGrid4;
      Method: TGetBoundaryCollectionEvent);
    procedure UpdateBoundaryState(Boundary: TFormulaProperty;
      ScreenObjectIndex: Integer; var State: TCheckBoxState);
    procedure GetSfrBoundary(const ScreenObjectList: TList);
    function ShouldStoreBoundary(Node: TJvPageIndexNode;
      Boundary: TFormulaProperty): boolean;
    procedure UpdateNodeState(Node: TJvPageIndexNode);
    procedure CreateChdNode;
    procedure CreateGhbNode;
    procedure CreateFhbHeadNode;
    procedure CreateWelNode;
    procedure CreateRivNode;
    procedure CreateDrnNode;
    procedure CreateDrtNode;
    procedure CreateRchNode(AScreenObject: TScreenObject);
    procedure CreateEvtNode(AScreenObject: TScreenObject);
    procedure CreateEtsNode(AScreenObject: TScreenObject);
    procedure CreateResNode(AScreenObject: TScreenObject);
    procedure CreateLakNode;
    procedure CreateLakMf6Node(AScreenObject: TScreenObject);
    procedure CreateSfrNode(AScreenObject: TScreenObject);
    procedure CreateStrNode(AScreenObject: TScreenObject);
    procedure CreateUzfNode(AScreenObject: TScreenObject);
    procedure CreateFarmWelNode;
    procedure CreateFarmPrecipNode(AScreenObject: TScreenObject);
    procedure CreateFarmRefEvapNode(AScreenObject: TScreenObject);
    procedure CreateFarmCropIDNode(AScreenObject: TScreenObject);
    procedure CreateFarmIDNode(AScreenObject: TScreenObject);
    procedure SetSelectedMfBoundaryNode;
    procedure CreateMawNode(AScreenObject: TScreenObject);
    procedure CreateCSubNode;
    procedure CreateSubPestObsNode(AScreenObject: TScreenObject);
    procedure CreateSwtPestObsNode(AScreenObject: TScreenObject);
    procedure CreateTvkNode;
    procedure CreateTvsNode;
    procedure InitializeVertexGrid;
    procedure InitializePhastSpecifiedHeadGrid;
    procedure InitializePhastSpecifiedFluxGrid;
    procedure InitializePhastLeakyBoundaryGrid;
    procedure InitializePhastRiverBoundaryGrid;
    procedure InitializePhastWellGrid;
    procedure SetColWidthsInPhastBoundaryGrids;
    procedure InitializePhastBoundaryControls;
    procedure GetPhastBoundariesForSingleObject;
    procedure GetPhastFluxBoundaryForSingleObject(UsedTimes: TRealList);
    procedure GetPhastLeakyBoundaryForSingleObject(UsedTimes: TRealList);
    procedure GetPhastRiverBoundaryForSingleObject(UsedTimes: TRealList);
    procedure GetPhastSpecifiedHeadBoundaryForSingleObject(
      UsedTimes: TRealList);
    procedure GetPhastWellBoundaryForSingleObject(UsedTimes: TRealList);
    procedure GetScreenObjectVerticies;
    procedure SetZLabelCaptions;
    procedure GetPhastBoundaryConditionsForAdditionalObjects(
      AScreenObject: TScreenObject; var TempType: TPhastBoundaryTypes);
    procedure GetPhastSpecifiedHeadBoundaryForAdditionalObject(
      AScreenObject: TScreenObject; UsedTimes: TRealList;
      var TempType: TPhastBoundaryTypes);
    procedure GetPhastSpecifiedFluxBoundaryForAdditionalObject(
      AScreenObject: TScreenObject; UsedTimes: TRealList;
      var TempType: TPhastBoundaryTypes);
    procedure GetPhastLeakyBoundaryForAdditionalObject(
      AScreenObject: TScreenObject; UsedTimes: TRealList;
      var TempType: TPhastBoundaryTypes);
    procedure GetPhastRiverBoundaryForAdditionalObject(
      AScreenObject: TScreenObject; UsedTimes: TRealList;
      var TempType: TPhastBoundaryTypes);
    procedure GetPhastWellBoundaryForAdditionalObject(
      AScreenObject: TScreenObject; UsedTimes: TRealList;
      var TempType: TPhastBoundaryTypes);
    procedure GetElevationFormulasForAdditionalObject(
      AScreenObject: TScreenObject);
    procedure GetDataSetsForAdditionalObject(AScreenObject: TScreenObject);
    procedure GetCellSizeUsedForAdditionalObject(AScreenObject: TScreenObject);
    procedure GetColorDataForAdditionalObject(AScreenObject: TScreenObject);
    procedure GetAssignmentMethodForAdditionalObject(AScreenObject: TScreenObject);
    procedure GetEvaluatedAtForAdditionalObject(AScreenObject: TScreenObject);
    procedure SetScreenObjectVerticies;
    procedure GetDataSetsForSingleObject;
    procedure SetGridCellSizeDataForSingleObject;
    procedure SetElevationDataForSingleObject;
    procedure GetColorDataForSingleObject;
    procedure GetAssignmentMethodForSingleObject;
    procedure AddGisFunctionsToAllParsers;
    procedure CreateDataSetEdits(ListOfScreenObjects: TList);
    procedure FillCompilerList(CompilerList: TList);
    procedure CheckIfDataSetUsedInElevationFormula(var CreateNode: Boolean;
      DataSet: TDataArray; ElevationFormula: string; Ed: TRbwEdit);
    procedure UpdateCurrentEdit;
    procedure UpdateScreenObjectData;
    procedure InvalidateAllDataSets;
    procedure UpdateDataSetTreeViewNodeStates;
    procedure SetSelectedName;
    procedure AssignHfbFormulas(Ed: TEdit);
    procedure DisableAllowGrayed(CheckBox: TCheckBox);
    procedure SetDisabledElevationFormulas(FirstScreenObject: TScreenObject);
    procedure AssignImportedValuesColumn(var First: boolean; var
      ColIndex: Integer; ValueStorage: TValueArrayStorage;
      const ColumnCaption: string);
    function GetCoordinateCaption(const AScreenObject: TScreenObject): string;
    function GetHigherCoordinateCaption(const AScreenObject: TScreenObject): string;
    function GetLowerCoordinateCaption(const AScreenObject: TScreenObject): string;
    procedure AssignConductanceCaptions(Frame: TframeScreenObjectCondParam;
      Boundary: TSpecificModflowBoundary);
    procedure GetIFaceForAdditionalObject(AScreenObject: TScreenObject);
    procedure GetModpathParticles(ListOfScreenObjects: TList);
    procedure GetFluxObservationsForFrame(Node: TJvPageIndexNode;
      FluxObservations: TFluxObservationGroups; const AScreenObjectList: TList;
      FluxFrame: TframeFluxObs); overload;
    procedure GetFluxObservationsForFrame(Node: TJvPageIndexNode;
      FluxObservations: TCustomSutraFluxObservationGroups;
      const AScreenObjectList: TList;
      FluxFrame: TframeFluxObs); overload;
    procedure GetHeadFluxObservations(const AScreenObjectList: TList);
    procedure CreateFluxNode(var NewNode: TJvPageIndexNode;
      FluxPackage: TModflowPackageSelection; AFrame: TframeFluxObs;
      APage: TJvStandardPage; FluxObservations: TFluxObservationGroups); overload;
    procedure CreateFluxNode(var NewNode: TJvPageIndexNode; Caption: string;
      AFrame: TframeFluxObs;
      APage: TJvStandardPage; FluxObservations: TCustomSutraFluxObservationGroups); overload;
    procedure SetFluxObservations(List: TList; ANode: TJvPageIndexNode;
      AFrame: TframeFluxObs; FluxObservations: TFluxObservationGroups); overload;
    procedure SetFluxObservations(List: TList; ANode: TJvPageIndexNode;
      AFrame: TframeFluxObs; FluxObservations: TCustomSutraFluxObservationGroups); overload;
    procedure SetAllFluxObservations(List: TList);
    procedure GetNearestOutflowSegment(var NewText: string; ParameterType: TParameterType);
    procedure GetNearestDiversionSegment(var NewText: string; ParameterType: TParameterType);
    procedure GetFluxObservations(const AScreenObjectList: TList);
    procedure SetGageNodeStateIndex;
    // If the points in a @link(ScreenObjectUnit.TScreenObject)
    // are being changed, all the data sets that
    // are being affected by the @link(ScreenObjectUnit.TScreenObject)
    // must be updated.
    procedure UpdateVertices;
    procedure SetFrameData;
    procedure UpdateVertexNumbers;
    procedure UpdateSectionNumbers;
    procedure SetupChildModelControls(AScreenObject: TScreenObject);
    function CanSpecifyChildModels(AScreenObject: TScreenObject): Boolean;
    procedure GetVertexValues;
    procedure SetVertexValues(AScreenObject: TScreenObject);
    procedure GetUsedLgrModels(const AScreenObject: TScreenObject);
    procedure GetAdditionalUsedModels(const AScreenObjectList: TList);
    procedure EnableChildModelList(AScreenObject: TScreenObject);
    procedure FillChildModelList;
    procedure GetPositionLockedForAdditionalObject(AScreenObject: TScreenObject);
    procedure GetCanSelectNode(Node: TTreeNode; var AllowChange: Boolean);
    function ShouldCreateSutraBoundary: Boolean;
    procedure CreateSutraFeatureNodes(AScreenObject: TScreenObject);
    procedure SetDefaultCellSize;
    procedure SetModflowBoundaryColCount;
    procedure GetObjectLabelForAdditionalScreenObject(AScreenObject: TScreenObject);
    procedure SetObjectCaption(List: TList);
    procedure EnableWellTabfile;
    procedure GetPotentialMvrSources(Sender: TObject;
      var PotentialSources: TSourcePackageChoices);
    procedure UpdateDrtReturnFlowLabels(Sender: TObject);
    procedure LakePestObsChanged(Sender: TObject);
    procedure ShowGageObservations;
    procedure GetSubObs(ListOfScreenObjects: TList);
    procedure GetSwtObs(ListOfScreenObjects: TList);
    procedure SubObsChanged(Sender: TObject);
    procedure SwtObsChanged(Sender: TObject);
    procedure EnablePestCells(Sender: TObject; ACol, ARow: Longint;
      var CanSelect: Boolean);
    Property PestMethod[Grid: TRbwDataGrid4; ACol: Integer]: TPestParamMethod
      read GetPestMethod write SetPestMethod;
//    Property PestMethodAssigned[Grid: TRbwDataGrid4; ACol: Integer]: Boolean
//      read GetPestMethodAssigned write SetPestMethodAssigned;
    Property PestModifier[Grid: TRbwDataGrid4; ACol: Integer]: string
      read GetPestModifier write SetPestModifier;
    procedure GetPestModifiers(Frame: TframeScreenObjectNoParam;
      Parameter: TParameterType; ScreenObjectList: TList);
    procedure StorePestModifiers(Frame: TframeScreenObjectParam;
      ParamType: TParameterType; Node: TJvPageIndexNode);
    { Private declarations }
    Property PestModifierAssigned[Grid: TRbwDataGrid4; ACol: Integer]: Boolean
      read GetPestModifierAssigned;
    procedure UpdateMawScrollWidth;
    function CheckMf6LakeOutlet: Boolean;
    function EtsColCount: Integer;
  protected
    procedure CreateParams(var Params: TCreateParams); override;
  public
    procedure Initialize;
    procedure ClearExpressionsAndVariables;
    // When a @link(TScreenObject) is first created,
    // @name is called to display it's properties.
    // GetDataForMultipleScreenObjects)
    procedure GetData(const AScreenObject: TScreenObject);
    // When the properties of one or more
    // @link(TScreenObject)s is being edited,
    // GetDataForMultipleScreenObjects is called to display their properties.
    // @SeeAlso(GetData)
    procedure GetDataForMultipleScreenObjects(const AScreenObjectList: TList);
    procedure HideGLViewersWithMicrosoftOpenGL;
    destructor Destroy; override;
    { Public declarations }
  end;

var
  // @name is the instance of @link(TfrmScreenObjectProperties)
  // used in GoPhast.
  frmScreenObjectProperties: TfrmScreenObjectProperties = nil;

resourcestring
  StrLowerZcoordinate = 'Lower Z-coordinate';
  StrLowerYcoordinate = 'Lower Y-coordinate';
  StrLowerXcoordinate = 'Lower X-coordinate';
  StrHigherZcoordinate = 'Higher Z-coordinate';
  StrHigherYcoordinate = 'Higher Y-coordinate';
  StrHigherXcoordinate = 'Higher X-coordinate';
  StrZcoordinate = 'Z-coordinate';
  StrYcoordinate = 'Y-coordinate';
  StrXcoordinate = 'X-coordinate';
  StrNoParameter = 'no parameter';

implementation

uses Math, JvToolEdit, frmGoPhastUnit, AbstractGridUnit,
  frmFormulaUnit, frmConvertChoiceUnit, GIS_Functions, PhastModelUnit,
  ModflowConstantHeadBoundaryUnit, ModflowTransientListParameterUnit,
  ModflowGhbUnit, ModflowDrtUnit, ModflowRchUnit, ModflowEvtUnit,
  ModflowEtsUnit, ModflowLakUnit, frameCrossSectionUnit, frameFlowTableUnit,
  ModflowUzfUnit, ModflowSfrUnit, ModflowHobUnit,
  ModpathParticleUnit, IntListUnit,
  frmManageFluxObservationsUnit, ModflowGageUnit, ModflowMnw2Unit, JvGroupBox,
  ModflowHydmodUnit, ModelMuseUtilities, Mt3dmsChemUnit,
  Mt3dmsTobUnit, Mt3dmsFluxObservationsUnit, frmDataSetsUnits,
  SutraBoundariesUnit, SutraMeshUnit, SutraOptionsUnit, ZoomBox2,
  ModflowStrUnit, ModflowFhbUnit,
  ModflowFmpPrecipitationUnit, ModflowFmpEvapUnit, ModflowFmpCropSpatialUnit,
  ModflowFmpWellUnit, ModflowCfpPipeUnit, ModflowCfpFixedUnit,
  ModflowCfpRechargeUnit, ModflowSwrUnit, ModflowSwrDirectRunoffUnit,
  ObjectLabelUnit, ModflowMnw1Unit, ModflowFmpFarmIdUnit, OpenGL,
  frmTimeUnitsConverterUnit, frmEditFeatureFormulaUnit, FootprintBoundary,
  ModflowSwiObsUnit, ModflowRipUnit, ModflowWellUnit, Mt3dUztRchUnit,
  Mt3dUztSatEtUnit, Mt3dUztUnsatEtUnit, Mt3dUzfSeepageUnit, ModflowSfr6Unit,
  ModflowMawUnit, Modflow6ObsUnit, ModflowLakMf6Unit, frameLakeOutletUnit,
  ModflowUzfMf6Unit, TimeUnit, Mt3dLktUnit, Mt3dSftUnit, ModflowCsubUnit,
  ModflowSubsidenceDefUnit, frmManageSutraBoundaryObservationsUnit,
  framePestObsMf6Unit, ModflowParameterUnit, ModflowDrnUnit, ModflowRivUnit,
  ModflowResUnit, Modflow6TimeSeriesCollectionsUnit, Modflow6TimeSeriesUnit,
  ModflowGwtSpecifiedConcUnit, PestPropertiesUnit, ModflowFmp4EfficiencyUnit,
  ModflowFmp4EfficiencyImprovementUnit, ModflowFmp4BareRunoffFractionUnit,
  ModflowFmp4BarePrecipitationConsumptionFractionUnit,
  ModflowFmp4PotentialEvapBareUnit, ModflowFmp4DirectRechargeUnit,
  ModflowFmp4PrecipPotConsumptionUnit, ModflowFmp4NrdInfilLocationUnit,
  ModflowFmp4CropCoefficientUnit, ModflowFmp4LandUseAreaFractionUnit,
  ModflowFmp4ConsumptiveUseUnit, ModflowFmp4IrrigationSpatialUnit,
  ModflowFmp4RootDepthUnit, ModflowFmp4TranspirationFractionUnit,
  frmImportVertexValuesUnit, QuadTreeClass,
  ModflowFmp4EvaporationIrrigationFractionUnit,
  ModflowFmp4FractionOfPrecipToSurfaceWaterUnit,
  ModflowFmp4FractionOfIrrigToSurfaceWaterUnit, ModflowFmp4AddedDemandUnit,
  ModflowFmp4CropHasSalinityDemandUnit, ModflowFmp4AddedDemandRunoffSplitUnit,
  DataArrayManagerUnit, DataSetNamesUnit, frameModflow6DynamicTimeSeriesUnit,
  ModflowTvkUnit, ModflowTvsUnit;

resourcestring
  StrConcentrationObserv = 'Concentration Observations: ';
  StrFluxObserv = 'Flux Observations: ';
  StrUseToSetGridElem = 'Use to set grid element size';
  StrGridElementSize = 'Grid element size';
  StrUseToSetGridCell = 'Use to set grid cell size';
  StrGridCellSize = 'Grid cell size';
  StrUseToSetMeshElem = 'Use to set mesh element size';
  StrMeshElementSize = 'Mesh element size';
  StrNumberOfZFormulas = 'Number of Z formulas';
  StrNumberOfYFormulas = 'Number of Y formulas';
  StrNumberOfXFormulas = 'Number of X formulas';
  StrObjEditing = 'The object or objects you are editing will not '
        + 'affect the values of any data set because:' + sLineBreak
        + '(1) neither enclosed nor '
        + 'intersected elements or nodes will have their values set by the '
        + 'object or objects and element, and' + sLineBreak
        + '(2) node values will not be set by '
        + 'interpolation.'
        + sLineBreak + sLineBreak
        + 'Is this really what you want?';
  StrYouAreAttemptingT = 'You are attempting to specify the value of a data ' +
  'set by interpolation but at least one of the data sets, %s, does not have' +
  ' an interpolator assigned.'#13#10'Is this really what you want?';
  StrErrorIn0sRow = 'Error in %0:s Row: %1:d Column: %2:d. %3:s';
  StrFormulaForSDat = 'Formula for "%s" data set';
  StrFormula = 'Formula';
  StrVertexNumbers = 'Vertex numbers';
  StrIfMoreThanOneObj = 'If more than one object is being edited, vertices c' +
  'an not be edited.';
  StrSorryThisFunction = 'Sorry, This function can only be performed when a ' +
  'single object is being edited.';
  StrThereIsNoOtherSt = 'There is no other stream or lake';
  StrTime = 'Time';
  StrSolution = 'Solution';
  StrHead = 'Head';
  StrAssociatedSolution = 'Associated solution';
  StrInterpolateHead = 'Interpolate head';
  StrInterpolateSolution = 'Interpolate solution';
  StrFlux = 'Flux';
  StrInterpolateFlux = 'Interpolate flux';
  StrSectionNumber = 'Section Number';
  StrNewSection = 'New section';
  StrX = 'X';
  StrY = 'Y';
  StrZ = 'Z';
  StrGAGEForS = 'GAGE: for %s';
  StrErrorThereAppears = 'Error: There appears to be a cirular reference to ' +
  '"%0:s" in the formula for %1:s.  Do you wish to restore the old formula';
  StrErrorThereAppearsNoRevert = 'Error: There appears to be a cirular refer' +
  'ence to %0:s"" in the formula for %1:s.';
  StrErrorInFormulaS = 'Error in formula: %s';
  StrErrorInMixtureFor = 'Error in mixture formula for the data set "%0:s ' +
  '%1:s": ';
  StrTheFormulaYouEnte = 'The formula you entered is does not return the cor' +
  'rect data type.  It will be automatically converted.';
  StrErrorInFormulaFor = 'Error in formula for the data set "%0:s": %1:s';
  StrSThisMightBeD = '%s '#13#10'This might be due to a circular reference. ' +
  ' Do you wish to restore the old formula?';
  StrSThisMightBeDNoRevert = '%s '#13#10'This might be due to a circular ref' +
  'erence.';
  StrYouMustSpecifyNod = 'You must specify nodes or elements before editing ' +
  'the formula.';
  StrErrorTheFormulaI = 'Error: the formula does not result in a real num' +
  'ber';
  StrThisObjectWillNo = 'This object will no longer set the properties of 2D' +
  ' data sets that are used in its elevation formula(s) either directly or i' +
  'ndirectly.';
  StrTheseObjectsWillN = 'These objects will no longer set the properties of' +
  ' 2D data sets that are used in their elevation formula(s) either directly' +
  ' or indirectly.';
  StrSpecifiedHead = 'Specified head';
  StrSpecifiedFlux = 'Specified flux';
  StrLeakyBoundaryHead = 'Leaky boundary head';
  StrRiver = 'River';
  StrWellRate = 'Well rate';
  StrInterpolated = 'Interpolated';
  StrFirstValue = 'First Value';
  StrSecondValue = 'Second Value';
  StrFirstElevation = 'First Elevation';
  StrSecondElevation = 'Second Elevation';
  StrFirstDepth = 'First Depth';
  StrSecondDepth = 'Second Depth';
  StrSpecifiedSolution = 'Specified solution';
  StrErrorThereAppearsCirc = 'Error: There appears to be an error or a cirular' +
  ' reference in this formula.  Do you wish to restore the old formula';
  StrErrorThereAppears2 = 'Error: There appears to be a cirular reference to' +
  ' "%s" in this formula.  Do you wish to restore the old formula';
  StrInvalidMethod = 'You are attempting to specify MODFLOW features but' +
  ' they won''t be specified correctly because neither "Set properties of en' +
  'closed cells" nor "Set properties of intersected cells" is checked.'#13#10 +
  #13#10'Is this really what you want?';
  StrSutraObservations = 'Observations';
  StrSutraSpecifiedHead = 'Specified Head';
  StrSpecifiedPressure = 'Specified Pressure';

  StrDuplicateSAllowed = 'Duplicate %s allowed';
  StrThereIsNoOtherSteam = 'There is no other stream.';
  StrFarmWellsInS = 'Farm Wells in %s';
  StrFarmPrecipInS = 'Precip. in %s';
  StrFarmRefEvapIn = 'Ref. Evap. in %s';
  StrFarmsInS = 'Farms in %s';
  StrCropIDInS = 'Land Use ID in %s';
  StrFarmIDInS = 'Water Balance Subregion ID in %s';
  StrCFPFixedHeads = 'CFP: Fixed Heads';
  StrCRCHConduitRechar = 'CRCH: Conduit Recharge';
  StrYouCanOnlyDefine = 'You can only define conduits in CFP with objects th' +
  'at have one %s formula on the Properties tab.';
  StrThereAreTooManyI = 'There are too many imported values for %s. The extr' +
  'a values will be deleted for any imported values for which this is the case.';
  StrThereAreTooFewIm = 'There are too few imported values for %s. Default v' +
  'alues will be added for any imported values for which this is the case.';
  StrTryModelLinkStre = 'Try "Model|Link Streams..." instead.';
  StrYouCanOnlyDefineMAW = 'You can only define multi-aquifer wells using po' +
  'int objects with zero Z-coordinates';
  StrModelMuseHasEncoun = 'ModelMuse has encountered a bug in selecting the ' +
  'correct MODFLOW package in the Object Properties dialog box. ModelMuse wi' +
  'll attempt to send a bug report. If you can, please provide any informati' +
  'on you can about what led up to this state. ';
  StrHeadObservationNamCount = 'Head observation names have not been specifi' +
  'ed by %d objects. Be sure to correct this before attempting to run MODFLO' +
  'W.';
  StrHeadObservationNamList = 'Head observation names have not been specifie' +
  'd in the following objects. Be sure to correct this before attempting to ' +
  'run MODFLOW.';
  StrYouCanOnlyDefineLkt = 'You can only define Lake transport using objects th' +
  'at define lakes';
  StrYouCanOnlyDefineSft = 'You can only define Stream transport using objec' +
  'ts that define SFR streams';
  StrReservoirPackage = 'Reservoir package';
  StrRechargeConcIn = 'Recharge conc in ';
  StrSatETConcIn = 'Sat ET conc in ';
  StrUnsatETConcIn = 'Unsat ET conc in ';
  StrUZFSinkConcIn = 'UZF sink conc in ';
  StrSomethingWentWrong = 'Something went wrong in the Object Properties dia' +
  'log box. Please save your work and restart ModelMuse.';
  StrSutraStateCalibrat = 'Sutra State Calibration Observations';
  StrSpecPressureObserv = 'Observations at Spec Pressure';
  StrSpecifiedConcTemp = 'Observations at Specified Conc/Temp';
  StrGeneralizedFlowObs = 'Observations at Generalized Flow';
  StrGeneralizedTranspor = 'Observations at Generalized Transport';
  StrSpecifiedFlowObser = 'Observations at Specified Flows';
  StrLandUseIDInS = 'Land Use ID in %s';

{$R *.dfm}

type
  TVertexColumn = (vcN, vcSection, vcX, vcY, vcNewSection);

  // @name represents the columns for the grid used in the specified head,
  // leaky, and flux boundary conditions.
  //
  // See TfrmScreenObjectProperties.@link(
  // TfrmScreenObjectProperties.dgSpecifiedHead).
  //
  // See TfrmScreenObjectProperties.@link(
  // TfrmScreenObjectProperties.dgBoundaryFlux).
  //
  // See TfrmScreenObjectProperties.@link(
  // TfrmScreenObjectProperties.dgBoundaryLeaky).
  TInterpolatedBoundaryColumns = (ibcNone, ibcTime, ibcBoundaryValue,
    ibcBoundaryInterpolate, ibcSolution, ibcSolutionInterpolate);

  // @name represents the columns for the grid used in the river and well
  // boundary condition
  //
  // See TfrmScreenObjectProperties.@link(
  // TfrmScreenObjectProperties.dgBoundaryRiver).
  //
  // See TfrmScreenObjectProperties.@link(TfrmScreenObjectProperties.dgWell).
  TNonInterpolateColumns = (nicNone, nicTime, nicBoundaryValue, nicSolution);


function CompareStartAndEndTimes(Item1, Item2: pointer): integer;
var
  Time1, Time2: TParameterTime;
begin
  Time1 := Item1;
  Time2 := Item2;
  result := Sign(Time1.StartTime - Time2.StartTime);
  if result = 0 then
  begin
    result := Sign(Time1.EndTime - Time2.EndTime);
  end;
end;

procedure TfrmScreenObjectProperties.EnableOK_Button;
var
  Index: integer;
  Enable: boolean;
  Edit: TScreenObjectDataEdit;
begin
  // EnableOK_Button allows the OK button to be pressed if all of the
  // formulas for the data sets and elevation formulas are valid.
  Enable := True;
  for Index := 1 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    if (Edit.Used = cbChecked)and (Edit.Expression = nil)
      and (Edit.Formula <> '') then
    begin
      Enable := False;
      break;
    end;
  end;
  if edZ.Enabled and (edZ.Text <> '') and (FZFormula = nil) then
  begin
    Enable := False;
  end;
  if edHighZ.Enabled and (edHighZ.Text <> '') and (FHighZFormula = nil) then
  begin
    Enable := False;
  end;
  if edLowZ.Enabled and (edLowZ.Text <> '') and (FLowZFormula = nil) then
  begin
    Enable := False;
  end;

  btnOK.Enabled := Enable;
end;

procedure TfrmScreenObjectProperties.EnablePestCells(Sender: TObject; ACol,
  ARow: Longint; var CanSelect: Boolean);
var
  Column: TRbwColumn4;
  PestParameterColumns: set of Byte;
  ParametersOnly: Boolean;
  UsedEvalAt: TEvaluatedAt;
  SpeciesIndex: Byte;
  AGrid: TRbwDataGrid4;
  DensityUsed: Boolean;
begin
  ParametersOnly := False;
  PestParameterColumns := [];
  UsedEvalAt := eaBlocks;
  DensityUsed := frmGoPhast.PhastModel.BuoyancyDensityUsed;
   {Support PEST here }

  if (Sender = frameChdParam.rdgModflowBoundary) then
  begin
    PestParameterColumns := [3,4,5];
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
      begin
        Include(PestParameterColumns, SpeciesIndex + 5);
      end;
    end;
  end
  else if (Sender = frameGhbParam.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3,4];
    if frmGoPhast.PhastModel.GwtUsed
      or frmGoPhast.PhastModel.BuoyancyDensityUsed then
    begin
      for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
      begin
        Include(PestParameterColumns, SpeciesIndex + 5);
      end;
    end;
  end
  else if (Sender = frameDrnParam.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3,4,5];
  end
  else if (Sender = frameHfbMf6.rdgModflowBoundary)
    or (Sender = frameRes.rdgModflowBoundary)
    then
  begin
    PestParameterColumns := [2,3];
//    if (Sender = frameHfbMf6.rdgModflowBoundary)
//      or (Sender = frameRes.rdgModflowBoundary)
//      then
    begin
      ParametersOnly := True;
    end;
  end
  else if (Sender = frameRchParam.rdgModflowBoundary)
    then
  begin
    PestParameterColumns := [2,3];
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
      begin
        Include(PestParameterColumns, SpeciesIndex + 4);
      end;
    end;
  end
  else if (Sender = frameWellParam.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3];
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
      begin
        Include(PestParameterColumns, SpeciesIndex + 4);
      end;
    end;
  end
  else if (Sender = frameFarmWell.rdgModflowBoundary)
    or (Sender = frameCSUB.rdgModflowBoundary)
    then
  begin
    PestParameterColumns := [2];
  end
  else if
    (Sender = frameGwtCnc.rdgModflowBoundary)
    or (Sender = frameGwtSrc.rdgModflowBoundary)
    then
  begin
    PestParameterColumns := [3];
  end
  else if (Sender = frameEtsParam.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3,4,5];
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
      begin
        Include(PestParameterColumns, SpeciesIndex + 6);
      end;
    end;
  end
  else if (Sender = frameRivParam.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3,4,5];
    if frmGoPhast.PhastModel.GwtUsed or frmGoPhast.PhastModel.BuoyancyDensityUsed then
    begin
      for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
      begin
        Include(PestParameterColumns, SpeciesIndex + 6);
      end;
    end;
  end
  else if (Sender = frameDrtParam.rdgModflowBoundary)
    or (Sender = frameEvtParam.rdgModflowBoundary)
    then
  begin
    PestParameterColumns := [2,3,4];
  end
  else if (Sender = frameScreenObjectSTR.rdgModflowBoundary) then
  begin
    PestParameterColumns := [4..11];
  end
  else if (Sender = frameFhbHead.rdgModflowBoundary)
    or (Sender = frameFhbFlow.rdgModflowBoundary) then
  begin
    PestParameterColumns := [1];
  end
  else if (Sender = frameScreenObjectUZF.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3,4,5];
  end
  else if (Sender = frameScreenObjectUzfMf6.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2..8];
  end
  else if (Sender = frameScreenObjectSfr6.rdgModflowBoundary) then
  begin
    if DensityUsed then
    begin
      PestParameterColumns := [3..10];
    end
    else
    begin
      PestParameterColumns := [3..9];
    end;
  end
  else if (Sender = frameMAW.rdgModflowBoundary) then
  begin
    PestParameterColumns := [3, 4, 6, 7, 8, 10..13, 15, 16];
  end
  else if (Sender = frameLakMf6.rdgModflowBoundary) then
  begin
    ParametersOnly := True;
    PestParameterColumns := [3..9];
  end
  else if (Sender = frameLak.rdgModflowBoundary) then
  begin
    ParametersOnly := True;
    PestParameterColumns := [2..7];
  end
  else if (Sender = frameMNW1.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2, 3, 5, 6, 7, 9, 10, 12, 14, 15];
  end
  else if (Sender = frameFarmRefEvap.rdgModflowBoundary)
   or (Sender = frameFarmPrecip.rdgModflowBoundary)
   or (Sender = frameFmp4AddedDemand.rdgModflowBoundary)
   or (Sender = frameFmp4AddedDemandRunoffSplit.rdgModflowBoundary)
   or (Sender = frameFmp4BareEvap.rdgModflowBoundary)
   or (Sender = frameFmp4BarePrecipitationConsumptionFraction.rdgModflowBoundary)
   or (Sender = frameFmp4BareRunoffFraction.rdgModflowBoundary)
   or (Sender = frameFmp4ConsumptiveUse.rdgModflowBoundary)
   or (Sender = frameFmp4CropCoefficient.rdgModflowBoundary)
   or (Sender = frameFmp4DirectRecharge.rdgModflowBoundary)
   or (Sender = frameFmp4Efficiency.rdgModflowBoundary)
   or (Sender = frameFmp4EvaporationIrrigationFraction.rdgModflowBoundary)
   or (Sender = frameFmp4FractionOfIrrigToSurfaceWater.rdgModflowBoundary)
   or (Sender = frameFmp4FractionOfPrecipToSurfaceWater.rdgModflowBoundary)
   or (Sender = frameFmp4LandUseAreaFraction.rdgModflowBoundary)
   or (Sender = frameFmp4PrecipPotConsumption.rdgModflowBoundary)
   or (Sender = frameFmp4RootDepth.rdgModflowBoundary)
   or (Sender = frameFmp4TranspirationFraction.rdgModflowBoundary)
   then
  begin
    PestParameterColumns := [2];
  end
  else if (Sender = frameFmp4MultAddedDemand.rdgModflowBoundary)
    or (Sender = frameFmp4MultConsumptiveUse.rdgModflowBoundary)
    or (Sender = frameFmp4MultCropCoefficients.rdgModflowBoundary)
    or (Sender = frameFmp4MultEvaporationIrrigationFraction.rdgModflowBoundary)
    or (Sender = frameFmp4MultFractionOfIrrigToSurfaceWater.rdgModflowBoundary)
    or (Sender = frameFmp4MultFractionOfPrecipToSurfaceWater.rdgModflowBoundary)
    or (Sender = frameMultLandUseAreaFraction.rdgModflowBoundary)
    or (Sender = frameFmp4MultTranspirationFraction.rdgModflowBoundary)
    or (Sender = frameFmp4MultRootDepth.rdgModflowBoundary)
    then
  begin
    AGrid := Sender as TRbwDataGrid4;
    PestParameterColumns := [2.. AGrid.ColCount-1];
  end
  else if (Sender = frameMNW2.rdgTimeTable) then
  begin
    ParametersOnly := True;
    PestParameterColumns := [2, 3, 4, 6, 7];
  end
  else if (Sender = frameScreenObjectSFR.dgFlowTimes) then
  begin
    ParametersOnly := True;
    PestParameterColumns := [2..6];
  end
  else if (Sender = frameScreenObjectSFR.dgUp)
    or (Sender = frameScreenObjectSFR.dgDown) then
  begin
    PestParameterColumns := [2..7];
  end
  else if (Sender = frameSwrReach.frameSwr.rdgModflowBoundary) then
  begin
    PestParameterColumns := [3, 5];
  end
  else if (Sender = frameSWR_Rain.rdgModflowBoundary)
    or (Sender = frameSWR_Evap.rdgModflowBoundary)
    or (Sender = frameSWR_LatInfl.rdgModflowBoundary)
    or (Sender = frameSWR_Stage.rdgModflowBoundary)
    then
  begin
    PestParameterColumns := [2];
  end
  else if (Sender = frameSutraSpecifiedPressure.rdgSutraFeature)
    or (Sender = frameSutraFluidFlux.rdgSutraFeature)
    then
  begin
    PestParameterColumns := [2, 3];
    UsedEvalAt := eaNodes;
  end
  else if (Sender = frameSutraMassEnergyFlux.rdgSutraFeature)
    or (Sender = frameSutraSpecTempConc.rdgSutraFeature) then
  begin
    PestParameterColumns := [2];
    UsedEvalAt := eaNodes;
  end
  else if (Sender = frameSutraGeneralizedFlowBoundary.rdgSutraFeature) then
  begin
    PestParameterColumns := [2..5, 8, 10];
    UsedEvalAt := eaNodes;
  end
  else if (Sender = frameSutraGeneralizeTransBoundary.rdgSutraFeature) then
  begin
    PestParameterColumns := [2..5];
    UsedEvalAt := eaNodes;
  end
  else if (Sender = frameScreenObjectTvk.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2..4];
  end
  else if (Sender = frameScreenObjectTvs.rdgModflowBoundary) then
  begin
    PestParameterColumns := [2,3];
  end
  ;

  if not (ACol in PestParameterColumns) and (ARow >= 1)
    and (ARow <= PestRowOffset) then
  begin
    CanSelect := False
  end;

  if csCustomPaint in (Sender as TRbwDataGrid4).ControlState then
  begin
    Exit;
  end;

  Assert(PestParameterColumns <> []);
  if (ARow >= 1) and (ACol in PestParameterColumns) then
  begin
    Column := (Sender as TRbwDataGrid4).Columns[ACol];
    if (ARow <= PestRowOffset)  then
    begin
      Column.ComboUsed := True;
      Column.LimitToList := True;
      if ARow = PestMethodRow then
      begin
        Column.PickList := FPestMethods
      end
      else
      begin
        if ParametersOnly then
        begin
          Column.PickList := FPestParameters;
        end
        else
        begin
          if UsedEvalAt = eaBlocks then
          begin
            Column.PickList := FPestBlockParametersAndDataSets;
          end
          else
          begin
            Column.PickList := FPestNodeParametersAndDataSets;
          end;
        end;
      end;
    end
    else
    begin
      Column.ButtonUsed := True;
      Column.LimitToList := False;
    end;
  end
  else if (ARow <= PestRowOffset) then
  begin
    CanSelect := False
  end;
end;

procedure TfrmScreenObjectProperties.btnColorClick(Sender: TObject);
var
  AShape: TShape;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
    // allow the user to edit the line or fill color of a @link(TScreenObject).
    // See @link(btnLineColor) and @link(btnFillColor).
  inherited;
  if Sender = btnLineColor then
  begin
    AShape := shpLineColor;
  end
  else if Sender = btnFillColor then
  begin
    AShape := shpFillColor;
  end
  else
  begin
    Assert(False);
    AShape := nil;
  end;

  coldlgColors.Color := AShape.Brush.Color;
  if coldlgColors.Execute then
  begin
    AShape.Brush.Color := coldlgColors.Color;
    AShape.Visible := True;
    if Sender = btnLineColor then
    begin
      AShape.Pen.Color := coldlgColors.Color;
      if IsLoaded then
      begin
        for Index := 0 to FNewProperties.Count - 1 do
        begin
          Item := FNewProperties[Index];
          Item.ScreenObject.LineColor := coldlgColors.Color;
        end;
      end;
    end
    else if Sender = btnFillColor then
    begin
      if IsLoaded then
      begin
        for Index := 0 to FNewProperties.Count - 1 do
        begin
          Item := FNewProperties[Index];
          Item.ScreenObject.FillColor := coldlgColors.Color;
        end;
      end;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.btnConvertTimeUnitsClick(Sender: TObject);
var
  frmTimeUnitsConverter: TfrmTimeUnitsConverter;
begin
  inherited;
  frmTimeUnitsConverter := TfrmTimeUnitsConverter.Create(nil);
  frmTimeUnitsConverter.Show;
end;

procedure TfrmScreenObjectProperties.btnDataSetFormulaClick(Sender: TObject);
var
  NewFormula: string;
  Variable: TCustomValue;
  Index: integer;
  Used: TStringList;
  Orientation: TDataSetOrientation;
  VariableList: TList;
  Expression: TExpression;
  OldFormula: string;
  OldFormulaOK: boolean;
  NewValue: string;
  EvaluatedAt: TEvaluatedAt;
  DSetName: string;
  ActiveOK: boolean;
  SpecifiedHeadOK: boolean;
  DsIndex: integer;
  ActiveDataArray: TDataArray;
begin
  inherited;

  Assert(FCurrentEdit <> nil);

  DSetName := FCurrentEdit.DataArray.DisplayName;

  VariableList := TList.Create;
  // VariableList will hold a list of variables that can
  // be used in the function
  Used := TStringList.Create;
  // "Used" will be a list of variables that depend on
  // the data set whose formula will be edited.
  try
    Orientation := FCurrentEdit.DataArray.Orientation;
    EvaluatedAt := FCurrentEdit.DataArray.EvaluatedAt;
    // Add the variable whose value is being set to "Used".

    Used.Assign(FCurrentEdit.UsedBy);

    Used.Sorted := True;
    GetListOfOkVariables(EvaluatedAt, Orientation, VariableList,
      FDataEdits.IndexOf(FCurrentEdit), FCurrentEdit);

    // if the user makes an invalid formula, it
    // may be necessary to restore it but only
    // if the formula that was already present
    // was OK to begin with.
    OldFormulaOK := FCurrentEdit.Expression <> nil;
    OldFormula := FCurrentEdit.Formula;
    NewValue := reDataSetFormula.Text;
    if (NewValue = '') and OldFormulaOK then
    begin
      NewValue := FCurrentEdit.Expression.DecompileDisplay;
    end;
//    with TfrmFormula.Create(self) do
    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(EvaluatedAt);
        ActiveDataArray := frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsActive);
        ActiveOK := (ActiveDataArray <> nil)
          and not ActiveDataArray.IsListeningTo(FCurrentEdit.DataArray);
        SpecifiedHeadOK := True;
        PopupParent := self;

        // register the appropriate variables with the
        // parser.
        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          rbFormulaParser.RegisterVariable(Variable);
          if UpperCase(Variable.Name) = UpperCase(rsActive) then
          begin
            ActiveOK := False;
          end;
          if UpperCase(Variable.Name) = UpperCase(rsModflowSpecifiedHead) then
          begin
            SpecifiedHeadOK := False;
          end;
        end;
        if not ActiveOK then
        begin
          RemoveActiveOnLayer;
        end;
        if not SpecifiedHeadOK then
        begin
          RemoveSpecifiedHeadOnLayer;
        end;
        RemoveGetVCont;
        RemoveHufFunctions;

        // show the variables and functions
        IncludeTimeSeries := False;
        UpdateTreeList;

        // put the formula in the TfrmFormula.
        Formula := NewValue;

        // The user edits the formula.
        ShowModal;
        if ResultSet then
        begin
          NewFormula := Formula;
          DsIndex := FDataEdits.IndexOf(FCurrentEdit);
          if FCurrentEdit.Formula <> NewFormula then
          begin
            FCurrentEdit.Formula := NewFormula;
            FSetCellsColor := True;
            CreateFormula(DsIndex, NewFormula);
            Expression := FCurrentEdit.Expression;

            if Expression <> nil then
            begin
              CheckForCircularReference(Expression, DSetName, DsIndex,
                OldFormulaOK, OldFormula);

              // update the list of which variables depend on which
              // others.;
              UpdateDataSetLinkages(Expression, DsIndex, DSetName);

            end;
          end;
          AssignNewDataSetFormula(DsIndex, FCurrentEdit.Formula);
          reDataSetFormula.Text := FCurrentEdit.Formula;
        end;                                                            
      finally
        Initialize;
//        Free;
      end;
    end;
  finally
    Used.Free;
    VariableList.Free;
    // Don't allow the user to click the OK button if any formulas are invalid.
    EnableOK_Button;
  end;
end;

procedure TfrmScreenObjectProperties.btnEditFeatureFormulasClick(
  Sender: TObject);
var
  ScreenObjects: TScreenObjectList;
  index: Integer;
  frmEditFeatureFormula: TfrmEditFeatureFormula;
begin
  inherited;
  Hide;
  ModalResult := mrCancel;
  ScreenObjects := TScreenObjectList.Create;
  try
    ScreenObjects.Capacity := FScreenObjectList.Count;
    for index := 0 to FScreenObjectList.Count - 1 do
    begin
      ScreenObjects.Add(
        TScreenObject(FScreenObjectList[index]));
    end;
    frmEditFeatureFormula := TfrmEditFeatureFormula.Create(nil);
    try
      frmEditFeatureFormula.GetData(ScreenObjects);
      frmEditFeatureFormula.ShowModal;
    finally
      frmEditFeatureFormula.Free
    end;
  finally
    ScreenObjects.Free;
  end;
end;

procedure TfrmScreenObjectProperties.InitializeGridObjects;
var
  List: TList;
  GridIndex, RowIndex, ColIndex: integer;
  Grid: TRbwDataGrid4;
  PhastTimes: TStringList;
  Times: TTimeCollection;
  TimeIndex: Integer;
  PhastTimeItem: TTimeItem;
begin
  List := TList.Create;
  PhastTimes := TStringList.Create;
  try
    Times := frmGoPhast.PhastModel.Times;
    PhastTimes.Capacity := Times.Count-1;
    for TimeIndex := 0 to Times.Count - 2 do
    begin
      PhastTimeItem := Times[TimeIndex];
      PhastTimes.Add(FloatToStr(PhastTimeItem.EndingTime));
    end;

    List.Capacity := 6;
    List.Add(dgSpecifiedHead);
    List.Add(dgBoundaryFlux);
    List.Add(dgBoundaryLeaky);
    List.Add(dgBoundaryRiver);
    List.Add(dgWell);
    List.Add(dgWellElevations);

    for GridIndex := 0 to List.Count -1 do
    begin
      Grid := List[GridIndex];
      Grid.Columns[1].PickList := PhastTimes;
      Grid.Columns[1].ComboUsed := PhastTimes.Count > 0;
      for RowIndex := 0 to Grid.RowCount -1 do
      begin
        for ColIndex := 0 to Grid.ColCount -1 do
        begin
          Grid.Objects[ColIndex,RowIndex] := nil;
          if (ColIndex >= Grid.FixedCols) and (RowIndex >= Grid.FixedRows) then
          begin
            Grid.Cells[ColIndex,RowIndex] := '';
            if Grid.Columns[ColIndex].Format = rcf4Boolean then
            begin
              Grid.Checked[ColIndex,RowIndex] := False;
            end;
          end;
        end;
      end;
    end;
    // remove dgWellElevations.
    List.Remove(dgWellElevations);
    // reset the first time for boundary conditions.
    for GridIndex := 0 to List.Count -1 do
    begin
      Grid := List[GridIndex];
      Grid.Cells[1,1] := '0';
    end;
  finally
    List.Free;
    PhastTimes.Free;
  end;
end;

procedure TfrmScreenObjectProperties.comboDrtLocationChoiceChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FDRT_Node);
  if comboDrtLocationChoice.ItemIndex >= 0 then
  begin
    pcDrtReturnLChoice.ActivePageIndex :=
      comboDrtLocationChoice.ItemIndex;
  end
  else
  begin
    pcDrtReturnLChoice.ActivePageIndex := 0;
  end;
  StoreDrtBoundary;
end;

procedure TfrmScreenObjectProperties.comboDrtReturnObjectChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FDRT_Node);
end;

procedure TfrmScreenObjectProperties.comboGhbConductanceInterpChange(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FGHB_Node);
  StoreGhbBoundary;
end;

procedure TfrmScreenObjectProperties.ShowGageObservations;
begin
  tabGageObservations.TabVisible := (FObjectCount = 1) and (FVertexCount = 1)
end;

procedure TfrmScreenObjectProperties.ShowOrHideObsTabs;
var
  Mf6ObsSeriesName: TStringList;
begin
  if IsLoaded then
  begin
    Mf6ObsSeriesName := TStringList.Create;
    try
      frameObsMf6.tabMAW.TabVisible := (FMAW_Node <> nil)
        and  (FMAW_Node.StateIndex in [2,3]);
      frameObsMf6.tabSFR.TabVisible := (FSFR6_Node <> nil)
        and  (FSFR6_Node.StateIndex in [2,3]);
      frameObsMf6.tabLAK.TabVisible := (FLAKMf6_Node <> nil)
        and  (FLAKMf6_Node.StateIndex in [2,3]);
      frameObsMf6.tabUZF.TabVisible := (FUZF_Mf6_Node <> nil);
//        and  (FUZF_Mf6_Node.StateIndex in [2,3]);
      frameObsMf6.tabCSUB.TabVisible := (FCSUB_Node <> nil);
//        and  (FCSUB_Node.StateIndex in [2,3]);
      Mf6ObsSeriesName.Add(ObsSeriesToString(osGeneral));
      if frameObsMf6.tabMAW.TabVisible then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osMaw));
      end;
      if frameObsMf6.tabSFR.TabVisible then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osSfr));
      end;
      if frameObsMf6.tabLAK.TabVisible then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osLak));
      end;
      if frameObsMf6.tabUZF.TabVisible then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osUzf));
      end;
      if frameObsMf6.tabCSUB.TabVisible then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osCSub));
      end;
      if frameObsMf6.cbConcentration.Enabled then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osGwt));
      end;
      if frameObsMf6.tabSFR.TabVisible
        and frameObsMf6.cbConcentration.Enabled then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osSft));
      end;
      if frameObsMf6.tabLAK.TabVisible
        and frameObsMf6.cbConcentration.Enabled then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osLkt));
      end;
      if frameObsMf6.tabMAW.TabVisible
        and frameObsMf6.cbConcentration.Enabled then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osMwt));
      end;
      if frameObsMf6.tabUzf.TabVisible
        and frameObsMf6.cbConcentration.Enabled then
      begin
        Mf6ObsSeriesName.Add(ObsSeriesToString(osUzt));
      end;

      frameObsMf6.framePestObs.SpecifyGroupTypes(Mf6ObsSeriesName);
    finally
      Mf6ObsSeriesName.Free;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.jvplModflowBoundariesChange(
  Sender: TObject);
begin
  inherited;
  if IsLoaded then
  begin
    HelpKeyWord := jvplModflowBoundaries.ActivePage.HelpKeyword;
    btnHelp.HelpKeyword := HelpKeyWord;

    if jvplModflowBoundaries.ActivePage = jvspMf6Obs then
    begin
      ShowOrHideObsTabs;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.jvplSutraFeaturesChange(Sender: TObject);
begin
  inherited;
  HelpKeyWord := jvplSutraFeatures.ActivePage.HelpKeyword;
  btnHelp.HelpKeyword := HelpKeyWord;
end;

procedure TfrmScreenObjectProperties.jvpltvSutraFeaturesCustomDrawItem(
  Sender: TCustomTreeView; Node: TTreeNode; State: TCustomDrawState;
  var DefaultDraw: Boolean);
begin
  inherited;
  if Node.Selected and not Sender.Focused then
  begin
    Sender.Canvas.Brush.Color := clMenuHighlight;
  end;
end;

procedure TfrmScreenObjectProperties.jvpltvSutraFeaturesMouseDown(
  Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  CanSelectNode: Boolean;
begin
  inherited;
  CanSelectNode := True;

  if jvpltvSutraFeatures.Selected = FSutraSpecPresObs_Node  then
  begin
    CanSelectNode := (frameSutraSpecifiedPressure.CheckState <> cbUnchecked);
    frameSutraSpecPresObs.Enabled := CanSelectNode;
  end;

  if jvpltvSutraFeatures.Selected = FSutraSpecFluidFlowObs_Node  then
  begin
    CanSelectNode :=
      (frameSutraFluidFlux.CheckState <> cbUnchecked);
    frameSutraSpecifiedFluidFlowObs.Enabled := CanSelectNode;
  end;

  if jvpltvSutraFeatures.Selected = FSutraSpecConcObs_Node  then
  begin
    CanSelectNode :=
      (frameSutraSpecTempConc.CheckState <> cbUnchecked);
    frameSutraSpecUObs.Enabled := CanSelectNode;
  end;

  if jvpltvSutraFeatures.Selected = FSutraGenFlowObs_Node  then
  begin
    CanSelectNode :=
      (frameSutraGeneralizedFlowBoundary.CheckState <> cbUnchecked);
    frameSutraGenFlowObs.Enabled := CanSelectNode;
  end;

  if jvpltvSutraFeatures.Selected = FSutraGenTransObs_Node  then
  begin
    CanSelectNode :=
      (frameSutraGeneralizeTransBoundary.CheckState <> cbUnchecked);
    frameSutraGenTransObs.Enabled := CanSelectNode;
  end;

//  jvtlModflowBoundaryNavigatorChanging(Sender,
//    jvpltvSutraFeatures.GetNodeAt(X,Y), CanSelectNode);
  if not CanSelectNode then
  begin
    Exit;
  end;
  if htOnStateIcon in jvpltvSutraFeatures.GetHitTestInfoAt(X, Y) then
  begin
    case jvpltvSutraFeatures.Selected.StateIndex of
      1:
        begin
          jvpltvSutraFeatures.Selected.StateIndex := 2;
        end;
      2:
        begin
          jvpltvSutraFeatures.Selected.StateIndex := 1;
        end;
      3:
        begin
          jvpltvSutraFeatures.Selected.StateIndex := 2;
        end;
    end;

    if jvpltvSutraFeatures.Selected = FSutraObs_Node then
    begin
      frameSutraObservations.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraLake_Node then
    begin
      frameSutraLake.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraSpecPressure_Node then
    begin
      frameSutraSpecifiedPressure.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraSpecTempConc_Node then
    begin
      frameSutraSpecTempConc.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraFluidFlux_Node then
    begin
      frameSutraFluidFlux.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraMassEnergyFlux_Node then
    begin
      frameSutraMassEnergyFlux.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraGeneralizedTransportNode then
    begin
      frameSutraGeneralizeTransBoundary.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraGeneralizedFlowNode then
    begin
      frameSutraGeneralizedFlowBoundary.CheckState := TCheckBoxState(jvpltvSutraFeatures.Selected.StateIndex-1);
    end
    else if jvpltvSutraFeatures.Selected = FSutraStateObsNode then
    begin

    end
    else if jvpltvSutraFeatures.Selected = FSutraSpecPresObs_Node then
    begin

    end
    else if jvpltvSutraFeatures.Selected = FSutraSpecFluidFlowObs_Node then
    begin

    end
    else if jvpltvSutraFeatures.Selected = FSutraSpecConcObs_Node then
    begin

    end
    else if jvpltvSutraFeatures.Selected = FSutraGenFlowObs_Node then
    begin

    end
    else if jvpltvSutraFeatures.Selected = FSutraGenTransObs_Node then
    begin

    end

    else
    begin
      Assert(False);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.jvspCSUBShow(Sender: TObject);
begin
  inherited;
  frameCSUB.tabInterbedSystemsShow(nil);
end;

procedure TfrmScreenObjectProperties.jvspSutraGenFlowObsShow(Sender: TObject);
begin
  inherited;
  frameSutraGenFlowObs.rdgObservationGroups.HideEditor;
end;

procedure TfrmScreenObjectProperties.jvspSutraGenTransObsShow(Sender: TObject);
begin
  inherited;
  frameSutraGenTransObs.rdgObservationGroups.HideEditor;
end;

procedure TfrmScreenObjectProperties.jvspSutraSpecFlowObsShow(Sender: TObject);
begin
  inherited;
  frameSutraSpecifiedFluidFlowObs.rdgObservationGroups.HideEditor;
end;

procedure TfrmScreenObjectProperties.jvspSutraSpecPresObsShow(Sender: TObject);
begin
  inherited;
  frameSutraSpecPresObs.rdgObservationGroups.HideEditor;
end;

procedure TfrmScreenObjectProperties.jvspSutraSpecUObsShow(Sender: TObject);
begin
  inherited;
  frameSutraSpecUObs.rdgObservationGroups.HideEditor;
end;

procedure TfrmScreenObjectProperties.jvtlModflowBoundaryNavigatorChanging(
  Sender: TObject; Node: TTreeNode; var AllowChange: Boolean);
begin
  inherited;
  GetCanSelectNode(Node, AllowChange);
end;

procedure TfrmScreenObjectProperties.jvtlModflowBoundaryNavigatorCustomDrawItem(
  Sender: TCustomTreeView; Node: TTreeNode; State: TCustomDrawState;
  var DefaultDraw: Boolean);
var
  CanSelect: boolean;
begin
  inherited;
  CanSelect := True;
  GetCanSelectNode(Node, CanSelect);
  if not CanSelect then
  begin
    Sender.Canvas.Brush.Color := clBtnFace;
  end;
  if Node.Selected then
  begin
    Sender.Canvas.Brush.Color := clMenuHighlight;
    Sender.Canvas.Font.Color := clWhite;
  end;
end;

procedure TfrmScreenObjectProperties.jvtlModflowBoundaryNavigatorMouseDown(
  Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  CanSelectNode: Boolean;
  ANode: TTreeNode;
  ViewDirString: string;
begin
  inherited;
  CanSelectNode := True;
  ANode := jvtlModflowBoundaryNavigator.GetNodeAt(X,Y);
  jvtlModflowBoundaryNavigatorChanging(Sender,
    ANode, CanSelectNode);
  if not CanSelectNode and (ANode <> nil) then
  begin
    if ANode = FCfpPipe_Node then
    begin
      Beep;
      case FViewDirection of
        vdTop: ViewDirString := StrZ;
        vdFront: ViewDirString := StrY;
        vdSide: ViewDirString := StrX;
      end;
      MessageDlg(Format(StrYouCanOnlyDefine, [ViewDirString]), mtInformation, [mbOK], 0);
    end;
    if ANode = FMAW_Node then
    begin
      Beep;
      MessageDlg(StrYouCanOnlyDefineMAW, mtInformation, [mbOK], 0);
    end;
    if ANode = FMt3d_LKT_Node then
    begin
      Beep;
      MessageDlg(StrYouCanOnlyDefineLkt, mtInformation, [mbOK], 0);
    end;
    if ANode = FMt3d_SFT_Node then
    begin
      Beep;
      MessageDlg(StrYouCanOnlyDefineSft, mtInformation, [mbOK], 0);
    end;

    Exit;
  end;
  if htOnStateIcon in jvtlModflowBoundaryNavigator.GetHitTestInfoAt(X, Y) then
  begin
    case jvtlModflowBoundaryNavigator.Selected.StateIndex of
      1:
        begin
          jvtlModflowBoundaryNavigator.Selected.StateIndex := 2;
        end;
      2:
        begin
          jvtlModflowBoundaryNavigator.Selected.StateIndex := 1;
        end;
      3:
        begin
          jvtlModflowBoundaryNavigator.Selected.StateIndex := 2;
        end;
    end;
    if jvtlModflowBoundaryNavigator.Selected = FCHD_Node then
    begin
      StoreChdBoundary;
      if (FChob_Node <> nil) and (FCHD_Node.StateIndex = 1) then
      begin
        FChob_Node.StateIndex := 1;
      end;
      jvtlModflowBoundaryNavigator.Invalidate;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FGHB_Node then
    begin
      StoreGhbBoundary;
      if (FGbob_Node <> nil) and (FGHB_Node.StateIndex = 1) then
      begin
        FGbob_Node.StateIndex := 1;
      end;
      jvtlModflowBoundaryNavigator.Invalidate;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FWEL_Node then
    begin
      StoreWellBoundary;
      EnableWellTabfile;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FRIV_Node then
    begin
      StoreRivBoundary;
      if (FRvob_Node <> nil) and (FRIV_Node.StateIndex = 1) then
      begin
        FRvob_Node.StateIndex := 1;
      end;
      jvtlModflowBoundaryNavigator.Invalidate;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FDRN_Node then
    begin
      StoreDrnBoundary;
      if (FDrob_Node <> nil) and (FDRN_Node.StateIndex = 1) then
      begin
        FDrob_Node.StateIndex := 1;
      end;
      jvtlModflowBoundaryNavigator.Invalidate;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FDRT_Node then
    begin
      StoreDrtBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FRCH_Node then
    begin
      StoreRchBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FEVT_Node then
    begin
      StoreEvtBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FETS_Node then
    begin
      StoreEtsBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FRES_Node then
    begin
      StoreResBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FLAK_Node then
    begin
      StoreLakBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMNW2_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMNW1_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSFR_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSFR6_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSTR_Node then
    begin
      if (FStob_Node <> nil) and (FSTR_Node.StateIndex = 1) then
      begin
        FStob_Node.StateIndex := 1;
      end;
      jvtlModflowBoundaryNavigator.Invalidate;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FHOB_Node then
    begin
      if jvtlModflowBoundaryNavigator.Selected.StateIndex <= 1 then
      begin
        frameHeadObservations.seTimes.AsInteger := 0;
      end;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FHFB_Node then
    begin
      if frmGoPhast.ModelSelection = msModflow2015 then
      begin
        frameHfbMf6.Enabled :=
          jvtlModflowBoundaryNavigator.Selected.StateIndex > 1;
      end
      else
      begin
        frameHfbBoundary.Enabled :=
          jvtlModflowBoundaryNavigator.Selected.StateIndex > 1;
      end;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FUZF_Node then
    begin
      StoreUzfBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FChob_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FDrob_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FGbob_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FRvob_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FStob_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FGage_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FHydmod_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFhbHead_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFhbFlow_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3dmsSsm_Node then
    begin
      StoreMt3dmsChemBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3d_UZT_Rech_Node then
    begin
      StoreMt3d_UztRechBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3d_UZT_Sat_Node then
    begin
      StoreMt3d_UztSatBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3d_UZT_Unsat_Node then
    begin
      StoreMt3d_UztUnsatBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3d_Uzf_Seep_Node then
    begin
      StoreMt3dUzfSeepageConcBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3dmsTobConc_Node then
    begin
      if jvtlModflowBoundaryNavigator.Selected.StateIndex <= 1 then
      begin
        frameMt3dmsTobConc.seTimes.AsInteger := 0;
      end;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3dmsTobFlux_Node then
    begin
      // do nothing
    end
//    else if jvtlModflowBoundaryNavigator.Selected = FFmpFarm_Node then
//    begin
//      // do nothing
//    end
    else if jvtlModflowBoundaryNavigator.Selected = FFarmWell_Node then
    begin
      StoreFarmWell;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFarmPrecip_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFarmRefEvap_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFarmCropID_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFarmID_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FCfpPipe_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FCfpFixedHead_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FCRCH_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWR_Reach_Node then
    begin
      jvtlModflowBoundaryNavigator.Invalidate;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWR_Rain_Node then
    begin
      StoreSwrRainBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWR_Evap_Node then
    begin
      StoreSwrEvapBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWR_LatInflow_Node then
    begin
      StoreSwrLatInflowBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWR_Stage_Node then
    begin
      StoreSwrStageBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWR_DirectRunoff_Node then
    begin
      StoreSwrDirectRunoffBoundary;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSWiObs_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FRipNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMAW_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMf6Obs_Node then
    begin
      // do nothing
      frameObsMf6.ActiveObs := FMf6Obs_Node.StateIndex >= 2;
    end
    else if jvtlModflowBoundaryNavigator.Selected = FLAKMf6_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMVR_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FUZF_Mf6_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3d_LKT_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FMt3d_SFT_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FCSUB_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSubPestObs_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FSwtPestObs_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FGwtCnc_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FGwtSrc_Node then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4EfficiencyNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4EfficiencyImprovementNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4BareRunoffFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4BarePrecipitationConsumptionFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4BareEvapNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4DirectRechargeNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4PrecipPotConsumptionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4NrdInfilLocationNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4LandUseAreaFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultLandUseAreaFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4CropCoefficientNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultCropCoefficientNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4ConsumptiveUseNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultConsumptiveUseNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4IrrigationNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultIrrigationNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4RootDepthNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultRootDepthNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4TranspirationFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultTranspirationFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4EvaporationIrrigationFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultEvaporationIrrigationFractionNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4FractionOfPrecipToSurfaceWaterNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultFractionOfPrecipToSurfaceWaterNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4FractionOfIrrigToSurfaceWaterNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultFractionOfIrrigToSurfaceWaterNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4AddedDemandNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultAddedDemandNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4CropHasSalinityDemandNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4MultCropHasSalinityDemandNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FFmp4AddedDemandRunoffSplitNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FTvkNode then
    begin
      // do nothing
    end
    else if jvtlModflowBoundaryNavigator.Selected = FTvsNode then
    begin
      // do nothing
    end

    else
    begin
      Beep;
      MessageDlg(StrModelMuseHasEncoun, mtError, [mbOK], 0);
      Assert(False, StrModelMuseHasEncoun);
    end;
//    if (FMt3dms_Node <> nil)
//      and (FMt3dms_Node.StateIndex <> 1)
//      and not CanSelectMt3dms then
//    begin
//      FMt3dms_Node.StateIndex := 1;
//      StoreMt3dmsChemBoundary;
//      jvtlModflowBoundaryNavigator.Invalidate;
//    end;
  end;
end;

procedure TfrmScreenObjectProperties.memoCaptionChange(Sender: TObject);
begin
  inherited;
  FCaptionTextChanged := True;
end;

procedure TfrmScreenObjectProperties.InitializeControls(
  AScreenObject: TScreenObject);
var
  Index: integer;
  CompilerList: TList;
  Compiler: TRbwParser;
begin

  CustomizeControls;
  GetAvailableParameters;
  GetAvailableTimes;
  InitializeGridObjects;

  tabNodes.TabVisible := True;
  if dgVerticies.RowCount <= 1 then
  begin
    dgVerticies.RowCount := 2;
  end;
  dgVerticies.FixedRows := 1;

  edName.Enabled := True;

  pageMain.ActivePageIndex := 0;
  FScreenObjectList := nil;
  memoNames.Lines.Clear;
  rgBoundaryType.ItemIndex := 0;
  comboSolutionType.ItemIndex := 0;
  comboSolutionTypeChange(nil);
  edLeakyHydraulicConductivity.Text := '';
  edLeakyThickness.Text := '';
  edRiverDescripton.Text := '';
  edRiverHydraulicConductivity.Text := '';
  edRiverWidth.Text := '';
  edRiverDepth.Text := '';
  edRiverBedThickness.Text := '';
  edWellDescription.Text := '';
  rdeWellDiameter.Text := '';
  rdeWellLandSurfaceDatum.Text := '';
  cbWellPumpAllocation.Checked := False;
  comboWellIntervalStyle.ItemIndex := 0;
  seWellIntervals.Value := 1;
  edZ.Text := '0';
  edHighZ.Text := '0';
  edLowZ.Text := '0';

  rdeGridCellSize.Text := '1';

  rgBoundaryType.Handle;
  rgBoundaryType.Buttons[Ord(btRiver)].Enabled := True;
  rgBoundaryType.Buttons[Ord(btWell)].Enabled := True;
//  rgBoundaryType.Controls[Ord(btRiver)].Enabled := True;
//  rgBoundaryType.Controls[Ord(btWell)].Enabled := True;

  CompilerList := TList.Create;
  try
    FillCompilerList(CompilerList);
    for Index := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[Index];
      Compiler.ClearExpressions;
      Compiler.ClearVariables;
    end;
    GetGlobalVariables;
  finally
    CompilerList.Free;
  end;


  // If FUndoSetScreenObjectProperties was submitted, it will have
  // been set to nil.
  FBoundaryPhastInterpolationList.Clear;

  jvtlModflowBoundaryNavigator.Handle;
  jvtlModflowBoundaryNavigator.Items.Clear;

  // The nodes in jvtlModflowBoundaryNavigator should be created
  // in the order in which they ought to be displayed.
  CreateChdNode;
  CreateChobNode;
  CreateCSubNode;
  CreateDrnNode;
  CreateDrobNode;
  CreateDrtNode;
  CreateEtsNode(AScreenObject);
  CreateEvtNode(AScreenObject);
  CreateFhbFlowNode;
  CreateFhbHeadNode;
  CreateGhbNode;
  CreateGbobNode;
  CreateHfbNode(AScreenObject);
  CreateHydmodNode(AScreenObject);
  CreateHobNode(AScreenObject);
  CreateLakNode;
  CreateLakMf6Node(AScreenObject);
  CreateMawNode(AScreenObject);
  CreateMnw1Node;
  CreateMnw2Node;
  CreateMvrNode;
  CreateMf6Obs_Node(AScreenObject);
  CreateRchNode(AScreenObject);
  CreateResNode(AScreenObject);
  CreateRipNode(AScreenObject);
  CreateRivNode;
  CreateRvobNode;
  CreateSfrNode(AScreenObject);
  CreateSfr6Node(AScreenObject);
  CreateStrNode(AScreenObject);
  CreateStobNode;
  CreateGageNode;
  CreateSwiObsNode(AScreenObject);
  CreateTvkNode;
  CreateTvsNode;
  CreateUzfNode(AScreenObject);
  CreateUzMf6fNode(AScreenObject);
  CreateWelNode;
  CreateCfpPipeNode(AScreenObject);
  CreateCfpFixedHeadNode(AScreenObject);
  CreateCfpRechargeNode;
//  CreateFarmNode(AScreenObject);
  // FmP4 WATER_BALANCE_SUBREGION
  CreateFarmIDNode(AScreenObject);
  CreateFarmWelNode;
  CreateFmp4EfficiencyNode;
  CreateFmp4EfficiencyImprovementNode;
  CreateFmp4BareRunoffFractionNode;
  CreateFmp4BarePrecipitationConsumptionFractionNode;
  CreateFmp4AddedDemandRunoffSplitNode;

  // UNUSED
  CreateFmp4NrdInfilLocationNode;

  // CLIMATE
  CreateFarmPrecipNode(AScreenObject);
  CreateFarmRefEvapNode(AScreenObject);
  CreateFmp4BareEvapNode;
  CreateFmp4DirectRechargeNode;
  CreateFmp4PrecipPotConsumptionNode;

  // LAND_USE
  CreateFarmCropIDNode(AScreenObject);
  CreateFmp4LandUseAreaFractionNode;
  CreateFmp4MultLandUseAreaFractionNode;
  CreateFmp4CropCoefficientNode;
  CreateFmp4MultCropCoefficientNode;
  CreateFmp4ConsumptiveUseNode;
  CreateFmp4MultConsumptiveUseNode;
  CreateFmp4IrrigationNode;
  CreateFmp4MultIrrigationNode;
  CreateFmp4RootDepthNode;
  CreateFmp4MultRootDepthNode;
  CreateFmp4TranspirationFractionNode;
  CreateFmp4MultTranspirationFractionNode;
  CreateFmp4EvaporationIrrigationFractionNode;
  CreateFmp4MultEvaporationIrrigationFractionNode;
  CreateFmp4FractionOfPrecipToSurfaceWaterNode;
  CreateFmp4MultFractionOfPrecipToSurfaceWaterNode;
  CreateFmp4FractionOfIrrigToSurfaceWaterNode;
  CreateFmp4MultFractionOfIrrigToSurfaceWaterNode;
  CreateFmp4AddedDemandNode;
  CreateFmp4MultAddedDemandNode;

  // SALINITY_FLUSH_IRRIGATION
  CreateFmp4CropHasSalinityDemandNode;
  CreateFmp4MultCropHasSalinityDemandNode;
  CreateSWR_Reach_Node(AScreenObject);
  CreateSWR_Rain_Node(AScreenObject);
  CreateSWR_Evap_Node(AScreenObject);
  CreateSWR_LatInflow_Node(AScreenObject);
  CreateSWR_Stage_Node(AScreenObject);
  CreateSWR_DirectRunoff_Node(AScreenObject);
  CreateGwtCncNode;
  CreateGwtSrcNode;
  CreateModpathNode;
  CreateMt3d_LktNode;
  CreateMt3d_SftNode;
  CreateMt3dmsSsmNode;
  CreateMt3dmsTobConcNode(AScreenObject);
  CreateMt3dmsTobFluxNode;
  CreateMt3d_Uzf_Seep_Node;
  CreateMt3d_UztRechNode;
  CreateMt3d_UztSatNode;
  CreateMt3d_UztUnsatNode;
  CreateSubPestObsNode(AScreenObject);
  CreateSwtPestObsNode(AScreenObject);

  CreateSutraFeatureNodes(AScreenObject);

  tabLGR.TabVisible := frmGoPhast.PhastModel.LgrUsed;
  SetupChildModelControls(AScreenObject);
  jvplModflowBoundaries.ActivePage := jvspBlank;
  jvplSutraFeatures.ActivePage := jvspSutraBlank;
end;

procedure TfrmScreenObjectProperties.GetGlobalVariables;
var
  CompilerList: TList;
begin
  CompilerList := TList.Create;
  try
    FillCompilerList(CompilerList);
    frmGoPhast.PhastModel.RefreshGlobalVariables(CompilerList);
  finally
    CompilerList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.ActivateSutraFeature(Sender: TObject;
  CheckState: TCheckBoxState);
begin
  if Sender = frameSutraObservations then
  begin
    if FSutraObs_Node <> nil then
    begin
      FSutraObs_Node.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraSpecifiedPressure then
  begin
    if FSutraSpecPressure_Node <> nil then
    begin
      FSutraSpecPressure_Node.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraSpecTempConc then
  begin
    if FSutraSpecTempConc_Node <> nil then
    begin
      FSutraSpecTempConc_Node.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraFluidFlux then
  begin
    if FSutraSpecTempConc_Node <> nil then
    begin
      FSutraFluidFlux_Node.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraMassEnergyFlux then
  begin
    if FSutraMassEnergyFlux_Node <> nil then
    begin
      FSutraMassEnergyFlux_Node.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraLake then
  begin
    if FSutraLake_Node <> nil then
    begin
      FSutraLake_Node.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraGeneralizedFlowBoundary then
  begin
    if FSutraGeneralizedFlowNode <> nil then
    begin
      FSutraGeneralizedFlowNode.StateIndex := Ord(CheckState)+1;
    end;
  end
  else if Sender = frameSutraGeneralizeTransBoundary then
  begin
    if FSutraGeneralizedTransportNode <> nil then
    begin
      FSutraGeneralizedTransportNode.StateIndex := Ord(CheckState)+1;
    end;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TfrmScreenObjectProperties.GetVertexLabels(ScreenObjects: TList);
var
  StringList: TStringList;
  ObjectIndex: integer;
  AScreenObject: TScreenObject;
  ItemIndex: integer;
  AnItem: TPointValuesItem;
  NameIndex: integer;
  ObjectVertexLabel: TObjectVertexLabel;
begin
  StringList := TStringList.Create;
  try
    StringList.Sorted := True;
    StringList.Duplicates := dupIgnore;
    for ObjectIndex := 0 to ScreenObjects.Count - 1 do
    begin
      AScreenObject := ScreenObjects[ObjectIndex];
      for ItemIndex := 0 to AScreenObject.PointPositionValues.Count - 1 do
      begin
        AnItem := AScreenObject.PointPositionValues[ItemIndex];
        for NameIndex := 0 to AnItem.Values.Count - 1 do
        begin
          StringList.Add(AnItem.Values[NameIndex].Name);
        end;
      end;
    end;
    StringList.Sorted := False;
    StringList.Insert(0, 'none');
    comboVertexValueLabels.Items := StringList;
  finally
    StringList.Free;
  end;

  Assert(ScreenObjects.Count > 0);
  ObjectVertexLabel := TScreenObject(ScreenObjects[0]).ObjectVertexLabel;
  if ObjectVertexLabel.VertexValueKey = '' then
  begin
    comboVertexValueLabels.ItemIndex := 0;
  end
  else
  begin
    ItemIndex := comboVertexValueLabels.Items.IndexOf(
      ObjectVertexLabel.VertexValueKey);
    ItemIndex := Max(ItemIndex, 0);
    comboVertexValueLabels.ItemIndex := ItemIndex;
  end;

end;

procedure TfrmScreenObjectProperties.GetData(const AScreenObject:
  TScreenObject);
var
  List: TList;
  NumberOfColumns: Integer;
  ColIndex: Integer;
  First: Boolean;
  ACaption: string;
  Index: Integer;
  ValueItem: TValueArrayItem;
  TreeViewFilled: boolean;
  SelectCell: TGridRect;
  ObjectLabel: TObjectLabel;
  ObjectVertexLabel: TObjectVertexLabel;
  SectionLabel:TSectionLabel;
  TempList: TList;
  SutraStateObs: TSutraStateObservations;
  DataArrayManager: TDataArrayManager;
  DataSetIndex: Integer;
  ADataArray: TDataArray;
  ModflowSteadyParameters: TModflowSteadyParameters;
  ParameterIndex: Integer;
  AParameter: TModflowSteadyParameter;
begin
  if frmGoPhast.ModelSelection = msModflowFMP then
  begin
    jvspFarmPrecip.HelpKeyword := 'Precip_in_FMP_Farm_Process';
    jvspFarmRefEvap.HelpKeyword := 'Ref_Evap_in_FMP_Farm_Process';
    jvspFarmID.HelpKeyword := 'Farm_ID_in_FMP_Farm_Process_Pa';
  end
  else
  begin
    jvspFarmPrecip.HelpKeyword := 'Precip-in-Climate-Farm-Process';
    jvspFarmRefEvap.HelpKeyword := 'Ref_-Evap-in-Climate-Farm-Proc';
    jvspFarmID.HelpKeyword := 'Water-Balance-Subregion-ID-in-';
  end;
  frameDynamicTimeSeries.SetGridButtonEvent(frameChdParamdgModflowBoundaryButtonClick);

  frameLak.tabObservations.Visible := frmGoPhast.PhastModel.PestUsed;

  FPestBlockParametersAndDataSets.Clear;
  FPestNodeParametersAndDataSets.Clear;
  FPestParameters.Clear;
  DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
  for DataSetIndex := 0 to DataArrayManager.DataSetCount - 1 do
  begin
    ADataArray := DataArrayManager.DataSets[DataSetIndex];
    if ADataArray.PestParametersUsed then
    begin
      if ADataArray.EvaluatedAt = eaBlocks then
      begin
        FPestBlockParametersAndDataSets.AddObject(ADataArray.Name, ADataArray);
      end
      else
      begin
        FPestNodeParametersAndDataSets.AddObject(ADataArray.Name, ADataArray);
      end;
    end;
  end;
  ModflowSteadyParameters := frmGoPhast.PhastModel.ModflowSteadyParameters;
  for ParameterIndex := 0 to ModflowSteadyParameters.Count - 1 do
  begin
    AParameter := ModflowSteadyParameters[ParameterIndex];
    if AParameter.ParameterType = ptPEST then
    begin
      FPestBlockParametersAndDataSets.AddObject(AParameter.ParameterName, AParameter);
      FPestNodeParametersAndDataSets.AddObject(AParameter.ParameterName, AParameter);
      FPestParameters.AddObject(AParameter.ParameterName, AParameter);
    end;
  end;
  FPestBlockParametersAndDataSets.Sorted := True;
  FPestBlockParametersAndDataSets.Sorted := False;
  FPestNodeParametersAndDataSets.Sorted := True;
  FPestNodeParametersAndDataSets.Sorted := False;
  FPestParameters.Sorted := True;
  FPestParameters.Sorted := False;
  FPestBlockParametersAndDataSets.Insert(0, strNone);
  FPestNodeParametersAndDataSets.Insert(0, strNone);
  FPestParameters.Insert(0, strNone);

  FObjectCount := 1;
  FVertexCount := AScreenObject.Count;
  ShowGageObservations;
  
  // This line should always be the first line.
  IsLoaded := False;

  frameMVR.OnGetSources := GetPotentialMvrSources;

  Initialize;
  TempList := TList.Create;
  try
    TempList.Add(AScreenObject);
    GetVertexLabels(TempList);
  finally
    TempList.Free;
  end;

  tvDataSets.Items.Clear;

  rgElevationCount.Enabled := frmGoPhast.ModelSelection <> msFootPrint;
  if not rgElevationCount.Enabled  then
  begin
    edZ.Enabled := False;
    edHighZ.Enabled := False;
    edLowZ.Enabled := False;
    btnZ.Enabled := False;
    btnHighZ.Enabled := False;
    btnLowZ.Enabled := False;
  end;

  HideGLViewersWithMicrosoftOpenGL;

  memoComments.Enabled := True;
  SetModflowBoundaryColCount;

  rdeQuadTreeRefinement.Enabled := (frmGoPhast.ModelSelection = msModflow2015)
    and (AScreenObject.ViewDirection = vdTop);
  lblQuadTreeRefinement.Enabled := rdeQuadTreeRefinement.Enabled;

  frameSutraSpecifiedPressure.BoundaryType := sbtSpecPress;
  frameSutraSpecTempConc.BoundaryType := sbtSpecConcTemp;
  frameSutraFluidFlux.BoundaryType := sbtFluidSource;
  frameSutraMassEnergyFlux.BoundaryType := sbtMassEnergySource;

  // Ensure that the check boxes in frameSTOB.rdgObservationGroups
  // are visible.
  SelectCell.Top := 1;
  SelectCell.Bottom := 1;
  SelectCell.Left := 2;
  SelectCell.Right := 2;
  frameSTOB.rdgObservationGroups.Selection := SelectCell;

  // This will cause TCustomRadioGroup.UpdateButtons to be called.
  rgBoundaryType.WordWrap := not rgBoundaryType.WordWrap;
  rgBoundaryType.WordWrap := not rgBoundaryType.WordWrap;

  FillChildModelList;
  FCurrentEdit := nil;

  case AScreenObject.ViewDirection of
    vdTop: rgElevationCount.Caption := StrNumberOfZFormulas;
    vdFront: rgElevationCount.Caption := StrNumberOfYFormulas;
    vdSide: rgElevationCount.Caption := StrNumberOfXFormulas;
    else Assert(False);
  end;

  FCanFillTreeView := False;
  tabImportedData.TabVisible := True;
  memoComments.Text := AScreenObject.Comment;

  rdeQuadTreeRefinement.IntegerValue := AScreenObject.QuadtreeRefinementLevel;

  FCaptionFontChanged := False;
  FVertexCaptionFontChanged := False;
  FSectionCaptionFontChanged := False;
  ObjectLabel := AScreenObject.ObjectLabel;
  cbCaptionVisible.AllowGrayed := False;
  cbCaptionVisible.Checked := ObjectLabel.Visible;
  rdeCaptionX.IntegerValue := ObjectLabel.OffSet.X;
  rdeCaptionY.IntegerValue := ObjectLabel.OffSet.Y;
  memoCaption.Lines.Text := ObjectLabel.Caption;
  FCaptionTextChanged := False;

  ObjectVertexLabel := AScreenObject.ObjectVertexLabel;
  cbVertexLabelVisible.AllowGrayed := False;
  cbVertexLabelVisible.Checked := ObjectVertexLabel.Visible;
  rdeVertexXOffset.IntegerValue := ObjectVertexLabel.OffSet.X;
  rdeVertexYOffset.IntegerValue := ObjectVertexLabel.OffSet.Y;

  SectionLabel := AScreenObject.SectionLabel;
  cbSectionLabelVisible.AllowGrayed := False;
  cbSectionLabelVisible.Checked := SectionLabel.Visible;
  rdeSectionXOffset.IntegerValue := SectionLabel.OffSet.X;
  rdeSectionYOffset.IntegerValue := SectionLabel.OffSet.Y;

  SetCheckBoxCaptions;
  frameModpathParticles.InitializeFrame;
  edObjectOrder.Text := IntToStr(
    frmGoPhast.PhastModel.IndexOfScreenObject(AScreenObject)+1);

  frameSwrReach.InitializeFrame;

  InitializeGridObjects;
  seBoundaryTimes.Value := 1;
  rgEvaluatedAt.Enabled := frmGoPhast.PhastModel.ModelSelection in
    [msPhast, msSutra22, msSutra30, msSutra40];

  rgEvaluatedAt.Items[Ord(eaBlocks)] := EvalAtToString(eaBlocks,
    frmGoPhast.PhastModel.ModelSelection, True, True);
  rgEvaluatedAt.Items[Ord(eaNodes)] := EvalAtToString(eaNodes,
    frmGoPhast.PhastModel.ModelSelection, True, True);

  FPriorModelUpToDate := frmGoPhast.PhastModel.UpToDate;
  FScreenObjectList := nil;
  InitializeModflowBoundaryFrames(AScreenObject);
  AddGisFunctionsToAllParsers;

  InitializeControls(AScreenObject);

  memoNames.Visible := False;
  lblNames.Visible := False;
  FScreenObject := AScreenObject;
  memoNames.Lines.Add(AScreenObject.Name);

  FViewDirection := FScreenObject.ViewDirection;
  if FViewDirection <> vdTop then
  begin
    rgBoundaryType.Handle;
    rgBoundaryType.Buttons[Ord(btRiver)].Enabled := False;
    rgBoundaryType.Buttons[Ord(btWell)].Enabled := False;
  end;

  if AScreenObject.Count > 1 then
  begin
    rgBoundaryType.Handle;
    rgBoundaryType.Buttons[Ord(btWell)].Enabled := False;
  end;
  if AScreenObject.Closed or (AScreenObject.Count <= 1) then
  begin
    rgBoundaryType.Handle;
    rgBoundaryType.Buttons[Ord(btRiver)].Enabled := False;
  end;

  rgEvaluatedAt.ItemIndex := Ord(AScreenObject.EvaluatedAt);

  SetZLabelCaptions;

  cbLock.Checked := FScreenObject.PositionLocked;
  cbLock.AllowGrayed := False;

  // Display the name of the screen object.
  EdName.Text := FScreenObject.Name;
  GetColorDataForSingleObject;
  GetAssignmentMethodForSingleObject;
  cbDuplicatesAllowed.Checked := FScreenObject.DuplicatesAllowed;
  cbDuplicatesAllowed.AllowGrayed := False;

  // Set AllowGrayed.
  MultipleScreenObjects := False;

  GetScreenObjectVerticies;

  cbFillColor.Enabled := FScreenObject.Closed or (FScreenObject.ElevationCount =
    ecTwo);

  cbEnclosedCells.Enabled := FScreenObject.Closed;
  rdeMinimumCellFraction.Enabled := (FScreenObject.ScreenObjectLength > 0)
    and (cbIntersectedCells.State <> cbUnchecked);


  FSetCellsColor := False;


  List := TList.Create;
  TreeViewFilled := False;
  try
    List.Add(AScreenObject);
    CreateDataSetEdits(List);
    GetGages(List);
    GetModpathParticles(List);
    framePestObsSub.InitializeControls;
    GetSubObs(List);
    framePestObsSwt.InitializeControls;
    GetSwtObs(List);

    GetDataSetsForSingleObject;
    GetPhastBoundariesForSingleObject;

    EnableOK_Button;
    SetElevationDataForSingleObject;
    SetGridCellSizeDataForSingleObject;

    if (FNewProperties = nil) or (FNewProperties.Count <= 1) then
    begin
      FCanFillTreeView := True;
      FillDataSetsTreeView(List);
      TreeViewFilled := True;
    end;

  finally
    List.Free;
  end;

  EmphasizeValueChoices;

  frameScreenObjectSFR.Initialize;
  if FNewProperties = nil then
  begin
    FNewProperties := TScreenObjectEditCollection.Create;
    FNewProperties.OwnScreenObject := True;
  end;
  List := TList.Create;
  try
    List.Add(AScreenObject);
    if FNewProperties.Count = 0 then
    begin
      FillPropertyCollection(FNewProperties, List);
    end;

    tabDynamicTimeSeries.TabVisible :=
      frameDynamicTimeSeries.GetData(FNewProperties);

    GetModflowBoundaries(List);
    GetSutraObservations(List);
    GetFootprintWells;
  finally
    List.Free;
  end;

  if frmGoPhast.PhastModel.ModelSelection in SutraSelection then
  begin
    frameSutraObservations.OnActivate := ActivateSutraFeature;
    frameSutraObservations.GetData(FNewProperties);

    frameSutraSpecifiedPressure.OnActivate := ActivateSutraFeature;
    frameSutraSpecifiedPressure.GetData(FNewProperties);

    frameSutraSpecTempConc.OnActivate := ActivateSutraFeature;
    frameSutraSpecTempConc.GetData(FNewProperties);

    frameSutraFluidFlux.OnActivate := ActivateSutraFeature;
    frameSutraFluidFlux.GetData(FNewProperties);

    frameSutraMassEnergyFlux.OnActivate := ActivateSutraFeature;
    frameSutraMassEnergyFlux.GetData(FNewProperties);

    frameSutraLake.OnActivate := ActivateSutraFeature;
    frameSutraLake.GetData(FNewProperties);

    frameSutraGeneralizedFlowBoundary.OnActivate := ActivateSutraFeature;
    frameSutraGeneralizedFlowBoundary.GetData(FNewProperties);

    frameSutraGeneralizeTransBoundary.OnActivate := ActivateSutraFeature;
    frameSutraGeneralizeTransBoundary.GetData(FNewProperties);

    frameSutraPestObsState.OnControlsChange := UpdateSutraStateObsNode;
    if (FNewProperties.Count = 1) and (FSutraStateObsNode <> nil) then
    begin
      frameSutraPestObsState.InitializeControls;
      frameSutraPestObsState.SpecifyObservationTypes(SutraStateObsTypes);
      SutraStateObs := AScreenObject.SutraBoundaries.SutraStateObs;
      frameSutraPestObsState.GetData(SutraStateObs);
      FSutraStateObsNode.StateIndex := Ord(SutraStateObs.Used) + 1;
    end
    else
    begin
      FreeAndNil(FSutraStateObsNode);
    end;

    SetSelectedSutraBoundaryNode;
  end;

  SetDisabledElevationFormulas(AScreenObject);

  // The first condition is because TStringGrid can't handle too many rows.
  if (FScreenObject.Count < 1048560)
    and ((AScreenObject.ImportedSectionElevations.Count > 0)
    or (AScreenObject.ImportedHigherSectionElevations.Count > 0)
    or (AScreenObject.ImportedLowerSectionElevations.Count > 0)
    or (AScreenObject.ImportedValues.Count > 0)) then
  begin
    tabImportedData.TabVisible := True;
    NumberOfColumns := 1;
    if AScreenObject.ImportedSectionElevations.Count > 0 then
    begin
      Inc(NumberOfColumns);
    end;
    if AScreenObject.ImportedHigherSectionElevations.Count > 0 then
    begin
      Inc(NumberOfColumns);
    end;
    if AScreenObject.ImportedLowerSectionElevations.Count > 0 then
    begin
      Inc(NumberOfColumns);
    end;
    NumberOfColumns := NumberOfColumns + AScreenObject.ImportedValues.Count;
    rdgImportedData.ColCount := NumberOfColumns;
    for ColIndex := 0 to rdgImportedData.ColCount - 1 do
    begin
      rdgImportedData.Columns[ColIndex].AutoAdjustColWidths:= True;
      rdgImportedData.Columns[ColIndex].WordWrapCaptions := True;
    end;
    rdgImportedData.Cells[0,0] := 'Section';
    ColIndex := 0;
    First := True;

    FTooFewError := False;
    FTooManyError := False;
    rdgImportedData.BeginUpdate;
    try
      if AScreenObject.ImportedSectionElevations.Count > 0 then
      begin
        ACaption := GetCoordinateCaption(AScreenObject);
        AssignImportedValuesColumn(First, ColIndex,
          AScreenObject.ImportedSectionElevations, ACaption);
      end;
      if AScreenObject.ImportedHigherSectionElevations.Count > 0 then
      begin
        ACaption := GetHigherCoordinateCaption(AScreenObject);
        AssignImportedValuesColumn(First, ColIndex,
          AScreenObject.ImportedHigherSectionElevations, ACaption);
      end;
      if AScreenObject.ImportedLowerSectionElevations.Count > 0 then
      begin
        ACaption := GetLowerCoordinateCaption(AScreenObject);
        AssignImportedValuesColumn(First, ColIndex,
          AScreenObject.ImportedLowerSectionElevations, ACaption);
      end;
      for Index := 0 to AScreenObject.ImportedValues.Count - 1 do
      begin
        ValueItem := AScreenObject.ImportedValues.Items[Index];
        AssignImportedValuesColumn(First, ColIndex,
          ValueItem.Values, ValueItem.Name);
      end;
    finally
      rdgImportedData.EndUpdate;
    end;
  end
  else
  begin
    tabImportedData.TabVisible := False;
  end;
  GetVertexValues;

  frameIface.IFACE := AScreenObject.IFACE;

  edObjectLength.Text := FloatToStr(AScreenObject.ScreenObjectLength);
  if AScreenObject.SectionCount > 1000 then
  begin
    edObjectArea.Text := '?';
  end
  else
  begin
    try
      edObjectArea.Text := FloatToStr(AScreenObject.ScreenObjectArea);
    except on EExternal do
      // EStackOverflow is caught here.
      edObjectArea.Text := '?';
    end;
  end;
  jvplObjectInfo.ActivePage := jvspSingleObject;
  FPriorElevationCount := rgElevationCount.ItemIndex;

  GetUsedLgrModels(AScreenObject);
  EnableWellTabfile;

  // Set Loaded to True.  FLoaded is used in event handlers to decide
  // whether or not anything should be done.
  IsLoaded := True;
  UpdateSubComponents(self);
  if TreeViewFilled then
  begin
    UpdateCurrentEdit;
    tvDataSetsChange(nil, nil);
  end;
  SetDefaultCellSize;
  EnableModpathObjectChoice;
  ShowOrHideObsTabs;
end;

procedure TfrmScreenObjectProperties.GetChdBoundary(ScreenObjectList: TList);
const
  StartHeadPosition = 0;
  EndHeadPosition = 1;
  MultiplierPosition = 2;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectParam;
  Parameter: TParameterType;
  ColIndex: Integer;
  SpeciesIndex: Integer;
begin
  if not frmGoPhast.PhastModel.ChdIsSelected then
  begin
    Exit;
  end;
  Frame := frameChdParam;
  Parameter := ptCHD;
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FCHD_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FCHD_Node);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+StartHeadPosition] :=
    TChdBoundary.DefaultBoundaryMethod(StartHeadPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+EndHeadPosition] :=
    TChdBoundary.DefaultBoundaryMethod(EndHeadPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+MultiplierPosition] :=
    TChdBoundary.DefaultBoundaryMethod(MultiplierPosition);
  if frmGoPhast.PhastModel.GwtUsed or frmGoPhast.PhastModel.GweUsed then
  begin
    for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
    begin
      ColIndex := SpeciesIndex + ColumnOffset+MultiplierPosition+1;
      PestMethod[Frame.rdgModflowBoundary, ColIndex] :=
        TChdBoundary.DefaultBoundaryMethod(ColIndex- ColumnOffset);
    end;
    for ColIndex := ColumnOffset to Frame.rdgModflowBoundary.ColCount - 1 do
    begin
      if not Frame.PestMethodAssigned[ColIndex] then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColIndex] := ppmMultiply;
      end;
    end;
  end;
  GetPestModifiers(Frame, Parameter, ScreenObjectList);
  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.btnOKClick(Sender: TObject);
var
  Columns: array of Integer;
  Orientation: TDataSetOrientation;
  DataGrid: TRbwDataGrid4;
  EvaluatedAt: TEvaluatedAt;
  NewValue: string;
  RowIndex, ColIndex, Col, Row: integer;
  DataSet: TDataArray;
  CanSelect: boolean;
  ShowError: boolean;
  Edit: TScreenObjectDataEdit;
  ListOfScreenObjects: TList;
  BoundaryNodeList: TList;
  BoundaryNodeIndex: integer;
  ANode: TJvPageIndexNode;
begin
  inherited;
  if not CheckMf6LakeOutlet then
  begin
    ModalResult := mrNone;
    Exit;
  end;
  frmGoPhast.BeginSuppressDrawing;
  try
    ShowError := False;
      // Warn the user about potential problems.
      // and apply the changes to the @link(TScreenObject) or @link(TScreenObject)s.
    if (cbEnclosedCells.State = cbUnchecked)
      and (cbIntersectedCells.State = cbUnchecked)
      and (cbInterpolation.State = cbUnchecked)
      and not rdeGridCellSize.Enabled then
    begin
      ShowError := True;
    end;
    if not ShowError then
    begin
      if (cbEnclosedCells.State = cbUnchecked)
        and (cbIntersectedCells.State = cbUnchecked)
        and (cbInterpolation.State = cbUnchecked)
//        and (cbPilotPoints.State = cbUnchecked)
        then
      begin
        ShowError := DataSetsSpecified;
      end;
    end;
    if ShowError then
    begin
      pageMain.ActivePageIndex := 0;
      if cbEnclosedCells.Enabled then
      begin
        cbEnclosedCells.SetFocus;
      end
      else
      begin
        cbIntersectedCells.SetFocus;
      end;

      if MessageDlg(StrObjEditing, mtWarning, [mbYes, mbNo], 0, mbNo) = mrNo then
      begin
        Exit;
      end;
    end;

    if cbInterpolation.Checked and not cbIntersectedCells.Checked
      and not cbEnclosedCells.Checked then
    begin
      for RowIndex := 0 to FDataEdits.Count -1 do
      begin
        Edit := FDataEdits[RowIndex];
        // determine if the cell can be selected.
        CanSelect := True;
        // prevent the grid from validating the formula in a grid cell while
        // the grid cell is being drawn.

        ListOfScreenObjects := TList.Create;
        try
          if FScreenObject <> nil then
          begin
            ListOfScreenObjects.Add(FScreenObject)
          end;
          if FScreenObject <> nil then
          begin
            CheckIfDataSetCanBeEdited(CanSelect, Edit, ListOfScreenObjects);
          end
          else
          begin
            CheckIfDataSetCanBeEdited(CanSelect, Edit, FScreenObjectList);
          end;
        finally
          ListOfScreenObjects.Free;
        end;

        if CanSelect and (Edit.Used <> cbUnchecked)  then
        begin
          DataSet := Edit.DataArray;
          if DataSet.TwoDInterpolator = nil then
          begin
            Beep;
            if MessageDlg(Format(StrYouAreAttemptingT, [DataSet.Name]),
              mtWarning, [mbYes, mbNo], 0, mbNo) = mrNo then
            begin
              Exit;
            end
            else
            begin
              break;
            end;
          end;
        end;
      end;
    end;

    if (cbIntersectedCells.State = cbUnchecked)
      and (cbEnclosedCells.State = cbUnchecked) then
    begin
//      ShowError :=
//        ((FDRN_Node <> nil) and (FDRN_Node.StateIndex <> 1));
      BoundaryNodeList := TList.Create;
      try
        BoundaryNodeList.Add(FCHD_Node);
        BoundaryNodeList.Add(FGHB_Node);
        BoundaryNodeList.Add(FWEL_Node);
        BoundaryNodeList.Add(FRIV_Node);
        BoundaryNodeList.Add(FDRN_Node);
        BoundaryNodeList.Add(FDRT_Node);
        BoundaryNodeList.Add(FRCH_Node);
        BoundaryNodeList.Add(FEVT_Node);
        BoundaryNodeList.Add(FETS_Node);
        BoundaryNodeList.Add(FRES_Node);
        BoundaryNodeList.Add(FLAK_Node);
        BoundaryNodeList.Add(FLAKMf6_Node);
        BoundaryNodeList.Add(FMNW1_Node);
        BoundaryNodeList.Add(FMNW2_Node);
        BoundaryNodeList.Add(FMVR_Node);
        BoundaryNodeList.Add(FSFR_Node);
        BoundaryNodeList.Add(FSFR6_Node);
        BoundaryNodeList.Add(FSTR_Node);
        BoundaryNodeList.Add(FUZF_Node);
        BoundaryNodeList.Add(FChob_Node);
        BoundaryNodeList.Add(FDrob_Node);
        BoundaryNodeList.Add(FGbob_Node);
        BoundaryNodeList.Add(FRvob_Node);
        BoundaryNodeList.Add(FStob_Node);
        BoundaryNodeList.Add(FGage_Node);
        BoundaryNodeList.Add(FSWiObs_Node);
        BoundaryNodeList.Add(FMt3dmsSsm_Node);
        BoundaryNodeList.Add(FMt3d_UZT_Rech_Node);
        BoundaryNodeList.Add(FMt3d_UZT_Sat_Node);
        BoundaryNodeList.Add(FMt3d_UZT_Unsat_Node);
        BoundaryNodeList.Add(FMt3d_Uzf_Seep_Node);
        BoundaryNodeList.Add(FMt3d_LKT_Node);
        BoundaryNodeList.Add(FMt3d_SFT_Node);
        BoundaryNodeList.Add(FMt3dmsTobConc_Node);
        BoundaryNodeList.Add(FMt3dmsTobFlux_Node);
        BoundaryNodeList.Add(FHOB_Node);
        BoundaryNodeList.Add(FHFB_Node);
        BoundaryNodeList.Add(FHydmod_Node);
        BoundaryNodeList.Add(FFhbFlow_Node);
        BoundaryNodeList.Add(FFhbHead_Node);
//        BoundaryNodeList.Add(FFmpFarm_Node);
        BoundaryNodeList.Add(FFarmID_Node);
        BoundaryNodeList.Add(FFarmWell_Node);
        BoundaryNodeList.Add(FFarmPrecip_Node);
        BoundaryNodeList.Add(FFarmRefEvap_Node);
        BoundaryNodeList.Add(FFarmCropID_Node);
        BoundaryNodeList.Add(FCfpPipe_Node);
        BoundaryNodeList.Add(FCfpFixedHead_Node);
        BoundaryNodeList.Add(FCRCH_Node);
        BoundaryNodeList.Add(FSWR_Reach_Node);
        BoundaryNodeList.Add(FSWR_Rain_Node);
        BoundaryNodeList.Add(FSWR_Evap_Node);
        BoundaryNodeList.Add(FSWR_LatInflow_Node);
        BoundaryNodeList.Add(FSWR_Stage_Node);
        BoundaryNodeList.Add(FSWR_DirectRunoff_Node);
        BoundaryNodeList.Add(FRipNode);
        BoundaryNodeList.Add(FMAW_Node);
        BoundaryNodeList.Add(FMf6Obs_Node);
        BoundaryNodeList.Add(FUZF_Mf6_Node);
        BoundaryNodeList.Add(FCSUB_Node);
        BoundaryNodeList.Add(FFmp4EfficiencyNode);
        BoundaryNodeList.Add(FFmp4EfficiencyImprovementNode);
        BoundaryNodeList.Add(FFmp4BareRunoffFractionNode);
        BoundaryNodeList.Add(FFmp4BarePrecipitationConsumptionFractionNode);
        BoundaryNodeList.Add(FFmp4BareEvapNode);
        BoundaryNodeList.Add(FFmp4DirectRechargeNode);
        BoundaryNodeList.Add(FFmp4PrecipPotConsumptionNode);
        BoundaryNodeList.Add(FFmp4NrdInfilLocationNode);
        BoundaryNodeList.Add(FFmp4LandUseAreaFractionNode);
        BoundaryNodeList.Add(FFmp4MultLandUseAreaFractionNode);
        BoundaryNodeList.Add(FFmp4CropCoefficientNode);
        BoundaryNodeList.Add(FFmp4MultCropCoefficientNode);
        BoundaryNodeList.Add(FFmp4ConsumptiveUseNode);
        BoundaryNodeList.Add(FFmp4MultConsumptiveUseNode);
        BoundaryNodeList.Add(FFmp4IrrigationNode);
        BoundaryNodeList.Add(FFmp4MultIrrigationNode);
        BoundaryNodeList.Add(FFmp4RootDepthNode);
        BoundaryNodeList.Add(FFmp4MultRootDepthNode);
        BoundaryNodeList.Add(FFmp4TranspirationFractionNode);
        BoundaryNodeList.Add(FFmp4MultTranspirationFractionNode);
        BoundaryNodeList.Add(FFmp4EvaporationIrrigationFractionNode);
        BoundaryNodeList.Add(FFmp4MultEvaporationIrrigationFractionNode);
        BoundaryNodeList.Add(FFmp4FractionOfPrecipToSurfaceWaterNode);
        BoundaryNodeList.Add(FFmp4MultFractionOfPrecipToSurfaceWaterNode);
        BoundaryNodeList.Add(FFmp4FractionOfIrrigToSurfaceWaterNode);
        BoundaryNodeList.Add(FFmp4MultFractionOfIrrigToSurfaceWaterNode);
        BoundaryNodeList.Add(FFmp4AddedDemandNode);
        BoundaryNodeList.Add(FFmp4MultAddedDemandNode);
        BoundaryNodeList.Add(FFmp4CropHasSalinityDemandNode);
        BoundaryNodeList.Add(FFmp4MultCropHasSalinityDemandNode);
        BoundaryNodeList.Add(FFmp4AddedDemandRunoffSplitNode);
        BoundaryNodeList.Add(FTvkNode);
        BoundaryNodeList.Add(FTvsNode);

        BoundaryNodeList.Pack;
        ShowError := False;
        for BoundaryNodeIndex := 0 to BoundaryNodeList.Count - 1 do
        begin
          ANode := BoundaryNodeList[BoundaryNodeIndex];
          if ANode.StateIndex <> 1 then
          begin
            ShowError := True;
            break;
          end;
        end;
      finally
        BoundaryNodeList.Free;
      end;
      if ShowError then
      begin
        if MessageDlg(StrInvalidMethod, mtWarning,
          [mbYes, mbNo], 0, mbNo) = mrNo then
        begin
          Exit;
        end;
      end;
    end;

    if rgEvaluatedAt.ItemIndex = 1 then
    begin
      DataGrid := nil;
      if rgBoundaryType.ItemIndex >= 0 then
      begin
        case rgBoundaryType.ItemIndex of
          Ord(btNone):
            begin
              DataGrid := nil;
            end;
          Ord(btSpecifiedHead):
            begin
              DataGrid := dgSpecifiedHead;
              SetLength(Columns, 2);
              Columns[0] := Ord(ibcBoundaryValue);
              Columns[1] := Ord(ibcSolution);
            end;
          Ord(btFlux):
            begin
              DataGrid := dgBoundaryFlux;
              SetLength(Columns, 2);
              Columns[0] := Ord(ibcBoundaryValue);
              Columns[1] := Ord(ibcSolution);
            end;
          Ord(btLeaky):
            begin
              DataGrid := dgBoundaryLeaky;
              SetLength(Columns, 2);
              Columns[0] := Ord(ibcBoundaryValue);
              Columns[1] := Ord(ibcSolution);
            end;
          Ord(btRiver):
            begin
              DataGrid := dgBoundaryRiver;
              SetLength(Columns, 2);
              Columns[0] := Ord(nicBoundaryValue);
              Columns[1] := Ord(nicSolution);
            end;
          Ord(btWell):
            begin
              DataGrid := dgWell;
              SetLength(Columns, 2);
              Columns[0] := Ord(nicBoundaryValue);
              Columns[1] := Ord(nicSolution);
            end;
        else
          Assert(False);
        end;
      end;
      if DataGrid <> nil then
      begin
        Col := 0;
        Row := 0;
        try
          if (DataGrid = dgSpecifiedHead) or
            (DataGrid = dgBoundaryFlux) or (DataGrid = dgBoundaryLeaky) then
          begin
            Orientation := dso3D;
          end
          else if (DataGrid = dgBoundaryRiver) or (DataGrid = dgWell) then
          begin
            Orientation := dsoTop;
          end
          else
          begin
            Assert(False);
            Orientation := dso3D;
          end;
          // All the PHAST boundary conditions are evaluated at nodes.
          EvaluatedAt := eaNodes;
          for RowIndex := 1 to DataGrid.RowCount - 1 do
          begin
            Row := RowIndex;
            for ColIndex := 0 to Length(Columns) - 1 do
            begin
              Col := Columns[ColIndex];
              NewValue := DataGrid.Cells[Col, RowIndex];
              if NewValue <> '' then
              begin
                CreateBoundaryFormula(DataGrid, Col, RowIndex, NewValue,
                  Orientation, EvaluatedAt);
              end;
            end;
          end;
        except on E: Exception do
          begin
            Beep;
            MessageDlg(Format(StrErrorIn0sRow,
              [rgBoundaryType.Items[rgBoundaryType.ItemIndex],
              Row + 1, Col, E.Message]), mtError,[mbOK], 0);
            Exit;
          end;
        end;
      end;
    end;

    SetSelectedName;
    // apply the changes to the screen object or screen objects.
    Screen.Cursor := crHourGlass;
    try
      Enabled := False;
      if FScreenObject <> nil then
      begin
        SetData;
      end
      else
      begin
        Assert(FScreenObjectList <> nil);
        SetMultipleScreenObjectData;
      end;
    finally
      Application.ProcessMessages;
      ModalResult := mrOK;
      Enabled := True;
      Screen.Cursor := crDefault;
    end;
  finally
    frmGoPhast.EndSupressDrawing;
    frmGoPhast.frameTopView.ZoomBox.InvalidateImage32;
    frmGoPhast.frameFrontView.ZoomBox.InvalidateImage32;
    frmGoPhast.frameSideView.ZoomBox.InvalidateImage32;
  end;
end;

procedure TfrmScreenObjectProperties.btnSectionFontClick(Sender: TObject);
var
  AScreenObject: TScreenObject;
begin
  if FScreenObject <> nil then
  begin
    dlgFontCaption.Font := FScreenObject.SectionLabel.Font;
  end
  else
  begin
    AScreenObject := FScreenObjectList[0];
    dlgFontCaption.Font := AScreenObject.SectionLabel.Font;
  end;
  if dlgFontCaption.Execute then
  begin
    FSectionCaptionFont.Free;
    FSectionCaptionFont := TFont.Create;
    FSectionCaptionFont.Assign(dlgFontCaption.Font);
    FSectionCaptionFontChanged := True;
  end;
end;

procedure TfrmScreenObjectProperties.btnVertexFontClick(Sender: TObject);
var
  AScreenObject: TScreenObject;
begin
  inherited;
  if FScreenObject <> nil then
  begin
    dlgFontCaption.Font := FScreenObject.ObjectVertexLabel.Font;
  end
  else
  begin
    AScreenObject := FScreenObjectList[0];
    dlgFontCaption.Font := AScreenObject.ObjectVertexLabel.Font;
  end;
  if dlgFontCaption.Execute then
  begin
    FVertexCaptionFont.Free;
    FVertexCaptionFont := TFont.Create;
    FVertexCaptionFont.Assign(dlgFontCaption.Font);
    FVertexCaptionFontChanged := True;
  end;
end;

procedure TfrmScreenObjectProperties.btnCopyImportedDataClick(Sender: TObject);
begin
  inherited;
  rdgImportedData.Options := rdgImportedData.Options - [goEditing];
  rdgImportedData.SelectAll;
  rdgImportedData.CopySelectedCellsToClipboard;
  rdgImportedData.ClearSelection;
end;

procedure TfrmScreenObjectProperties.btnCopyVerticesClick(Sender: TObject);
begin
  inherited;
  dgVerticies.Options := dgVerticies.Options - [goEditing];
  dgVerticies.SelectAll;
  dgVerticies.CopySelectedCellsToClipboard;
  dgVerticies.ClearSelection;
//  ActiveControl := dgVerticies;
end;

procedure TfrmScreenObjectProperties.GetAvailableTimes;
var
  Index: integer;
  Frame: TframeScreenObjectNoParam;
begin
  for Index := 0 to ComponentCount - 1 do
  begin
    if Components[Index] is TframeScreenObjectNoParam then
    begin
      Frame := TframeScreenObjectParam(Components[Index]);
      Frame.GetStartTimes(0);
      Frame.GetEndTimes(1);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetDefaultCellSize;
var
  ZoomBox: TQRbwZoomBox2;
  XWidth: double;
  YWidth: double;
  DefaultValue: Extended;
begin
  if not rdeGridCellSize.Enabled then
  begin
    ZoomBox:= nil;
    case FNewProperties[0].ScreenObject.ViewDirection of
      vdTop: ZoomBox := frmGoPhast.frameTopView.ZoomBox;
      vdFront: ZoomBox := frmGoPhast.frameFrontView.ZoomBox;
      vdside: ZoomBox := frmGoPhast.frameSideView.ZoomBox;
      else Assert(False);
    end;

    XWidth := Abs(ZoomBox.X(ZoomBox.Width) - ZoomBox.X(0));
    YWidth := Abs(ZoomBox.Y(ZoomBox.Height) - ZoomBox.Y(0));

    if (frmGoPhast.ModelSelection in SutraSelection)
      and (frmGoPhast.PhastModel.SutraMesh.MeshType = mtProfile) then
    begin
      YWidth := YWidth * frmGoPhast.PhastModel.Exaggeration;
    end;

    DefaultValue := Min(XWidth,YWidth)/20;
    if DefaultValue > 0 then
    begin
      DefaultValue := Round(log10(DefaultValue));
      DefaultValue := Power(10,DefaultValue);
      rdeGridCellSize.Text := FloatToStr(DefaultValue);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetAvailableParameters;
var
  Index: integer;
  Param: TModflowParameter;
begin
  SetModflowBoundaryColCount;

  frameChdParam.clbParameters.Items.Clear;
  frameGhbParam.clbParameters.Items.Clear;
  frameWellParam.clbParameters.Items.Clear;
  frameRivParam.clbParameters.Items.Clear;
  frameDrnParam.clbParameters.Items.Clear;
  frameDrtParam.clbParameters.Items.Clear;
  frameRchParam.clbParameters.Items.Clear;
  frameEvtParam.clbParameters.Items.Clear;
  frameEtsParam.clbParameters.Items.Clear;
  frameFarmWell.clbParameters.Items.Clear;

  frameChdParam.clbParameters.Items.Add(StrNoParameter);
  frameGhbParam.clbParameters.Items.Add(StrNoParameter);
  frameWellParam.clbParameters.Items.Add(StrNoParameter);
  frameFarmWell.clbParameters.Items.Add(StrNoParameter);
  frameRivParam.clbParameters.Items.Add(StrNoParameter);
  frameDrnParam.clbParameters.Items.Add(StrNoParameter);
  frameDrtParam.clbParameters.Items.Add(StrNoParameter);
  frameRchParam.clbParameters.Items.Add(StrNoParameter);
  frameEvtParam.clbParameters.Items.Add(StrNoParameter);
  frameEtsParam.clbParameters.Items.Add(StrNoParameter);

  for Index := 0 to frmGoPhast.PhastModel.ModflowTransientParameters.Count - 1 do
  begin
    Param := frmGoPhast.PhastModel.ModflowTransientParameters[Index];
    case Param.ParameterType of
      ptUndefined: Assert(False);
      ptLPF_HK..ptLPF_VKCB: Assert(False);
      ptCHD:
        begin
          frameChdParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptGHB:
        begin
          frameGhbParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptQ:
        begin
          frameWellParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptRIV:
        begin
          frameRivParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptDRN:
        begin
          frameDrnParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptDRT:
        begin
          frameDrtParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptRCH:
        begin
          frameRchParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptEVT:
        begin
          frameEvtParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptETS:
        begin
          frameEtsParam.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      ptSFR, ptSTR:
        begin
          // do nothing
        end;
      ptQMAX:
        begin
          frameFarmWell.clbParameters.Items.
            AddObject(Param.ParameterName, Param);
        end;
      else Assert(False);
    end;
  end;

  if frameChdParam.clbParameters.Items.Count = 1 then
  begin
    frameChdParam.clbParameters.Items.Clear;
  end;
  if frameGhbParam.clbParameters.Items.Count = 1 then
  begin
    frameGhbParam.clbParameters.Items.Clear;
  end;
  if frameWellParam.clbParameters.Items.Count = 1 then
  begin
    frameWellParam.clbParameters.Items.Clear;
  end;
  if frameFarmWell.clbParameters.Items.Count = 1 then
  begin
    frameFarmWell.clbParameters.Items.Clear;
  end;
  if frameRivParam.clbParameters.Items.Count = 1 then
  begin
    frameRivParam.clbParameters.Items.Clear;
  end;
  if frameDrnParam.clbParameters.Items.Count = 1 then
  begin
    frameDrnParam.clbParameters.Items.Clear;
  end;
  if frameDrtParam.clbParameters.Items.Count = 1 then
  begin
    frameDrtParam.clbParameters.Items.Clear;
  end;
  if frameRchParam.clbParameters.Items.Count = 1 then
  begin
    frameRchParam.clbParameters.Items.Clear;
  end;
  if frameEvtParam.clbParameters.Items.Count = 1 then
  begin
    frameEvtParam.clbParameters.Items.Clear;
  end;
  if frameEtsParam.clbParameters.Items.Count = 1 then
  begin
    frameEtsParam.clbParameters.Items.Clear;
  end;

end;

procedure TfrmScreenObjectProperties.SetIsLoaded(const Value: boolean);
var
  Index: integer;
  Component: TComponent;
begin
  FIsLoaded := Value;
  for Index := 0 to ComponentCount - 1 do
  begin
    Component := Components[Index];
    if Component is TframeScreenObject then
    begin
      TframeScreenObject(Component).FrameLoaded := Value;
    end;
  end;
  frameSwrReach.frameSwr.FrameLoaded := Value;
end;

procedure TfrmScreenObjectProperties.Mf6ObsChanged(Sender: TObject);
begin
  UpdateNodeState(FMf6Obs_Node);
end;

procedure TfrmScreenObjectProperties.Mnw1Changed(Sender: TObject);
begin
  if (FMNW1_Node <> nil) and (FMNW1_Node.StateIndex <> 3) then
  begin
    FMNW1_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Mnw2Changed(Sender: TObject);
begin
  if (FMNW2_Node <> nil) and (FMNW2_Node.StateIndex <> 3) then
  begin
    FMNW2_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.LakeMf6Changed(Sender: TObject);
begin
  if (FLAKMf6_Node <> nil) and (FLAKMf6_Node.StateIndex <> 3) then
  begin
    FLAKMf6_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.LakePestObsChanged(Sender: TObject);
begin
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.MvrChanged(Sender: TObject);
begin
  if (FMVR_Node <> nil) and (FMVR_Node.StateIndex <> 3) then
  begin
    FMVR_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.MawChanged(Sender: TObject);
begin
  if (FMAW_Node <> nil) and (FMAW_Node.StateIndex <> 3) then
  begin
    FMAW_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.FhbHeadChanged(Sender: TObject);
begin
  if (FFhbHead_Node <> nil) and (FFhbHead_Node.StateIndex <> 3) then
  begin
    FFhbHead_Node.StateIndex := 2;
  end;
end;

//procedure TfrmScreenObjectProperties.FarmChanged(Sender: TObject);
//begin
//  if (FFmpFarm_Node <> nil) and (FFmpFarm_Node.StateIndex <> 3) then
//  begin
//    FFmpFarm_Node.StateIndex := 2;
//  end;
//end;

procedure TfrmScreenObjectProperties.FarmPrecipChanged(Sender: TObject);
begin
  if (FFarmPrecip_Node <> nil) and (FFarmPrecip_Node.StateIndex <> 3) then
  begin
    FFarmPrecip_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.FarmRefEvapChanged(Sender: TObject);
begin
  if (FFarmRefEvap_Node <> nil) and (FFarmRefEvap_Node.StateIndex <> 3) then
  begin
    FFarmRefEvap_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.FarmCropIDChanged(Sender: TObject);
begin
  if (FFarmCropID_Node <> nil) and (FFarmCropID_Node.StateIndex <> 3) then
  begin
    FFarmCropID_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.FarmIDChanged(Sender: TObject);
begin
  if (FFarmID_Node <> nil) and (FFarmID_Node.StateIndex <> 3) then
  begin
    FFarmID_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.CfpPipesChanged(Sender: TObject);
begin
  if (FCfpPipe_Node <> nil) and (FCfpPipe_Node.StateIndex <> 3) then
  begin
    FCfpPipe_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.CfpRchargeOnChange(Sender: TObject);
begin
  UpdateNodeState(FCRCH_Node)
end;

procedure TfrmScreenObjectProperties.CfpFixedHeadsChanged(Sender: TObject);
begin
  if (FCfpFixedHead_Node <> nil) and (FCfpFixedHead_Node.StateIndex <> 3) then
  begin
    FCfpFixedHead_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.RipChanged(Sender: TObject);
begin
  if (FRipNode <> nil) and (FRipNode.StateIndex <> 3) then
  begin
    FRipNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.FhbFlowChanged(Sender: TObject);
begin
  if (FFhbFlow_Node <> nil) and (FFhbFlow_Node.StateIndex <> 3) then
  begin
    FFhbFlow_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.SetMultipleScreenObjectData;
var
  List: TList;
  index: Integer;
begin
  UpdateScreenObjectData;

  SetFrameData;

  List := TList.Create;
  try
    for index := 0 to FNewProperties.Count - 1 do
    begin
      List.Add(FNewProperties[index].ScreenObject)
    end;
    SetObjectCaption(List);
  finally
    List.Free;
  end;

  SetGages(FNewProperties);

  FUndoSetScreenObjectProperties.Free;
  FUndoSetScreenObjectProperties :=
    TUndoSetScreenObjectProperties.Create(FScreenObjectList,
    FNewProperties, FOldProperties, FChildModelsScreenObjects);
  // SetMultipleScreenObjectData is called when the user press the OK button
  // after editing the properties of one or more screen objects.
  // It sets up an TUndoSetScreenObjectProperties based on the data that the
  // user has changed.  @SeeAlso(SetData)
  FUndoSetScreenObjectProperties.FSetCellsColor := FSetCellsColor;

  if FUndoSetScreenObjectProperties <> nil then
  begin
//    SetGages(FScreenObjectList);
    SetAllFluxObservations(FScreenObjectList);
    FUndoSetScreenObjectProperties.UpdateObservations;
    frmGoPhast.UndoStack.Submit(FUndoSetScreenObjectProperties);
    FUndoSetScreenObjectProperties := nil;
  end;

end;

procedure TfrmScreenObjectProperties.RemoveLayerDataArraysFrom3DObject(
  AScreenObject: TScreenObject; DataSetList: TDataArrayList);
var
  DataArrayIndex: Integer;
begin
  if AScreenObject.ElevationCount in [ecOne, ecTwo] then
  begin
    for DataArrayIndex := 0 to DataSetList.Count - 1 do
    begin
      AScreenObject.RemoveDataSet(DataSetList[DataArrayIndex]);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetData;
var
  List: TList;
  DataArrayList: TDataArrayList;
begin
  // set the data for a single screen object when it is first created.
  // See SetMultipleScreenObjectData if there is more than one screen object.

  if FSetCellsColor then
  begin
    frmGoPhast.PhastGrid.NeedToRecalculateCellColors;
    frmGoPhast.ModflowGrid.NeedToRecalculateCellColors;
  end;

  if FScreenObject.SetValuesOfEnclosedCells or
    FScreenObject.SetValuesOfIntersectedCells then
  begin
    frmGoPhast.PhastGrid.NeedToRecalculateCellColors;
    frmGoPhast.ModflowGrid.NeedToRecalculateCellColors;
  end;
  SetScreenObjectVerticies;

  FScreenObject.ClearDataSets;

  UpdateScreenObjectData;

  Assert(FNewProperties.Count = 1);

  SetFrameData;

  FScreenObject.Assign(FNewProperties.Items[0].ScreenObject);
  FScreenObject.Comment := memoComments.Text;

  DataArrayList := TDataArrayList.Create;
  try
    frmGoPhast.PhastModel.GetLayerDataArrays(DataArrayList);
    RemoveLayerDataArraysFrom3DObject(FScreenObject, DataArrayList);
  finally
    DataArrayList.Free;
  end;

  List := TList.Create;
  try
    List.Add(FScreenObject);
    SetGages(List);
    SetAllFluxObservations(List);
    SetObjectCaption(List);
  finally
    List.Free;
  end;

  case FScreenObject.ViewDirection of
    vdTop:
      begin
        frmGoPhast.TopScreenObjectsChanged := True;
      end;
    vdFront:
      begin
        frmGoPhast.FrontScreenObjectsChanged := True;
      end;
    vdSide:
      begin
        frmGoPhast.SideScreenObjectsChanged := True;
      end;
  else
    Assert(False);
  end;
  frmGoPhast.timTimer.Enabled := False;
  frmGoPhast.timTimer.OnTimer := frmGoPhast.ReDrawAllViews;
  frmGoPhast.timTimer.Interval := 100;
  frmGoPhast.timTimer.Enabled := True;
end;

procedure TfrmScreenObjectProperties.cbLgrAllModelsClick(Sender: TObject);
var
  ItemIndex: Integer;
  Index: Integer;
begin
  inherited;
  if IsLoaded then
  begin
    cbLgrAllModels.AllowGrayed := False;
    for ItemIndex := 0 to FNewProperties.Count - 1 do
    begin
      FNewProperties[ItemIndex].ScreenObject.UsedModels.UsedWithAllModels
        := cbLgrAllModels.Checked;
    end;
    if cbLgrAllModels.Checked then
    begin
      for Index := 0 to clbLgrUsedModels.Items.Count - 1 do
      begin
        clbLgrUsedModels.Checked[Index] := True;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbLineColorClick(Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  btnLineColor.Enabled := cbLineColor.Checked;
  if IsLoaded then
  begin
    if cbLineColor.Checked and (shpLineColor.Brush.Color = clBlack) then
    begin
      btnColorClick(btnLineColor);
    end;
    DisableAllowGrayed(cbLineColor);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.ColorLine := cbLineColor.Checked;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbLockClick(Sender: TObject);
var
  Index: integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  if IsLoaded then
  begin
    DisableAllowGrayed(cbLock);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.PositionLocked := cbLock.Checked;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbFillColorClick(Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  btnFillColor.Enabled := cbFillColor.Checked and cbFillColor.Enabled;
  if IsLoaded then
  begin
    if cbFillColor.Checked and (shpFillColor.Brush.Color = clBlack) then
    begin
      btnColorClick(btnFillColor);
    end;
    DisableAllowGrayed(cbFillColor);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.FillScreenObject := cbFillColor.Checked;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbGageStandardClick(Sender: TObject);
begin
  inherited;
  (Sender as TCheckBox).AllowGrayed := False;
  SetGageNodeStateIndex;
end;

procedure TfrmScreenObjectProperties.cbCaptionVisibleClick(Sender: TObject);
begin
  inherited;
  cbCaptionVisible.AllowGrayed := False;
end;

procedure TfrmScreenObjectProperties.cbDuplicatesAllowedClick(Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  if IsLoaded then
  begin
    DisableAllowGrayed(cbDuplicatesAllowed);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.DuplicatesAllowed := cbDuplicatesAllowed.Checked;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbEnclosedCellsClick(Sender: TObject);
var
  Index: integer;
  Item: TScreenObjectEditItem;
begin
  // Mark all used data sets as in need of updating when this
  // check box is checked.

  inherited;
  InvalidateAllDataSets;

  ShowOrHideTabs;
  EmphasizeValueChoices;
  if IsLoaded then
  begin
    DisableAllowGrayed(cbEnclosedCells);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.SetValuesOfEnclosedCells := cbEnclosedCells.Checked;
    end;
  end;

end;

procedure TfrmScreenObjectProperties.cbIntersectedCellsClick(
  Sender: TObject);
var
  Index: integer;
  Item: TScreenObjectEditItem;
  LinePresent: Boolean;
begin
  inherited;

  InvalidateAllDataSets;

  ShowOrHideTabs;
  EmphasizeValueChoices;
  LinePresent := False;
  if IsLoaded then
  begin
    DisableAllowGrayed(cbIntersectedCells);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.SetValuesOfIntersectedCells
        := cbIntersectedCells.Checked;
      if not LinePresent then
      begin
        LinePresent := Item.ScreenObject.ScreenObjectLength > 0;
      end;
    end;
  end;
  rdeMinimumCellFraction.Enabled := LinePresent
    and (cbIntersectedCells.State <> cbUnchecked);
end;

procedure TfrmScreenObjectProperties.FillPropertyCollection(
  Collection: TScreenObjectEditCollection; List: TList);
var
  Index: Integer;
  ScreenObject: TScreenObject;
  Item: TScreenObjectEditItem;
  ScreenObjectClass: TScreenObjectClass;
  PriorCanInvalidateModel: boolean;
begin
  Collection.Clear;
  for Index := 0 to List.Count - 1 do
  begin
    ScreenObject := List[Index];
    Item := Collection.Add as TScreenObjectEditItem;
    ScreenObjectClass := TScreenObjectClass(ScreenObject.ClassType);
    Item.ScreenObject := ScreenObjectClass.Create(nil);
    Item.ScreenObject.CanInvalidateModel := False;
//    ScreenObject := List[Index];
    PriorCanInvalidateModel := ScreenObject.CanInvalidateModel;
    try
      ScreenObject.CanInvalidateModel := False;
      Item.ScreenObject.Assign(ScreenObject);
    finally
      ScreenObject.CanInvalidateModel := PriorCanInvalidateModel;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4AddedDemandChanged(Sender: TObject);
begin
  if (FFmp4AddedDemandNode <> nil)
    and (FFmp4AddedDemandNode.StateIndex <> 3) then
  begin
    FFmp4AddedDemandNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4AddedDemandRunoffSplitChanged(
  Sender: TObject);
begin
  if (FFmp4AddedDemandRunoffSplitNode <> nil)
    and (FFmp4AddedDemandRunoffSplitNode.StateIndex <> 3) then
  begin
    FFmp4AddedDemandRunoffSplitNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4BareEvapChanged(Sender: TObject);
begin
  if (FFmp4BareEvapNode <> nil)
    and (FFmp4BareEvapNode.StateIndex <> 3) then
  begin
    FFmp4BareEvapNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4BarePrecipitationConsumptionFractionChanged(
  Sender: TObject);
begin
  if (FFmp4BarePrecipitationConsumptionFractionNode <> nil)
    and (FFmp4BarePrecipitationConsumptionFractionNode.StateIndex <> 3) then
  begin
    FFmp4BarePrecipitationConsumptionFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4BareRunoffFractionChanged(
  Sender: TObject);
begin
  if (FFmp4BareRunoffFractionNode <> nil) and (FFmp4BareRunoffFractionNode.StateIndex <> 3) then
  begin
    FFmp4BareRunoffFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4ConsumptiveUseChanged(Sender: TObject);
begin
  if (FFmp4ConsumptiveUseNode <> nil)
    and (FFmp4ConsumptiveUseNode.StateIndex <> 3) then
  begin
    FFmp4ConsumptiveUseNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4CropCoefficientChanged(
  Sender: TObject);
begin
  if (FFmp4CropCoefficientNode <> nil)
    and (FFmp4CropCoefficientNode.StateIndex <> 3) then
  begin
    FFmp4CropCoefficientNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4CropHasSalinityDemandChanged(
  Sender: TObject);
begin
  if (FFmp4CropHasSalinityDemandNode <> nil)
    and (FFmp4CropHasSalinityDemandNode.StateIndex <> 3) then
  begin
    FFmp4CropHasSalinityDemandNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4DirectRechargeChanged(Sender: TObject);
begin
  if (FFmp4DirectRechargeNode <> nil)
    and (FFmp4DirectRechargeNode.StateIndex <> 3) then
  begin
    FFmp4DirectRechargeNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4EfficiencyChanged(Sender: TObject);
begin
  if (FFmp4EfficiencyNode <> nil) and (FFmp4EfficiencyNode.StateIndex <> 3) then
  begin
    FFmp4EfficiencyNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4EfficiencyImprovementChanged(
  Sender: TObject);
begin
  if (FFmp4EfficiencyImprovementNode <> nil) and (FFmp4EfficiencyImprovementNode.StateIndex <> 3) then
  begin
    FFmp4EfficiencyImprovementNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4EvaporationIrrigationFractionChanged(
  Sender: TObject);
begin
  if (FFmp4EvaporationIrrigationFractionNode <> nil)
    and (FFmp4EvaporationIrrigationFractionNode.StateIndex <> 3) then
  begin
    FFmp4EvaporationIrrigationFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4FractionOfIrrigToSurfaceWaterChanged(
  Sender: TObject);
begin
  if (FFmp4FractionOfIrrigToSurfaceWaterNode <> nil)
    and (FFmp4FractionOfIrrigToSurfaceWaterNode.StateIndex <> 3) then
  begin
    FFmp4FractionOfIrrigToSurfaceWaterNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4FractionOfPrecipToSurfaceWaterChanged(
  Sender: TObject);
begin
  if (FFmp4FractionOfPrecipToSurfaceWaterNode <> nil)
    and (FFmp4FractionOfPrecipToSurfaceWaterNode.StateIndex <> 3) then
  begin
    FFmp4FractionOfPrecipToSurfaceWaterNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4IrrigationChanged(Sender: TObject);
begin
  if (FFmp4IrrigationNode <> nil)
    and (FFmp4IrrigationNode.StateIndex <> 3) then
  begin
    FFmp4IrrigationNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4LandUseAreaFractionChanged(
  Sender: TObject);
begin
  if (FFmp4LandUseAreaFractionNode <> nil)
    and (FFmp4LandUseAreaFractionNode.StateIndex <> 3) then
  begin
    FFmp4LandUseAreaFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultAddedDemandChanged(
  Sender: TObject);
begin
  if (FFmp4MultAddedDemandNode <> nil)
    and (FFmp4MultAddedDemandNode.StateIndex <> 3) then
  begin
    FFmp4MultAddedDemandNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultConsumptiveUseChanged(
  Sender: TObject);
begin
  if (FFmp4MultConsumptiveUseNode <> nil)
    and (FFmp4MultConsumptiveUseNode.StateIndex <> 3) then
  begin
    FFmp4MultConsumptiveUseNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultCropCoefficientChanged(
  Sender: TObject);
begin
  if (FFmp4MultCropCoefficientNode <> nil)
    and (FFmp4MultCropCoefficientNode.StateIndex <> 3) then
  begin
    FFmp4MultCropCoefficientNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultCropHasSalinityDemandChanged(
  Sender: TObject);
begin
  if (FFmp4MultCropHasSalinityDemandNode <> nil)
    and (FFmp4MultCropHasSalinityDemandNode.StateIndex <> 3) then
  begin
    FFmp4MultCropHasSalinityDemandNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultEvaporationIrrigationFractionChanged(
  Sender: TObject);
begin
  if (FFmp4MultEvaporationIrrigationFractionNode <> nil)
    and (FFmp4MultEvaporationIrrigationFractionNode.StateIndex <> 3) then
  begin
    FFmp4MultEvaporationIrrigationFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultFractionOfIrrigToSurfaceWaterChanged(
  Sender: TObject);
begin
  if (FFmp4MultFractionOfIrrigToSurfaceWaterNode <> nil)
    and (FFmp4MultFractionOfIrrigToSurfaceWaterNode.StateIndex <> 3) then
  begin
    FFmp4MultFractionOfIrrigToSurfaceWaterNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultFractionOfPrecipToSurfaceWaterChanged(
  Sender: TObject);
begin
  if (FFmp4MultFractionOfPrecipToSurfaceWaterNode <> nil)
    and (FFmp4MultFractionOfPrecipToSurfaceWaterNode.StateIndex <> 3) then
  begin
    FFmp4MultFractionOfPrecipToSurfaceWaterNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultIrrigationChanged(Sender: TObject);
begin
  if (FFmp4MultIrrigationNode <> nil)
    and (FFmp4MultIrrigationNode.StateIndex <> 3) then
  begin
    FFmp4MultIrrigationNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultLandUseAreaFractionChanged(
  Sender: TObject);
begin
  if (FFmp4MultLandUseAreaFractionNode <> nil)
    and (FFmp4MultLandUseAreaFractionNode.StateIndex <> 3) then
  begin
    FFmp4MultLandUseAreaFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultRootDepthChanged(Sender: TObject);
begin
  if (FFmp4MultRootDepthNode <> nil)
    and (FFmp4MultRootDepthNode.StateIndex <> 3) then
  begin
    FFmp4MultRootDepthNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4MultTranspirationFractionChanged(
  Sender: TObject);
begin
  if (FFmp4MultTranspirationFractionNode <> nil)
    and (FFmp4MultTranspirationFractionNode.StateIndex <> 3) then
  begin
    FFmp4MultTranspirationFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4NrdInfilLocationChanged(
  Sender: TObject);
begin
  if (FFmp4NrdInfilLocationNode <> nil)
    and (FFmp4NrdInfilLocationNode.StateIndex <> 3) then
  begin
    FFmp4NrdInfilLocationNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4PrecipPotConsumptionChanged(
  Sender: TObject);
begin
  if (FFmp4PrecipPotConsumptionNode <> nil)
    and (FFmp4PrecipPotConsumptionNode.StateIndex <> 3) then
  begin
    FFmp4PrecipPotConsumptionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4RootDepthChanged(Sender: TObject);
begin
  if (FFmp4RootDepthNode <> nil)
    and (FFmp4RootDepthNode.StateIndex <> 3) then
  begin
    FFmp4RootDepthNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.Fmp4TranspirationFractionChanged(
  Sender: TObject);
begin
  if (FFmp4TranspirationFractionNode <> nil)
    and (FFmp4TranspirationFractionNode.StateIndex <> 3) then
  begin
    FFmp4TranspirationFractionNode.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.FormClose(Sender: TObject;
  var Action: TCloseAction);
var
  RowIndex: Integer;
  ColIndex: Integer;
begin
  inherited;
  // release memory asociated with rdgImportedData.
  rdgImportedData.BeginUpdate;
  try
    for RowIndex := 1 to rdgImportedData.RowCount - 1 do
    begin
      for ColIndex := 1 to rdgImportedData.ColCount - 1 do
      begin
        rdgImportedData.Cells[ColIndex, RowIndex] := '';
      end;
    end;
    rdgImportedData.ColCount := 2;
    rdgImportedData.RowCount := 2;
  finally
    rdgImportedData.EndUpdate;
  end;
  if FNewProperties <> nil then
  begin
    FNewProperties.Clear;
  end;
  if FOldProperties <> nil then
  begin
    FOldProperties.Clear;
  end;
  FCurrentEdit := nil;
  FDataEdits.Clear;
  frameScreenObjectSFR.Clear;
  IsLoaded := False;
end;

procedure TfrmScreenObjectProperties.FormCreate(Sender: TObject);
begin
  inherited;
  FPestMethods := TStringList.Create;
  FPestMethods.Add(StrMultiply);
  FPestMethods.Add(StrAdd);
  FPestBlockParametersAndDataSets := TStringList.Create;
  FPestNodeParametersAndDataSets := TStringList.Create;
  FPestParameters := TStringList.Create;


  frameObsMf6.OnChangeProperties := Mf6ObsChanged;

  reDataSetFormula.DoubleBuffered := False;
  frameLakMf6.OnChange := LakeMf6Changed;
  frameMnw2.OnChange := Mnw2Changed;
  frameMnw1.OnChange := Mnw1Changed;
  frameMvr.OnChange := MvrChanged;

  frameCfpRechargeFraction1.OnChange := CfpRchargeOnChange;

  frameScreenObjectUzfMf6.OnEdited := UzfMf6Changed;

  frameFhbHead.OnChange := FhbHeadChanged;
  frameFhbFlow.OnChange := FhbFlowChanged;
//  frameScreenObjectFarm.OnChange := FarmChanged;
  frameFarmPrecip.OnChange := FarmPrecipChanged;
  frameFarmRefEvap.OnChange := FarmRefEvapChanged;
  frameFarmCropID.OnChange := FarmCropIDChanged;
  frameFarmID.OnChange := FarmIDChanged;
  frameCfpPipes.OnChange := CfpPipesChanged;
  frameCfpFixedHeads.OnChange := CfpFixedHeadsChanged;
  frameRIP.OnChange := RipChanged;
  frameMAW.OnEdited := MawChanged;
  frameCSUB.OnEdited := CSubChanged;
  frameFmp4Efficiency.OnEdited := Fmp4EfficiencyChanged;
  frameFmp4EfficiencyImprovement.OnEdited := Fmp4EfficiencyImprovementChanged;
  frameFmp4BareRunoffFraction.OnEdited := Fmp4BareRunoffFractionChanged;
  frameFmp4BarePrecipitationConsumptionFraction.OnEdited :=
    Fmp4BarePrecipitationConsumptionFractionChanged;
  frameFmp4BareEvap.OnEdited := Fmp4BareEvapChanged;
  frameFmp4DirectRecharge.OnEdited := Fmp4DirectRechargeChanged;
  frameFmp4PrecipPotConsumption.OnEdited := Fmp4PrecipPotConsumptionChanged;
  frameFmp4NrdInfilLocation.OnEdited := Fmp4NrdInfilLocationChanged;
  frameFmp4LandUseAreaFraction.OnEdited := Fmp4LandUseAreaFractionChanged;
  frameMultLandUseAreaFraction.OnEdited := Fmp4MultLandUseAreaFractionChanged;
  frameFmp4CropCoefficient.OnEdited := Fmp4CropCoefficientChanged;
  frameFmp4MultCropCoefficients.OnEdited := Fmp4MultCropCoefficientChanged;
  frameFmp4ConsumptiveUse.OnEdited := Fmp4ConsumptiveUseChanged;
  frameFmp4MultConsumptiveUse.OnEdited := Fmp4MultConsumptiveUseChanged;
  frameFmp4Irrigation.OnEdited := Fmp4IrrigationChanged;
  frameFmp4MultIrrigation.OnEdited := Fmp4MultIrrigationChanged;
  frameFmp4RootDepth.OnEdited := Fmp4RootDepthChanged;
  frameFmp4MultRootDepth.OnEdited := Fmp4MultRootDepthChanged;
  frameFmp4TranspirationFraction.OnEdited := Fmp4TranspirationFractionChanged;
  frameFmp4MultTranspirationFraction.OnEdited := Fmp4MultTranspirationFractionChanged;
  frameFmp4EvaporationIrrigationFraction.OnEdited := Fmp4EvaporationIrrigationFractionChanged;
  frameFmp4MultEvaporationIrrigationFraction.OnEdited := Fmp4MultEvaporationIrrigationFractionChanged;
  frameFmp4FractionOfPrecipToSurfaceWater.OnEdited := Fmp4FractionOfPrecipToSurfaceWaterChanged;
  frameFmp4MultFractionOfPrecipToSurfaceWater.OnEdited := Fmp4MultFractionOfPrecipToSurfaceWaterChanged;
  frameFmp4FractionOfIrrigToSurfaceWater.OnEdited := Fmp4FractionOfIrrigToSurfaceWaterChanged;
  frameFmp4MultFractionOfIrrigToSurfaceWater.OnEdited := Fmp4MultFractionOfIrrigToSurfaceWaterChanged;
  frameFmp4AddedDemand.OnEdited := Fmp4AddedDemandChanged;
  frameFmp4MultAddedDemand.OnEdited := Fmp4MultAddedDemandChanged;
  frameFmp4CropHasSalinityDemand.OnEdited := Fmp4CropHasSalinityDemandChanged;
  frameFmp4MultCropHasSalinityDemand.OnEdited := Fmp4MultCropHasSalinityDemandChanged;
  frameFmp4AddedDemandRunoffSplit.OnEdited := Fmp4AddedDemandRunoffSplitChanged;

  frameDrnParam.ConductanceColumn := 1;
  frameDrtParam.ConductanceColumn := 1;
  frameGhbParam.ConductanceColumn := 1;
  frameRivParam.ConductanceColumn := 1;
  frameWellParam.ConductanceColumn := 0;
  frameFarmWell.ConductanceColumn := 0;

  FFormulaEdit := nil;
  FDataEdits := TObjectList.Create;

  frameRchParam.UnselectableColumnsIfParametersUsed := [2,3];
  frameEvtParam.UnselectableColumnsIfParametersUsed := [2];
  frameEtsParam.UnselectableColumnsIfParametersUsed := [2,3];

  frameScreenObjectSFR.OnEdited := UpdateSfrNode;
  frameScreenObjectSTR.OnEdited := UpdateStrNode;
  frameScreenObjectSFR6.OnChange := UpdateSfr6Node;

  // See FInitialWidth for details.
  FInitialWidth := Width - pnlBoundaries.Width;

  rgEvaluatedAtClick(nil);
  seBoundaryTimes.MaxValue := MAXINT;
  seWellIntervals.MaxValue := MAXINT;

  FBoundaryPhastInterpolationList := TObjectList.Create;

  InitializeVertexGrid;

  pageMain.ActivePageIndex := 0;
  btnHelp.HelpKeyword := HelpKeyword;

  InitializePhastBoundaryControls;

  Constraints.MinWidth := Width;

  frameScreenObjectSFR.GetParser := GetSfrParser;

  frameScreenObjectSFR.OnButtonClick := frameResdgModflowBoundaryButtonClick;

  frameScreenObjectSFR.pnlSegmentUpstream.Height :=
    (frameScreenObjectSFR.pnlSegmentUpstream.Height +
    frameScreenObjectSFR.pnlSegmentDownstream.Height) div 2;

  frameHeadObservations.InitializeControls;
  frameMt3dmsTobConc.InitializeControls;

  frameLak.framePestObsLak.InitializeControls;
  frameLak.framePestObsLak.SpecifyObservationTypes(LakeGageOutputTypes);
  frameLak.framePestObsLak.OnControlsChange := LakePestObsChanged;

  framePestObsSub.InitializeControls;
  framePestObsSub.SpecifyObservationTypes(SubsidenceTypes);
  framePestObsSub.OnControlsChange := SubObsChanged;

  framePestObsSwt.InitializeControls;
  framePestObsSwt.SpecifyObservationTypes(SwtTypes);
  framePestObsSwt.OnControlsChange := SwtObsChanged;

   { Support PEST here }
  frameDrnParam.OnCheckPestCell := EnablePestCells;
  frameGhbParam.OnCheckPestCell := EnablePestCells;
  frameWellParam.OnCheckPestCell := EnablePestCells;
  frameRivParam.OnCheckPestCell := EnablePestCells;
  frameDrtParam.OnCheckPestCell := EnablePestCells;
  frameScreenObjectStr.OnCheckPestCell := EnablePestCells;
  frameFarmWell.OnCheckPestCell := EnablePestCells;
  frameChdParam.OnCheckPestCell := EnablePestCells;
  frameFhbHead.OnCheckPestCell := EnablePestCells;
  frameFhbFlow.OnCheckPestCell := EnablePestCells;
  frameRchParam.OnCheckPestCell := EnablePestCells;
  frameEvtParam.OnCheckPestCell := EnablePestCells;
  frameEtsParam.OnCheckPestCell := EnablePestCells;
  frameScreenObjectUZF.OnCheckPestCell := EnablePestCells;
  frameScreenObjectUzfMf6.OnCheckPestCell := EnablePestCells;
  frameScreenObjectSfr6.OnCheckPestCell := EnablePestCells;
  frameMAW.OnCheckPestCell := EnablePestCells;
  frameLakMf6.OnCheckPestCell := EnablePestCells;
  frameCSUB.OnCheckPestCell := EnablePestCells;
  frameHfbMf6.OnCheckPestCell := EnablePestCells;
  frameLak.OnCheckPestCell := EnablePestCells;
  frameMNW1.OnCheckPestCell := EnablePestCells;
  frameMNW2.OnCheckPestCell := EnablePestCells;
  frameRes.OnCheckPestCell := EnablePestCells;
  frameScreenObjectSFR.OnCheckPestCell := EnablePestCells;
  frameSwrReach.frameSwr.OnCheckPestCell := EnablePestCells;
  frameSWR_Rain.OnCheckPestCell := EnablePestCells;
  frameSWR_Evap.OnCheckPestCell := EnablePestCells;
  frameSWR_LatInfl.OnCheckPestCell := EnablePestCells;
  frameSWR_Stage.OnCheckPestCell := EnablePestCells;
  frameSutraSpecifiedPressure.OnCheckPestCell := EnablePestCells;
  frameSutraFluidFlux.OnCheckPestCell := EnablePestCells;
  frameSutraMassEnergyFlux.OnCheckPestCell := EnablePestCells;
  frameSutraSpecTempConc.OnCheckPestCell := EnablePestCells;
  frameSutraGeneralizedFlowBoundary.OnCheckPestCell := EnablePestCells;
  frameSutraGeneralizeTransBoundary.OnCheckPestCell := EnablePestCells;
  frameGwtCnc.OnCheckPestCell := EnablePestCells;
  frameGwtSrc.OnCheckPestCell := EnablePestCells;

  frameFarmRefEvap.OnCheckPestCell := EnablePestCells;
  frameFarmPrecip.OnCheckPestCell := EnablePestCells;
  frameFmp4AddedDemand.OnCheckPestCell := EnablePestCells;
  frameFmp4AddedDemandRunoffSplit.OnCheckPestCell := EnablePestCells;
  frameFmp4BareEvap.OnCheckPestCell := EnablePestCells;
  frameFmp4BarePrecipitationConsumptionFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4BareRunoffFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4ConsumptiveUse.OnCheckPestCell := EnablePestCells;
  frameFmp4CropCoefficient.OnCheckPestCell := EnablePestCells;
  frameFmp4DirectRecharge.OnCheckPestCell := EnablePestCells;
  frameFmp4Efficiency.OnCheckPestCell := EnablePestCells;
  frameFmp4EvaporationIrrigationFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4FractionOfIrrigToSurfaceWater.OnCheckPestCell := EnablePestCells;
  frameFmp4FractionOfPrecipToSurfaceWater.OnCheckPestCell := EnablePestCells;
  frameFmp4LandUseAreaFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4PrecipPotConsumption.OnCheckPestCell := EnablePestCells;
  frameFmp4RootDepth.OnCheckPestCell := EnablePestCells;
  frameFmp4TranspirationFraction.OnCheckPestCell := EnablePestCells;

  frameFmp4MultAddedDemand.OnCheckPestCell := EnablePestCells;
  frameFmp4MultConsumptiveUse.OnCheckPestCell := EnablePestCells;
  frameFmp4MultCropCoefficients.OnCheckPestCell := EnablePestCells;
  frameFmp4MultEvaporationIrrigationFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4MultFractionOfIrrigToSurfaceWater.OnCheckPestCell := EnablePestCells;
  frameFmp4MultFractionOfPrecipToSurfaceWater.OnCheckPestCell := EnablePestCells;
  frameMultLandUseAreaFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4MultTranspirationFraction.OnCheckPestCell := EnablePestCells;
  frameFmp4MultRootDepth.OnCheckPestCell := EnablePestCells;

  frameScreenObjectTvk.OnCheckPestCell := EnablePestCells;
  frameScreenObjectTvs.OnCheckPestCell := EnablePestCells;
end;

procedure TfrmScreenObjectProperties.ResetSpecifiedHeadGrid;
begin
  // ResetSpecifiedHeadGrid resets the data displayed in dgSpecifiedHead.
  // It is called by GetDataForMultipleScreenObjects when two screen objects have
  // Specified Head boundaries that differ.
  pcPhastBoundaries.ActivePage := tabBoundarySpecifiedHead;
  seBoundaryTimes.Value := 1;
  dgSpecifiedHead.RowCount := 2;
  dgSpecifiedHead.Cells[Ord(ibcBoundaryValue), 1] := '';
  dgSpecifiedHead.Cells[Ord(ibcSolution), 1] := '';
  dgSpecifiedHead.Checked[Ord(ibcBoundaryInterpolate), 1] := False;
  dgSpecifiedHead.Checked[Ord(ibcSolutionInterpolate), 1] := False;
end;

procedure TfrmScreenObjectProperties.ResetFluxGrid;
begin
  // ResetFluxGrid resets the data displayed in dgBoundaryFlux.
  // It is called by GetDataForMultipleScreenObjects when two screen objects have Flux
  // boundaries that differ.
  pcPhastBoundaries.ActivePage := tabBoundaryFlux;
  seBoundaryTimes.Value := 1;
  dgBoundaryFlux.RowCount := 2;
  dgBoundaryFlux.Cells[Ord(ibcBoundaryValue), 1] := '';
  dgBoundaryFlux.Cells[Ord(ibcSolution), 1] := '';
  dgBoundaryFlux.Checked[Ord(ibcBoundaryInterpolate), 1] := False;
  dgBoundaryFlux.Checked[Ord(ibcSolutionInterpolate), 1] := False;
end;

procedure TfrmScreenObjectProperties.ResetLeakyGrid;
begin
  // ResetFluxGrid resets the data displayed in dgBoundaryLeaky.
  // It is called by GetDataForMultipleScreenObjects when two screen objects have Leaky
  // boundaries that differ.
  pcPhastBoundaries.ActivePage := tabBoundaryLeaky;
  seBoundaryTimes.Value := 1;
  dgBoundaryLeaky.RowCount := 2;
  dgBoundaryLeaky.Cells[Ord(ibcBoundaryValue), 1] := '';
  dgBoundaryLeaky.Cells[Ord(ibcSolution), 1] := '';
  dgBoundaryLeaky.Checked[Ord(ibcBoundaryInterpolate), 1] := False;
  dgBoundaryLeaky.Checked[Ord(ibcSolutionInterpolate), 1] := False;
end;

procedure TfrmScreenObjectProperties.ResetRiverGrid;
begin
  // ResetRiverGrid resets the data displayed in dgBoundaryRiver.
  // It is called by GetDataForMultipleScreenObjects when two screen objects have River
  // boundaries that differ.
  pcPhastBoundaries.ActivePage := tabBoundaryRiver;
  seBoundaryTimes.Value := 1;
  dgBoundaryRiver.RowCount := 2;
  dgBoundaryRiver.Cells[Ord(nicBoundaryValue), 1] := '';
  dgBoundaryRiver.Cells[Ord(nicSolution), 1] := '';
end;

procedure TfrmScreenObjectProperties.ResetWellGrid;
begin
  // ResetWellGrid resets the data displayed in dgWell.
  // It is called by GetDataForMultipleScreenObjects when two screen objects have
  // Well boundaries that differ.
  pcPhastBoundaries.ActivePage := tabBoundaryWell;
  seBoundaryTimes.Value := 1;
  dgWell.RowCount := 2;
  dgWell.Cells[Ord(nicBoundaryValue), 1] := '';
  dgWell.Cells[Ord(nicSolution), 1] := '';
end;

procedure TfrmScreenObjectProperties.ResetWellElevationGrid;
begin
  // ResetWellElevationGrid resets the data displayed in dgWellElevations.
  // It is called by GetDataForMultipleScreenObjects when two screen objects have
  // Well boundaries with well elevations that differ.
  seWellIntervals.Value := 1;
  dgWellElevations.Cells[Ord(wicFirst), 1] := '';
  dgWellElevations.Cells[Ord(wicSecond), 1] := '';
end;

procedure TfrmScreenObjectProperties.GetBoundaryTimes(const Boundaries:
  array of TCustomPhastBoundaryCollection; const Times: TRealList);
var
  BoundaryIndex: integer;
  timeIndex: integer;
  Boundary: TCustomPhastBoundaryCollection;
begin
  // GetBoundaryTimes fills Times with all the times in  Boundaries.
  Times.Clear;
  Times.AddUnique(0);
  for BoundaryIndex := 0 to Length(Boundaries) - 1 do
  begin
    Boundary := Boundaries[BoundaryIndex];
    for timeIndex := 0 to Boundary.Count - 1 do
    begin
      Times.AddUnique((Boundary.Items[timeIndex]
        as TCustomPhastBoundaryCondition).Time);
    end;
  end;
end;

function TfrmScreenObjectProperties.TimesIdentical(const Grid: TRbwDataGrid4;
  const UsedTimes: TRealList; const TimeCol: integer): boolean;
var
  Index: integer;
begin
  // TimesIdentical returns True if all the times recorded in Grid
  // in column TimeCol are identical to those in UsedTimes.
  result := True;
  if UsedTimes.Count + 1 <> Grid.RowCount then
  begin
    result := False;
  end;
  if result then
  begin
    for Index := 0 to UsedTimes.Count - 1 do
    begin
      if FloatToStr(UsedTimes[Index]) <> Grid.Cells[TimeCol, Index + 1] then
      begin
        result := False;
        Break;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.Initialize;
begin
  FCurrentEdit := nil;
  FSelectedDataArrayName := '';
  if IsLoaded then
  begin
    FIsLoaded := False;
    try
      tvDataSets.Selected := nil;
    finally
      FIsLoaded := True;
    end;
  end
  else
  begin
    tvDataSets.Selected := nil;
  end;
  tvDataSetsChange(nil, nil);
end;

procedure TfrmScreenObjectProperties.tvDataSetsChange(Sender: TObject;
  Node: TTreeNode);
begin
  inherited;
  if IsLoaded then
  begin
    UpdateCurrentEdit;
    if (tvDataSets.Selected <> nil) and (tvDataSets.Selected.Data <> nil) then
    begin
      lblDataSetFormula.Caption := Format(StrFormulaForSDat,
        [tvDataSets.Selected.Text]);
    end
    else
    begin
      lblDataSetFormula.Caption := StrFormula;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.tvDataSetsMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  Edit: TScreenObjectDataEdit;
begin
  inherited;
  if htOnStateIcon in tvDataSets.GetHitTestInfoAt(X, Y) then
  begin
    if (tvDataSets.Selected <> nil) and (tvDataSets.Selected.Data <> nil) then
    begin
      Edit := tvDataSets.Selected.Data;
      case Edit.Used of
        cbUnchecked: Edit.Used := cbChecked;
        cbChecked: Edit.Used := cbUnchecked;
        cbGrayed: Edit.Used := cbChecked;
      end;
      UpdateCurrentEdit;
      UpdateCurrentEdit;
      if (Edit.Used <> cbUnchecked) and (FCurrentEdit.Formula = '') then
      begin
        FCurrentEdit.Formula := GenerateNewDataSetFormula(FCurrentEdit.DataArray);
        UpdateCurrentEdit;
      end;
    end;
  end;
end;

function TfrmScreenObjectProperties.PhastBoundaryIsIdentical(const Grid:
  TRbwDataGrid4;
  const UsedTimes: TRealList; const Boundary: TCustomPhastBoundaryCollection;
  const ExpressionCol, PhastInterpolateCol: integer): boolean;
var
  Index: integer;
  Item: TCustomPhastBoundaryCondition;
  RealItem: TRealPhastBoundaryCondition;
  IntegerItem: TIntegerPhastBoundaryCondition;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
  RowIndex: integer;
begin
  {BoundaryIsIdentical tests whether the boundary specified in Grid is
   identical to the one in Boundary.}
  result := True;
  for Index := 0 to Boundary.Count - 1 do
  begin
    Item := Boundary.Items[Index] as TCustomPhastBoundaryCondition;
    RowIndex := UsedTimes.IndexOf(Item.Time) + 1;
    if RowIndex <= 0 then
    begin
      result := false;
      Break;
    end;
    if (PhastInterpolateCol >= 0) and (Item.UsePHAST_Interpolation
      <> Grid.Checked[PhastInterpolateCol, RowIndex]) then
    begin
      result := false;
      Break;
    end;
    if (PhastInterpolateCol < 0) or not Item.UsePHAST_Interpolation then
    begin
      if Item.FormulaExpression <> Grid.Cells[ExpressionCol, RowIndex] then
      begin
        result := false;
        Break;
      end;
    end
    else
    begin
      Assert(Grid.Objects[PhastInterpolateCol, RowIndex] <> nil);
      InterpValuesCollection := Grid.Objects[PhastInterpolateCol, RowIndex]
        as TInterpValuesCollection;
      Assert(InterpValuesCollection.Count > 0);
      InterpValuesItem := InterpValuesCollection.Items[0] as TInterpValuesItem;
      if Item.Distance1 <> InterpValuesItem.Values.Distance1 then
      begin
        result := false;
        Break;
      end;
      if Item.Distance2 <> InterpValuesItem.Values.Distance2 then
      begin
        result := false;
        Break;
      end;
      if Item.InterpolationDirection <>
        InterpValuesItem.Values.InterpolationDirection then
      begin
        result := false;
        Break;
      end;
      if Item is TRealPhastBoundaryCondition then
      begin
        RealItem := TRealPhastBoundaryCondition(Item);
        if RealItem.Value1 <> InterpValuesItem.Values.RealValue1 then
        begin
          result := false;
          Break;
        end;
        if RealItem.Value2 <> InterpValuesItem.Values.RealValue2 then
        begin
          result := false;
          Break;
        end;
      end
      else if Item is TIntegerPhastBoundaryCondition then
      begin
        IntegerItem := TIntegerPhastBoundaryCondition(Item);
        if IntegerItem.Value1 <> InterpValuesItem.Values.IntValue1 then
        begin
          result := false;
          Break;
        end;
        if IntegerItem.Value2 <> InterpValuesItem.Values.IntValue2 then
        begin
          result := false;
          Break;
        end;
      end
      else
      begin
        Assert(False);
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetDataForMultipleScreenObjects(
  const AScreenObjectList: TList);
var
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  TempList: TStringList;
  TempType: TPhastBoundaryTypes;
  CompilerList: TList;
  Index: Integer;
  Compiler: TRbwParser;
  FirstScreenObject: TScreenObject;
  QuadRefinement: Integer;
begin
  // This line should always be the first line.
  IsLoaded := False;

  GetVertexLabels(AScreenObjectList);

  FCanFillTreeView := False;
//  OutputDebugString('SAMPLING ON');
  if FNewProperties = nil then
  begin
    FNewProperties := TScreenObjectEditCollection.Create;
    FNewProperties.OwnScreenObject := True;
  end;
  FillPropertyCollection(FNewProperties, AScreenObjectList);

  TempList := TStringList.Create;
  try
    if AScreenObjectList.Count >= 1 then
    begin
      // get data for first screen object
      GetData(AScreenObjectList[0]);
      FCanFillTreeView := False;
      IsLoaded := False;
    end;

    FObjectCount := AScreenObjectList.Count;
    ShowGageObservations;

    if AScreenObjectList.Count > 1 then
    begin
      memoComments.Enabled := False;
      memoComments.Lines.Clear;

      tabVertexValues.TabVisible := False;
      clbChildModels.Enabled := False;
//      tabImportedData.TabVisible := False;
      tabImportedData.TabVisible := False;
      CompilerList := TList.Create;
      try
        FillCompilerList(CompilerList);
        for Index := 0 to CompilerList.Count - 1 do
        begin
          Compiler := CompilerList[Index];
          Compiler.ClearVariables;
        end;
        GetGlobalVariables;
      finally
        CompilerList.Free;
      end;
      CreateDataSetEdits(AScreenObjectList);
    end;


    if FOldProperties = nil then
    begin
      FOldProperties := TScreenObjectEditCollection.Create;
      FOldProperties.OwnScreenObject := True;
    end;
    FillPropertyCollection(FOldProperties, AScreenObjectList);

    FScreenObjectList := AScreenObjectList;
    FScreenObject := nil;
    if AScreenObjectList.Count > 1 then
    begin

      memoNames.Visible := True;
      lblNames.Visible := True;
      // Don't allow user to change the name because each screen object should
      // have a unique name.
      EdName.Text := '';
      EdName.Enabled := False;
      MultipleScreenObjects := True;

      //Get data for the remaining screen objects.
      GetGages(AScreenObjectList);
      GetModpathParticles(AScreenObjectList);
      GetSubObs(AScreenObjectList);
      GetSwtObs(AScreenObjectList);

      TempType := btNone;
      for ScreenObjectIndex := 1 to AScreenObjectList.Count - 1 do
      begin
        AScreenObject := AScreenObjectList[ScreenObjectIndex];
        memoNames.Lines.Add(AScreenObject.Name);

        if rdeQuadTreeRefinement.Enabled then
        begin
          if TryStrToInt(rdeQuadTreeRefinement.Text, QuadRefinement) then
          begin
            if QuadRefinement <> AScreenObject.QuadtreeRefinementLevel then
            begin
              rdeQuadTreeRefinement.Text := '';
            end;
          end;
        end;

        GetObjectLabelForAdditionalScreenObject(AScreenObject);
        GetEvaluatedAtForAdditionalObject(AScreenObject);
        GetPositionLockedForAdditionalObject(AScreenObject);
        GetDataSetsForAdditionalObject(AScreenObject);
        GetElevationFormulasForAdditionalObject(AScreenObject);
        GetCellSizeUsedForAdditionalObject(AScreenObject);
        GetColorDataForAdditionalObject(AScreenObject);
        GetAssignmentMethodForAdditionalObject(AScreenObject);
        GetIFaceForAdditionalObject(AScreenObject);
        GetDuplicatesAllowedForAdditionalObject(AScreenObject);
//        GetPilotPointsForAdditionalObject(AScreenObject);

        GetPhastBoundaryConditionsForAdditionalObjects(AScreenObject, TempType);
      end;
      // Don't allow users to edit more than one type of boundary
      // condition at a time.
      if (TempType=btNone) and (rgBoundaryType.ItemIndex <> 0) then
      begin
        rgBoundaryType.ItemIndex := -1;
      end;

      ShowOrHideTabs;
      // don't allow the users to edit nodes if the number of screen objects
      // is greater than 1.
      tabNodes.TabVisible := False;

      tabDynamicTimeSeries.TabVisible :=
        frameDynamicTimeSeries.GetData(FNewProperties);

      GetModflowBoundaries(AScreenObjectList);
      GetSutraObservations(AScreenObjectList);
      GetFootprintWells;
      GetAdditionalUsedModels(AScreenObjectList);
      SetSelectedSutraBoundaryNode;
    end;
    FCanFillTreeView := True;
    if AScreenObjectList.Count > 1 then
    begin
      FillDataSetsTreeView(AScreenObjectList);
    end;

  finally
    TempList.Free;
  end;

  if AScreenObjectList.Count >= 1 then
  begin
    FirstScreenObject := AScreenObjectList[0];
    SetDisabledElevationFormulas(FirstScreenObject);
  end;

  FSetCellsColor := False;

  if AScreenObjectList.Count = 1 then
  begin
    jvplObjectInfo.ActivePage := jvspSingleObject;
  end
  else
  begin
    jvplObjectInfo.ActivePage := jvspMultipleObjects;
  end;

  FPriorElevationCount := rgElevationCount.ItemIndex;
  EnableWellTabfile;

  IsLoaded := True;
  SelectBoundaryCell;
  EnableOK_Button;
  EmphasizeValueChoices;
  UpdateSubComponents(self);
  UpdateCurrentEdit;
  SetDefaultCellSize;
  tvDataSetsChange(nil, nil);
  EnableModpathObjectChoice;
  ShowOrHideObsTabs;
//  OutputDebugString('SAMPLING OFF');
end;

procedure TfrmScreenObjectProperties.HideGLViewersWithMicrosoftOpenGL;
{$IFDEF Win64}
var
  VendorString: PAnsiChar;
{$ENDIF}
begin
  // Work-around for buggy Microsoft OpenGL driver.
{$IFDEF Win64}
  Handle;
  VendorString := glGetString(GL_VENDOR);
  if (VendorString <> '') and (VendorString <> 'Microsoft Corporation') then
  begin
    frameModpathParticles.GLSceneViewer1.Visible := True;
    frameIface.glsvViewer.Visible := True;

    frameModpathParticles.lblMessage.Visible := False;
    frameIface.lblMessage.Visible := False;
  end;
{$ELSE}
  frameModpathParticles.GLSceneViewer1.Visible := True;
  frameIface.glsvViewer.Visible := True;

  frameModpathParticles.lblMessage.Visible := False;
  frameIface.lblMessage.Visible := False;
{$ENDIF}
end;

procedure TfrmScreenObjectProperties.SetObjectCaption(List: TList);
var
  AScreenObject: TScreenObject;
  ObjectLabel: TObjectLabel;
  ObjectVertexLabel: TObjectVertexLabel;
  SectionLabel: TSectionLabel;
  index: Integer;
begin
  for index := 0 to List.Count - 1 do
  begin
    AScreenObject := List[index];
    ObjectLabel := AScreenObject.ObjectLabel;
    if cbCaptionVisible.State <> cbGrayed then
    begin
      ObjectLabel.Visible := cbCaptionVisible.Checked;
    end;
    if (rdeCaptionX.Text <> '') and (rdeCaptionY.Text <> '') then
    begin
      ObjectLabel.OffSet := Point(rdeCaptionX.IntegerValue, rdeCaptionY.IntegerValue);
    end;
    if FCaptionTextChanged then
    begin
      ObjectLabel.Caption := memoCaption.Text;
    end;
    if FCaptionFontChanged then
    begin
      ObjectLabel.Font := FCaptionFont;
    end;

    ObjectVertexLabel := AScreenObject.ObjectVertexLabel;
    if cbVertexLabelVisible.State <> cbGrayed then
    begin
      ObjectVertexLabel.Visible := cbVertexLabelVisible.Checked;
    end;
    if (rdeVertexXOffset.Text <> '') and (rdeVertexYOffset.Text <> '') then
    begin
      ObjectVertexLabel.OffSet := Point(rdeVertexXOffset.IntegerValue,
        rdeVertexYOffset.IntegerValue);
    end;
    if FVertexCaptionFontChanged then
    begin
      ObjectVertexLabel.Font := FVertexCaptionFont;
    end;

    SectionLabel := AScreenObject.SectionLabel;
    if cbVertexLabelVisible.State <> cbGrayed then
    begin
      SectionLabel.Visible := cbSectionLabelVisible.Checked;
    end;
    if (rdeSectionXOffset.Text <> '') and (rdeSectionYOffset.Text <> '') then
    begin
      SectionLabel.OffSet := Point(rdeSectionXOffset.IntegerValue,
        rdeSectionYOffset.IntegerValue);
    end;
    if FSectionCaptionFontChanged then
    begin
      SectionLabel.Font := FSectionCaptionFont;
    end;

    if comboVertexValueLabels.ItemIndex >= 0 then
    begin
      if comboVertexValueLabels.ItemIndex = 0 then
      begin
        ObjectVertexLabel.VertexValueKey := '';
      end
      else
      begin
        ObjectVertexLabel.VertexValueKey :=
          comboVertexValueLabels.Items[comboVertexValueLabels.ItemIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetPestMethod(Grid: TRbwDataGrid4;
  ACol: Integer; const Value: TPestParamMethod);
begin
  if PestMethodRow = 0 then
  begin
    Exit;
  end;
  Grid.Cells[ACol,PestMethodRow] := FPestMethods[Ord(Value)];
end;

//procedure TfrmScreenObjectProperties.SetPestMethodAssigned(Grid: TRbwDataGrid4;
//  ACol: Integer; const Value: Boolean);
//begin
//
//end;

procedure TfrmScreenObjectProperties.SetPestModifier(Grid: TRbwDataGrid4;
  ACol: Integer; const Value: string);
begin
  if PestRowOffset = 0 then
  begin
    Assert(False);
    Exit;
  end;
  if Value = '' then
  begin
    Grid.Cells[ACol, PestModifierRow] := strNone;
  end
  else
  begin
    Grid.Cells[ACol, PestModifierRow] := Value;
  end;
end;

procedure TfrmScreenObjectProperties.GetObjectLabelForAdditionalScreenObject(
  AScreenObject: TScreenObject);
var
  ObjectLabel: TObjectLabel;
  ObjectVertexLabel: TObjectVertexLabel;
  SectionLabel: TSectionLabel;
  ItemIndex: Integer;
begin
  ObjectLabel := AScreenObject.ObjectLabel;
  if cbCaptionVisible.Checked <> ObjectLabel.Visible then
  begin
    cbCaptionVisible.AllowGrayed := True;
    cbCaptionVisible.State := cbGrayed;
  end;
  if (rdeCaptionX.Text <> '')
    and (rdeCaptionX.IntegerValue <> ObjectLabel.OffSet.X) then
  begin
    rdeCaptionX.Text := '';
  end;
  if (rdeCaptionY.Text <> '')
    and (rdeCaptionY.IntegerValue <> ObjectLabel.OffSet.Y) then
  begin
    rdeCaptionY.Text := '';
  end;

  ObjectVertexLabel := AScreenObject.ObjectVertexLabel;
  if cbVertexLabelVisible.Checked <> ObjectVertexLabel.Visible then
  begin
    cbVertexLabelVisible.AllowGrayed := True;
    cbVertexLabelVisible.State := cbGrayed;
  end;
  if (rdeVertexXOffset.Text <> '')
    and (rdeVertexXOffset.IntegerValue <> ObjectVertexLabel.OffSet.X) then
  begin
    rdeVertexXOffset.Text := '';
  end;
  if (rdeVertexYOffset.Text <> '')
    and (rdeVertexYOffset.IntegerValue <> ObjectVertexLabel.OffSet.Y) then
  begin
    rdeVertexYOffset.Text := '';
  end;

  if ObjectVertexLabel.VertexValueKey = '' then
  begin
    ItemIndex := 0;
  end
  else
  begin
    ItemIndex := comboVertexValueLabels.Items.IndexOf(
      ObjectVertexLabel.VertexValueKey);
    ItemIndex := Max(ItemIndex, 0);
  end;

  if comboVertexValueLabels.ItemIndex <> ItemIndex then
  begin
    comboVertexValueLabels.ItemIndex := -1;
  end;

  SectionLabel := AScreenObject.SectionLabel;
  if cbSectionLabelVisible.Checked <> SectionLabel.Visible then
  begin
    cbSectionLabelVisible.AllowGrayed := True;
    cbSectionLabelVisible.State := cbGrayed;
  end;
  if (rdeSectionXOffset.Text <> '')
    and (rdeSectionXOffset.IntegerValue <> SectionLabel.OffSet.X) then
  begin
    rdeSectionXOffset.Text := '';
  end;
  if (rdeSectionYOffset.Text <> '')
    and (rdeSectionYOffset.IntegerValue <> SectionLabel.OffSet.Y) then
  begin
    rdeSectionYOffset.Text := '';
  end;


end;

function TfrmScreenObjectProperties.GwtColumnCount: integer;
begin
  result := 0;
  if frmGoPhast.PhastModel.GwtUsed or frmGoPhast.PhastModel.GweUsed then
  begin
    result := frmGoPhast.PhastModel.MobileComponents.Count;
  end;
end;

procedure TfrmScreenObjectProperties.SetModflowBoundaryColCount;
var
  CropIrrigationRequirement: TCropIrrigationRequirement;
  MobileSpeciesCount: Integer;
begin
  MobileSpeciesCount := GwtColumnCount;
  frameChdParam.rdgModflowBoundary.ColCount := 6 + MobileSpeciesCount;
  frameGhbParam.rdgModflowBoundary.ColCount := 5 + MobileSpeciesCount;
  frameWellParam.rdgModflowBoundary.ColCount := 4 + MobileSpeciesCount;
  frameRivParam.rdgModflowBoundary.ColCount := 6 + MobileSpeciesCount;
  frameDrnParam.rdgModflowBoundary.ColCount := 6;
  frameDrtParam.rdgModflowBoundary.ColCount := 5;
  CropIrrigationRequirement :=
    frmGoPhast.PhastModel.ModflowPackages.FarmProcess.CropIrrigationRequirement;
  case CropIrrigationRequirement of
    cirContinuously:
      begin
        frameFarmWell.rdgModflowBoundary.ColCount := 4;
      end;
    cirOnlyWhenNeeded:
      begin
        frameFarmWell.rdgModflowBoundary.ColCount := 5;
      end;
  end;
  if frmGoPhast.PhastModel.RchTimeVaryingLayers then
  begin
    frameRchParam.rdgModflowBoundary.ColCount := 5 + MobileSpeciesCount;
  end
  else
  begin
    frameRchParam.rdgModflowBoundary.ColCount := 4 + MobileSpeciesCount;
  end;
  if frmGoPhast.PhastModel.EvtTimeVaryingLayers then
  begin
    frameEvtParam.rdgModflowBoundary.ColCount := 6;
  end
  else
  begin
    frameEvtParam.rdgModflowBoundary.ColCount := 5;
  end;
  frameEtsParam.rdgModflowBoundary.ColCount := EtsColCount;

  frameMT3DMS_SSM.rdgModflowBoundary.ColCount :=
    2 + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;

  frameMt3d_UZT_Rech.rdgModflowBoundary.ColCount :=
    2 + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;

  frameMt3d_UZT_Sat.rdgModflowBoundary.ColCount :=
    2 + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;

  frameMt3d_UZT_Unsat.rdgModflowBoundary.ColCount :=
    2 + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;

  frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary.ColCount :=
    2 + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;

  frameSWR_Rain.rdgModflowBoundary.ColCount := 3;
  frameSWR_Evap.rdgModflowBoundary.ColCount := 3;
  frameSWR_LatInfl.rdgModflowBoundary.ColCount := 3;
  frameSWR_Stage.rdgModflowBoundary.ColCount := 3;
  frameSWR_DirectRunoff.rdgModflowBoundary.ColCount := 4;
end;

procedure TfrmScreenObjectProperties.CreateSubPestObsNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSubPestObs_Node := nil;
  if frmGoPhast.PhastModel.SubIsSelected
    and (AScreenObject.Count = 1) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.SubPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSubPestObs.PageIndex;
    framePestObsSub.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSubPestObs_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraFeatureNodes(
  AScreenObject: TScreenObject);
begin
  jvpltvSutraFeatures.Items.Clear;
  CreateSutraObsNode;
  CreateSutraSpecPressNode;
  CreateSutraSpecTempConcNode;
  CreateSutraFluidFluxNode;
  CreateSutraMassEnergyFluxNode;
  CreateSutraLakeNode;
  CreateSutraGeneralizedFlowNode;
  CreateSutraGeneralizedTransportNode;
  if AScreenObject <> nil then
  begin
    CreateSutraStateObsNode(AScreenObject);
  end;
  CreateSutraSpecPresObsNode;
  CreateSutraSpecifiedFluidFlowObsNode;
  CreateSutraSpecConcObsNode;
  CreateSutraGenFlowObsNode;
  CreateSutraGenTransObsNode;
end;

function TfrmScreenObjectProperties.ShouldCreateSutraLakeBoundary: Boolean;
var
  LocalModel: TPhastModel;
  AScreenObject: TScreenObject;
begin
  LocalModel := frmGoPhast.PhastModel;
  if FScreenObject = nil then
  begin
    if (FScreenObjectList <> nil) and (FScreenObjectList.Count > 0) then
    begin
      AScreenObject := FScreenObjectList[0];
    end
    else
    begin
      AScreenObject := nil;
    end;
  end
  else
  begin
    AScreenObject := FScreenObject
  end;

  result := (LocalModel.ModelSelection in [msSutra30, msSutra40])
    and LocalModel.SutraOptions.LakeOptions.UseLakes
//    and (not LocalModel.SutraOptions.LakeOptions.AllNodesLakes)
    and (LocalModel.SutraMesh <> nil)
    and (rgEvaluatedAt.ItemIndex = Ord(eaNodes))
    and (LocalModel.SutraMesh.MeshType = mt3D)
    and (AScreenObject <> nil)
    and (AScreenObject.ViewDirection = vdTop);
end;

function TfrmScreenObjectProperties.ShouldCreateSutraGeneralBoundary: Boolean;
var
  LocalModel: TPhastModel;
begin
  LocalModel := frmGoPhast.PhastModel;
  result := (LocalModel.ModelSelection in [msSutra30, msSutra40])
    and (LocalModel.SutraMesh <> nil)
    and (rgEvaluatedAt.ItemIndex = Ord(eaNodes))
end;

function TfrmScreenObjectProperties.ShouldCreateSutraBoundary: Boolean;
var
  LocalModel: TPhastModel;
begin
  LocalModel := frmGoPhast.PhastModel;
  result := (LocalModel.ModelSelection in SutraSelection)
    and (LocalModel.SutraMesh <> nil)
    and (rgEvaluatedAt.ItemIndex = Ord(eaNodes))
    and ((LocalModel.SutraMesh.MeshType in [mt2D, mtProfile])
    or (rgElevationCount.ItemIndex in [1, 2]));
end;

procedure TfrmScreenObjectProperties.GetCanSelectNode(Node: TTreeNode; var AllowChange: Boolean);
var
  SwrPackage: TSwrPackage;
begin
  if Node = nil then
  begin
    AllowChange := False;
    Exit;
  end;
  SwrPackage := frmGoPhast.PhastModel.ModflowPackages.SwrPackage;
  if (Node = FChob_Node) then
  begin
    if (FCHD_Node = nil) or (FCHD_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if (Node = FDrob_Node) then
  begin
    if (FDRN_Node = nil) or (FDRN_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if (Node = FGbob_Node) then
  begin
    if (FGHB_Node = nil) or (FGHB_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if (Node = FRvob_Node) then
  begin
    if (FRIV_Node = nil) or (FRIV_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end
  end
  else if (Node = FStob_Node) then
  begin
    if (FSTR_Node = nil) or (FSTR_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end
  end
  else if (Node = FMt3dmsTobFlux_Node) then
  begin
    AllowChange := False;
    if (FCHD_Node <> nil) and (FCHD_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FDRN_Node <> nil) and (FDRN_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FGHB_Node <> nil) and (FGHB_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FRIV_Node <> nil) and (FRIV_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FWEL_Node <> nil) and (FWEL_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FEVT_Node <> nil) and (FEVT_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FRCH_Node <> nil) and (FRCH_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMt3dmsSsm_Node <> nil) and (FMt3dmsSsm_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMt3d_UZT_Rech_Node <> nil) and (FMt3d_UZT_Rech_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMt3d_UZT_Sat_Node <> nil) and (FMt3d_UZT_Sat_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMt3d_UZT_Unsat_Node <> nil) and (FMt3d_UZT_Unsat_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMt3d_Uzf_Seep_Node <> nil) and (FMt3d_Uzf_Seep_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMt3d_LKT_Node <> nil) and (FMt3d_LKT_Node.StateIndex <> 1) then
    begin
      if (FLAK_Node <> nil) and (FLAK_Node.StateIndex <> 1) then
      begin
        AllowChange := True;
      end
//      else if (FLAKMf6_Node <> nil) and (FLAKMf6_Node.StateIndex <> 1) then
//      begin
//        AllowChange := True;
//      end
      else
      begin
        AllowChange := False;
      end;
    end
    else if (FMt3d_SFT_Node <> nil) and (FMt3d_SFT_Node.StateIndex <> 1) then
    begin
      if (FSFR_Node <> nil) and (FSFR_Node.StateIndex <> 1) then
      begin
        AllowChange := True;
      end
      else
      begin
        AllowChange := False;
      end;
    end
    else if (FRES_Node <> nil) and (FRES_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FLAK_Node <> nil) and (FLAK_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FLAKMf6_Node <> nil) and (FLAKMf6_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FMVR_Node <> nil) and (FMVR_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FDRT_Node <> nil) and (FDRT_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FETS_Node <> nil) and (FETS_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSTR_Node <> nil) and (FSTR_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FFhbHead_Node <> nil) and (FFhbHead_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FFhbFlow_Node <> nil) and (FFhbFlow_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSWR_Reach_Node <> nil) and (FSWR_Reach_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSWR_Rain_Node <> nil) and (FSWR_Rain_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSWR_Evap_Node <> nil) and (FSWR_Evap_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSWR_LatInflow_Node <> nil) and (FSWR_LatInflow_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSWR_Stage_Node <> nil) and (FSWR_Stage_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FSWR_DirectRunoff_Node <> nil) and (FSWR_DirectRunoff_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end
    else if (FUZF_Mf6_Node <> nil) and (FUZF_Mf6_Node.StateIndex <> 1) then
    begin
      AllowChange := True;
    end


  end
  else if (Node = FCfpPipe_Node) then
  begin
    if (rgElevationCount.ItemIndex <> 1) then
    begin
      AllowChange := False;
    end
  end
//  else if (Node = FSWR_Reach_Node) and (FSWR_Reach_Node.StateIndex <> 1) then
//  begin
//    AllowChange := True;
//  end
  else if Node = FSWR_Rain_Node then
  begin
    if (SwrPackage.RainSpecification = smObject)
      and (FSWR_Reach_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if Node = FSWR_Evap_Node then
  begin
    if (SwrPackage.EvapSpecification = smObject)
      and (FSWR_Reach_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if Node = FSWR_LatInflow_Node then
  begin
    if (SwrPackage.LateralInflowSpecification = smObject)
      and (FSWR_Reach_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if Node = FSWR_Stage_Node then
  begin
    if (SwrPackage.StageSpecification = smObject)
      and (FSWR_Reach_Node.StateIndex = 1) then
    begin
      AllowChange := False;
    end;
  end
  else if Node = FSWR_DirectRunoff_Node then
  begin
    AllowChange := True;
  end
  else if Node = FSWiObs_Node then
  begin
    AllowChange := True;
  end
  else if Node = FRipNode then
  begin
    AllowChange := True;
  end
  else if (Node = FMAW_Node) then
  begin
    AllowChange := rgElevationCount.ItemIndex = 0;
  end
  else if Node = FMf6Obs_Node then
  begin
    AllowChange := True;
  end
  else if Node = FLAKMf6_Node then
  begin
    AllowChange := True;
  end
  else if Node = FMVR_Node then
  begin
    AllowChange := True;
  end
  else if (Node = FCSUB_Node) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4EfficiencyNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4EfficiencyImprovementNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4BareRunoffFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4BarePrecipitationConsumptionFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4BareEvapNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4DirectRechargeNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4PrecipPotConsumptionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4NrdInfilLocationNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4LandUseAreaFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultLandUseAreaFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4CropCoefficientNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultCropCoefficientNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4ConsumptiveUseNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultConsumptiveUseNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4IrrigationNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultIrrigationNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4RootDepthNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultRootDepthNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4TranspirationFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultTranspirationFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4EvaporationIrrigationFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultEvaporationIrrigationFractionNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4FractionOfPrecipToSurfaceWaterNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultFractionOfPrecipToSurfaceWaterNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4FractionOfIrrigToSurfaceWaterNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultFractionOfIrrigToSurfaceWaterNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4AddedDemandNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultAddedDemandNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4CropHasSalinityDemandNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4MultCropHasSalinityDemandNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FFmp4AddedDemandRunoffSplitNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FTvkNode) then
  begin
    AllowChange := True;
  end
  else if (Node = FTvsNode) then
  begin
    AllowChange := True;
  end

//  end
//  else if (Node = FMt3dms_Node) then
//  begin
//    AllowChange := CanSelectMt3dms;
//  end;
end;

procedure TfrmScreenObjectProperties.GetPositionLockedForAdditionalObject(AScreenObject: TScreenObject);
begin
  if AScreenObject.PositionLocked <> cbLock.Checked then
  begin
    cbLock.AllowGrayed := True;
    cbLock.State := cbGrayed;
  end;
end;

procedure TfrmScreenObjectProperties.GetPotentialMvrSources(Sender: TObject;
  var PotentialSources: TSourcePackageChoices);
begin
  PotentialSources := [];
  if (FWEL_Node <> nil) and (FWEL_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcWel);
  end;
  if (FDRN_Node <> nil) and (FDRN_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcDrn);
  end;
  if (FRIV_Node <> nil) and (FRIV_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcRiv);
  end;
  if (FGHB_Node <> nil) and (FGHB_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcGhb);
  end;
  if (FLAKMf6_Node <> nil) and (FLAKMf6_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcLak);
  end;
  if (FMAW_Node <> nil) and (FMAW_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcMaw);
  end;
  if (FSFR6_Node <> nil) and (FSFR6_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcSfr);
  end;
  if (FUZF_Mf6_Node <> nil) and (FUZF_Mf6_Node.StateIndex <> 1) then
  begin
    Include(PotentialSources, spcUzf);
  end;
end;

procedure TfrmScreenObjectProperties.FillChildModelList;
var
  Item: TChildModelItem;
  ChildModelIndex: Integer;
begin
  if FChildModels = nil then
  begin
    FChildModels := TList.Create;
  end;
  if FChildModelsScreenObjects = nil then
  begin
    FChildModelsScreenObjects := TList.Create;
  end;
  FChildModels.Clear;
  FChildModelsScreenObjects.Clear;
  clbChildModels.Items.BeginUpdate;
  try
    clbChildModels.Items.Clear;
    clbChildModels.Items.Add('none');
    for ChildModelIndex := 0 to frmGoPhast.PhastModel.ChildModels.Count - 1 do
    begin
      Item := frmGoPhast.PhastModel.ChildModels[ChildModelIndex];
      if Item.ChildModel <> nil then
      begin
        clbChildModels.Items.AddObject(Item.ChildModel.ModelName, Item.ChildModel);
        FChildModels.Add(Item.ChildModel);
        FChildModelsScreenObjects.Add(Item.ChildModel.HorizontalPositionScreenObject);
      end;
    end;
    clbChildModels.CheckedIndex := 0;
  finally
    clbChildModels.Items.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.EnableChildModelList(AScreenObject: TScreenObject);
begin
  if CanSpecifyChildModels(AScreenObject) then
  begin
    clbChildModels.Enabled := True;
//    FillChildModelList;
  end
  else
  begin
    clbChildModels.Enabled := False;
  end;
  if clbChildModels.Enabled then
  begin
    clbChildModels.Color := clWindow;
  end
  else
  begin
    clbChildModels.Color := clBtnFace;
  end;
end;

procedure TfrmScreenObjectProperties.EnableModpathObjectChoice;
var
  ShouldEnable: Boolean;
  index: Integer;
  AScreenObject: TScreenObject;
begin
  ShouldEnable := rgElevationCount.ItemIndex = 1;
  if ShouldEnable then
  begin
    if FScreenObject <> nil then
    begin
      ShouldEnable := (FScreenObject.SectionCount = FScreenObject.Count)
        and (FScreenObject.ViewDirection = vdTop);
    end
    else
    begin
      Assert(FScreenObjectList <> nil);
      for index := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[index];
        ShouldEnable := (AScreenObject.SectionCount = AScreenObject.Count)
          and (AScreenObject.ViewDirection = vdTop);
        if not ShouldEnable then
        begin
          Break;
        end;
      end;
    end;
  end;
  frameModpathParticles.SetObjectChoiceEnabled(ShouldEnable);
end;

procedure TfrmScreenObjectProperties.GetAdditionalUsedModels(const AScreenObjectList: TList);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  for ScreenObjectIndex := 1 to AScreenObjectList.Count - 1 do
  begin
    AScreenObject := AScreenObjectList[ScreenObjectIndex];
    if cbLgrAllModels.Checked <> AScreenObject.UsedModels.UsedWithAllModels then
    begin
      cbLgrAllModels.AllowGrayed := True;
      cbLgrAllModels.State := cbGrayed;
    end;
    if clbLgrUsedModels.Checked[0] <> AScreenObject.UsedModels.UsesModel(frmGoPhast.PhastModel) then
    begin
      clbLgrUsedModels.AllowGrayed := True;
      clbLgrUsedModels.State[0] := cbGrayed;
    end;
    for ChildIndex := 0 to frmGoPhast.PhastModel.ChildModels.Count - 1 do
    begin
      ChildModel := frmGoPhast.PhastModel.ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        if clbLgrUsedModels.Checked[ChildIndex+1] <> AScreenObject.UsedModels.UsesModel(ChildModel) then
        begin
          clbLgrUsedModels.AllowGrayed := True;
          clbLgrUsedModels.State[ChildIndex + 1] := cbGrayed;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetUsedLgrModels(const AScreenObject: TScreenObject);
var
  ChildModel: TChildModel;
  ChildModelIndex: Integer;
begin
  cbLgrAllModels.AllowGrayed := False;
  cbLgrAllModels.Checked := AScreenObject.UsedModels.UsedWithAllModels;
  clbLgrUsedModels.Checked[0] := AScreenObject.UsedModels.UsesModel(frmGoPhast.PhastModel);
  for ChildModelIndex := 0 to frmGoPhast.PhastModel.ChildModels.Count - 1 do
  begin
    ChildModel := frmGoPhast.PhastModel.ChildModels[ChildModelIndex].ChildModel;
    if ChildModel <> nil then
    begin
      clbLgrUsedModels.Checked[ChildModelIndex + 1] := AScreenObject.UsedModels.UsesModel(ChildModel);
    end;
  end;
  clbLgrUsedModels.AllowGrayed := False;
  
end;

procedure TfrmScreenObjectProperties.SetVertexValues(AScreenObject: TScreenObject);
var
  RowIndex: Integer;
  PointValueItem: TPointValuesItem;
  ColIndex: Integer;
  ValuePosition: Integer;
  ValueItem: TPointValue;
  AValue: Double;
  PPItem: TPointValuesItem;
begin
  if tabVertexValues.TabVisible then
  begin
    while AScreenObject.PointPositionValues.Count < rdgVertexValues.RowCount - 1 do
    begin
      PPItem := AScreenObject.PointPositionValues.Add;
      RowIndex := AScreenObject.PointPositionValues.Count;
      PPItem.Position := rdgVertexValues.IntegerValueDefault[0, RowIndex, 0]-1;
    end;
    Assert(AScreenObject.PointPositionValues.Count =
      rdgVertexValues.RowCount - 1);
    for RowIndex := rdgVertexValues.RowCount - 1 downto 1 do
    begin
      PointValueItem := AScreenObject.PointPositionValues.
        Items[RowIndex - 1] as TPointValuesItem;
      for ColIndex := 1 to rdgVertexValues.ColCount - 1 do
      begin
        ValuePosition := PointValueItem.IndexOfName(
          rdgVertexValues.Cells[ColIndex, 0]);
        if rdgVertexValues.Cells[ColIndex, RowIndex] = '' then
        begin
          if ValuePosition >= 0 then
          begin
            PointValueItem.Values.Delete(ValuePosition);
          end;
        end
        else
        begin
          if ValuePosition >= 0 then
          begin
            ValueItem := PointValueItem.Values.
              Items[ValuePosition] as TPointValue;
          end
          else
          begin
            ValueItem := PointValueItem.Values.Add as TPointValue;
            ValueItem.Name := rdgVertexValues.Cells[ColIndex, 0];
            ValueItem.Value := 0;
          end;

          if TryStrToFloat(rdgVertexValues.Cells[ColIndex, RowIndex], AValue) then
          begin
            ValueItem.Value := AValue;
          end;
        end;
      end;
      if PointValueItem.Values.Count = 0 then
      begin
        AScreenObject.PointPositionValues.Delete(RowIndex - 1);
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetVertexValues;
var
  AColumn: TRbwColumn4;
  RowIndex: Integer;
  VertexValueItem: TPointValue;
  ValueIndex: Integer;
  PointValueItem: TPointValuesItem;
  PointIndex: Integer;
  Keys: TStringList;
  ColIndex: Integer;
begin
  if FScreenObject.PointPositionValues.Count > 0 then
  begin
    tabVertexValues.TabVisible := True;
    rdgVertexValues.BeginUpdate;
    try
      Keys := TStringList.Create;
      try
        Keys.Sorted := True;
        Keys.CaseSensitive := False;
        for PointIndex := 0 to FScreenObject.PointPositionValues.Count - 1 do
        begin
          PointValueItem := FScreenObject.PointPositionValues.
            Items[PointIndex] as TPointValuesItem;
          for ValueIndex := 0 to PointValueItem.Values.Count - 1 do
          begin
            VertexValueItem := PointValueItem.Values.
              Items[ValueIndex] as TPointValue;
            if Keys.IndexOf(VertexValueItem.Name) < 0 then
            begin
              Keys.Add(VertexValueItem.Name);
            end;
          end;
        end;
        Keys.Sorted := False;
        Keys.CustomSort(CompareNames);
        rdgVertexValues.RowCount := FScreenObject.PointPositionValues.Count + 1;
        rdgVertexValues.ColCount := Keys.Count + 1;
        for ColIndex := 0 to rdgVertexValues.ColCount - 1 do
        begin
          for RowIndex := 0 to rdgVertexValues.RowCount - 1 do
          begin
            rdgVertexValues.Cells[ColIndex, RowIndex] := '';
          end;
        end;
        rdgVertexValues.Cells[0, 0] := StrVertexNumbers;
        for ColIndex := 1 to rdgVertexValues.ColCount - 1 do
        begin
          rdgVertexValues.ColWidths[ColIndex] :=
            rdgVertexValues.DefaultColWidth;
          rdgVertexValues.Cells[ColIndex, 0] := Keys[ColIndex - 1];
          AColumn := rdgVertexValues.Columns[ColIndex];
          AColumn.AutoAdjustColWidths := True;
          AColumn.Format := rcf4Real;
        end;
        for PointIndex := 0 to FScreenObject.PointPositionValues.Count - 1 do
        begin
          PointValueItem := FScreenObject.PointPositionValues.
            Items[PointIndex] as TPointValuesItem;
          rdgVertexValues.Cells[0, PointIndex + 1] :=
            IntToStr(PointValueItem.Position + 1);
          for ValueIndex := 0 to PointValueItem.Values.Count - 1 do
          begin
            VertexValueItem := PointValueItem.Values.
              Items[ValueIndex] as TPointValue;
            ColIndex := Keys.IndexOf(VertexValueItem.Name) + 1;
            rdgVertexValues.Cells[ColIndex, PointIndex + 1] :=
              FloatToStr(VertexValueItem.Value);
          end;
        end;
      finally
        Keys.Free;
      end;
    finally
      rdgVertexValues.EndUpdate;
    end;
  end
  else
  begin
    tabVertexValues.TabVisible := False;
  end;
end;

function TfrmScreenObjectProperties.CanSpecifyChildModels(AScreenObject: TScreenObject): Boolean;
begin
  result := (AScreenObject <> nil)
    and frmGoPhast.PhastModel.LgrUsed
    and (AScreenObject.ViewDirection = vdTop)
    and (rgElevationCount.ItemIndex = 0);
end;

procedure TfrmScreenObjectProperties.SetupChildModelControls(AScreenObject: TScreenObject);
var
  ChildModelIndex: Integer;
  Item: TChildModelItem;
begin
  clbLgrUsedModels.Items.BeginUpdate;
  try
    clbLgrUsedModels.Clear;
    clbLgrUsedModels.Items.AddObject(StrParentModel,frmGoPhast.PhastModel);
    for ChildModelIndex := 0 to frmGoPhast.PhastModel.ChildModels.Count - 1 do
    begin
      Item := frmGoPhast.PhastModel.ChildModels[ChildModelIndex];
      if Item.ChildModel <> nil then
      begin
        clbLgrUsedModels.Items.AddObject(
          Item.ChildModel.ModelName, Item.ChildModel);
      end;
    end;
  finally
    clbLgrUsedModels.Items.EndUpdate;
  end;
  EnableChildModelList(AScreenObject);
end;

procedure TfrmScreenObjectProperties.UpdateSectionNumbers;
var
  SectionIndex: Integer;
  TempString: string;
  Index: Integer;
begin
  if dgVerticies.DistributingText then
  begin
    Exit
  end;
  if FSettingVerticies then
  begin
    Exit;
  end;
  SectionIndex := 0;
  TempString := '0';
  dgVerticies.BeginUpdate;
  try
    for Index := 1 to dgVerticies.RowCount - 1 do
    begin
      if dgVerticies.Checked[Ord(vcNewSection), Index] then
      begin
        Inc(SectionIndex);
        TempString := IntToStr(SectionIndex);
      end;
      dgVerticies.Cells[Ord(vcSection), Index] := TempString;
    end;
  finally
    dgVerticies.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.UpdateVertexNumbers;
var
  Index: Integer;
  TempString: string;
begin
  if FSettingVerticies then
  begin
    Exit;
  end;
  dgVerticies.BeginUpdate;
  try
    for Index := 1 to dgVerticies.RowCount - 1 do
    begin
      TempString := IntToStr(Index);
      dgVerticies.Cells[Ord(vcN), Index] := TempString;
    end;
  finally
    dgVerticies.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.ClearExpressionsAndVariables();
var
  Compiler: TRbwParser;
  Index: Integer;
  CompilerList: TList;
begin
  CompilerList := TList.Create;
  try
    FillCompilerList(CompilerList);
    for Index := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[Index];
      Compiler.ClearExpressions;
      Compiler.ClearVariables;
    end;
  finally
    CompilerList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.SetFluxObservations(List: TList;
  ANode: TJvPageIndexNode; AFrame: TframeFluxObs;
  FluxObservations: TCustomSutraFluxObservationGroups);
var
  CheckState: TCheckBoxState;
begin
  if ANode <> nil then
  begin
    Assert(ANode.StateIndex in [1, 2, 3]);
    CheckState := TCheckBoxState(ANode.StateIndex - 1);
    AFrame.SetData(List, FluxObservations, CheckState);
  end;
end;

procedure TfrmScreenObjectProperties.SetFrameData;
var
  DataSetIndex: Integer;
  PipeIndex: Integer;
  CfpRchIndex: Integer;
  AnEdit: TScreenObjectEditItem;
  Pipes: TCfpPipeBoundary;
  CfpEdit: TScreenObjectDataEdit;
  DiameterDataArray: TDataArray;
  TortuosityDataArray: TDataArray;
  RoughnessHeightDataArray: TDataArray;
  LowerCriticalRDataArray: TDataArray;
  UpperCriticalRDataArray: TDataArray;
  CondOrPermDataArray: TDataArray;
  PipeElevation: TDataArray;
  DrainableStorageWidth: TDataArray;
  CfpFixedHeadsDataArray: TDataArray;
  CfpLimitedFlowDataArray: TDataArray;
  CfpBoundaryTypeDataArray: TDataArray;
  CfpWellFlowDataArray: TDataArray;
//  CfpWellConductanceDataArray: TDataArray;
  CfpCauchyHeadDataArray: TDataArray;
  CfpCauchyConductivityDataArray: TDataArray;
  CfpCauchyLimitedInflowDataArray: TDataArray;
  CfpLimitedHeadDataArray: TDataArray;
  BoundaryTypeDataSetIndex: Integer;
  FixedHeadIndex: Integer;
  CfpFixedHeads: TCfpFixedBoundary;
  MissingHeadObsNames: TStringList;
  ScreenObject: TScreenObject;
begin
  if (FHOB_Node <> nil) then
  begin
    MissingHeadObsNames := TStringList.Create;
    try
      frameHeadObservations.SetData(FNewProperties,
        (FHOB_Node.StateIndex = 2),
        (FHOB_Node.StateIndex = 1) and frmGoPhast.PhastModel.HobIsSelected,
        MissingHeadObsNames);
      if MissingHeadObsNames.Count > 0 then
      begin
        if MissingHeadObsNames.Count > 10 then
        begin
          MessageDlg(Format(StrHeadObservationNamCount,
            [MissingHeadObsNames.Count]), mtWarning, [mbOK], 0);
        end
        else
        begin
          MessageDlg(StrHeadObservationNamList + #13#10
            + MissingHeadObsNames.Text, mtWarning, [mbOK], 0);
        end;
      end;
    finally
      MissingHeadObsNames.Free;
    end;
  end;

  frameDynamicTimeSeries.SetData(FNewProperties);

  if (FSFR_Node <> nil) then
  begin
    frameScreenObjectSFR.SetData(FNewProperties,
      (FSFR_Node.StateIndex = 2),
      (FSFR_Node.StateIndex = 1) and frmGoPhast.PhastModel.SfrIsSelected);
  end;

  if (FSFR6_Node <> nil) then
  begin
    frameScreenObjectSfr6.SetData(FNewProperties,
      (FSFR6_Node.StateIndex = 2),
      (FSFR6_Node.StateIndex = 1) and frmGoPhast.PhastModel.Sfr6IsSelected);
  end;

  if (FSTR_Node <> nil) then
  begin
    frameScreenObjectSTR.SetData(FNewProperties,
      (FSTR_Node.StateIndex = 2),
      (FSTR_Node.StateIndex = 1) and frmGoPhast.PhastModel.StrIsSelected);
  end;

  if FSWiObs_Node <> nil then
  begin
    frameSwiObs.SetData(FNewProperties,
      (FSWiObs_Node.StateIndex = 2),
      (FSWiObs_Node.StateIndex = 1) and frmGoPhast.PhastModel.SwiObsUsed(nil));
  end;

  if (FMNW2_Node <> nil) then
  begin
    frameMNW2.SetData(FNewProperties,
      (FMNW2_Node.StateIndex = 2),
      (FMNW2_Node.StateIndex = 1) and frmGoPhast.PhastModel.Mnw2IsSelected);
  end;

  if (FMNW1_Node <> nil) then
  begin
    frameMNW1.SetData(FNewProperties,
      (FMNW1_Node.StateIndex = 2),
      (FMNW1_Node.StateIndex = 1) and frmGoPhast.PhastModel.Mnw1IsSelected);
  end;

  if (FHFB_Node <> nil) then
  begin
    if frmGoPhast.ModelSelection = msModflow2015 then
    begin
      frameHfbMf6.SetData(FNewProperties,
        (FHFB_Node.StateIndex = 2),
        (FHFB_Node.StateIndex = 1) and frmGoPhast.PhastModel.HfbIsSelected);
    end
    else
    begin
      frameHfbBoundary.SetData(FNewProperties,
        (FHFB_Node.StateIndex = 2),
        (FHFB_Node.StateIndex = 1) and frmGoPhast.PhastModel.HfbIsSelected);
    end;
  end
  else
  begin
    frameHfbBoundary.ClearInvalidHfbs(FNewProperties);
  end;

  if (FHydmod_Node <> nil) then
  begin
    frameHydmod.SetData(FNewProperties,
      (FHydmod_Node.StateIndex = 2),
      (FHydmod_Node.StateIndex = 1) and frmGoPhast.PhastModel.HydmodIsSelected);
  end;

  if (FMt3dmsTobConc_Node <> nil) then
  begin
    frameMt3dmsTobConc.SetData(FNewProperties,
      (FMt3dmsTobConc_Node.StateIndex = 2),
      (FMt3dmsTobConc_Node.StateIndex = 1)
      and frmGoPhast.PhastModel.Mt3dmsTobIsSelected);
  end;

  if (FFhbHead_Node <> nil) then
  begin
    frameFhbHead.SetData(FNewProperties,
      (FFhbHead_Node.StateIndex = 2),
      (FFhbHead_Node.StateIndex = 1) and frmGoPhast.PhastModel.FhbIsSelected);
  end;

  if (FFhbFlow_Node <> nil) then
  begin
    frameFhbFlow.SetData(FNewProperties,
      (FFhbFlow_Node.StateIndex = 2),
      (FFhbFlow_Node.StateIndex = 1) and frmGoPhast.PhastModel.FhbIsSelected);
  end;

  if (FSWR_Reach_Node <> nil) then
  begin
    frameSwrReach.SetData(FNewProperties,
      (FSWR_Reach_Node.StateIndex = 2),
      (FSWR_Reach_Node.StateIndex = 1) and frmGoPhast.PhastModel.SwrIsSelected);
  end;

  if (FMf6Obs_Node <> nil) then
  begin
    frameObsMf6.SetData(FNewProperties,
      (FMf6Obs_Node.StateIndex = 2),
      (FMf6Obs_Node.StateIndex = 1) and frmGoPhast.PhastModel.Mf6ObsIsSelected);
  end;

  if (FSutraObs_Node <> nil) then
  begin
    frameSutraObservations.SetData(FNewProperties,
      (FSutraObs_Node.StateIndex = 2),
      (FSutraObs_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraSpecPressure_Node <> nil) then
  begin
    frameSutraSpecifiedPressure.SetData(FNewProperties,
      (FSutraSpecPressure_Node.StateIndex = 2),
      (FSutraSpecPressure_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraLake_Node <> nil) then
  begin
    frameSutraLake.SetData(FNewProperties,
      (FSutraLake_Node.StateIndex = 2),
      (FSutraLake_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraSpecTempConc_Node <> nil) then
  begin
    frameSutraSpecTempConc.SetData(FNewProperties,
      (FSutraSpecTempConc_Node.StateIndex = 2),
      (FSutraSpecTempConc_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraFluidFlux_Node <> nil) then
  begin
    frameSutraFluidFlux.SetData(FNewProperties,
      (FSutraFluidFlux_Node.StateIndex = 2),
      (FSutraFluidFlux_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraMassEnergyFlux_Node <> nil) then
  begin
    frameSutraMassEnergyFlux.SetData(FNewProperties,
      (FSutraMassEnergyFlux_Node.StateIndex = 2),
      (FSutraMassEnergyFlux_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraGeneralizedFlowNode <> nil) then
  begin
    frameSutraGeneralizedFlowBoundary.SetData(FNewProperties,
      (FSutraGeneralizedFlowNode.StateIndex = 2),
      (FSutraGeneralizedFlowNode.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FSutraGeneralizedTransportNode <> nil) then
  begin
    frameSutraGeneralizeTransBoundary.SetData(FNewProperties,
      (FSutraGeneralizedTransportNode.StateIndex = 2),
      (FSutraGeneralizedTransportNode.StateIndex = 1)
      and (frmGoPhast.PhastModel.ModelSelection in SutraSelection));
  end;

  if (FFarmPrecip_Node <> nil) then
  begin
    frameFarmPrecip.SetData(FNewProperties,
      (FFarmPrecip_Node.StateIndex = 2),
      (FFarmPrecip_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.FarmProcess3IsSelected
      or frmGoPhast.PhastModel.FarmProcess4TransientPrecipIsSelected));
  end;

  if (FFarmRefEvap_Node <> nil) then
  begin
    frameFarmRefEvap.SetData(FNewProperties,
      (FFarmRefEvap_Node.StateIndex = 2),
      (FFarmRefEvap_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.FarmProcess3IsSelected
      or frmGoPhast.PhastModel.FarmProcess4TransientRefEtIsSelected));
  end;

  if (FFarmCropID_Node <> nil) then
  begin
    frameFarmCropID.SetData(FNewProperties,
      (FFarmCropID_Node.StateIndex = 2),
      (FFarmCropID_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.FarmProcess3IsSelected
      or frmGoPhast.PhastModel.FarmProcess4TransientCropsUsed(nil)));
  end;

  if (FFarmID_Node <> nil) then
  begin
    frameFarmID.SetData(FNewProperties,
      (FFarmID_Node.StateIndex = 2),
      (FFarmID_Node.StateIndex = 1)
      and (frmGoPhast.PhastModel.FarmProcess3IsSelected
      or frmGoPhast.PhastModel.FarmProcess4TransientFarmIsSelected));
  end;

  if (FRipNode <> nil) then
  begin
    frameRip.SetData(FNewProperties,
      (FRipNode.StateIndex = 2),
      (FRipNode.StateIndex = 1) and frmGoPhast.PhastModel.RipIsSelected);
  end;

  if (FMAW_Node <> nil) then
  begin
    frameMaw.SetData(FNewProperties,
      (FMAW_Node.StateIndex = 2),
      (FMAW_Node.StateIndex = 1) and frmGoPhast.PhastModel.MawIsSelected);
  end;

  if (FCSUB_Node <> nil) then
  begin
    frameCSUB.SetData(FNewProperties,
      (FCSUB_Node.StateIndex = 2),
      (FCSUB_Node.StateIndex = 1) and frmGoPhast.PhastModel.CSubIsSelected);
  end;

  if (FLAKMf6_Node <> nil) then
  begin
    frameLakMf6.SetData(FNewProperties,
      (FLAKMf6_Node.StateIndex = 2),
      (FLAKMf6_Node.StateIndex = 1) and frmGoPhast.PhastModel.LakMf6IsSelected);
  end;

  if (FMVR_Node <> nil) then
  begin
    frameMVR.SetData(FNewProperties,
      (FMVR_Node.StateIndex = 2),
      (FMVR_Node.StateIndex = 1) and frmGoPhast.PhastModel.MvrIsSelected);
  end;

  if (FUZF_Mf6_Node <> nil) then
  begin
    frameScreenObjectUzfMf6.SetData(FNewProperties,
      (FUZF_Mf6_Node.StateIndex = 2),
      (FUZF_Mf6_Node.StateIndex = 1) and frmGoPhast.PhastModel.UzfMf6IsSelected);
  end;

  if (FMt3d_LKT_Node <> nil) then
  begin
    frameMT3D_LKT.SetData(FNewProperties,
      (FMt3d_LKT_Node.StateIndex = 2),
      (FMt3d_LKT_Node.StateIndex = 1) and frmGoPhast.PhastModel.Mt3d_LktIsSelected(nil));
  end;

  if (FMt3d_SFT_Node <> nil) then
  begin
    frameMT3D_SFT.SetData(FNewProperties,
      (FMt3d_SFT_Node.StateIndex = 2),
      (FMt3d_SFT_Node.StateIndex = 1) and frmGoPhast.PhastModel.Mt3d_SFtIsSelected);
  end;

  if (FCfpPipe_Node <> nil) then
  begin
    frameCfpPipes.SetData(FNewProperties,
      (FCfpPipe_Node.StateIndex = 2),
      (FCfpPipe_Node.StateIndex = 1) and frmGoPhast.PhastModel.CfpIsSelected);

    DataSetIndex := self.GetDataSetIndexByName(KPipeDiameter);
    CfpEdit := FDataEdits[DataSetIndex];
    DiameterDataArray := CfpEdit.DataArray;

    DataSetIndex := self.GetDataSetIndexByName(KTortuosity);
    CfpEdit := FDataEdits[DataSetIndex];
    TortuosityDataArray := CfpEdit.DataArray;

    DataSetIndex := self.GetDataSetIndexByName(KRoughnessHeight);
    CfpEdit := FDataEdits[DataSetIndex];
    RoughnessHeightDataArray := CfpEdit.DataArray;

    DataSetIndex := self.GetDataSetIndexByName(KLowerCriticalR);
    CfpEdit := FDataEdits[DataSetIndex];
    LowerCriticalRDataArray := CfpEdit.DataArray;

    DataSetIndex := self.GetDataSetIndexByName(KUpperCriticalR);
    CfpEdit := FDataEdits[DataSetIndex];
    UpperCriticalRDataArray := CfpEdit.DataArray;

    DataSetIndex := self.GetDataSetIndexByName(KPipeConductanceOrPer);
    CfpEdit := FDataEdits[DataSetIndex];
    CondOrPermDataArray := CfpEdit.DataArray;

    DataSetIndex := self.GetDataSetIndexByName(KCfpNodeElevation);
    CfpEdit := FDataEdits[DataSetIndex];
    PipeElevation := CfpEdit.DataArray;


    for PipeIndex := 0 to FNewProperties.Count - 1 do
    begin
      AnEdit := FNewProperties[PipeIndex];
      Pipes := AnEdit.ScreenObject.ModflowCfpPipes;
      if (Pipes <> nil)  then
      begin
        if Pipes.Used then
        begin
          DataSetIndex := AnEdit.ScreenObject.AddDataSet(DiameterDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            Pipes.Diameter;

          DataSetIndex := AnEdit.ScreenObject.AddDataSet(TortuosityDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            Pipes.Tortuosity;

          DataSetIndex := AnEdit.ScreenObject.AddDataSet(RoughnessHeightDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            Pipes.RoughnessHeight;

          DataSetIndex := AnEdit.ScreenObject.AddDataSet(LowerCriticalRDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            Pipes.LowerCriticalR;

          DataSetIndex := AnEdit.ScreenObject.AddDataSet(UpperCriticalRDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            Pipes.HigherCriticalR;

          DataSetIndex := AnEdit.ScreenObject.AddDataSet(CondOrPermDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            Pipes.ConductancePermeability;

          if frameCfpPipes.edElevation.Enabled then
          begin
            DataSetIndex := AnEdit.ScreenObject.AddDataSet(PipeElevation);
            AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
              Pipes.Elevation;
          end
          else
          begin
            AnEdit.ScreenObject.RemoveDataSet(PipeElevation);
          end;

        end
        else
        begin
          AnEdit.ScreenObject.RemoveDataSet(DiameterDataArray);
          AnEdit.ScreenObject.RemoveDataSet(TortuosityDataArray);
          AnEdit.ScreenObject.RemoveDataSet(RoughnessHeightDataArray);
          AnEdit.ScreenObject.RemoveDataSet(LowerCriticalRDataArray);
          AnEdit.ScreenObject.RemoveDataSet(UpperCriticalRDataArray);
          AnEdit.ScreenObject.RemoveDataSet(CondOrPermDataArray);
          AnEdit.ScreenObject.RemoveDataSet(PipeElevation);
        end;
      end
      else
      begin
        AnEdit.ScreenObject.RemoveDataSet(DiameterDataArray);
        AnEdit.ScreenObject.RemoveDataSet(TortuosityDataArray);
        AnEdit.ScreenObject.RemoveDataSet(RoughnessHeightDataArray);
        AnEdit.ScreenObject.RemoveDataSet(LowerCriticalRDataArray);
        AnEdit.ScreenObject.RemoveDataSet(UpperCriticalRDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CondOrPermDataArray);
        AnEdit.ScreenObject.RemoveDataSet(PipeElevation);
      end;
    end;

    DataSetIndex := self.GetDataSetIndexByName(KDrainableStorageWidth);
    if DataSetIndex >= 0 then
    begin
      CfpEdit := FDataEdits[DataSetIndex];
      DrainableStorageWidth := CfpEdit.DataArray;

      for CfpRchIndex := 0 to FNewProperties.Count - 1 do
      begin
        AnEdit := FNewProperties[CfpRchIndex];
        Pipes := AnEdit.ScreenObject.ModflowCfpPipes;
        if (Pipes <> nil) and Pipes.Used then
        begin
          if frameCfpPipes.edCads.Enabled then
          begin
            DataSetIndex := AnEdit.ScreenObject.AddDataSet(DrainableStorageWidth);
            AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
              Pipes.DrainableStorageWidth;
          end
          else
          begin
            AnEdit.ScreenObject.RemoveDataSet(DrainableStorageWidth);
          end;
        end
        else
        begin
          AnEdit.ScreenObject.RemoveDataSet(DrainableStorageWidth);
        end;
      end
    end;

  end;

  if (FCfpFixedHead_Node <> nil) then
  begin
    frameCfpFixedHeads.SetData(FNewProperties,
      (FCfpFixedHead_Node.StateIndex = 2),
      (FCfpFixedHead_Node.StateIndex = 1) and frmGoPhast.PhastModel.CfpIsSelected);

    DataSetIndex := self.GetDataSetIndexByName(KCfpFixedHeads);
    CfpEdit := FDataEdits[DataSetIndex];
    CfpFixedHeadsDataArray := CfpEdit.DataArray;

    CfpBoundaryTypeDataArray := nil;
    CfpLimitedFlowDataArray := nil;
    CfpWellFlowDataArray := nil;
//    CfpWellConductanceDataArray := nil;
    CfpCauchyHeadDataArray := nil;
    CfpCauchyConductivityDataArray := nil;
    CfpCauchyLimitedInflowDataArray := nil;
    CfpLimitedHeadDataArray := nil;
    if frmGoPhast.ModelSelection = msModflowOwhm2 then
    begin
      BoundaryTypeDataSetIndex := self.GetDataSetIndexByName(KCfpBoundaryType);
      CfpEdit := FDataEdits[BoundaryTypeDataSetIndex];
      CfpBoundaryTypeDataArray := CfpEdit.DataArray;

      DataSetIndex := self.GetDataSetIndexByName(KCfpLimitedFlowValue);
      CfpEdit := FDataEdits[DataSetIndex];
      CfpLimitedFlowDataArray := CfpEdit.DataArray;

      DataSetIndex := self.GetDataSetIndexByName(KCfpWellFlow);
      CfpEdit := FDataEdits[DataSetIndex];
      CfpWellFlowDataArray := CfpEdit.DataArray;

//      DataSetIndex := self.GetDataSetIndexByName(KCfpWellConductance);
//      CfpEdit := FDataEdits[DataSetIndex];
//      CfpWellConductanceDataArray := CfpEdit.DataArray;

      DataSetIndex := self.GetDataSetIndexByName(KCfpCauchyHead);
      CfpEdit := FDataEdits[DataSetIndex];
      CfpCauchyHeadDataArray := CfpEdit.DataArray;

      DataSetIndex := self.GetDataSetIndexByName(KCfpCauchyConductivity);
      CfpEdit := FDataEdits[DataSetIndex];
      CfpCauchyConductivityDataArray := CfpEdit.DataArray;

      DataSetIndex := self.GetDataSetIndexByName(KCfpCauchyLimitedInflow);
      CfpEdit := FDataEdits[DataSetIndex];
      CfpCauchyLimitedInflowDataArray := CfpEdit.DataArray;

      DataSetIndex := self.GetDataSetIndexByName(KCfpLimitedHead);
      CfpEdit := FDataEdits[DataSetIndex];
      CfpLimitedHeadDataArray := CfpEdit.DataArray;
    end;

    for FixedHeadIndex := 0 to FNewProperties.Count - 1 do
    begin
      AnEdit := FNewProperties[FixedHeadIndex];
      CfpFixedHeads := AnEdit.ScreenObject.ModflowCfpFixedHeads;
      if (CfpFixedHeads <> nil) and CfpFixedHeads.Used then
      begin
        if CfpBoundaryTypeDataArray = nil then
        begin
          DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpFixedHeadsDataArray);
          AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
            CfpFixedHeads.FixedHead;
        end
        else
        begin
          BoundaryTypeDataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpBoundaryTypeDataArray);
          AnEdit.ScreenObject.DataSetFormulas[BoundaryTypeDataSetIndex] :=
            IntToStr(Ord(CfpFixedHeads.BoundaryType));
          case CfpFixedHeads.BoundaryType of
            cbtFixedHead:
              begin
                DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpFixedHeadsDataArray);
                AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                  CfpFixedHeads.FixedHead;
                if (CfpFixedHeads.Value2 <> '') then
                begin
                  DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpLimitedFlowDataArray);
                  AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                    CfpFixedHeads.Value2;
                  BoundaryTypeDataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpBoundaryTypeDataArray);
                  AnEdit.ScreenObject.DataSetFormulas[BoundaryTypeDataSetIndex] :=
                    IntToStr(Ord(cbtFixedHeadLimitedFlow));
                end
                else
                begin
                  AnEdit.ScreenObject.RemoveDataSet(CfpLimitedFlowDataArray);
                end;
                AnEdit.ScreenObject.RemoveDataSet(CfpWellFlowDataArray);
//                AnEdit.ScreenObject.RemoveDataSet(CfpWellConductanceDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyHeadDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyConductivityDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyLimitedInflowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpLimitedHeadDataArray);
              end;
            cbtWell:
              begin
                DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpWellFlowDataArray);
                AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                  CfpFixedHeads.FixedHead;
                AnEdit.ScreenObject.RemoveDataSet(CfpFixedHeadsDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpLimitedFlowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyHeadDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyConductivityDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyLimitedInflowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpLimitedHeadDataArray);
              end;
            cbtCauchy:
              begin
                DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpCauchyHeadDataArray);
                AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                  CfpFixedHeads.FixedHead;
                DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpCauchyConductivityDataArray);
                AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                  CfpFixedHeads.Value2;
                DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpCauchyLimitedInflowDataArray);
                AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                  CfpFixedHeads.Value3;
                AnEdit.ScreenObject.RemoveDataSet(CfpFixedHeadsDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpLimitedFlowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpWellFlowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpLimitedHeadDataArray);
              end;
            cbtLimitedHead:
              begin
                DataSetIndex := AnEdit.ScreenObject.AddDataSet(CfpLimitedHeadDataArray);
                AnEdit.ScreenObject.DataSetFormulas[DataSetIndex] :=
                  CfpFixedHeads.FixedHead;
                AnEdit.ScreenObject.RemoveDataSet(CfpFixedHeadsDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpLimitedFlowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpWellFlowDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyHeadDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyConductivityDataArray);
                AnEdit.ScreenObject.RemoveDataSet(CfpCauchyLimitedInflowDataArray);
              end;
            else
              Assert(False);
          end;
        end;
      end
      else
      begin
        AnEdit.ScreenObject.RemoveDataSet(CfpBoundaryTypeDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpFixedHeadsDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpLimitedFlowDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpWellFlowDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpCauchyHeadDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpCauchyConductivityDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpCauchyLimitedInflowDataArray);
        AnEdit.ScreenObject.RemoveDataSet(CfpLimitedHeadDataArray);
      end;
    end;

  end;

  if FCRCH_Node <> nil then
  begin
    frameCfpRechargeFraction1.SetData(FNewProperties,
      (FCRCH_Node.StateIndex = 2),
      (FCRCH_Node.StateIndex = 1)
        and frmGoPhast.PhastModel.CfpRechargeIsSelected(nil));
  end;

  if FSubPestObs_Node <> nil then
  begin
    ScreenObject := FNewProperties[0].ScreenObject;
    framePestObsSub.SetData(ScreenObject.ModflowSubObservations,
      ScreenObject.Name);
  end;

  if FSwtPestObs_Node <> nil then
  begin
    ScreenObject := FNewProperties[0].ScreenObject;
    framePestObsSwt.SetData(ScreenObject.ModflowSwtObservations,
      ScreenObject.Name);
  end;

  if FSutraStateObsNode <> nil then
  begin
    ScreenObject := FNewProperties[0].ScreenObject;
    frameSutraPestObsState.SetData(
      ScreenObject.SutraBoundaries.SutraStateObs, ScreenObject.Name);
  end;

  frameScreenObjectFootprintWell.SetData(FNewProperties);

  if (FGwtCnc_Node <> nil) then
  begin
    frameGwtCnc.SetData(FNewProperties,
      (FGwtCnc_Node.StateIndex = 2),
      (FGwtCnc_Node.StateIndex = 1) and frmGoPhast.PhastModel.GwtCncIsSelected);
  end;

  if (FGwtSrc_Node <> nil) then
  begin
    frameGwtSrc.SetData(FNewProperties,
      (FGwtSrc_Node.StateIndex = 2),
      (FGwtSrc_Node.StateIndex = 1) and frmGoPhast.PhastModel.GwtSrcIsSelected);
  end;

  if (FFmp4EfficiencyNode <> nil) then
  begin
    frameFmp4Efficiency.SetData(FNewProperties,
      (FFmp4EfficiencyNode.StateIndex = 2),
      (FFmp4EfficiencyNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientEfficiencyArrayIsSelected);
  end;

  if (FFmp4EfficiencyImprovementNode <> nil) then
  begin
    frameFmp4EfficiencyImprovement.SetData(FNewProperties,
      (FFmp4EfficiencyImprovementNode.StateIndex = 2),
      (FFmp4EfficiencyImprovementNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientEfficiencyImprovementArrayIsSelected);
  end;

  if (FFmp4BareRunoffFractionNode <> nil) then
  begin
    frameFmp4BareRunoffFraction.SetData(FNewProperties,
      (FFmp4BareRunoffFractionNode.StateIndex = 2),
      (FFmp4BareRunoffFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientBareRunoffFractionArrayIsSelected);
  end;

  if (FFmp4BarePrecipitationConsumptionFractionNode <> nil) then
  begin
    frameFmp4BarePrecipitationConsumptionFraction.SetData(FNewProperties,
      (FFmp4BarePrecipitationConsumptionFractionNode.StateIndex = 2),
      (FFmp4BarePrecipitationConsumptionFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected);
  end;

  if (FFmp4BareEvapNode <> nil) then
  begin
    frameFmp4BareEvap.SetData(FNewProperties,
      (FFmp4BareEvapNode.StateIndex = 2),
      (FFmp4BareEvapNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientBareEvapArrayIsSelected);
  end;

  if (FFmp4DirectRechargeNode <> nil) then
  begin
    frameFmp4DirectRecharge.SetData(FNewProperties,
      (FFmp4DirectRechargeNode.StateIndex = 2),
      (FFmp4DirectRechargeNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientDirectRechargeArrayIsSelected);
  end;

  if (FFmp4PrecipPotConsumptionNode <> nil) then
  begin
    frameFmp4PrecipPotConsumption.SetData(FNewProperties,
      (FFmp4PrecipPotConsumptionNode.StateIndex = 2),
      (FFmp4PrecipPotConsumptionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientPrecipPotConsumptionArrayIsSelected);
  end;

  if (FFmp4NrdInfilLocationNode <> nil) then
  begin
    frameFmp4NrdInfilLocation.SetData(FNewProperties,
      (FFmp4NrdInfilLocationNode.StateIndex = 2),
      (FFmp4NrdInfilLocationNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientNrdInfilLocIsSelected);
  end;

  if (FFmp4LandUseAreaFractionNode <> nil) then
  begin
    frameFmp4LandUseAreaFraction.SetData(FNewProperties,
      (FFmp4LandUseAreaFractionNode.StateIndex = 2),
      (FFmp4LandUseAreaFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientLandUseAreaFractionIsSelected);
  end;

  if (FFmp4MultLandUseAreaFractionNode <> nil) then
  begin
    frameMultLandUseAreaFraction.SetData(FNewProperties,
      (FFmp4MultLandUseAreaFractionNode.StateIndex = 2),
      (FFmp4MultLandUseAreaFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientLandUseAreaFractionMultIsSelected);
  end;

  if (FFmp4CropCoefficientNode <> nil) then
  begin
    frameFmp4CropCoefficient.SetData(FNewProperties,
      (FFmp4CropCoefficientNode.StateIndex = 2),
      (FFmp4CropCoefficientNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientCropCoefficientIsSelected);
  end;

  if (FFmp4MultCropCoefficientNode <> nil) then
  begin
    frameFmp4MultCropCoefficients.SetData(FNewProperties,
      (FFmp4MultCropCoefficientNode.StateIndex = 2),
      (FFmp4MultCropCoefficientNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientCropCoefficientMultIsSelected);
  end;

  if (FFmp4ConsumptiveUseNode <> nil) then
  begin
    frameFmp4ConsumptiveUse.SetData(FNewProperties,
      (FFmp4ConsumptiveUseNode.StateIndex = 2),
      (FFmp4ConsumptiveUseNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientConsumptiveUseIsSelected);
  end;

  if (FFmp4MultConsumptiveUseNode <> nil) then
  begin
    frameFmp4MultConsumptiveUse.SetData(FNewProperties,
      (FFmp4MultConsumptiveUseNode.StateIndex = 2),
      (FFmp4MultConsumptiveUseNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientConsumptiveUseMultIsSelected);
  end;

  if (FFmp4IrrigationNode <> nil) then
  begin
    frameFmp4Irrigation.SetData(FNewProperties,
      (FFmp4IrrigationNode.StateIndex = 2),
      (FFmp4IrrigationNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientIrrigationIsSelected);
  end;

  if (FFmp4MultIrrigationNode <> nil) then
  begin
    frameFmp4MultIrrigation.SetData(FNewProperties,
      (FFmp4MultIrrigationNode.StateIndex = 2),
      (FFmp4MultIrrigationNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientIrrigationMultIsSelected);
  end;

  if (FFmp4RootDepthNode <> nil) then
  begin
    frameFmp4RootDepth.SetData(FNewProperties,
      (FFmp4RootDepthNode.StateIndex = 2),
      (FFmp4RootDepthNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientRootDepthIsSelected);
  end;

  if (FFmp4MultRootDepthNode <> nil) then
  begin
    frameFmp4MultRootDepth.SetData(FNewProperties,
      (FFmp4MultRootDepthNode.StateIndex = 2),
      (FFmp4MultRootDepthNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientRootDepthMultIsSelected);
  end;

  if (FFmp4TranspirationFractionNode <> nil) then
  begin
    frameFmp4TranspirationFraction.SetData(FNewProperties,
      (FFmp4TranspirationFractionNode.StateIndex = 2),
      (FFmp4TranspirationFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientTranspirationFractionIsSelected);
  end;

  if (FFmp4MultTranspirationFractionNode <> nil) then
  begin
    frameFmp4MultTranspirationFraction.SetData(FNewProperties,
      (FFmp4MultTranspirationFractionNode.StateIndex = 2),
      (FFmp4MultTranspirationFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientTranspirationFractionMultIsSelected);
  end;

  if (FFmp4EvaporationIrrigationFractionNode <> nil) then
  begin
    frameFmp4EvaporationIrrigationFraction.SetData(FNewProperties,
      (FFmp4EvaporationIrrigationFractionNode.StateIndex = 2),
      (FFmp4EvaporationIrrigationFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientEvaporationIrrigationFractionIsSelected);
  end;

  if (FFmp4MultEvaporationIrrigationFractionNode <> nil) then
  begin
    frameFmp4MultEvaporationIrrigationFraction.SetData(FNewProperties,
      (FFmp4MultEvaporationIrrigationFractionNode.StateIndex = 2),
      (FFmp4MultEvaporationIrrigationFractionNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected);
  end;

  if (FFmp4FractionOfPrecipToSurfaceWaterNode <> nil) then
  begin
    frameFmp4FractionOfPrecipToSurfaceWater.SetData(FNewProperties,
      (FFmp4FractionOfPrecipToSurfaceWaterNode.StateIndex = 2),
      (FFmp4FractionOfPrecipToSurfaceWaterNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected);
  end;

  if (FFmp4MultFractionOfPrecipToSurfaceWaterNode <> nil) then
  begin
    frameFmp4MultFractionOfPrecipToSurfaceWater.SetData(FNewProperties,
      (FFmp4MultFractionOfPrecipToSurfaceWaterNode.StateIndex = 2),
      (FFmp4MultFractionOfPrecipToSurfaceWaterNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected);
  end;

  if (FFmp4FractionOfIrrigToSurfaceWaterNode <> nil) then
  begin
    frameFmp4FractionOfIrrigToSurfaceWater.SetData(FNewProperties,
      (FFmp4FractionOfIrrigToSurfaceWaterNode.StateIndex = 2),
      (FFmp4FractionOfIrrigToSurfaceWaterNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected);
  end;

  if (FFmp4MultFractionOfIrrigToSurfaceWaterNode <> nil) then
  begin
    frameFmp4MultFractionOfIrrigToSurfaceWater.SetData(FNewProperties,
      (FFmp4MultFractionOfIrrigToSurfaceWaterNode.StateIndex = 2),
      (FFmp4MultFractionOfIrrigToSurfaceWaterNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected);
  end;

  if (FFmp4AddedDemandNode <> nil) then
  begin
    frameFmp4AddedDemand.SetData(FNewProperties,
      (FFmp4AddedDemandNode.StateIndex = 2),
      (FFmp4AddedDemandNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandIsSelected);
  end;

  if (FFmp4MultAddedDemandNode <> nil) then
  begin
    frameFmp4MultAddedDemand.SetData(FNewProperties,
      (FFmp4MultAddedDemandNode.StateIndex = 2),
      (FFmp4MultAddedDemandNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandMultIsSelected);
  end;

  if (FFmp4CropHasSalinityDemandNode <> nil) then
  begin
    frameFmp4CropHasSalinityDemand.SetData(FNewProperties,
      (FFmp4CropHasSalinityDemandNode.StateIndex = 2),
      (FFmp4CropHasSalinityDemandNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientCropHasSalinityDemandIsSelected);
  end;

  if (FFmp4MultCropHasSalinityDemandNode <> nil) then
  begin
    frameFmp4MultCropHasSalinityDemand.SetData(FNewProperties,
      (FFmp4MultCropHasSalinityDemandNode.StateIndex = 2),
      (FFmp4MultCropHasSalinityDemandNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientCropHasSalinityDemandMultIsSelected);
  end;

  if (FFmp4AddedDemandRunoffSplitNode <> nil) then
  begin
    frameFmp4AddedDemandRunoffSplit.SetData(FNewProperties,
      (FFmp4AddedDemandRunoffSplitNode.StateIndex = 2),
      (FFmp4AddedDemandRunoffSplitNode.StateIndex = 1)
      and frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected);
  end;

  if (FTvkNode <> nil) then
  begin
    frameScreenObjectTvk.SetData(FNewProperties,
      (FTvkNode.StateIndex = 2),
      (FTvkNode.StateIndex = 1) and frmGoPhast.PhastModel.TvkIsSelected);
  end;

  if (FTvsNode <> nil) then
  begin
    frameScreenObjectTvs.SetData(FNewProperties,
      (FTvsNode.StateIndex = 2),
      (FTvsNode.StateIndex = 1) and frmGoPhast.PhastModel.TvsIsSelected);
  end;

end;

procedure TfrmScreenObjectProperties.UpdateVertices;
var
  Item: TScreenObjectEditItem;
  RowIndex: Integer;
  AnotherPoint: TPoint2D;
begin
  FCanSetPointsOutOfDate := True;
  InvalidateAllDataSets;
  if IsLoaded then
  begin
    dgVerticies.Invalidate;
    if CanSetPoints then
    begin
      if FNewProperties.Count <> 1 then
      begin
        Beep;
        MessageDlg(StrIfMoreThanOneObj, mtError, [mbOK], 0);
        Exit;
      end;
      Assert(FNewProperties.Count = 1);
      Item := FNewProperties[0];
      Item.ScreenObject.SectionStarts.Clear;
      Item.ScreenObject.ClearPoints;
      for RowIndex := 1 to dgVerticies.RowCount - 1 do
      begin
        if not AssignPoint(RowIndex, AnotherPoint) then
        begin
          Continue;
        end;
        Item.ScreenObject.AddPoint(AnotherPoint, dgVerticies.Checked[Ord(vcNewSection), RowIndex]);
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetGageNodeStateIndex;
begin
  if FGage_Node = nil then
  begin
    Exit;
  end;
  if (cbGageStandard.State = cbUnchecked)
    and (cbGage1.State = cbUnchecked)
    and (cbGage2.State = cbUnchecked)
    and (cbGage3.State = cbUnchecked)
    and (cbGage5.State = cbUnchecked)
    and (cbGage6.State = cbUnchecked)
    and (cbGage7.State = cbUnchecked) then
  begin
    FGage_Node.StateIndex := 1;
  end
  else if (cbGageStandard.State = cbChecked)
    or (cbGage1.State = cbChecked)
    or (cbGage2.State = cbChecked)
    or (cbGage3.State = cbChecked)
    or (cbGage5.State = cbChecked)
    or (cbGage6.State = cbChecked)
    or (cbGage7.State = cbChecked) then
  begin
    FGage_Node.StateIndex := 2;
  end
  else
  begin
    FGage_Node.StateIndex := 3;
  end;
end;

procedure TfrmScreenObjectProperties.SetGages(
  Collection: TScreenObjectEditCollection);
var
  List: TList;
  index: Integer;
begin
  List := TList.Create;
  try
    for index := 0 to Collection.Count - 1 do
    begin
      List.Add(Collection[index].ScreenObject)
    end;
    SetGages(List);
  finally
    List.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetFluxObservations(const AScreenObjectList: TList);
begin
  GetHeadFluxObservations(AScreenObjectList);
  GetDrainFluxObservations(AScreenObjectList);
  GetGhbFluxObservations(AScreenObjectList);
  GetRiverFluxObservations(AScreenObjectList);
  GetStreamFluxObservations(AScreenObjectList);
  GetMt3dmsFluxObservations(AScreenObjectList);
end;

procedure TfrmScreenObjectProperties.GetFluxObservationsForFrame(
  Node: TJvPageIndexNode; FluxObservations: TCustomSutraFluxObservationGroups;
  const AScreenObjectList: TList; FluxFrame: TframeFluxObs);
var
  UsedObjectCount: Integer;
begin
  FluxFrame.InitializeControls;
  UsedObjectCount := FluxFrame.GetData(AScreenObjectList, FluxObservations);
  if Node = nil then
  begin
    Exit;
  end;
  if UsedObjectCount = 0 then
  begin
    Node.StateIndex := 1;
  end
  else if UsedObjectCount = AScreenObjectList.Count then
  begin
    Node.StateIndex := 2;
  end
  else
  begin
    Node.StateIndex := 3;
  end;
end;

procedure TfrmScreenObjectProperties.GetNearestDiversionSegment(
  var NewText: string; ParameterType: TParameterType);
var
  TestScreenObject: TScreenObject;
  InFlowLocation: TPoint2D;
  NearestStream: TScreenObject;
  Dist: Double;
  Index: Integer;
  AScreenObject: TScreenObject;
  TestLocation: TPoint2D;
  TestDist: Double;
  NearestLake: TScreenObject;
  SectionIndex: Integer;
begin
  if FScreenObject = nil then
  begin
    if FScreenObjectList.Count <> 1 then
    begin
      Beep;
      MessageDlg(StrSorryThisFunction, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FScreenObjectList.Count = 1);
    TestScreenObject := FScreenObjectList[0];
  end
  else
  begin
    TestScreenObject := FScreenObject;
  end;
  Assert(TestScreenObject <> nil);
  InFlowLocation := TestScreenObject.Points[0];
  Dist := 0;
  if ParameterType = ptSFR then
  begin
    NearestStream := nil;
    for Index := 0 to frmGoPhast.PhastModel.ScreenObjectCount - 1 do
    begin
      AScreenObject := frmGoPhast.PhastModel.ScreenObjects[Index];
      if (AScreenObject <> TestScreenObject)
        and (AScreenObject.ModflowSfrBoundary <> nil)
        and AScreenObject.ModflowSfrBoundary.Used then
      begin
        TestLocation := AScreenObject.Points[AScreenObject.Count - 1];
        if NearestStream = nil then
        begin
          NearestStream := AScreenObject;
          Dist := Distance(TestLocation, InFlowLocation);
        end
        else
        begin
          TestDist := Distance(TestLocation, InFlowLocation);
          if TestDist < Dist then
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end;
      end;
    end;
    NearestLake := nil;
    if frmGoPhast.PhastModel.LakIsSelected then
    begin
      for Index := 0 to frmGoPhast.PhastModel.ScreenObjectCount - 1 do
      begin
        AScreenObject := frmGoPhast.PhastModel.ScreenObjects[Index];
        if (AScreenObject <> TestScreenObject)
           and (AScreenObject.ModflowLakBoundary <> nil)
           and AScreenObject.ModflowLakBoundary.Used then
        begin
          TestDist := AScreenObject.DistanceToScreenObject(
            InFlowLocation, TestLocation, 1, SectionIndex);
          if (NearestStream = nil) or (TestDist < Dist) then
          begin
            Dist := TestDist;
            NearestLake := AScreenObject;
          end;
        end;
      end;
    end;
    NewText := '';
    if NearestLake = nil then
    begin
      if (NearestStream = nil)  then
      begin
        Beep;
        MessageDlg(StrThereIsNoOtherSt, mtInformation, [mbOK], 0);
      end
      else
      begin
        Assert(NearestStream.ModflowSfrBoundary <> nil);
        NewText := IntToStr(NearestStream.ModflowSfrBoundary.SegmentNumber);
      end;
    end
    else
    begin
      Assert(NearestLake.ModflowLakBoundary <> nil);
      NewText := IntToStr(-NearestLake.ModflowLakBoundary.LakeID);
    end;
  end
  else
  begin
    Assert(ParameterType = ptSTR);
    NearestStream := nil;
    for Index := 0 to frmGoPhast.PhastModel.ScreenObjectCount - 1 do
    begin
      AScreenObject := frmGoPhast.PhastModel.ScreenObjects[Index];
      if (AScreenObject <> TestScreenObject)
        and (AScreenObject.ModflowStrBoundary <> nil)
        and AScreenObject.ModflowStrBoundary.Used then
      begin
        TestLocation := AScreenObject.Points[AScreenObject.Count - 1];
        if NearestStream = nil then
        begin
          NearestStream := AScreenObject;
          Dist := Distance(TestLocation, InFlowLocation);
        end
        else
        begin
          TestDist := Distance(TestLocation, InFlowLocation);
          if TestDist < Dist then
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end;
      end;
    end;
    if (NearestStream = nil)  then
    begin
      Beep;
      MessageDlg(StrThereIsNoOtherSteam, mtInformation, [mbOK], 0);
    end
    else
    begin
      Assert(NearestStream.ModflowStrBoundary <> nil);
      NewText := IntToStr(NearestStream.ModflowStrBoundary.SegmentNumber);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetNearestOutflowSegment(
  var NewText: string; ParameterType: TParameterType);
var
  NearestStream: TScreenObject;
  NearestLake: TScreenObject;
  TestScreenObject: TScreenObject;
begin
  if FScreenObject = nil then
  begin
    if FScreenObjectList.Count <> 1 then
    begin
      Beep;
      MessageDlg(StrSorryThisFunction + sLineBreak + StrTryModelLinkStre, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FScreenObjectList.Count = 1);
    TestScreenObject := FScreenObjectList[0];
  end
  else
  begin
    TestScreenObject := FScreenObject;
  end;
  Assert(TestScreenObject <> nil);
  NewText := '';
  if ParameterType = ptSFR then
  begin
    frmGoPhast.PhastModel.LocateNearestLakeOrStream(TestScreenObject,
      NearestLake, NearestStream);
    if (NearestStream = nil) and (NearestLake = nil) then
    begin
      Beep;
      MessageDlg(StrThereIsNoOtherSt, mtInformation, [mbOK], 0);
    end
    else
    begin
      if NearestLake = nil then
      begin
        Assert(NearestStream.ModflowSfrBoundary <> nil);
        NewText := IntToStr(NearestStream.ModflowSfrBoundary.SegmentNumber);
      end
      else
      begin
        Assert(NearestLake.ModflowLakBoundary <> nil);
        NewText := IntToStr(-NearestLake.ModflowLakBoundary.LakeID);
      end;
    end;
  end
  else if (ParameterType = ptSTR) then
  begin
//    Assert(ParameterType = ptSTR);
    frmGoPhast.PhastModel.LocateNearestStrStream(TestScreenObject,
      NearestStream);
    if (NearestStream = nil)  then
    begin
      Beep;
      MessageDlg(StrThereIsNoOtherSteam, mtInformation, [mbOK], 0);
    end
    else
    begin
      Assert(NearestStream.ModflowStrBoundary <> nil);
      NewText := IntToStr(NearestStream.ModflowStrBoundary.SegmentNumber);
    end;
  end
  else
  begin
    Assert(ParameterType = ptUndefined);
    frmGoPhast.PhastModel.LocateNearestSfrMf6Stream(TestScreenObject,
      NearestStream);
    if (NearestStream = nil)  then
    begin
      Beep;
      MessageDlg(StrThereIsNoOtherSteam, mtInformation, [mbOK], 0);
    end
    else
    begin
      Assert(NearestStream.ModflowSfr6Boundary <> nil);
      NewText := IntToStr(NearestStream.ModflowSfr6Boundary.SegmentNumber);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetGages(List: TList);
var
  Index: Integer;
  ScreenObject: TScreenObject;
  Gage: TStreamGage;
begin
  if tabGageObservations.TabVisible then
  begin
    ScreenObject := List[0];
    Gage := ScreenObject.ModflowStreamGage;
    if frameGagePestObs.frameObservations.seNumber.AsInteger > 0 then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      frameGagePestObs.SetData(Gage.Observations, ScreenObject.Name);
    end;
  end;

  for Index := 0 to List.Count - 1 do
  begin
    ScreenObject := List[Index];
    Gage := ScreenObject.ModflowStreamGage;
    if (cbGageStandard.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage0 := True;
    end
    else if (Gage <> nil)
      and (cbGageStandard.State = cbUnchecked) then
    begin
      Gage.Gage0 := False;
    end;

    if (cbGage1.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage1 := True;
    end
    else if (Gage <> nil)
      and (cbGage1.State = cbUnchecked) then
    begin
      Gage.Gage1 := False;
    end;

    if (cbGage2.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage2 := True;
    end
    else if (Gage <> nil)
      and (cbGage2.State = cbUnchecked) then
    begin
      Gage.Gage2 := False;
    end;

    if (cbGage3.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage3 := True;
    end
    else if (Gage <> nil)
      and (cbGage3.State = cbUnchecked) then
    begin
      Gage.Gage3 := False;
    end;

    if Gage <> nil then
    begin
      if Gage.Observations.Count > 0 then
      begin
        Gage.Gage0 := True;
        Gage.Gage1 := True;
        Gage.Gage2 := True;
        Gage.Gage3 := True;
      end;
    end;

    if (cbGage5.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage5 := True;
    end
    else if (Gage <> nil)
      and (cbGage5.State = cbUnchecked) then
    begin
      Gage.Gage5 := False;
    end;

    if (cbGage6.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage6 := True;
    end
    else if (Gage <> nil)
      and (cbGage6.State = cbUnchecked) then
    begin
      Gage.Gage6 := False;
    end;

    if (cbGage7.State = cbChecked) then
    begin
      if Gage = nil then
      begin
        ScreenObject.CreateGagBoundary;
        Gage := ScreenObject.ModflowStreamGage;
      end;
      Gage.Gage7 := True;
    end
    else if (Gage <> nil)
      and (cbGage7.State = cbUnchecked) then
    begin
      Gage.Gage7 := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetAllFluxObservations(List: TList);
begin
  SetFluxObservations(List, FChob_Node, frameCHOB, frmGoPhast.PhastModel.HeadFluxObservations);
  SetFluxObservations(List, FDrob_Node, frameDROB, frmGoPhast.PhastModel.DrainObservations);
  SetFluxObservations(List, FGbob_Node, frameGBOB, frmGoPhast.PhastModel.GhbObservations);
  SetFluxObservations(List, FRvob_Node, frameRVOB, frmGoPhast.PhastModel.RiverObservations);
  SetFluxObservations(List, FStob_Node, frameSTOB, frmGoPhast.PhastModel.StreamObservations);
  SetMt3dFluxObs(List);

  SetFluxObservations(List, FSutraSpecPresObs_Node, frameSutraSpecPresObs,
    frmGoPhast.PhastModel.SutraFluxObs.SpecPres);
  SetFluxObservations(List, FSutraSpecFluidFlowObs_Node, frameSutraSpecifiedFluidFlowObs,
    frmGoPhast.PhastModel.SutraFluxObs.FluidFlow);
  SetFluxObservations(List, FSutraSpecConcObs_Node, frameSutraSpecUObs,
    frmGoPhast.PhastModel.SutraFluxObs.SpecConc);
  SetFluxObservations(List, FSutraGenFlowObs_Node, frameSutraGenFlowObs,
    frmGoPhast.PhastModel.SutraFluxObs.GenFlow);
  SetFluxObservations(List, FSutraGenTransObs_Node, frameSutraGenTransObs,
    frmGoPhast.PhastModel.SutraFluxObs.GenTrans);
end;

procedure TfrmScreenObjectProperties.SetMt3dFluxObs(List: TList);
var
  ObsList: TMt3dFluxGroupList;
  CheckState: TCheckBoxState;
begin
  if FMt3dmsTobFlux_Node = nil then
  begin
    Exit;
  end;
  ObsList := TMt3dFluxGroupList.Create;
  try
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsHeadMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsWellMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsDrnMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsRivMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsGhbMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsRchMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsEvtMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsMassLoadingMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsResMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsLakMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsDrtMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsEtsMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsStrMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsFhbHeadMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsFhbFlowMassFluxObservations);

    Assert(FMt3dmsTobFlux_Node.StateIndex in [1, 2, 3]);
    CheckState := TCheckBoxState(FMt3dmsTobFlux_Node.StateIndex - 1);
    frameMt3dmsFluxObs.SetData(List, ObsList, CheckState);
  finally
    ObsList.Free;
  end;

end;

procedure TfrmScreenObjectProperties.SetFluxObservations(List: TList;
   ANode: TJvPageIndexNode;
  AFrame: TframeFluxObs; FluxObservations: TFluxObservationGroups);
var
  CheckState: TCheckBoxState;
begin
  if ANode <> nil then
  begin
    Assert(ANode.StateIndex in [1, 2, 3]);
    CheckState := TCheckBoxState(ANode.StateIndex - 1);
    AFrame.SetData(List, FluxObservations, CheckState);
  end;
end;

procedure TfrmScreenObjectProperties.CreateFhbHeadNode;
var
  Node: TJvPageIndexNode;
begin
  FFhbHead_Node := nil;
  if frmGoPhast.PhastModel.FhbIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Heads in ' +
      frmGoPhast.PhastModel.ModflowPackages.FhbPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspFhbHeads.PageIndex;
    frameFhbHead.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFhbHead_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFluxNode(
  var NewNode: TJvPageIndexNode; Caption: string;
  AFrame: TframeFluxObs; APage: TJvStandardPage;
  FluxObservations: TCustomSutraFluxObservationGroups);
begin
  NewNode := nil;
  if (frmGoPhast.ModelSelection in  SutraSelection)
    and (frmGoPhast.PhastModel.PestStatus in [psObservations, psActive])
    and (rgEvaluatedAt.ItemIndex = 1)
    and (FluxObservations.Count > 0) then
  begin
    NewNode := jvpltvSutraFeatures.Items.AddChild(
      nil, Caption) as TJvPageIndexNode;
    NewNode.PageIndex := APage.PageIndex;
    AFrame.lblFluxObservations.Caption := NewNode.Text;
    NewNode.ImageIndex := 1;
    NewNode.StateIndex := Ord(AFrame.FrameCheckState) + 1;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFhbFlowNode;
var
  Node: TJvPageIndexNode;
begin
  FFhbFlow_Node := nil;
  if frmGoPhast.PhastModel.FhbIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Flows in ' +
      frmGoPhast.PhastModel.ModflowPackages.FhbPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspFhbFlows.PageIndex;
    frameFhbFlow.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFhbFlow_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFluxNode(
  var NewNode: TJvPageIndexNode; FluxPackage: TModflowPackageSelection;
  AFrame: TframeFluxObs; APage: TJvStandardPage;
  FluxObservations: TFluxObservationGroups);
begin
  NewNode := nil;
  if frmGoPhast.PhastModel.PackageIsSelected(FluxPackage)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    NewNode := jvtlModflowBoundaryNavigator.Items.AddChild(
      nil, FluxPackage.PackageIdentifier) as TJvPageIndexNode;
    NewNode.PageIndex := APage.PageIndex;
    AFrame.lblFluxObservations.Caption := NewNode.Text;
    NewNode.ImageIndex := 1;
//    NewNode.StateIndex := Ord(AFrame.FrameCheckState)+1;
  end;
end;

procedure TfrmScreenObjectProperties.GetHeadFluxObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FChob_Node, frmGoPhast.PhastModel.HeadFluxObservations,
    AScreenObjectList, frameCHOB);
end;

procedure TfrmScreenObjectProperties.GetDrainFluxObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FDrob_Node, frmGoPhast.PhastModel.DrainObservations,
    AScreenObjectList, frameDROB);
end;

procedure TfrmScreenObjectProperties.GetGhbFluxObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FGbob_Node, frmGoPhast.PhastModel.GhbObservations,
    AScreenObjectList, frameGBOB);
end;

procedure TfrmScreenObjectProperties.GetRiverFluxObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FRvob_Node, frmGoPhast.PhastModel.RiverObservations,
    AScreenObjectList, frameRvOB);
end;

procedure TfrmScreenObjectProperties.GetStreamFluxObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FStob_Node, frmGoPhast.PhastModel.StreamObservations,
    AScreenObjectList, frameSTOB);
end;

procedure TfrmScreenObjectProperties.GetSubObs(ListOfScreenObjects: TList);
var
  ScreenObject: TScreenObject;
begin
  if (ListOfScreenObjects.Count = 1) then
  begin
    if (FSubPestObs_Node <> nil) then
    begin
      ScreenObject := ListOfScreenObjects[0];
      framePestObsSub.GetData(ScreenObject.ModflowSubObservations);
      if ScreenObject.ModflowSubObservations = nil then
      begin
        FSubPestObs_Node.StateIndex := 1;
      end
      else
      begin
        FSubPestObs_Node.StateIndex := 2;
      end;
    end;
  end
  else
  begin
    FreeAndNil(FSubPestObs_Node);
    if jvplModflowBoundaries.ActivePage = jvspSubPestObs then
    begin
      jvplModflowBoundaries.ActivePage := jvspBlank;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetSutraSpecPresObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FSutraSpecPresObs_Node,
    frmGoPhast.PhastModel.SutraFluxObs.SpecPres,
    AScreenObjectList, frameSutraSpecPresObs);
end;

procedure TfrmScreenObjectProperties.GetSutraGenPresObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FSutraGenFlowObs_Node,
    frmGoPhast.PhastModel.SutraFluxObs.GenFlow,
    AScreenObjectList, frameSutraGenFlowObs);
end;

procedure TfrmScreenObjectProperties.GetSutraGenTransObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FSutraGenTransObs_Node,
    frmGoPhast.PhastModel.SutraFluxObs.GenTrans,
    AScreenObjectList, frameSutraGenTransObs);
end;

procedure TfrmScreenObjectProperties.GetSutraObservations(
  const AScreenObjectList: TList);
begin
  GetSutraSpecPresObservations(AScreenObjectList);
  GetSutraSpecFlowObservations(AScreenObjectList);
  GetSutraSpecConcObservations(AScreenObjectList);
  GetSutraGenPresObservations(AScreenObjectList);
  GetSutraGenTransObservations(AScreenObjectList);
end;

procedure TfrmScreenObjectProperties.GetSutraSpecConcObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FSutraSpecConcObs_Node,
    frmGoPhast.PhastModel.SutraFluxObs.SpecConc,
    AScreenObjectList, frameSutraSpecUObs);
end;

procedure TfrmScreenObjectProperties.GetSutraSpecFlowObservations(
  const AScreenObjectList: TList);
begin
  GetFluxObservationsForFrame(FSutraSpecFluidFlowObs_Node,
    frmGoPhast.PhastModel.SutraFluxObs.FluidFlow,
    AScreenObjectList, frameSutraSpecifiedFluidFlowObs);
end;

procedure TfrmScreenObjectProperties.GetSwrEvapBoundary(
  ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwrEvapBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
  Frame: TframeScreenObjectNoParam;
  First: Boolean;
  Identical: Boolean;
  Method: TPestParamMethod;
  Modifier: string;
begin
  if not frmGoPhast.PhastModel.SwrIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrEvap;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FSWR_Evap_Node <> nil then
    begin
      FSWR_Evap_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrEvap;
      // get all the times associated with the boundary.
      if Boundary <> nil then
      begin
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;

      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.

    frameSWR_Evap.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameSWR_Evap.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + PestRowOffset + 1] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + PestRowOffset + 1] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetSwrEvapBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

      Frame := frameSWR_Evap;
      Frame.PestMethod[ColumnOffset] :=
        TCustomSwrBoundary.DefaultBoundaryMethod(SwrValuePosition);
      First := True;
      Identical := True;
      Method := ppmMultiply;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowSwrEvap;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Method := Boundary.PestBoundaryMethod[SwrValuePosition];
            First := False;
          end
          else
          begin
            Identical := Method = Boundary.PestBoundaryMethod[SwrValuePosition];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;
      if Identical then
      begin
        Frame.PestMethod[ ColumnOffset] := Method;
      end
      else
      begin
        Frame.PestMethodAssigned[ColumnOffset] := False;
      end;

      Modifier := '';
      First := True;
      Identical := True;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowSwrEvap;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Modifier := Boundary.PestBoundaryFormula[SwrValuePosition];
            First := False;
          end
          else
          begin
            Identical := Modifier = Boundary.PestBoundaryFormula[SwrValuePosition];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;

      if Identical then
      begin
        Frame.PestModifier[ColumnOffset] := Modifier;
      end
      else
      begin
        Frame.PestModifierAssigned[ColumnOffset] := False;
      end;
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrLatInflowBoundary(
  ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwrLatInflowBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
  First: Boolean;
  Identical: Boolean;
  Method: TPestParamMethod;
  Modifier: string;
  Frame: TframeScreenObjectSwr;
begin
  if not frmGoPhast.PhastModel.SwrIsSelected then
  begin
    Exit;
  end;
  frameSWR_LatInfl.comboFormulaInterp.Enabled :=
    frmGoPhast.PhastModel.ModflowPackages.
    SwrPackage.LateralInflowSpecification = smObject;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrLatInflow;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FSWR_LatInflow_Node <> nil then
    begin
      FSWR_LatInflow_Node.StateIndex := Ord(State)+1;
    end;
    First := True;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrLatInflow;
      // get all the times associated with the boundary.
      if Boundary <> nil then
      begin
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;

        if First then
        begin
          frameSWR_LatInfl.comboFormulaInterp.ItemIndex :=
            Ord(Boundary.FormulaInterpretation);
          First := False;
        end
        else
        begin
          if frameSWR_LatInfl.comboFormulaInterp.ItemIndex <>
            Ord(Boundary.FormulaInterpretation) then
          begin
            frameSWR_LatInfl.comboFormulaInterp.ItemIndex := -1;
          end;
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.

    frameSWR_LatInfl.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameSWR_LatInfl.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + PestRowOffset + 1] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + PestRowOffset + 1] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetSwrLatInflowBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

      Frame := frameSWR_LatInfl;
      Frame.PestMethod[ColumnOffset] :=
        TCustomSwrBoundary.DefaultBoundaryMethod(SwrValuePosition);
      First := True;
      Identical := True;
      Method := ppmMultiply;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowSwrLatInflow;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Method := Boundary.PestBoundaryMethod[SwrValuePosition];
            First := False;
          end
          else
          begin
            Identical := Method = Boundary.PestBoundaryMethod[SwrValuePosition];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;
      if Identical then
      begin
        Frame.PestMethod[ ColumnOffset] := Method;
      end
      else
      begin
        Frame.PestMethodAssigned[ColumnOffset] := False;
      end;

      Modifier := '';
      First := True;
      Identical := True;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowSwrLatInflow;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Modifier := Boundary.PestBoundaryFormula[SwrValuePosition];
            First := False;
          end
          else
          begin
            Identical := Modifier = Boundary.PestBoundaryFormula[SwrValuePosition];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;

      if Identical then
      begin
        Frame.PestModifier[ColumnOffset] := Modifier;
      end
      else
      begin
        Frame.PestModifierAssigned[ColumnOffset] := False;
      end;
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrRainBoundary(
  ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwrRainBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
  Frame: TframeScreenObjectNoParam;
  First: Boolean;
  Identical: Boolean;
  Method: TPestParamMethod;
  Modifier: string;
begin
  if not frmGoPhast.PhastModel.SwrIsSelected then
  begin
    Exit;
  end;
  ColumnOffset := 2;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrRain;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FSWR_Rain_Node <> nil then
    begin
      FSWR_Rain_Node.StateIndex := Ord(State)+1;
    end;

    Frame := frameSWR_Rain;
    Frame.PestMethod[ColumnOffset] :=
      TCustomSwrBoundary.DefaultBoundaryMethod(SwrValuePosition);
    First := True;
    Identical := True;
    Method := ppmMultiply;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrRain;
      if (Boundary <> nil) and Boundary.Used then
      begin
        if First then
        begin
          Method := Boundary.PestBoundaryMethod[SwrValuePosition];
          First := False;
        end
        else
        begin
          Identical := Method = Boundary.PestBoundaryMethod[SwrValuePosition];
          if not Identical then
          begin
            break;
          end;
        end;
      end;
    end;
    if Identical then
    begin
      Frame.PestMethod[ ColumnOffset] := Method;
    end
    else
    begin
      Frame.PestMethodAssigned[ColumnOffset] := False;
    end;

    Modifier := '';
    First := True;
    Identical := True;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrRain;
      if (Boundary <> nil) and Boundary.Used then
      begin
        if First then
        begin
          Modifier := Boundary.PestBoundaryFormula[SwrValuePosition];
          First := False;
        end
        else
        begin
          Identical := Modifier = Boundary.PestBoundaryFormula[SwrValuePosition];
          if not Identical then
          begin
            break;
          end;
        end;
      end;
    end;

    if Identical then
    begin
      Frame.PestModifier[ColumnOffset] := Modifier;
    end
    else
    begin
      Frame.PestModifierAssigned[ColumnOffset] := False;
    end;

    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrRain;
      // get all the times associated with the boundary.
      if Boundary <> nil then
      begin
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.

    frameSWR_Rain.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameSWR_Rain.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      GetSwrRainBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;


procedure TfrmScreenObjectProperties.GetSwrDirectRunoffBoundary(
  ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwrDirectRunoffBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
//  First: Boolean;
begin
  if not frmGoPhast.PhastModel.SwrIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrDirectRunoff;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FSWR_DirectRunoff_Node <> nil then
    begin
      FSWR_DirectRunoff_Node.StateIndex := Ord(State)+1;
    end;
//    First := True;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrDirectRunoff;
      // get all the times associated with the boundary.
      if Boundary <> nil then
      begin
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;

      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.

    frameSWR_DirectRunoff.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameSWR_DirectRunoff.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetSwrDirectRunoffBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrStageBoundary(
  ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwrStageBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
  First: Boolean;
  Identical: Boolean;
  Method: TPestParamMethod;
  Frame: TframeScreenObjectNoParam;
  Modifier: string;
//  First: Boolean;
begin
  if not frmGoPhast.PhastModel.SwrIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrStage;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FSWR_Stage_Node <> nil then
    begin
      FSWR_Stage_Node.StateIndex := Ord(State)+1;
    end;
//    First := True;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowSwrStage;
      // get all the times associated with the boundary.
      if Boundary <> nil then
      begin
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;

      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.

    frameSWR_Stage.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameSWR_Stage.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + PestRowOffset + 1] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + PestRowOffset + 1] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetSwrStageBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

      PestMethod[DataGrid, ColumnOffset] :=
        TSwrStageBoundary.DefaultBoundaryMethod(SwrValuePosition);

      Frame := frameSWR_Stage;
      First := True;
      Identical := True;
      Method := ppmMultiply;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowSwrStage;;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Method := Boundary.PestBoundaryMethod[SwrValuePosition];
            First := False;
          end
          else
          begin
            Identical := Method = Boundary.PestBoundaryMethod[SwrValuePosition];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;
      if Identical then
      begin
        Frame.PestMethod[ColumnOffset] := Method;
      end
      else
      begin
        Frame.PestMethodAssigned[{Frame.rdgModflowBoundary,} ColumnOffset{+BoundaryIndex}] := False;
      end;

      Modifier := '';
      First := True;
      Identical := True;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowSwrStage;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Modifier := Boundary.PestBoundaryFormula[SwrValuePosition];
            First := False;
          end
          else
          begin
            Identical := Modifier = Boundary.PestBoundaryFormula[SwrValuePosition];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;

      if Identical then
      begin
        Frame.PestModifier[ColumnOffset] := Modifier;
      end
      else
      begin
        Frame.PestModifierAssigned[ColumnOffset] := False;
      end;
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrRainBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
begin
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowSwrRain;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Boundary.Values;
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowSwrRain;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime)
        + PestRowOffset + 1;
      Assert(RowIndex >= PestRowOffset + 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrStageBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
begin
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowSwrStage;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Boundary.Values;
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowSwrStage;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime)
        + PestRowOffset + 1;
      Assert(RowIndex >= PestRowOffset + 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwtObs(ListOfScreenObjects: TList);
var
  ScreenObject: TScreenObject;
begin
  if (ListOfScreenObjects.Count = 1) then
  begin
    if (FSwtPestObs_Node <> nil) then
    begin
      ScreenObject := ListOfScreenObjects[0];
      framePestObsSwt.GetData(ScreenObject.ModflowSwtObservations);
      if ScreenObject.ModflowSwtObservations = nil then
      begin
        FSwtPestObs_Node.StateIndex := 1;
      end
      else
      begin
        FSwtPestObs_Node.StateIndex := 2;
      end;
    end;
  end
  else
  begin
    FreeAndNil(FSwtPestObs_Node);
    if jvplModflowBoundaries.ActivePage = jvspSwtPestObs then
    begin
      jvplModflowBoundaries.ActivePage := jvspBlank;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetTvkBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TTvkBoundary;
begin
  if not frmGoPhast.PhastModel.TvkIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowTvkBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FTvkNode <> nil then
  begin
    FTvkNode.StateIndex := Ord(State)+1;
  end;
  frameScreenObjectTvk.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetTvsBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TTvsBoundary;
begin
  if not frmGoPhast.PhastModel.TvsIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowTvsBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FTvsNode <> nil then
  begin
    FTvsNode.StateIndex := Ord(State)+1;
  end;
  frameScreenObjectTvs.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetSwrDirectRunoffBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
begin
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowSwrDirectRunoff;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Boundary.Values;
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowSwrDirectRunoff;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1;
      Assert(RowIndex >= 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrEvapBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
begin
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowSwrEvap;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Boundary.Values;
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowSwrEvap;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime)
        + PestRowOffset + 1;
      Assert(RowIndex >= PestRowOffset + 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetSwrLatInflowBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
begin
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowSwrLatInflow;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Boundary.Values;
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowSwrLatInflow;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime)
        + PestRowOffset + 1;
      Assert(RowIndex >= PestRowOffset + 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dmsFluxObservations(
  const AScreenObjectList: TList);
var
  ObsList: TMt3dFluxGroupList;
  UsedObjectCount: Integer;
begin
  if FMt3dmsTobFlux_Node = nil then
  begin
    Exit;
  end;
  frameMt3dmsFluxObs.InitializeControls;
  ObsList := TMt3dFluxGroupList.Create;
  try
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsHeadMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsWellMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsDrnMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsRivMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsGhbMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsRchMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsEvtMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsMassLoadingMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsResMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsLakMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsDrtMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsEtsMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsStrMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsFhbHeadMassFluxObservations);
    ObsList.Add(frmGoPhast.PhastModel.Mt3dmsFhbFlowMassFluxObservations);
    UsedObjectCount := frameMt3dmsFluxObs.GetData(AScreenObjectList, ObsList);
    if UsedObjectCount = 0 then
    begin
      FMt3dmsTobFlux_Node.StateIndex := 1;
    end
    else if UsedObjectCount = AScreenObjectList.Count then
    begin
      FMt3dmsTobFlux_Node.StateIndex := 2;
    end
    else
    begin
      FMt3dmsTobFlux_Node.StateIndex := 3;
    end;
  finally
    ObsList.Free;
  end;
end;


procedure TfrmScreenObjectProperties.GetFluxObservationsForFrame(Node: TJvPageIndexNode;
  FluxObservations: TFluxObservationGroups; const AScreenObjectList: TList;
  FluxFrame: TframeFluxObs);
var
  UsedObjectCount: Integer;
begin
  FluxFrame.InitializeControls;
  if Node = nil then
  begin
    Exit;
  end;
//  FluxFrame.InitializeControls;
  UsedObjectCount := FluxFrame.GetData(AScreenObjectList, FluxObservations);
  if UsedObjectCount = 0 then
  begin
    Node.StateIndex := 1;
  end
  else if UsedObjectCount = AScreenObjectList.Count then
  begin
    Node.StateIndex := 2;
  end
  else
  begin
    Node.StateIndex := 3;
  end;
end;

procedure TfrmScreenObjectProperties.GetGages(ListOfScreenObjects: TList);
var
  ScreenObjectIndex: Integer;
  ScreenObject: TScreenObject;
  Gage: TStreamGage;
  procedure GrayCheck(CheckBox: TCheckBox);
  begin
    if CheckBox.Checked then
    begin
      CheckBox.AllowGrayed := True;
      CheckBox.State := cbGrayed;
    end;
  end;
begin
  pcGage.ActivePageIndex := 0;
  cbGageStandard.AllowGrayed := False;
  cbGage1.AllowGrayed := False;
  cbGage2.AllowGrayed := False;
  cbGage3.AllowGrayed := False;
  cbGage5.AllowGrayed := False;
  cbGage6.AllowGrayed := False;
  cbGage7.AllowGrayed := False;
  for ScreenObjectIndex := 0 to ListOfScreenObjects.Count - 1 do
  begin
    ScreenObject := ListOfScreenObjects[ScreenObjectIndex];
    Gage := ScreenObject.ModflowStreamGage;
    if ScreenObjectIndex = 0 then
    begin
      if (Gage <> nil) and Gage.Used then
      begin
        cbGageStandard.Checked := Gage.Gage0;
        cbGage1.Checked := Gage.Gage1;
        cbGage2.Checked := Gage.Gage2;
        cbGage3.Checked := Gage.Gage3;
        cbGage5.Checked := Gage.Gage5;
        cbGage6.Checked := Gage.Gage6;
        cbGage7.Checked := Gage.Gage7;
      end
      else
      begin
        cbGageStandard.Checked := False;
        cbGage1.Checked := False;
        cbGage2.Checked := False;
        cbGage3.Checked := False;
        cbGage5.Checked := False;
        cbGage6.Checked := False;
        cbGage7.Checked := False;
      end;
    end
    else
    begin
      if (Gage <> nil) and Gage.Used then
      begin
        if cbGageStandard.Checked <> Gage.Gage0 then
        begin
          cbGageStandard.AllowGrayed := True;
          cbGageStandard.State := cbGrayed;
        end;
        if cbGage1.Checked <> Gage.Gage1 then
        begin
          cbGage1.AllowGrayed := True;
          cbGage1.State := cbGrayed;
        end;
        if cbGage2.Checked <> Gage.Gage2 then
        begin
          cbGage2.AllowGrayed := True;
          cbGage2.State := cbGrayed;
        end;
        if cbGage3.Checked <> Gage.Gage3 then
        begin
          cbGage3.AllowGrayed := True;
          cbGage3.State := cbGrayed;
        end;
        if cbGage5.Checked <> Gage.Gage5 then
        begin
          cbGage5.AllowGrayed := True;
          cbGage5.State := cbGrayed;
        end;
        if cbGage6.Checked <> Gage.Gage6 then
        begin
          cbGage6.AllowGrayed := True;
          cbGage6.State := cbGrayed;
        end;
        if cbGage7.Checked <> Gage.Gage7 then
        begin
          cbGage7.AllowGrayed := True;
          cbGage7.State := cbGrayed;
        end;
      end
      else
      begin
        GrayCheck(cbGageStandard);
        GrayCheck(cbGage1);
        GrayCheck(cbGage2);
        GrayCheck(cbGage3);
        GrayCheck(cbGage5);
        GrayCheck(cbGage6);
        GrayCheck(cbGage7);
      end;
    end;
  end;
  SetGageNodeStateIndex;

  frameGagePestObs.InitializeControls;
  frameGagePestObs.SpecifyObservationTypes(StreamGageOutputTypes);
  if ListOfScreenObjects.Count = 1 then
  begin
    ScreenObject := ListOfScreenObjects[0];
    Gage := ScreenObject.ModflowStreamGage;
    if Gage <> nil then    
    begin    
      frameGagePestObs.GetData(Gage.Observations);
    end;      
  end;
end;

procedure TfrmScreenObjectProperties.GetModpathParticles(ListOfScreenObjects: TList);
var
  Frame: TframeModpathParticles;
  Particles: TParticleStorage;
  GridParticles: TGridDistribution;
  CylParticles: TCylSphereDistribution;
  SphereParticles: TCylSphereDistribution;
  CustomParticles: TParticles;
  Index: Integer;
  Item: TParticleLocation;
  ScreenObject : TScreenObject;
  ScreenObjectIndex: Integer;
  UsedDistribution: Set of TParticleDistribution;
  CheckBox: TCheckBox;
  RowIndex: Integer;
  TimeItem: TModpathTimeItem;
  procedure UpdateRadioGroup(RadioGroup: TRadioGroup; Value: integer);
  begin
    if RadioGroup.ItemIndex <> Value then
    begin
      RadioGroup.ItemIndex := -1;
    end;
  end;
  procedure UpdateCheckBox(CheckBox: TCheckBox; Checked: boolean);
  begin
    if CheckBox.Checked <> Checked then
    begin
      CheckBox.AllowGrayed := True;
      CheckBox.State := cbGrayed;
    end;
  end;
  procedure UpdateIntegerSpinEdit(SpinEdit: TJvSpinEdit; Value: integer);
  begin
    if SpinEdit.AsInteger <> Value then
    begin
      SpinEdit.MinValue := 0;
      SpinEdit.AsInteger := 0;
    end;
  end;
  procedure UpdateFloatSpinEdit(SpinEdit: TJvSpinEdit; Value: double);
  begin
    if SpinEdit.Value <> Value then
    begin
      SpinEdit.MinValue := 0;
      SpinEdit.Value := 0;
    end;
  end;
  procedure AssignGridParticles;
  begin
    GridParticles := Particles.GridParticles;
    Frame.cbLeftFace.Checked := GridParticles.LeftFace;
    Frame.cbRightFace.Checked := GridParticles.RightFace;
    Frame.cbBackFace.Checked := GridParticles.BackFace;
    Frame.cbFrontFace.Checked := GridParticles.FrontFace;
    Frame.cbBottomFace.Checked := GridParticles.BottomFace;
    Frame.cbTopFace.Checked := GridParticles.TopFace;
    Frame.cbInternal.Checked := GridParticles.Internal;
    Frame.seX.AsInteger := GridParticles.XCount;
    Frame.seY.AsInteger := GridParticles.YCount;
    Frame.seZ.AsInteger := GridParticles.ZCount;
  end;
  procedure AssignCylinderParticles;
  begin
    CylParticles := Particles.CylinderParticles;
    Frame.rgCylinderOrientation.ItemIndex := Ord(CylParticles.Orientation);
    Frame.seCylParticleCount.AsInteger := CylParticles.CircleParticleCount;
    Frame.seCylLayerCount.AsInteger := CylParticles.LayerCount;
    Frame.seCylRadius.Value := CylParticles.Radius;
  end;
  procedure AssignSphereParticles;
  begin
    SphereParticles := Particles.SphereParticles;
    Frame.rgSphereOrientation.ItemIndex := Ord(SphereParticles.Orientation);
    Frame.seSphereParticleCount.AsInteger := SphereParticles.CircleParticleCount;
    Frame.seSphereLayerCount.AsInteger := SphereParticles.LayerCount;
    Frame.seSphereRadius.Value := SphereParticles.Radius;
  end;
  procedure AssignCustomParticles;
  var
    Index: integer;
    Item: TParticleLocation;
  begin
    CustomParticles := Particles.CustomParticles;
    Frame.seSpecificParticleCount.AsInteger := CustomParticles.Count;
    frameModpathParticlesseSpecificParticleCountChange(nil);
    for Index := 0 to CustomParticles.Count - 1 do
    begin
      Item := CustomParticles.Items[Index] as TParticleLocation;
      Frame.rdgSpecific.Cells[1, Index + 1] := FloatToStr(Item.X);
      Frame.rdgSpecific.Cells[2, Index + 1] := FloatToStr(Item.Y);
      Frame.rdgSpecific.Cells[3, Index + 1] := FloatToStr(Item.Z);
    end;
  end;
begin
  Frame := frameModpathParticles;
  Frame.TrackingDirection := frmGoPhast.PhastModel.
    ModflowPackages.ModPath.TrackingDirection;
  Frame.MPathVersion := frmGoPhast.PhastModel.
    ModflowPackages.ModPath.MPathVersion;
  UsedDistribution := [];
  for ScreenObjectIndex := 0 to ListOfScreenObjects.Count - 1 do
  begin
    ScreenObject := ListOfScreenObjects[ScreenObjectIndex];
    Particles := ScreenObject.ModpathParticles;

    if not Particles.Used then
    begin
      if ScreenObjectIndex = 0 then
      begin
        Frame.gbParticles.Checked := False;
      end
      else
      begin
        CheckBox := Frame.gbParticles.Components[0] as TCheckBox;
        if CheckBox.State = cbChecked then
        begin
          CheckBox.AllowGrayed := True;
          CheckBox.State := cbGrayed;
        end;
      end;
    end
    else
    begin
      if ScreenObjectIndex = 0 then
      begin
        Frame.gbParticles.Checked := True;
      end
      else
      begin
        CheckBox := Frame.gbParticles.Components[0] as TCheckBox;
        if CheckBox.State = cbUnChecked then
        begin
          CheckBox.AllowGrayed := True;
          CheckBox.State := cbGrayed;
        end;
      end;

      if UsedDistribution = [] then
      begin
        Frame.rgChoice.ItemIndex := Ord(Particles.ParticleDistribution);
      end
      else
      begin
        UpdateRadioGroup(Frame.rgChoice, Ord(Particles.ParticleDistribution));
      end;
      if not (Particles.ParticleDistribution in UsedDistribution) then
      begin
        Include(UsedDistribution, Particles.ParticleDistribution);
        case Particles.ParticleDistribution of
          pdGrid: AssignGridParticles;
          pdCylinder: AssignCylinderParticles;
          pdSphere: AssignSphereParticles;
          pdIndividual: AssignCustomParticles;
          pdObjectLocation: ; // do nothing
          else Assert(False);
        end;
        Frame.seTimeCount.AsInteger := Particles.ReleaseTimes.Count;
        Frame.UpdateTimeRowCount;
        for RowIndex := 0 to Particles.ReleaseTimes.Count - 1 do
        begin
          TimeItem := Particles.ReleaseTimes.Items[RowIndex] as TModpathTimeItem;
          Frame.rdgReleaseTimes.Cells[1,RowIndex+1] := FloatToStr(TimeItem.Time);
        end;
      end
      else
      begin
        case Particles.ParticleDistribution of
          pdGrid:
            begin
              GridParticles := Particles.GridParticles;
              UpdateCheckBox(Frame.cbLeftFace, GridParticles.LeftFace);
              UpdateCheckBox(Frame.cbRightFace, GridParticles.RightFace);
              UpdateCheckBox(Frame.cbBackFace, GridParticles.BackFace);
              UpdateCheckBox(Frame.cbFrontFace, GridParticles.FrontFace);
              UpdateCheckBox(Frame.cbBottomFace, GridParticles.BottomFace);
              UpdateCheckBox(Frame.cbTopFace, GridParticles.TopFace);
              UpdateCheckBox(Frame.cbInternal, GridParticles.Internal);
              UpdateIntegerSpinEdit(Frame.seX, GridParticles.XCount);
              UpdateIntegerSpinEdit(Frame.seY, GridParticles.YCount);
              UpdateIntegerSpinEdit(Frame.seZ, GridParticles.ZCount);
            end;
          pdCylinder:
            begin
              CylParticles := Particles.CylinderParticles;
              UpdateRadioGroup(Frame.rgCylinderOrientation, Ord(CylParticles.Orientation));
              UpdateIntegerSpinEdit(Frame.seCylParticleCount, CylParticles.CircleParticleCount);
              UpdateIntegerSpinEdit(Frame.seCylLayerCount, CylParticles.LayerCount);
              UpdateFloatSpinEdit(Frame.seCylRadius, CylParticles.Radius);
            end;
          pdSphere:
            begin
              SphereParticles := Particles.SphereParticles;
              UpdateRadioGroup(Frame.rgSphereOrientation, Ord(SphereParticles.Orientation));
              UpdateIntegerSpinEdit(Frame.seSphereParticleCount, SphereParticles.CircleParticleCount);
              UpdateIntegerSpinEdit(Frame.seSphereLayerCount, SphereParticles.LayerCount);
              UpdateFloatSpinEdit(Frame.seSphereRadius, SphereParticles.Radius);
            end;
          pdIndividual:
            begin
              CustomParticles := Particles.CustomParticles;
              if Frame.seSpecificParticleCount.AsInteger <> CustomParticles.Count then
              begin
                Frame.seSpecificParticleCount.MinValue := -1;
                Frame.seSpecificParticleCount.AsInteger := -1;
                frameModpathParticlesseSpecificParticleCountChange(nil);
              end
              else
              begin
                for Index := 0 to CustomParticles.Count - 1 do
                begin
                  Item := CustomParticles.Items[Index] as TParticleLocation;
                  if Frame.rdgSpecific.Cells[1, Index + 1] <> FloatToStr(Item.X) then
                  begin
                    Frame.rdgSpecific.Cells[1, Index + 1] := '';
                  end;
                  if Frame.rdgSpecific.Cells[2, Index + 1] <> FloatToStr(Item.Y) then
                  begin
                    Frame.rdgSpecific.Cells[2, Index + 1] := '';
                  end;
                  if Frame.rdgSpecific.Cells[3, Index + 1] <> FloatToStr(Item.Z) then
                  begin
                    Frame.rdgSpecific.Cells[4, Index + 1] := '';
                  end;
                end;
              end;
            end;
          pdObjectLocation:
            begin
            end;
          else Assert(False);
        end;
        UpdateIntegerSpinEdit(Frame.seTimeCount,
          Particles.ReleaseTimes.Count);
        Frame.UpdateTimeRowCount;
        if Frame.seTimeCount.AsInteger >= 1 then
        begin
          for RowIndex := 0 to Particles.ReleaseTimes.Count - 1 do
          begin
            TimeItem := Particles.ReleaseTimes.Items[RowIndex] as TModpathTimeItem;
            if Frame.rdgReleaseTimes.Cells[1,RowIndex+1] <>
              FloatToStr(TimeItem.Time) then
            begin
              Frame.rdgReleaseTimes.Cells[1,RowIndex+1] := '';
            end;
          end;
        end;

      end;
    end;
  end;
  frameModpathParticlesgbParticlesCheckBoxClick(nil);
  frameModpathParticles.CreateParticles;
end;

procedure TfrmScreenObjectProperties.GetIFaceForAdditionalObject(AScreenObject: TScreenObject);
begin
  if frameIFACE.IFACE <> AScreenObject.IFACE then
  begin
    frameIFACE.IFACE := iIndeterminant;
  end;
end;

procedure TfrmScreenObjectProperties.AssignConductanceCaptions(
  Frame: TframeScreenObjectCondParam; Boundary: TSpecificModflowBoundary);
var
  ColIndex: Integer;
  Index: Integer;
  Param: TModflowParameter;
  TimeList: TModflowTimeList;
begin
  ColIndex := -1;
  for Index := 0 to Frame.rdgModflowBoundary.ColCount - 1 do
  begin
    if Frame.rdgModflowBoundary.Objects[Index, 0] <> nil then
    begin
      ColIndex := Index + Frame.ConductanceColumn;
      break;
    end;
  end;
  if ColIndex >= 0 then
  begin
    while ColIndex < Frame.rdgModflowBoundary.ColCount do
    begin
      Param := Frame.rdgModflowBoundary.Objects[
        ColIndex - Frame.ConductanceColumn, 0] as TModflowParameter;
      Frame.rdgModflowBoundary.Cells[ColIndex, 0] :=
        Param.ParameterName + Frame.ParamColumnCaption(Frame.ConductanceColumn);
      Inc(ColIndex, Frame.ParameterColumnSuffix.Count);
    end;
  end;
  if (Boundary <> nil) {and Boundary.Used} then
  begin
    // Testing if the boundary is used prevents the caption from being changed
    // if the first thing the user does is to change the conductance method
    // used. Therefore, don't check Boundary.Used
    TimeList := Boundary.Values.TimeLists[Frame.ConductanceColumn, frmGoPhast.PhastModel];
    Frame.rdgModflowBoundary.Cells[Frame.ConductanceColumn + 2, 0] :=
      Frame.ConductanceCaption(TimeList.NonParamDescription);
  end;
end;

function TfrmScreenObjectProperties.GetLowerCoordinateCaption(
  const AScreenObject: TScreenObject): string;
begin
  result := AScreenObject.LowerCoordinateCaption;
//  case AScreenObject.ViewDirection of
//    vdTop:
//      begin
//        result := StrLowerZcoordinate;
//      end;
//    vdFront:
//      begin
//        result := StrLowerYcoordinate;
//      end;
//    vdSide:
//      begin
//        result := StrLowerXcoordinate;
//      end;
//  else
//    begin
//      Assert(False);
//    end;
//  end;
end;

function TfrmScreenObjectProperties.GetHigherCoordinateCaption(
  const AScreenObject: TScreenObject): string;
begin
  result := AScreenObject.HigherCoordinateCaption;
//  case AScreenObject.ViewDirection of
//    vdTop:
//      begin
//        result := StrHigherZcoordinate;
//      end;
//    vdFront:
//      begin
//        result := StrHigherYcoordinate;
//      end;
//    vdSide:
//      begin
//        result := StrHigherXcoordinate;
//      end;
//  else
//    begin
//      Assert(False);
//    end;
//  end;
end;

function TfrmScreenObjectProperties.GetCoordinateCaption(
  const AScreenObject: TScreenObject): string;
begin
  result := AScreenObject.CoordinateCaption;
//  case AScreenObject.ViewDirection of
//    vdTop:
//      begin
//        result := StrZcoordinate;
//      end;
//    vdFront:
//      begin
//        result := StrYcoordinate;
//      end;
//    vdSide:
//      begin
//        result := StrXcoordinate;
//      end;
//  else
//    begin
//      Assert(False);
//    end;
//  end;
end;

procedure TfrmScreenObjectProperties.GetCSubBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TCSubBoundary;
begin
  if not frmGoPhast.PhastModel.CSubIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowCSub;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FCSUB_Node <> nil then
  begin
    FCSUB_Node.StateIndex := Ord(State)+1;
  end;
  frameCSUB.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.AssignImportedValuesColumn(
  var First: boolean; var ColIndex: Integer; ValueStorage: TValueArrayStorage;
  const ColumnCaption: string);
var
  ValueIndex: Integer;
  RowCount: Integer;
  RowIndex: Integer;
  ExistingCount: Integer;
begin
  Inc(ColIndex);
  RowCount := ValueStorage.Count + 1;
  rdgImportedData.Objects[ColIndex, 0] := ValueStorage;
  if First then
  begin
    rdgImportedData.RowCount := RowCount;
    First := False;
    for RowIndex := 1 to rdgImportedData.RowCount - 1 do
    begin
      rdgImportedData.Cells[0,RowIndex] := IntToStr(RowIndex);
    end;
  end
  else
  begin
    if rdgImportedData.RowCount < RowCount then
    begin
      ValueStorage.Count := rdgImportedData.RowCount-1;
      RowCount := ValueStorage.Count + 1;
      if not FTooManyError then
      begin
        Beep;
        MessageDlg(Format(StrThereAreTooManyI, [ColumnCaption]), mtWarning, [mbOK], 0);
        FTooManyError := True;
      end;
    end
    else if rdgImportedData.RowCount > RowCount then
    begin
      if not FTooFewError then
      begin
        Beep;
        MessageDlg(Format(StrThereAreTooFewIm, [ColumnCaption]), mtWarning, [mbOK], 0);
        FTooFewError := True;
      end;
      ExistingCount := ValueStorage.Count;
      ValueStorage.Count := rdgImportedData.RowCount-1;
      case ValueStorage.DataType of
        rdtDouble:
          begin
            for ValueIndex := ExistingCount+1 to ValueStorage.Count - 1 do
            begin
              ValueStorage.RealValues[ValueIndex] := 0;
            end;
          end;
        rdtInteger:
          begin
            for ValueIndex := ExistingCount+1 to ValueStorage.Count - 1 do
            begin
              ValueStorage.IntValues[ValueIndex] := 0;
            end;
          end;
        rdtBoolean:
          begin
            for ValueIndex := ExistingCount+1 to ValueStorage.Count - 1 do
            begin
              ValueStorage.BooleanValues[ValueIndex] := False;
            end;
          end;
        rdtString:
          begin
            for ValueIndex := ExistingCount+1 to ValueStorage.Count - 1 do
            begin
              ValueStorage.StringValues[ValueIndex] := '""';
            end;
          end;
      end;
      RowCount := ValueStorage.Count + 1;
    end;
    Assert(rdgImportedData.RowCount = RowCount)
  end;
  rdgImportedData.Cells[ColIndex, 0] := ColumnCaption;
  case ValueStorage.DataType of
    rdtDouble: rdgImportedData.Columns[ColIndex].Format := rcf4Real;
    rdtInteger: rdgImportedData.Columns[ColIndex].Format := rcf4Integer;
    rdtBoolean: rdgImportedData.Columns[ColIndex].Format := rcf4Boolean;
    rdtString:
      begin
        rdgImportedData.Columns[ColIndex].Format := rcf4String;
        rdgImportedData.Columns[ColIndex].AutoAdjustColWidths:= False;
      end
    else Assert(False);
  end;
  for ValueIndex := 0 to ValueStorage.Count - 1 do
  begin
    case ValueStorage.DataType of
      rdtDouble:
        begin
          rdgImportedData.Cells[ColIndex, ValueIndex + 1] :=
            FloatToStr(ValueStorage.RealValues[ValueIndex]);
        end;
      rdtInteger:
        begin
          rdgImportedData.Cells[ColIndex, ValueIndex + 1] :=
            IntToStr(ValueStorage.IntValues[ValueIndex]);
        end;
      rdtBoolean:
        begin
          rdgImportedData.Checked[ColIndex, ValueIndex + 1] :=
            ValueStorage.BooleanValues[ValueIndex];
        end;
      rdtString:
        begin
          rdgImportedData.Cells[ColIndex, ValueIndex + 1] :=
            ValueStorage.StringValues[ValueIndex];
        end;
    else
      Assert(False);
    end;
  end;
  ValueStorage.CacheData;
end;

procedure TfrmScreenObjectProperties.SetDisabledElevationFormulas(
  FirstScreenObject: TScreenObject);
var
  EvalAt: TEvaluatedAt;
begin
  if rgEvaluatedAt.ItemIndex >= 0 then
  begin
    EvalAt := TEvaluatedAt(rgEvaluatedAt.ItemIndex);
  end
  else
  begin
    EvalAt := eaBlocks;
  end;
  if not edZ.Enabled then
  begin
    edZ.Text := frmGoPhast.PhastModel.DefaultElevationFormula(
      FirstScreenObject.ViewDirection, EvalAt);
  end;
  if not edHighZ.Enabled then
  begin
    edHighZ.Text := frmGoPhast.PhastModel.DefaultHigherElevationFormula(
      FirstScreenObject.ViewDirection, EvalAt);
  end;
  if not edLowZ.Enabled then
  begin
    edLowZ.Text := frmGoPhast.PhastModel.DefaultLowerElevationFormula(
      FirstScreenObject.ViewDirection, EvalAt);
  end;
end;

procedure TfrmScreenObjectProperties.DisableAllowGrayed(CheckBox: TCheckBox);
begin
  if CheckBox.State = cbGrayed then
  begin
    CheckBox.AllowGrayed := False;
    CheckBox.State := cbChecked;
  end;
end;

procedure TfrmScreenObjectProperties.AssignTransientHfbFormulas(const Row, Col: Integer);
var
  NewFormula: string;
  NewValue: string;
  OldFormula: string;
  TempCompiler: TRbwParser;
  CompiledFormula: TExpression;
  PestParamAllowed: Boolean;
begin
  Assert(Row >= 1);
  Assert(Col in [2,3]);
  OldFormula := frameHfbMf6.rdgModflowBoundary.Cells[Col,Row];
  NewValue := OldFormula;
//  with TfrmFormula.Create(self) do
  with frmFormula do
  begin
    try
      Initialize;
      IncludeGIS_Functions(eaBlocks);
      RemoveGetVCont;
      RemoveHufFunctions;
      PopupParent := self;
      // show the variables and functions
      IncludeTimeSeries := False;
      UpdateTreeList;
      // put the formula in the TfrmFormula.
      Formula := NewValue;
      // The user edits the formula.
      ShowModal;
      if ResultSet then
      begin
        NewFormula := Formula;

      end;
    finally
      Initialize;
//      Free;
    end;
  end;

  TempCompiler := GetCompiler(dso3D, eaBlocks);
  try
    TempCompiler.Compile(NewFormula);

  except on E: ERbwParserError do
    begin
      NewFormula := '0';
      TempCompiler.Compile(NewFormula);
    end
  end;
  CompiledFormula := TempCompiler.CurrentExpression;

  PestParamAllowed := (frameHfbMf6.comboHfbParameters.ItemIndex <= 0)
    and GetPestParameterAllowed(frameHfbMf6.rdgModflowBoundary, Col);
  if PestParamAllowed then
  begin
    PestParamAllowed :=
      frmGoPhast.PhastModel.GetPestParameterByName(
      CompiledFormula.DecompileDisplay) <> nil;
  end;

  if (CompiledFormula.ResultType in [rdtDouble, rdtInteger]) then
  begin
    frameHfbMf6.rdgModflowBoundary.Cells[Col, Row] := CompiledFormula.DecompileDisplay;
  end
  else if PestParamAllowed then
  begin
    frameHfbMf6.rdgModflowBoundary.Cells[Col, Row] := CompiledFormula.DecompileDisplay;
  end
  else
  begin
    NewFormula := AdjustFormula(NewFormula, CompiledFormula.ResultType, rdtDouble);
    TempCompiler.Compile(NewFormula);
    CompiledFormula := TempCompiler.CurrentExpression;
    frameHfbMf6.rdgModflowBoundary.Cells[Col, Row] := CompiledFormula.DecompileDisplay;
  end;

end;

procedure TfrmScreenObjectProperties.AssignHfbFormulas(Ed: TEdit);
var
  NewFormula: string;
  NewValue: string;
  OldFormula: string;
  TempCompiler: TRbwParser;
  CompiledFormula: TExpression;
  PestParamAllowed: Boolean;
begin
  OldFormula := Ed.Text;
  NewValue := OldFormula;
//  with TfrmFormula.Create(self) do
  with frmFormula do
  begin
    try
      Initialize;
      IncludeGIS_Functions(eaBlocks);
      RemoveGetVCont;
      RemoveHufFunctions;
      PopupParent := self;
      // show the variables and functions
      IncludeTimeSeries := False;
      UpdateTreeList;
      // put the formula in the TfrmFormula.
      Formula := NewValue;
      // The user edits the formula.
      ShowModal;
      if ResultSet then
      begin
        NewFormula := Formula;
      end;
    finally
      Initialize;
//      Free;
    end;
  end;

  TempCompiler := GetCompiler(dso3D, eaBlocks);
  try
    TempCompiler.Compile(NewFormula);

  except on E: ERbwParserError do
    begin
      Beep;
      raise ERbwParserError.Create(Format(StrErrorInFormulaS,
        [E.Message]));
      Exit;
    end
  end;
  CompiledFormula := TempCompiler.CurrentExpression;

  PestParamAllowed := (frameHfbBoundary.comboHfbParameters.ItemIndex <= 0)
    and (frmGoPhast.PhastModel.GetPestParameterByName(
    CompiledFormula.DecompileDisplay) <> nil);

  if (CompiledFormula.ResultType in [rdtDouble, rdtInteger]) then
  begin
    Ed.Text := CompiledFormula.DecompileDisplay;
  end
  else if PestParamAllowed then
  begin
    Ed.Text := CompiledFormula.DecompileDisplay;
  end
  else
  begin
    NewFormula := AdjustFormula(NewFormula, CompiledFormula.ResultType, rdtDouble);
    TempCompiler.Compile(NewFormula);
    CompiledFormula := TempCompiler.CurrentExpression;
    Ed.Text := CompiledFormula.DecompileDisplay;
  end;

//  Ed.Text := NewFormula;
    // Don't allow the user to click the OK button if any formulas are invalid.
//    EnableOK_Button;
end;

procedure TfrmScreenObjectProperties.SetSelectedName;
var
  SelectedEdit: TScreenObjectDataEdit;
begin
  if tvDataSets.Selected = nil then
  begin
    FSelectedDataArrayName := '';
  end
  else
  begin
    SelectedEdit := tvDataSets.Selected.Data;
    if SelectedEdit = nil then
    begin
      FSelectedDataArrayName := '';
    end
    else
    begin
      if SelectedEdit.DataArray = nil then
      begin
        FSelectedDataArrayName := '';
      end
      else
      begin
        FSelectedDataArrayName := SelectedEdit.DataArray.Name;
      end;
    end;
  end;
end;


procedure TfrmScreenObjectProperties.UpdateDataSetTreeViewNodeStates;
var
  ChildState: Integer;
  ChildNode: TTreeNode;
  Node: TTreeNode;
  Index: Integer;
begin
  for Index := tvDataSets.Items.Count - 1 downto 0 do
  begin
    Node := tvDataSets.Items[Index];
    if Node.HasChildren then
    begin
      ChildNode := Node.getFirstChild;
      ChildState := ChildNode.StateIndex;
      while ChildNode <> nil do
      begin
        ChildNode := ChildNode.getNextSibling;
        if ChildNode = nil then
          break;
        if ChildState <> ChildNode.StateIndex then
        begin
          ChildState := Ord(cbGrayed) + 1;
          break;
        end;
      end;
      Node.StateIndex := ChildState;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.InvalidateAllDataSets;
var
  Edit: TScreenObjectDataEdit;
  Index: Integer;
begin
  for Index := 0 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    if Edit.Used <> cbUnChecked then
    begin
      Edit.Invalidate;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.UpdateScreenObjectData;
var
  DataEditIndex: Integer;
  ScreenObject: TScreenObject;
  Item: TScreenObjectEditItem;
  Index: Integer;
  ExistingItem: TInterpValuesItem;
  UpdatedItem: TInterpValuesItem;
  FormulaPosition: Integer;
  Formula: string;
  DataSetFormula: string;
  SpecialCase: Boolean;
  Used: TCheckBoxState;
  UseDataArray: Boolean;
  Edit: TScreenObjectDataEdit;
  Boundary: TLakBoundary;
  AScreenObject: TScreenObject;
  DataArrayList: TDataArrayList;
  QuadRefinement: Integer;
begin
  DataArrayList := TDataArrayList.Create;
  try
    frmGoPhast.PhastModel.GetLayerDataArrays(DataArrayList);
    Assert(FNewProperties <> nil);
    if (FNewProperties.Count = 1) and (FScreenObjectList <> nil) then
    begin
      AScreenObject := FScreenObjectList[0];
      Item := FNewProperties[0];
      ScreenObject := Item.ScreenObject;
      if AScreenObject.ImportedValues.Count > 0 then
      begin
        ScreenObject.ImportedValues := AScreenObject.ImportedValues;
      end;
      if AScreenObject.ImportedSectionElevations.Count > 0 then
      begin
        AScreenObject.ImportedSectionElevations :=
          AScreenObject.ImportedSectionElevations;
      end;
      if AScreenObject.ImportedHigherSectionElevations.Count > 0 then
      begin
        AScreenObject.ImportedHigherSectionElevations :=
          AScreenObject.ImportedHigherSectionElevations;
      end;
      if AScreenObject.ImportedLowerSectionElevations.Count > 0 then
      begin
        AScreenObject.ImportedLowerSectionElevations :=
          AScreenObject.ImportedLowerSectionElevations;
      end;
      ScreenObject.Comment := memoComments.Text;
      AScreenObject.Comment := memoComments.Text;

    end;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      ScreenObject := Item.ScreenObject;
      if FNewProperties.Count = 1 then
      begin
        SetVertexValues(ScreenObject);
      end;
      Assert(ScreenObject <> nil);

      if rdeQuadTreeRefinement.Enabled
        and TryStrToInt(rdeQuadTreeRefinement.Text, QuadRefinement) then
      begin
        ScreenObject.QuadtreeRefinementLevel := QuadRefinement;
      end;

      for DataEditIndex := 0 to FDataEdits.Count - 1 do
      begin
        Edit := FDataEdits[DataEditIndex];
        if not Edit.ShouldUpdateDataSet then
        begin
          Continue;
        end;
        UseDataArray := False;
        Used := Edit.Used;
        SpecialCase := False;
        if UpperCase(Edit.DataArray.Name) = UpperCase(rsModflowSpecifiedHead) then
        begin
          SpecialCase := True;
          if (frameChdParam.seNumberOfTimes.Value > 0)
            or ((frmGoPhast.ModelSelection <> msModflow2015)
              and (frameFhbHead.seNumberOfTimes.Value > 0)) then
          begin
            Used := cbChecked;
          end
          else
          begin
            Used := cbUnChecked;
          end;
          DataSetFormula := 'True';
        end
        else if UpperCase(Edit.DataArray.Name) = UpperCase(StrUzfGage_1_and_2) then
        begin
          SpecialCase := True;
          if cbUzfGage1.Checked then
          begin
            Used := cbChecked;
          end
          else
          begin
            Used := cbUnChecked;
          end;
          if cbUzfGage1.Checked then
          begin
            if cbUzfGage2.Checked then
            begin
              DataSetFormula := '2';
            end
            else
            begin
              DataSetFormula := '1';
            end;
          end
          else
          begin
            DataSetFormula := '0';
          end;
        end
        else if UpperCase(Edit.DataArray.Name) = UpperCase(StrUzfGage3) then
        begin
          SpecialCase := True;
          if cbUzfGage3.Checked then
          begin
            Used := cbChecked;
          end
          else
          begin
            Used := cbUnChecked;
          end;
          if cbUzfGage3.Checked then
          begin
            DataSetFormula := '3';
          end
          else
          begin
            DataSetFormula := '0';
          end;
        end
        else if UpperCase(Edit.DataArray.Name) = UpperCase(rsLakeID) then
        begin
          Boundary := ScreenObject.ModflowLakBoundary;
          if (Boundary <> nil) and ShouldStoreBoundary(FLAK_Node, Boundary) then
          begin
            Used := cbChecked;
          end
          else
          begin
            Used := cbUnChecked;
          end;
          if Used = cbChecked then
          begin
            DataSetFormula := IntToStr(Boundary.LakeID);
            if DataSetFormula = '0' then
            begin
              Used := cbUnChecked;
            end;
          end;
        end;

        case Used of
          cbUnchecked:
            begin
              UseDataArray := False;
            end;
          cbChecked:
            begin
              UseDataArray := True;
            end;
          cbGrayed:
            begin
              UseDataArray := ScreenObject.IndexOfDataSet(Edit.DataArray) >= 0;
            end;
        else
          Assert(False);
        end;
        if not UseDataArray then
        begin
          ScreenObject.RemoveDataSet(Edit.DataArray);
        end
        else
        begin
          if SpecialCase then
          begin
            Formula := DataSetFormula;
          end
          else
          begin
            Formula := Edit.Formula;
          end;
          FormulaPosition := ScreenObject.IndexOfDataSet(Edit.DataArray);
          if FormulaPosition < 0 then
          begin
            FormulaPosition := ScreenObject.AddDataSet(Edit.DataArray);
            if Formula = '' then
            begin
              Formula := Edit.DataArray.Formula;
            end;
          end;
          if Formula <> '' then
          begin
            ScreenObject.DataSetFormulas[FormulaPosition] := Formula;
          end;
          if Edit.DataArray is TCustomPhastDataSet then
          begin
            UpdatedItem := Edit.InterpValue.Items[Index] as TInterpValuesItem;
            ExistingItem := ScreenObject.InterpValues.ItemOfDataSet[Edit.DataArray];
            ExistingItem.Assign(UpdatedItem);
          end;
        end;
      end;
      RemoveLayerDataArraysFrom3DObject(ScreenObject, DataArrayList);
    end;
  finally
    DataArrayList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.UpdateMawScrollWidth;
const
  AddChar = 'MMMM';
var
  MaxLen: Integer;
  index: Integer;
  Len: Integer;
begin
  Canvas.Font := frameObsMf6.chklstMAW.Font;

  MaxLen := 0;
  for index := 0 to frameObsMf6.chklstMAW.Items.Count - 1 do
  begin
    Len := Canvas.TextWidth(frameObsMf6.chklstMAW.Items[index] + AddChar);
    if Len > MaxLen then
    begin
      MaxLen := Len;
    end;
  end;
  frameObsMf6.chklstMAW.ScrollWidth := MaxLen;

  MaxLen := 0;
  for index := 0 to frameObsMf6.chklstMwt.Items.Count - 1 do
  begin
    Len := Canvas.TextWidth(frameObsMf6.chklstMwt.Items[index] + AddChar);
    if Len > MaxLen then
    begin
      MaxLen := Len;
    end;
  end;
  frameObsMf6.chklstMwt.ScrollWidth := MaxLen;

  Canvas.Font := Font;
end;

procedure TfrmScreenObjectProperties.UpdateUzfScrollWidth;
const
  AddChar = 'MMMM';
var
  MaxLen: Integer;
  index: Integer;
  Len: Integer;
begin
  Canvas.Font := frameObsMf6.chklstUZF.Font;

  MaxLen := 0;
  for index := 0 to frameObsMf6.chklstUZF.Items.Count - 1 do
  begin
    Len := Canvas.TextWidth(frameObsMf6.chklstUZF.Items[index] + AddChar);
    if Len > MaxLen then
    begin
      MaxLen := Len;
    end;
  end;
  frameObsMf6.chklstUZF.ScrollWidth := MaxLen;

  Canvas.Font := Font;
end;

procedure TfrmScreenObjectProperties.UpdateCurrentEdit;
var
  Edit: TScreenObjectDataEdit;
  Index: Integer;
  InterpValue: TInterpValuesItem;
  ChemDataSets: TList;
begin
  if not IsLoaded then
  begin
    Exit;
  end;
  FUpdatingCurrentEdit := True;
  try
    reDataSetComment.Lines.Clear;
    reAssocModDataSets.Lines.Clear;
    // Check that the formula entered for the previous
    // data set is correct.
    if FCurrentEdit <> nil then
    begin
      ValidateDataSetFormula;
    end;
    // Change the FCurrentEdit to the one for the new
    // data set that is being edited.
    if tvDataSets.Selected = nil then
    begin
      reDataSetFormula.Enabled := False;
      framePhastInterpolationData.Enabled := False;
      reDataSetFormula.Text := '';
      FCurrentEdit := nil;
    end
    else
    begin
      Edit := tvDataSets.Selected.Data;
      FCurrentEdit := Edit;
      if Edit = nil then
      begin
        reDataSetFormula.Enabled := False;
        reDataSetFormula.Text := '';
        framePhastInterpolationData.Enabled := False;
      end
      else
      begin
        if Edit.Used = cbUnchecked then
        begin
          reDataSetFormula.Enabled := False;
          reDataSetFormula.Text := '';
        end
        else
        begin
          reDataSetFormula.Enabled := True;
          reDataSetFormula.Text := Edit.Formula;
          ValidateDataSetFormula;
        end;
        if (Edit.DataArray is TCustomPhastDataSet)
          and (frmGoPhast.PhastModel.ModelSelection = msPhast) then
        begin
          framePhastInterpolationData.Enabled := Edit.Used <> cbUnChecked;
          for Index := 0 to Edit.InterpValue.Count - 1 do
          begin
            InterpValue := Edit.InterpValue.Items[Index] as TInterpValuesItem;
            if Index = 0 then
            begin
              framePhastInterpolationData.AssigningValues := True;
              framePhastInterpolationData.GetFirstData(InterpValue.Values);
              framePhastInterpolationData.AssigningValues := False;
            end
            else
            begin
              framePhastInterpolationData.AssigningValues := True;
              framePhastInterpolationData.GetMoreData(InterpValue.Values);
              framePhastInterpolationData.AssigningValues := False;
            end;
          end;
          ChemDataSets := TList.Create;
          try
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Solution));
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Equilibrium_Phases));
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Surface));
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Exchange));
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Gas_Phase));
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Solid_Solutions));
            ChemDataSets.Add(frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsChemistry_Initial_Kinetics));
            framePhastInterpolationData.SetMixtureAllowed(ChemDataSets.IndexOf(Edit.DataArray) >= 0);
          finally
            ChemDataSets.Free;
          end;
        end
        else
        begin
          framePhastInterpolationData.Enabled := False;
        end;
        if Edit.DataArray <> nil then
        begin
          reDataSetComment.Lines.Add(Edit.DataArray.Comment);
          reAssocModDataSets.Lines.Add(Edit.DataArray.AssociatedDataSets);
        end;
      end;
    end;
    btnDataSetFormula.Enabled := reDataSetFormula.Enabled;
    UpdateDataSetTreeViewNodeStates;
  finally
    FUpdatingCurrentEdit := False;
  end;
end;

procedure TfrmScreenObjectProperties.CheckIfDataSetUsedInElevationFormula(
  var CreateNode: Boolean; DataSet: TDataArray; ElevationFormula: string;
  Ed: TRbwEdit);
var
  Compiler: TRbwParser;
  Expression: TExpression;
begin
  if Ed.Text <> '' then
  begin
    ElevationFormula := Ed.Text;
  end;
  Compiler := GetElevationCompiler;
  try
    Compiler.Compile(ElevationFormula);
    CreateNode := ElevationFormula <> DataSet.Name;
    if CreateNode then
    begin
      Expression := Compiler.CurrentExpression;
      CreateNode := Expression.VariablesUsed.IndexOf(DataSet.Name) <= 0;
    end;
  except
    on ERbwParserError do
    begin
    end;
  end;
end;

function TfrmScreenObjectProperties.CheckMf6LakeOutlet: Boolean;
var
  ProblemOutlet: Integer;
begin
  result := True;
  ProblemOutlet := -1;
  if (frmGoPhast.ModelSelection = msModflow2015) then
  begin
    if (FLAKMf6_Node <> nil) and (FLAKMf6_Node.StateIndex in [2,3]) then
    begin
      if not frameLakMf6.LakeOutletsDefined(ProblemOutlet)
        and ((FMVR_Node = nil) or not (FMVR_Node.StateIndex in [2,3])) then
      begin
        Beep;
        if (MessageDlg(Format(StrNoOutletLakeIsSp + ' Do you want to change this now?', [ProblemOutlet]),
          mtWarning, [mbYes, mbNo], 0, mbNo) = mrYes) then
        begin
          Result := False;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.clbChildModelsClickCheck(Sender: TObject);
var
  ChildModel: TChildModel;
  ItemIndex: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  ChildModel := clbChildModels.Items.Objects[
    clbChildModels.CheckedIndex] as TChildModel;
  if ChildModel <> nil then
  begin
    ChildModel.CanUpdateGrid := False;
  end;

  if FScreenObject <> nil then
  begin
    FScreenObject.ChildModel := ChildModel;
  end
  else
  begin
    for ItemIndex := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[ItemIndex];
      Item.ScreenObject.ChildModel := ChildModel;
    end;
  end;

end;

procedure TfrmScreenObjectProperties.clbLgrUsedModelsClickCheck(
  Sender: TObject);
var
  Model: TCustomModel;
  ItemIndex: Integer;
  UsedsModels: TUsedWithModelCollection;
  ModelIndex: Integer;
  AllUsed: Boolean;
begin
  inherited;
  if IsLoaded then
  begin
    if clbLgrUsedModels.State[clbLgrUsedModels.ItemIndex] = cbGrayed then
    begin
      clbLgrUsedModels.State[clbLgrUsedModels.ItemIndex] := cbChecked
    end;
    AllUsed := True;
    for ModelIndex := 0 to clbLgrUsedModels.Items.Count - 1 do
    begin
      Model := clbLgrUsedModels.Items.Objects[ModelIndex] as TCustomModel;
      for ItemIndex := 0 to FNewProperties.Count - 1 do
      begin
        UsedsModels := FNewProperties[ItemIndex].ScreenObject.UsedModels;
        if clbLgrUsedModels.State[ModelIndex] = cbChecked then
        begin
          UsedsModels.AddModel(Model);
        end
        else if clbLgrUsedModels.State[ModelIndex] = cbUnChecked then
        begin
          UsedsModels.RemoveModel(Model);
          AllUsed := False;
        end;
      end;
      if FScreenObject <> nil then
      begin
        UsedsModels := FScreenObject.UsedModels;
        if clbLgrUsedModels.State[ModelIndex] = cbChecked then
        begin
          UsedsModels.AddModel(Model);
        end
        else if clbLgrUsedModels.State[ModelIndex] = cbUnChecked then
        begin
          UsedsModels.RemoveModel(Model);
          AllUsed := False;
        end;
      end;
    end;
    if not AllUsed then
    begin
      cbLgrAllModels.Checked := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.FillCompilerList(CompilerList: TList);
begin
  CompilerList.Add(rparserFrontFormulaElements);
  CompilerList.Add(rparserFrontFormulaNodes);
  CompilerList.Add(rparserSideFormulaElements);
  CompilerList.Add(rparserSideFormulaNodes);
  CompilerList.Add(rparserThreeDFormulaElements);
  CompilerList.Add(rparserThreeDFormulaNodes);
  CompilerList.Add(rparserTopFormulaElements);
  CompilerList.Add(rparserTopFormulaNodes);

  rparserFrontFormulaElements.Tag := Ord(eaBlocks);
  rparserSideFormulaElements.Tag := Ord(eaBlocks);
  rparserThreeDFormulaElements.Tag := Ord(eaBlocks);
  rparserTopFormulaElements.Tag := Ord(eaBlocks);

  rparserFrontFormulaNodes.Tag := Ord(eaNodes);
  rparserSideFormulaNodes.Tag := Ord(eaNodes);
  rparserThreeDFormulaNodes.Tag := Ord(eaNodes);
  rparserTopFormulaNodes.Tag := Ord(eaNodes);
end;

procedure TfrmScreenObjectProperties.CheckIfDataSetCanBeEdited(
  var CanEdit: boolean; Edit: TScreenObjectDataEdit;
  ListOfScreenObjects: TList);
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  DataSet: TDataArray;
  MethodIndex: Integer;
  List: TList;
  TestedElevationFormulas: TStringList;
begin
  CanEdit := True;

  // Check that Edit.DataArray.EvaluatedAt is correct.
  if rgEvaluatedAt.ItemIndex >= 0 then
  begin
    CanEdit := (Ord(Edit.DataArray.EvaluatedAt) = rgEvaluatedAt.ItemIndex);
  end
  else
  begin
    for ScreenObjectIndex := 0 to ListOfScreenObjects.Count - 1 do
    begin
      AScreenObject := ListOfScreenObjects[ScreenObjectIndex];
      CanEdit := Edit.DataArray.EvaluatedAt = AScreenObject.EvaluatedAt;
      if not CanEdit then
      begin
        break;
      end;
    end;
  end;
  CanEdit := CanEdit and not (dcFormula in Edit.DataArray.Lock);
  CanEdit := CanEdit and Edit.DataArray.Visible;
  // Check that Edit.DataArray.Orientation is correct.
  case Edit.DataArray.Orientation of
    dsoTop:
      begin
        CanEdit := CanEdit and (FViewDirection = vdTop);
      end;
    dsoFront:
      begin
        CanEdit := CanEdit and (FViewDirection = vdFront);
      end;
    dsoSide:
      begin
        CanEdit := CanEdit and (FViewDirection = vdSide);
      end;
    dso3D: ; // do nothing
    else Assert(False);
  end;
  if (rgElevationCount.ItemIndex = 0)
    and (Edit.DataArray.Orientation = dso3D) then
  begin
    CanEdit := False;
  end;

  // Check that the Elevation formula(s) does not depend on the
  // the TDataArray.
  if CanEdit then
  begin
    DataSet := Edit.DataArray;
    TestedElevationFormulas:= TStringList.Create;
    List := TList.Create;
    try
      TestedElevationFormulas.Capacity := ListOfScreenObjects.Count;
      TestedElevationFormulas.Sorted := True;
      frmGoPhast.PhastModel.GetModflowLayerGroupDataSets(List);
      frmGoPhast.PhastModel.GetSutraLayerGroupDataSets(List);
      for ScreenObjectIndex := 0 to ListOfScreenObjects.Count - 1 do
      begin
        if not CanEdit then
        begin
          break;
        end;
        AScreenObject := ListOfScreenObjects[ScreenObjectIndex];
        if rgElevationCount.ItemIndex = -1 then
        begin
          MethodIndex := Ord(AScreenObject.ElevationCount);
        end
        else
        begin
          MethodIndex := rgElevationCount.ItemIndex
        end;
        if MethodIndex <> 0 then
        begin
          CanEdit := (List.IndexOf(DataSet) < 0);
          if not CanEdit then
          begin
            break;
          end;
        end;
        if (MethodIndex <> 0) or (List.IndexOf(DataSet) < 0) then
        begin
          CanEdit := not AScreenObject.IsListeningTo(DataSet);
        end;
        if CanEdit then
        begin
          case MethodIndex of
            0:
              begin
                // Do nothing
              end;
            1:
              begin
                if TestedElevationFormulas.IndexOf(
                  AScreenObject.ElevationFormula) < 0 then
                begin
                  CheckIfDataSetUsedInElevationFormula(CanEdit,
                    DataSet, AScreenObject.ElevationFormula, edZ);
                  TestedElevationFormulas.Add(AScreenObject.ElevationFormula);
                end;
              end;
            2:
              begin
                if TestedElevationFormulas.IndexOf(
                  AScreenObject.HigherElevationFormula) < 0 then
                begin
                  CheckIfDataSetUsedInElevationFormula(CanEdit,
                    DataSet, AScreenObject.HigherElevationFormula, edHighZ);
                  TestedElevationFormulas.Add(AScreenObject.HigherElevationFormula);
                end;
                if CanEdit then
                begin
                  if TestedElevationFormulas.IndexOf(
                    AScreenObject.LowerElevationFormula) < 0 then
                  begin
                    CheckIfDataSetUsedInElevationFormula(CanEdit,
                      DataSet, AScreenObject.LowerElevationFormula, edLowZ);
                    TestedElevationFormulas.Add(AScreenObject.LowerElevationFormula);
                  end;
                end;
              end;
            else Assert(False);
          end;
        end;
      end;
    finally
      TestedElevationFormulas.Free;
      List.Free;
    end;
  end
end;

procedure TfrmScreenObjectProperties.FillDataSetsTreeView(ListOfScreenObjects: TList);
var
  Index: Integer;
  Edit: TScreenObjectDataEdit;
  CreateNode: boolean;
  Node: TTreeNode;
  Position: integer;
  ClassifiedDataSets: TStringList;
  LayerList: TList;
  SutraLayerList: TList;
  DataEdits: TClassificationList;
  LayerEdits: TClassificationList;
  SutraLayerEdits: TClassificationList;
  HydrogeologicUnitNames: TStringList;
  HufDataArrays: TClassificationList;
  SelectedNode: TTreeNode;
begin

  { TODO : Nearly the same code is use in TfrmFormulaUnit, TFrmGridColor,
  TfrmScreenObjectProperties, and TfrmDataSets. Find a way to combine them. }
  // depends on rgEvaluatedAt.ItemIndex
  // depends on rgElevationCount.ItemIndex
  // depends on edZ.Text
  // depends on edHighZ.Text
  // depends on edLowZ.Text
  if not FCanFillTreeView or (FDataEdits.Count = 0) or FFilledDataSetTreeView then
  begin
    Exit;
  end;

  FFillingDataSetTreeView := True;
  HydrogeologicUnitNames := TStringList.Create;
  HufDataArrays := TClassificationList.Create;
  LayerList := TList.Create;
  SutraLayerList := TList.Create;
  ClassifiedDataSets := TStringList.Create;
  DataEdits := TClassificationList.Create;
  LayerEdits := TClassificationList.Create;
  SutraLayerEdits := TClassificationList.Create;
  try
    frmGoPhast.PhastModel.HydrogeologicUnits.FillDataArrayNames(
      HydrogeologicUnitNames);
    HydrogeologicUnitNames.CaseSensitive := False;
    for Index := 0 to HydrogeologicUnitNames.Count - 1 do
    begin
      HufDataArrays.Add(nil);
    end;

    frmGoPhast.PhastModel.GetModflowLayerGroupDataSets(LayerList);
    for Index := 0 to LayerList.Count - 1 do
    begin
      LayerEdits.Add(nil);
    end;

    frmGoPhast.PhastModel.GetSutraLayerGroupDataSets(SutraLayerList);
    for Index := 0 to SutraLayerList.Count - 1 do
    begin
      SutraLayerEdits.Add(nil);
    end;

    FCurrentEdit := nil;
    tvDataSets.Items.Clear;
    for Index := 0 to FDataEdits.Count - 1 do
    begin
      Edit := FDataEdits[Index];
      Edit.Node := nil;

      CheckIfDataSetCanBeEdited(CreateNode, Edit, ListOfScreenObjects);

      // Only include the data set in on tvDataSets
      // if it can be validly set by
      // one or more of the TScreenObject's,
      if CreateNode then
      begin
        DataEdits.Add(Edit);
        Position := LayerList.IndexOf(Edit.DataArray);
        if Position >= 0 then
        begin
          LayerEdits[Position] := Edit;
        end;

        Position := SutraLayerList.IndexOf(Edit.DataArray);
        if Position >= 0 then
        begin
          SutraLayerEdits[Position] := Edit;
        end;

        Position := HydrogeologicUnitNames.IndexOf(Edit.DataArray.Name);
        if Position >= 0 then
        begin
          HufDataArrays[Position] := Edit;
        end;
      end;
    end;
    LayerEdits.Pack;
    HufDataArrays.Pack;
    SutraLayerEdits.Pack;

    if DataEdits.Count > 0 then
    begin
      ClassifyListedObjects(ClassifiedDataSets, DataEdits,
        [LayerEdits, SutraLayerEdits, HufDataArrays]);
      Assert(ClassifiedDataSets.Count> 0);
      Assert(ClassifiedDataSets[0] = StrDataSets);
      ClassifiedDataSets.Delete(0);
      Assert(ClassifiedDataSets.IndexOf(StrDataSets) < 0);

      CreateClassifiedNodes(ClassifiedDataSets, 1, tvDataSets,
        FSelectedDataArrayName);

      for Index := 0 to tvDataSets.Items.Count - 1 do
      begin
        Node := tvDataSets.Items[Index];
        Edit := Node.Data;
        if Edit <> nil then
        begin
          Node.StateIndex := Ord(Edit.Used) + 1;
          Edit.Node := Node;
        end;
      end;

      UpdateDataSetTreeViewNodeStates;

      SelectedNode := nil;
      for Index := 0 to tvDataSets.Items.Count - 1 do
      begin
        Node := tvDataSets.Items[Index];
        if Node.HasChildren and (Node.StateIndex <> Ord(cbUnchecked) + 1) then
        begin
          Node.Expanded := True;
        end;
        if (SelectedNode = nil) and not Node.HasChildren
          and (Node.StateIndex <> Ord(cbUnchecked) + 1) then
        begin
          SelectedNode := Node;
          tvDataSets.Selected := SelectedNode;
        end;
      end;


    end;
  finally
    SutraLayerList.Free;
    ClassifiedDataSets.Free;
    LayerList.Free;
    DataEdits.Free;
    SutraLayerEdits.Free;
    LayerEdits.Free;
    HufDataArrays.Free;
    HydrogeologicUnitNames.Free;
    FFillingDataSetTreeView := False;
  end;

end;

procedure TfrmScreenObjectProperties.CreateDataSetEdits(ListOfScreenObjects: TList);
//  function DataArrayNameToEdit(const Name: string): TScreenObjectDataEdit;
//  var
//    Index: integer;
//    Edit: TScreenObjectDataEdit;
//  begin
//    result := nil;
//    for Index := 0 to FDataEdits.Count - 1 do
//    begin
//      Edit := FDataEdits[Index];
//      if Edit.DataArray.Name = Name then
//      begin
//        result := Edit;
//        Exit;
//      end;
//    end;
//  end;
var
  Index: Integer;
  Edit: TScreenObjectDataEdit;
  DataSet: TDataArray;
  DataArrayManager: TDataArrayManager;
begin
  FCurrentEdit := nil;
  FDataEdits.Clear;
  DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
  for Index := 0 to DataArrayManager.DataSetCount - 1 do
  begin
    Edit := TScreenObjectDataEdit.Create(ListOfScreenObjects,
      DataArrayManager.DataSets[Index]);
    FDataEdits.Add(Edit);
    CreateVariable(Edit);
  end;
  for Index := 0 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    DataSet := Edit.DataArray;
    // Get the names of all the data sets that depend on DataSet
    DataSet.FullUseList(Edit.UsedBy);
  end;
  for Index := 0 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    if (Edit.Used <> cbUnchecked) and (Edit.Expression = nil) then
    begin
      CreateFormula(Index, Edit.Formula, false);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.AddGisFunctionsToAllParsers;
var
  CompilerList: TList;
  Index: Integer;
  Compiler: TRbwParser;
begin
  CompilerList := TList.Create;
  try
    FillCompilerList(CompilerList);
    for Index := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[Index];
      AddGIS_Functions(Compiler, frmGoPhast.PhastModel.ModelSelection,
        TEvaluatedAt(Compiler.Tag));
    end;
  finally
    CompilerList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetAssignmentMethodForSingleObject;
begin
  // Display whether the enclosed or intersected cells should
  // have their values set.
  cbEnclosedCells.Checked := FScreenObject.SetValuesOfEnclosedCells;
  cbIntersectedCells.Checked := FScreenObject.SetValuesOfIntersectedCells;
  cbInterpolation.Checked := FScreenObject.SetValuesByInterpolation;
  rdeMinimumCellFraction.RealValue := FScreenObject.MinimumFraction;
  // Enable or disable controls.
  cbEnclosedCellsClick(nil);
  cbIntersectedCellsClick(nil);
  cbInterpolationClick(nil);
end;

procedure TfrmScreenObjectProperties.GetColorDataForSingleObject;
begin
  // Display the colors associated with the screen object.
  shpLineColor.Brush.Color := FScreenObject.LineColor;
  shpLineColor.Pen.Color := FScreenObject.LineColor;
  shpFillColor.Brush.Color := FScreenObject.FillColor;
  // Display whether the colors are used.
  cbLineColor.Checked := FScreenObject.ColorLine;
  cbFillColor.Checked := FScreenObject.FillScreenObject;
  // Enable or disable controls.
  cbLineColorClick(nil);
  cbFillColorClick(nil);
end;

procedure TfrmScreenObjectProperties.SetElevationDataForSingleObject;
begin
  rgElevationCount.ItemIndex := Ord(FScreenObject.ElevationCount);
  rgElevationCount.OnClick(nil);
  if (FScreenObject.ElevationCount = ecOne) then
  begin
    edZ.Text := FScreenObject.ElevationFormula;
  end
  else if (FScreenObject.ElevationCount = ecTwo) then
  begin
    edHighZ.Text := FScreenObject.HigherElevationFormula;
    edLowZ.Text := FScreenObject.LowerElevationFormula;
  end;
  ValidateEdFormula(edZ);
  ValidateEdFormula(edHighZ);
  ValidateEdFormula(edLowZ);
end;

procedure TfrmScreenObjectProperties.SetGridCellSizeDataForSingleObject;
begin
  cbSetGridCellSize.Checked := FScreenObject.CellSizeUsed;
  if FScreenObject.CellSizeUsed then
  begin
    rdeGridCellSize.Enabled := True;
    lblGridCellSize.Enabled := True;
    rdeGridCellSize.Text := FloatToStr(FScreenObject.CellSize);
  end;
end;

procedure TfrmScreenObjectProperties.GetDataSetsForSingleObject;
var
  Index: Integer;
  DataSet: TDataArray;
  DataSetPosition: Integer;
  Edit: TScreenObjectDataEdit;
begin
  // read data sets.

  for Index := 0 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    DataSet := Edit.DataArray;
    // store data for PHAST-style interpolation.
    Assert(FScreenObject is TScreenObject);
    if Edit.Used <> cbUnchecked then
    begin
      DataSetPosition := FScreenObject.IndexOfDataSet(DataSet);
      Edit.Formula := FScreenObject.DataSetFormulas[DataSetPosition];
      CreateFormula(Index, Edit.Formula);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.SetScreenObjectVerticies;
var
  TempScreenObject: TScreenObject;
  Index: Integer;
  APoint: TPoint2D;
  CanSetPositions: Boolean;
begin
  if tabNodes.TabVisible then
  begin
    CanSetPositions := True;
    TempScreenObject := frmGoPhast.PhastModel.ScreenObjectClass.Create(nil);
    try
      TempScreenObject.Capacity := dgVerticies.RowCount - 1;
      for Index := 1 to dgVerticies.RowCount - 1 do
      begin
        if dgVerticies.Cells[Ord(vcX), Index] = '' then
        begin
          APoint.X := 0;
        end
        else
        begin
          try
            APoint.X := StrToFloat(dgVerticies.Cells[Ord(vcX), Index]);
          except
            on EConvertError do
            begin
              APoint.X := 0;
            end;
          end;
        end;
        if dgVerticies.Cells[Ord(vcY), Index] = '' then
        begin
          APoint.Y := 0;
        end
        else
        begin
          try
            APoint.Y := StrToFloat(dgVerticies.Cells[Ord(vcY), Index]);
          except
            on EConvertError do
            begin
              APoint.Y := 0;
            end;
          end;
        end;
        try
          TempScreenObject.AddPoint(APoint,
            dgVerticies.Checked[Ord(vcNewSection), Index]);
        except
          on E: EScreenObjectError do
          begin
          end;
        end;
        if TempScreenObject.Count <> Index then
        begin
          CanSetPositions := False;
          break;
        end;
      end;
    finally
      TempScreenObject.Free;
    end;
    if CanSetPositions then
    begin
      FScreenObject.SectionStarts.Clear;
      for Index := 2 to dgVerticies.RowCount - 1 do
      begin
        if dgVerticies.Checked[Ord(vcNewSection), Index] then
        begin
          FScreenObject.SectionStarts.Add;
          FScreenObject.SectionStarts.IntValues[FScreenObject.SectionStarts.Count -1] := Index -1;
        end;
      end;
      FScreenObject.Count := dgVerticies.RowCount - 1;
      for Index := 1 to dgVerticies.RowCount - 1 do
      begin
        if dgVerticies.Cells[Ord(vcX), Index] = '' then
        begin
          APoint.X := 0;
        end
        else
        begin
          try
            APoint.X := StrToFloat(dgVerticies.Cells[Ord(vcX), Index]);
          except
            on EConvertError do
            begin
              APoint.X := 0;
            end;
          end;
        end;
        if dgVerticies.Cells[Ord(vcY), Index] = '' then
        begin
          APoint.Y := 0;
        end
        else
        begin
          try
            APoint.Y := StrToFloat(dgVerticies.Cells[Ord(vcY), Index]);
          except
            on EConvertError do
            begin
              APoint.Y := 0;
            end;
          end;
        end;
        if (FScreenObject.Points[Index - 1].X <> APoint.X) or (FScreenObject.Points[Index - 1].Y <> APoint.Y) then
        begin
          FScreenObject.Points[Index - 1] := APoint;
          frmGoPhast.PhastGrid.NeedToRecalculateCellColors;
          frmGoPhast.ModflowGrid.NeedToRecalculateCellColors;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetEvaluatedAtForAdditionalObject(AScreenObject: TScreenObject);
var
  EvaluatedAtIndex: Integer;
begin
  EvaluatedAtIndex := Ord(AScreenObject.EvaluatedAt);
  if EvaluatedAtIndex <> rgEvaluatedAt.ItemIndex then
  begin
    rgEvaluatedAt.ItemIndex := -1;
  end;
end;

function TfrmScreenObjectProperties.GenerateNewDataSetFormula(
  DataArray: TDataArray): string;
var
  DataSetPosition: Integer;
  Index: Integer;
  AScreenObject: TScreenObject;
begin
  result := '';
  if FScreenObject <> nil then
  begin
    DataSetPosition := FScreenObject.IndexOfDataSet(DataArray);
    if DataSetPosition >= 0 then
    begin
      result := FScreenObject.DataSetFormulas[DataSetPosition];
    end;
  end
  else
  begin
    for Index := 0 to FScreenObjectList.Count - 1 do
    begin
      AScreenObject := FScreenObjectList[Index];
      DataSetPosition := AScreenObject.IndexOfDataSet(DataArray);
      if DataSetPosition >= 0 then
      begin
        result := AScreenObject.DataSetFormulas[DataSetPosition];
        if result <> '' then
        begin
          break;
        end;
      end;
    end;
  end;
  if result = '' then
  begin
    result := DataArray.DisplayFormula;
  end;
end;

//procedure TfrmScreenObjectProperties.GetPilotPointsForAdditionalObject
//  (AScreenObject: TScreenObject);
//begin
//  if cbPilotPoints.Checked <> AScreenObject.VerticesArePilotPoints then
//  begin
//    cbPilotPoints.AllowGrayed := True;
//    cbPilotPoints.State := cbGrayed;
//    cbEnclosedCellsClick(nil);
//  end;
//end;


procedure TfrmScreenObjectProperties.GetDuplicatesAllowedForAdditionalObject
  (AScreenObject: TScreenObject);
begin
  if cbDuplicatesAllowed.Checked <> AScreenObject.DuplicatesAllowed then
  begin
    cbDuplicatesAllowed.AllowGrayed := True;
    cbDuplicatesAllowed.State := cbGrayed;
    cbEnclosedCellsClick(nil);
  end;
end;


procedure TfrmScreenObjectProperties.GetAssignmentMethodForAdditionalObject(AScreenObject: TScreenObject);
begin
  if AScreenObject.Closed then
  begin
    cbEnclosedCells.Enabled := True;
  end;
  if cbEnclosedCells.Checked <> AScreenObject.SetValuesOfEnclosedCells then
  begin
    cbEnclosedCells.AllowGrayed := True;
    cbEnclosedCells.State := cbGrayed;
    cbEnclosedCellsClick(nil);
  end;
  if cbIntersectedCells.Checked <> AScreenObject.SetValuesOfIntersectedCells then
  begin
    cbIntersectedCells.AllowGrayed := True;
    cbIntersectedCells.State := cbGrayed;
    cbIntersectedCellsClick(nil);
  end;
  if cbInterpolation.Checked <> AScreenObject.SetValuesByInterpolation then
  begin
    cbInterpolation.AllowGrayed := True;
    cbInterpolation.State := cbGrayed;
    cbInterpolationClick(nil);
  end;
  if not rdeMinimumCellFraction.Enabled then
  begin
    rdeMinimumCellFraction.Enabled := (AScreenObject.ScreenObjectLength > 0)
      and (cbIntersectedCells.State <> cbUnchecked);
  end;
  if rdeMinimumCellFraction.RealValue <> AScreenObject.MinimumFraction then
  begin
    rdeMinimumCellFraction.Text := '';
  end;
end;

procedure TfrmScreenObjectProperties.GetColorDataForAdditionalObject(AScreenObject: TScreenObject);
begin
  // update display of screen object line and fill colors.
  // Hide the TShapes that display the colors if the
  // colors are not consistent.
  if shpLineColor.Brush.Color <> AScreenObject.LineColor then
  begin
    shpLineColor.Visible := False;
  end;
  if shpFillColor.Brush.Color <> AScreenObject.FillColor then
  begin
    shpFillColor.Visible := False;
  end;
  // Set checkbox state to grayed if they screen objects don't
  // all do the same thing.
  if cbLineColor.Checked <> AScreenObject.ColorLine then
  begin
    cbLineColor.AllowGrayed := True;
    cbLineColor.State := cbGrayed;
  end;
  if cbFillColor.Checked <> AScreenObject.FillScreenObject then
  begin
    cbFillColor.AllowGrayed := True;
    cbFillColor.State := cbGrayed;
  end;
end;

procedure TfrmScreenObjectProperties.GetCellSizeUsedForAdditionalObject(AScreenObject: TScreenObject);
var
  CellSizeText: string;
begin
  if AScreenObject.CellSizeUsed <> cbSetGridCellSize.Checked then
  begin
    cbSetGridCellSize.AllowGrayed := True;
    cbSetGridCellSize.State := cbGrayed;
  end;
  if AScreenObject.CellSizeUsed then
  begin
    if not rdeGridCellSize.Enabled then
    begin
      rdeGridCellSize.Enabled := True;
      lblGridCellSize.Enabled := True;
      rdeGridCellSize.Text := FloatToStr(AScreenObject.CellSize);
    end
    else
    begin
      CellSizeText := FloatToStr(AScreenObject.CellSize);
      if CellSizeText <> rdeGridCellSize.Text then
      begin
        rdeGridCellSize.Text := '';
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetDataSetsForAdditionalObject(
  AScreenObject: TScreenObject);
var
  DataSetIndex: Integer;
  DataSet: TDataArray;
  ScreenObjectDataSetIndex: Integer;
  DataSetUsed: Boolean;
  DataSetState: TCheckBoxState;
  AFunction: string;
  Edit: TScreenObjectDataEdit;
begin
  // update data for Data sets.
  for DataSetIndex := 0 to frmGoPhast.PhastModel.DataArrayManager.DataSetCount - 1 do
  begin
    Edit := FDataEdits[DataSetIndex];
    DataSet := Edit.DataArray;
    // see if the data set is used.
    ScreenObjectDataSetIndex := AScreenObject.IndexOfDataSet(DataSet);
    DataSetUsed := ScreenObjectDataSetIndex >= 0;
    // Set the DataSetState depending on DataSetUsed.
    if DataSetUsed then
    begin
      DataSetState := cbChecked;
    end
    else
    begin
      DataSetState := cbUnChecked;
    end;
    // If the data set is not used in previous screen objects but is used in
    // the current screen object. display the function.
    if (Edit.Used = cbUnChecked)
      and DataSetUsed then
    begin
      AFunction := AScreenObject.DataSetFormulas[ScreenObjectDataSetIndex];
      CreateFormula(DataSetIndex, AFunction);
    end;
    // Set the checkbox to cbGrayed if only some of the screen objects
    // use the data set.
    if Edit.Used <> DataSetState then
    begin
      Edit.Used := cbGrayed;
    end;
    if DataSetUsed then
    begin
      // If some screen objects use different expressions than others,
      // blank out the display of the expression.
      AFunction := AScreenObject.DataSetFormulas[ScreenObjectDataSetIndex];
      if AFunction <> Edit.Formula then
      begin
        Edit.Formula := '';
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetElevationFormulasForAdditionalObject(
  AScreenObject: TScreenObject);
var
  TempEnabled: Boolean;
begin
  if Ord(AScreenObject.ElevationCount) <> (rgElevationCount.ItemIndex) then
  begin
    rgElevationCount.ItemIndex := -1;
    if AScreenObject.ElevationCount = ecZero then
    begin
      cbInterpolation.Enabled := True;
    end;
  end;
  if (AScreenObject.ElevationCount = ecOne) then
  begin
    if not edZ.Enabled then
    begin
      TempEnabled := edHighZ.Enabled;
      rgElevationCount.ItemIndex := -1;
      lblZ.Enabled := True;
      edZ.Enabled := True;
      btnZ.Enabled := True;
      edZ.Text := AScreenObject.ElevationFormula;
      rgElevationCountClick(rgElevationCount);
      lblHighZ.Enabled := TempEnabled;
      edHighZ.Enabled := TempEnabled;
      btnHighZ.Enabled := TempEnabled;
      lblLowZ.Enabled := TempEnabled;
      edLowZ.Enabled := TempEnabled;
      btnLowZ.Enabled := TempEnabled;
    end
    else if edZ.Text <> AScreenObject.ElevationFormula then
    begin
      edZ.Text := '';
    end;
  end
  else if (AScreenObject.ElevationCount = ecTwo) then
  begin
    if not edHighZ.Enabled then
    begin
      TempEnabled := edZ.Enabled;
      rgElevationCount.ItemIndex := -1;
      lblHighZ.Enabled := True;
      edHighZ.Enabled := True;
      btnHighZ.Enabled := True;
      edHighZ.Text := AScreenObject.HigherElevationFormula;
      lblLowZ.Enabled := True;
      edLowZ.Enabled := True;
      btnLowZ.Enabled := True;
      edLowZ.Text := AScreenObject.LowerElevationFormula;
      rgElevationCountClick(rgElevationCount);
      lblZ.Enabled := TempEnabled;
      edZ.Enabled := TempEnabled;
      btnZ.Enabled := TempEnabled;
    end
    else
    begin
      if edHighZ.Text <> AScreenObject.HigherElevationFormula then
      begin
        edHighZ.Text := '';
      end;
      if edLowZ.Text <> AScreenObject.LowerElevationFormula then
      begin
        edLowZ.Text := '';
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastWellBoundaryForAdditionalObject(
  AScreenObject: TScreenObject; UsedTimes: TRealList;
  var TempType: TPhastBoundaryTypes);
var
  BoundaryIndentical: Boolean;
  Index: Integer;
  WellInterval: TWellInterval;
begin
  with AScreenObject.WellBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      TempType := btWell;
      if rgBoundaryType.ItemIndex <> Integer(btRiver) then
      begin
        rgBoundaryType.ItemIndex := -1;
      end;
      GetBoundaryTimes([BoundaryValue, Solution], UsedTimes);
      BoundaryIndentical := TimesIdentical(dgWell, UsedTimes, Ord(nicTime))
        and PhastBoundaryIsIdentical(dgWell, UsedTimes, BoundaryValue, Ord(nicBoundaryValue), -1)
        and PhastBoundaryIsIdentical(dgWell, UsedTimes, Solution, Ord(nicSolution), -1);
      if not BoundaryIndentical then
      begin
        ResetWellGrid;
      end;
      if edWellDescription.Text <> Description then
      begin
        edWellDescription.Text := '';
      end;
      if rdeWellDiameter.Text <> FloatToStr(Diameter) then
      begin
        rdeWellDiameter.Text := '';
      end;
      if rdeWellLandSurfaceDatum.Text <> FloatToStr(LandSurfaceDatum) then
      begin
        rdeWellLandSurfaceDatum.Text := '';
      end;
      if cbWellPumpAllocation.Checked <> AllocateByPressureAndMobility then
      begin
        cbWellPumpAllocation.AllowGrayed := True;
        cbWellPumpAllocation.State := cbGrayed;
      end;
      if comboWellIntervalStyle.ItemIndex <> Ord(WellElevationFormat) then
      begin
        comboWellIntervalStyle.ItemIndex := -1;
        comboWellIntervalStyleChange(nil);
      end;
      BoundaryIndentical := True;
      if Intervals.Count <> seWellIntervals.Value then
      begin
        BoundaryIndentical := False;
      end;
      if BoundaryIndentical then
      begin
        for Index := 0 to Intervals.Count - 1 do
        begin
          WellInterval := Intervals.Items[Index] as TWellInterval;
          if FloatToStr(WellInterval.FirstElevation)
            <> dgWellElevations.Cells[Ord(wicFirst), Index + 1] then
          begin
            BoundaryIndentical := False;
            break;
          end;
          if FloatToStr(WellInterval.SecondElevation)
            <> dgWellElevations.Cells[Ord(wicSecond), Index + 1] then
          begin
            BoundaryIndentical := False;
            break;
          end;
        end;
      end;
      if not BoundaryIndentical then
      begin
        ResetWellElevationGrid;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastRiverBoundaryForAdditionalObject(
  AScreenObject: TScreenObject; UsedTimes: TRealList;
  var TempType: TPhastBoundaryTypes);
var
  BoundaryIndentical: Boolean;
begin
  with AScreenObject.RiverBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      TempType := btRiver;
      if rgBoundaryType.ItemIndex <> Integer(btRiver) then
      begin
        rgBoundaryType.ItemIndex := -1;
      end;
      GetBoundaryTimes([BoundaryValue, Solution], UsedTimes);
      BoundaryIndentical := TimesIdentical(dgBoundaryRiver, UsedTimes, Ord(nicTime))
        and PhastBoundaryIsIdentical(dgBoundaryRiver, UsedTimes, BoundaryValue, Ord(nicBoundaryValue), -1)
        and PhastBoundaryIsIdentical(dgBoundaryRiver, UsedTimes, Solution, Ord(nicSolution), -1);
      if not BoundaryIndentical then
      begin
        ResetRiverGrid;
      end;
      if edRiverDescripton.Text <> Description then
      begin
        edRiverDescripton.Text := '';
      end;
      if edRiverHydraulicConductivity.Text <> BedHydraulicConductivity then
      begin
        edRiverHydraulicConductivity.Text := '';
      end;
      if edRiverWidth.Text <> Width then
      begin
        edRiverWidth.Text := '';
      end;
      if edRiverDepth.Text <> Depth then
      begin
        edRiverDepth.Text := '';
      end;
      if edRiverBedThickness.Text <> BedThickness then
      begin
        edRiverBedThickness.Text := '';
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastLeakyBoundaryForAdditionalObject(
  AScreenObject: TScreenObject; UsedTimes: TRealList;
  var TempType: TPhastBoundaryTypes);
var
  BoundaryIndentical: Boolean;
begin
  with AScreenObject.LeakyBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      TempType := btLeaky;
      if rgBoundaryType.ItemIndex <> Integer(btLeaky) then
      begin
        rgBoundaryType.ItemIndex := -1;
      end;
      GetBoundaryTimes([BoundaryValue, Solution], UsedTimes);
      BoundaryIndentical := TimesIdentical(dgBoundaryLeaky, UsedTimes, Ord(ibcTime))
        and PhastBoundaryIsIdentical(dgBoundaryLeaky, UsedTimes, BoundaryValue,
          Ord(ibcBoundaryValue), Ord(ibcBoundaryInterpolate))
        and PhastBoundaryIsIdentical(dgBoundaryLeaky, UsedTimes, Solution,
          Ord(ibcSolution), Ord(ibcSolutionInterpolate));
      if not BoundaryIndentical then
      begin
        ResetLeakyGrid;
      end;
      if edLeakyHydraulicConductivity.Text <> HydraulicConductivity then
      begin
        edLeakyHydraulicConductivity.Text := '';
      end;
      if edLeakyThickness.Text <> Thickness then
      begin
        edLeakyThickness.Text := '';
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  GetPhastSpecifiedFluxBoundaryForAdditionalObject(AScreenObject: TScreenObject;
  UsedTimes: TRealList; var TempType: TPhastBoundaryTypes);
var
  BoundaryIndentical: Boolean;
begin
  with AScreenObject.FluxBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      TempType := btFlux;
      if rgBoundaryType.ItemIndex <> Integer(btFlux) then
      begin
        rgBoundaryType.ItemIndex := -1;
      end;
      GetBoundaryTimes([BoundaryValue, Solution], UsedTimes);
      BoundaryIndentical := TimesIdentical(dgBoundaryFlux, UsedTimes, Ord(ibcTime))
        and PhastBoundaryIsIdentical(dgBoundaryFlux, UsedTimes, BoundaryValue,
          Ord(ibcBoundaryValue), Ord(ibcBoundaryInterpolate))
        and PhastBoundaryIsIdentical(dgBoundaryFlux, UsedTimes, Solution,
          Ord(ibcSolution), Ord(ibcSolutionInterpolate));
      if not BoundaryIndentical then
      begin
        ResetFluxGrid;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  GetPhastSpecifiedHeadBoundaryForAdditionalObject(AScreenObject: TScreenObject;
  UsedTimes: TRealList; var TempType: TPhastBoundaryTypes);
var
  BoundaryIndentical: Boolean;
begin
  with AScreenObject.SpecifiedHeadBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      TempType := btSpecifiedHead;
      if rgBoundaryType.ItemIndex <> Integer(btSpecifiedHead) then
      begin
        rgBoundaryType.ItemIndex := -1;
      end;
      if (Ord(SolutionType) <> comboSolutionType.ItemIndex) then
      begin
        comboSolutionType.ItemIndex := -1;
        comboSolutionTypeChange(nil);
      end;
      GetBoundaryTimes([BoundaryValue, Solution], UsedTimes);
      BoundaryIndentical := TimesIdentical(dgSpecifiedHead, UsedTimes, Ord(ibcTime))
        and PhastBoundaryIsIdentical(dgSpecifiedHead, UsedTimes, BoundaryValue,
          Ord(ibcBoundaryValue), Ord(ibcBoundaryInterpolate))
        and PhastBoundaryIsIdentical(dgSpecifiedHead, UsedTimes, Solution,
          Ord(ibcSolution), Ord(ibcSolutionInterpolate));
      if not BoundaryIndentical then
      begin
        ResetSpecifiedHeadGrid;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  GetPhastBoundaryConditionsForAdditionalObjects(AScreenObject: TScreenObject;
  var TempType: TPhastBoundaryTypes);
var
  UsedTimes: TRealList;
begin
  TempType := btNone;
  UsedTimes := TRealList.Create;
  try
    GetPhastSpecifiedHeadBoundaryForAdditionalObject(
      AScreenObject, UsedTimes, TempType);
    GetPhastSpecifiedFluxBoundaryForAdditionalObject(
      AScreenObject, UsedTimes, TempType);
    GetPhastLeakyBoundaryForAdditionalObject(
      AScreenObject, UsedTimes, TempType);
    GetPhastRiverBoundaryForAdditionalObject(
      AScreenObject, UsedTimes, TempType);
    GetPhastWellBoundaryForAdditionalObject(
      AScreenObject, UsedTimes, TempType);
  finally
    UsedTimes.Free;
  end;
end;

procedure TfrmScreenObjectProperties.SetZLabelCaptions;
begin
  lblZ.Caption := GetCoordinateCaption(FScreenObject);
  lblHighZ.Caption := GetHigherCoordinateCaption(FScreenObject);
  lblLowZ.Caption := GetLowerCoordinateCaption(FScreenObject);
  case FScreenObject.ViewDirection of
    vdTop:
      begin
        dgVerticies.Cells[Ord(vcX), 0] := StrX;
        dgVerticies.Cells[Ord(vcY), 0] := StrY;
      end;
    vdFront:
      begin
        dgVerticies.Cells[Ord(vcX), 0] := StrX;
        dgVerticies.Cells[Ord(vcY), 0] := StrZ;
      end;
    vdSide:
      begin
        dgVerticies.Cells[Ord(vcX), 0] := StrZ;
        dgVerticies.Cells[Ord(vcY), 0] := StrY;
      end;
  else
    Assert(False);
  end;
end;

procedure TfrmScreenObjectProperties.GetScreenObjectVerticies;
var
  APoint: TPoint2D;
  Index: Integer;
  TempString: string;
{$IFDEF DEBUG}
  LFormatSettings: TFormatSettings;
{$ENDIF}
begin
  if FScreenObject.Count >= 1048560 then
  begin
    // TStringGrid can't handle too many rows.
    tabNodes.TabVisible := False;
    Exit;
  end;
  // read vertices of the screen object.
  dgVerticies.RowCount := FScreenObject.Count + 1;

  dgVerticies.BeginUpdate;
  try
    UpdateVertexNumbers;
    FSettingVerticies := True;
  {$IFDEF DEBUG}
    LFormatSettings := TFormatSettings.Create('en-US'); // do not localize
    LFormatSettings.DecimalSeparator := AnsiChar('.');
  {$ENDIF}
    try
      for Index := 1 to dgVerticies.RowCount - 1 do
      begin
        APoint := FScreenObject.Points[Index - 1];
      {$IFDEF DEBUG}
        // get more precise vertex locations for debugging mesh generation.
        TempString := FloatToStrF(APoint.X, ffFixed, 16, 18, LFormatSettings);
      {$ELSE}
        TempString := FloatToStr(APoint.X);
      {$ENDIF}
        dgVerticies.Cells[Ord(vcX), Index] := TempString;
      {$IFDEF DEBUG}
        // get more precise vertex locations for debugging mesh generation.
        TempString := FloatToStrF(APoint.Y, ffFixed, 16, 18, LFormatSettings);
      {$ELSE}
        TempString := FloatToStr(APoint.Y);
      {$ENDIF}
        dgVerticies.Cells[Ord(vcY), Index] := TempString;
        dgVerticies.Checked[Ord(vcNewSection), Index] := False;
      end;
      for Index := 0 to FScreenObject.SectionCount - 1 do
      begin
        dgVerticies.Checked[Ord(vcNewSection),
          FScreenObject.SectionStart[Index] + 1] := True;
      end;
    finally
      FSettingVerticies := False;
    end;
    UpdateSectionNumbers;
  finally
    dgVerticies.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastWellBoundaryForSingleObject(
  UsedTimes: TRealList);
var
  WellInterval: TWellInterval;
  Local_Index25: Integer;
  IntegerBoundary: TIntegerPhastBoundaryCondition;
  Local_Index24: Integer;
  InterpValuesItem: TInterpValuesItem;
  InterpValuesCollection: TInterpValuesCollection;
  RowIndex: Integer;
  RealBoundary: TRealPhastBoundaryCondition;
  Local_Index23: Integer;
  Local_Index22: Integer;
  Local_Index21: Integer;
  Local_Index20: Integer;
begin
  with FScreenObject.WellBoundary do
  begin
    seWellIntervals.Value := Intervals.Count;
    seWellIntervalsChange(nil);
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      dgWell.RowCount := Max(BoundaryValue.Count, Solution.Count) + 1;
      rgBoundaryType.ItemIndex := Integer(btWell);
      edWellDescription.Text := Description;
      rdeWellDiameter.Text := FloatToStr(Diameter);
      rdeWellLandSurfaceDatum.Text := FloatToStr(LandSurfaceDatum);
      cbWellPumpAllocation.Checked := AllocateByPressureAndMobility;
      comboWellIntervalStyle.ItemIndex := Ord(WellElevationFormat);
      comboWellIntervalStyleChange(nil);
      UsedTimes.Clear;
      // In PHAST, the first time must always be zero.
      UsedTimes.AddUnique(0);
      for Local_Index20 := 0 to BoundaryValue.Count - 1 do
      begin
        UsedTimes.AddUnique((BoundaryValue.Items[Local_Index20]
          as TRealPhastBoundaryCondition).Time);
      end;
      for Local_Index21 := 0 to Solution.Count - 1 do
      begin
        UsedTimes.AddUnique((Solution.Items[Local_Index21]
          as TIntegerPhastBoundaryCondition).Time);
      end;
      // store the times for the boundary condition.
      seBoundaryTimes.Value := UsedTimes.Count;
      for Local_Index22 := 0 to UsedTimes.Count - 1 do
      begin
        dgWell.Cells[Ord(nicTime), Local_Index22 + 1]
          := FloatToStr(UsedTimes[Local_Index22]);
      end;
      for Local_Index23 := 0 to BoundaryValue.Count - 1 do
      begin
        RealBoundary := BoundaryValue.Items[Local_Index23]
          as TRealPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(RealBoundary.Time) + 1;
        if not RealBoundary.UsePHAST_Interpolation then
        begin
          dgWell.Cells[Ord(nicBoundaryValue), RowIndex]
            := RealBoundary.FormulaExpression;
        end;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(RealBoundary);
        dgWell.Objects[Ord(nicBoundaryValue), RowIndex]
          := InterpValuesCollection;
      end;
      for Local_Index24 := 0 to Solution.Count - 1 do
      begin
        IntegerBoundary := Solution.Items[Local_Index24]
          as TIntegerPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(IntegerBoundary.Time) + 1;
        if not IntegerBoundary.UsePHAST_Interpolation then
        begin
          dgWell.Cells[Ord(nicSolution), RowIndex]
            := IntegerBoundary.FormulaExpression;
        end;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(IntegerBoundary);
        dgWell.Objects[Ord(nicSolution), RowIndex] := InterpValuesCollection;
      end;
    end
    else
    begin
      dgWell.RowCount := 2;
    end;
    if Intervals.Count > 0 then
    begin
      for Local_Index25 := 0 to Intervals.Count - 1 do
      begin
        WellInterval := Intervals.Items[Local_Index25] as TWellInterval;
        dgWellElevations.Cells[Ord(wicFirst), Local_Index25 + 1]
          := FloatToStr(WellInterval.FirstElevation);
        dgWellElevations.Cells[Ord(wicSecond), Local_Index25 + 1]
          := FloatToStr(WellInterval.SecondElevation);
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  GetPhastSpecifiedHeadBoundaryForSingleObject(UsedTimes: TRealList);
var
  IntegerBoundary: TIntegerPhastBoundaryCondition;
  Local_Index19: Integer;
  InterpValuesItem: TInterpValuesItem;
  InterpValuesCollection: TInterpValuesCollection;
  RowIndex: Integer;
  RealBoundary: TRealPhastBoundaryCondition;
  Local_Index18: Integer;
  Local_Index17: Integer;
  Local_Index16: Integer;
  Local_Index15: Integer;
begin
  with FScreenObject.SpecifiedHeadBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      dgSpecifiedHead.RowCount := Max(BoundaryValue.Count, Solution.Count) + 1;
      comboSolutionType.ItemIndex := Ord(SolutionType);
      comboSolutionTypeChange(nil);
      rgBoundaryType.ItemIndex := Integer(btSpecifiedHead);
      UsedTimes.Clear;
      // In PHAST, the first time must always be zero.
      UsedTimes.AddUnique(0);
      for Local_Index15 := 0 to BoundaryValue.Count - 1 do
      begin
        UsedTimes.AddUnique((BoundaryValue.Items[Local_Index15]
          as TRealPhastBoundaryCondition).Time);
      end;
      for Local_Index16 := 0 to Solution.Count - 1 do
      begin
        UsedTimes.AddUnique((Solution.Items[Local_Index16]
          as TIntegerPhastBoundaryCondition).Time);
      end;
      // store the times for the boundary condition.
      seBoundaryTimes.Value := UsedTimes.Count;
      for Local_Index17 := 0 to UsedTimes.Count - 1 do
      begin
        dgSpecifiedHead.Cells[Ord(ibcTime), Local_Index17 + 1]
          := FloatToStr(UsedTimes[Local_Index17]);
      end;
      for Local_Index18 := 0 to BoundaryValue.Count - 1 do
      begin
        RealBoundary := BoundaryValue.Items[Local_Index18]
          as TRealPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(RealBoundary.Time) + 1;
        if not RealBoundary.UsePHAST_Interpolation then
        begin
          dgSpecifiedHead.Cells[Ord(ibcBoundaryValue), RowIndex]
            := RealBoundary.FormulaExpression;
        end;
        dgSpecifiedHead.Checked[Ord(ibcBoundaryInterpolate), RowIndex]
          := RealBoundary.UsePHAST_Interpolation;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(RealBoundary);
        dgSpecifiedHead.Objects[Ord(ibcBoundaryValue), RowIndex]
          := InterpValuesCollection;
        dgSpecifiedHead.Objects[Ord(ibcBoundaryInterpolate), RowIndex]
          := InterpValuesCollection;
      end;
      for Local_Index19 := 0 to Solution.Count - 1 do
      begin
        IntegerBoundary := Solution.Items[Local_Index19]
          as TIntegerPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(IntegerBoundary.Time) + 1;
        if not IntegerBoundary.UsePHAST_Interpolation then
        begin
          dgSpecifiedHead.Cells[Ord(ibcSolution), RowIndex]
            := IntegerBoundary.FormulaExpression;
        end;
        dgSpecifiedHead.Checked[Ord(ibcSolutionInterpolate), RowIndex]
          := IntegerBoundary.UsePHAST_Interpolation;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(IntegerBoundary);
        dgSpecifiedHead.Objects[Ord(ibcSolution), RowIndex]
          := InterpValuesCollection;
        dgSpecifiedHead.Objects[Ord(ibcSolutionInterpolate), RowIndex]
          := InterpValuesCollection;
      end;
    end
    else
    begin
      dgSpecifiedHead.RowCount := 2;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastRiverBoundaryForSingleObject(
  UsedTimes: TRealList);
var
  IntegerBoundary: TIntegerPhastBoundaryCondition;
  Local_Index14: Integer;
  InterpValuesItem: TInterpValuesItem;
  InterpValuesCollection: TInterpValuesCollection;
  RowIndex: Integer;
  RealBoundary: TRealPhastBoundaryCondition;
  Local_Index13: Integer;
  Local_Index12: Integer;
  Local_Index11: Integer;
  Local_Index10: Integer;
begin
  with FScreenObject.RiverBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      dgBoundaryRiver.RowCount := Max(BoundaryValue.Count, Solution.Count) + 1;
      rgBoundaryType.ItemIndex := Integer(btRiver);
      // Store things that don't change with time.
      edRiverDescripton.Text := Description;
      edRiverHydraulicConductivity.Text := BedHydraulicConductivity;
      edRiverWidth.Text := Width;
      edRiverDepth.Text := Depth;
      edRiverBedThickness.Text := BedThickness;
      UsedTimes.Clear;
      // In PHAST, the first time must always be zero.
      UsedTimes.AddUnique(0);
      for Local_Index10 := 0 to BoundaryValue.Count - 1 do
      begin
        UsedTimes.AddUnique((BoundaryValue.Items[Local_Index10]
          as TRealPhastBoundaryCondition).Time);
      end;
      for Local_Index11 := 0 to Solution.Count - 1 do
      begin
        UsedTimes.AddUnique((Solution.Items[Local_Index11]
          as TIntegerPhastBoundaryCondition).Time);
      end;
      // store the times for the boundary condition.
      seBoundaryTimes.Value := UsedTimes.Count;
      for Local_Index12 := 0 to UsedTimes.Count - 1 do
      begin
        dgBoundaryRiver.Cells[Ord(nicTime), Local_Index12 + 1]
          := FloatToStr(UsedTimes[Local_Index12]);
      end;
      for Local_Index13 := 0 to BoundaryValue.Count - 1 do
      begin
        RealBoundary := BoundaryValue.Items[Local_Index13]
          as TRealPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(RealBoundary.Time) + 1;
        if not RealBoundary.UsePHAST_Interpolation then
        begin
          dgBoundaryRiver.Cells[Ord(nicBoundaryValue), RowIndex]
            := RealBoundary.FormulaExpression;
        end;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(RealBoundary);
        dgBoundaryRiver.Objects[Ord(nicBoundaryValue), RowIndex]
          := InterpValuesCollection;
      end;
      for Local_Index14 := 0 to Solution.Count - 1 do
      begin
        IntegerBoundary := Solution.Items[Local_Index14]
          as TIntegerPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(IntegerBoundary.Time) + 1;
        if not IntegerBoundary.UsePHAST_Interpolation then
        begin
          dgBoundaryRiver.Cells[Ord(nicSolution), RowIndex]
            := IntegerBoundary.FormulaExpression;
        end;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(IntegerBoundary);
        dgBoundaryRiver.Objects[Ord(nicSolution), RowIndex]
          := InterpValuesCollection;
      end;
    end
    else
    begin
      dgBoundaryRiver.RowCount := 2;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastLeakyBoundaryForSingleObject(
  UsedTimes: TRealList);
var
  InterpValuesCollection: TInterpValuesCollection;
  RowIndex: Integer;
  RealBoundary: TRealPhastBoundaryCondition;
  Local_Index8: Integer;
  Local_Index7: Integer;
  Local_Index6: Integer;
  Local_Index5: Integer;
  IntegerBoundary: TIntegerPhastBoundaryCondition;
  Local_Index9: Integer;
  InterpValuesItem: TInterpValuesItem;
begin
  // store leaky boundary
  with FScreenObject.LeakyBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      dgBoundaryLeaky.RowCount := Max(BoundaryValue.Count, Solution.Count) + 1;
      rgBoundaryType.ItemIndex := Integer(btLeaky);
      // Store things that don't change with time.
      edLeakyHydraulicConductivity.Text := HydraulicConductivity;
      edLeakyThickness.Text := Thickness;
      UsedTimes.Clear;
      // In PHAST, the first time must always be zero.
      UsedTimes.AddUnique(0);
      for Local_Index5 := 0 to BoundaryValue.Count - 1 do
      begin
        UsedTimes.AddUnique((BoundaryValue.Items[Local_Index5]
          as TRealPhastBoundaryCondition).Time);
      end;
      for Local_Index6 := 0 to Solution.Count - 1 do
      begin
        UsedTimes.AddUnique((Solution.Items[Local_Index6]
          as TIntegerPhastBoundaryCondition).Time);
      end;
      // store the times for the boundary condition.
      seBoundaryTimes.Value := UsedTimes.Count;
      for Local_Index7 := 0 to UsedTimes.Count - 1 do
      begin
        dgBoundaryLeaky.Cells[Ord(ibcTime), Local_Index7 + 1]
          := FloatToStr(UsedTimes[Local_Index7]);
      end;
      for Local_Index8 := 0 to BoundaryValue.Count - 1 do
      begin
        RealBoundary := BoundaryValue.Items[Local_Index8]
          as TRealPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(RealBoundary.Time) + 1;
        if not RealBoundary.UsePHAST_Interpolation then
        begin
          dgBoundaryLeaky.Cells[Ord(ibcBoundaryValue), RowIndex]
            := RealBoundary.FormulaExpression;
        end;
        dgBoundaryLeaky.Checked[Ord(ibcBoundaryInterpolate), RowIndex]
          := RealBoundary.UsePHAST_Interpolation;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(RealBoundary);
        dgBoundaryLeaky.Objects[Ord(ibcBoundaryValue), RowIndex]
          := InterpValuesCollection;
        dgBoundaryLeaky.Objects[Ord(ibcBoundaryInterpolate), RowIndex]
          := InterpValuesCollection;
      end;
      for Local_Index9 := 0 to Solution.Count - 1 do
      begin
        IntegerBoundary := Solution.Items[Local_Index9]
          as TIntegerPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(IntegerBoundary.Time) + 1;
        if not IntegerBoundary.UsePHAST_Interpolation then
        begin
          dgBoundaryLeaky.Cells[Ord(ibcSolution), RowIndex]
            := IntegerBoundary.FormulaExpression;
        end;
        dgBoundaryLeaky.Checked[Ord(ibcSolutionInterpolate), RowIndex]
          := IntegerBoundary.UsePHAST_Interpolation;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(IntegerBoundary);
        dgBoundaryLeaky.Objects[Ord(ibcSolution), RowIndex]
          := InterpValuesCollection;
        dgBoundaryLeaky.Objects[Ord(ibcSolutionInterpolate), RowIndex]
          := InterpValuesCollection;
      end;
    end
    else
    begin
      dgBoundaryLeaky.RowCount := 2;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastFluxBoundaryForSingleObject(
  UsedTimes: TRealList);
var
  IntegerBoundary: TIntegerPhastBoundaryCondition;
  Local_Index4: Integer;
  InterpValuesItem: TInterpValuesItem;
  InterpValuesCollection: TInterpValuesCollection;
  RowIndex: Integer;
  RealBoundary: TRealPhastBoundaryCondition;
  Local_Index3: Integer;
  Local_Index2: Integer;
  Local_Index1: Integer;
  Local_Index: Integer;
begin
  // Store flux boundary
  with FScreenObject.FluxBoundary do
  begin
    if (BoundaryValue.Count > 0) or (Solution.Count > 0) then
    begin
      dgBoundaryFlux.RowCount := Max(BoundaryValue.Count, Solution.Count) + 1;
      rgBoundaryType.ItemIndex := Integer(btFlux);
      // UsedTimes.Clear is not really needed here
      // but if another boundary were stored before this,
      // it would be.
      UsedTimes.Clear;
      // Make a list of the times for the boundary condition.
      // In PHAST, the first time must always be zero.
      UsedTimes.AddUnique(0);
      for Local_Index := 0 to BoundaryValue.Count - 1 do
      begin
        UsedTimes.AddUnique((BoundaryValue.Items[Local_Index]
          as TRealPhastBoundaryCondition).Time);
      end;
      for Local_Index1 := 0 to Solution.Count - 1 do
      begin
        UsedTimes.AddUnique((Solution.Items[Local_Index1]
          as TIntegerPhastBoundaryCondition).Time);
      end;
      // store the times for the boundary condition.
      seBoundaryTimes.Value := UsedTimes.Count;
      for Local_Index2 := 0 to UsedTimes.Count - 1 do
      begin
        dgBoundaryFlux.Cells[Ord(ibcTime), Local_Index2 + 1]
          := FloatToStr(UsedTimes[Local_Index2]);
      end;
      for Local_Index3 := 0 to BoundaryValue.Count - 1 do
      begin
        RealBoundary := BoundaryValue.Items[Local_Index3]
          as TRealPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(RealBoundary.Time) + 1;
        if not RealBoundary.UsePHAST_Interpolation then
        begin
          dgBoundaryFlux.Cells[Ord(ibcBoundaryValue), RowIndex]
            := RealBoundary.FormulaExpression;
        end;
        dgBoundaryFlux.Checked[Ord(ibcBoundaryInterpolate), RowIndex]
          := RealBoundary.UsePHAST_Interpolation;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(RealBoundary);
        dgBoundaryFlux.Objects[Ord(ibcBoundaryValue), RowIndex]
          := InterpValuesCollection;
        dgBoundaryFlux.Objects[Ord(ibcBoundaryInterpolate), RowIndex]
          := InterpValuesCollection;
      end;
      for Local_Index4 := 0 to Solution.Count - 1 do
      begin
        IntegerBoundary := Solution.Items[Local_Index4]
          as TIntegerPhastBoundaryCondition;
        RowIndex := UsedTimes.IndexOf(IntegerBoundary.Time) + 1;
        if not IntegerBoundary.UsePHAST_Interpolation then
        begin
          dgBoundaryFlux.Cells[Ord(ibcSolution), RowIndex]
            := IntegerBoundary.FormulaExpression;
        end;
        dgBoundaryFlux.Checked[Ord(ibcSolutionInterpolate), RowIndex]
          := IntegerBoundary.UsePHAST_Interpolation;
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        InterpValuesItem := InterpValuesCollection.Add as TInterpValuesItem;
        InterpValuesItem.Values.Assign(IntegerBoundary);
        dgBoundaryFlux.Objects[Ord(ibcSolution), RowIndex]
          := InterpValuesCollection;
        dgBoundaryFlux.Objects[Ord(ibcSolutionInterpolate), RowIndex]
          := InterpValuesCollection;
      end;
    end
    else
    begin
      dgBoundaryFlux.RowCount := 2;
    end;
  end;
end;

function TfrmScreenObjectProperties.GetPestMethod(Grid: TRbwDataGrid4;
  ACol: Integer): TPestParamMethod;
var
  ItemIndex: Integer;
begin
  if PestRowOffset = 0 then
  begin
    result := ppmMultiply;
    Assert(False);
    Exit;
  end;
  ItemIndex := FPestMethods.IndexOf(Grid.Cells[ACol,PestMethodRow]);
  if ItemIndex >= 0 then
  begin
    result := TPestParamMethod(ItemIndex);
  end
  else
  begin
    result := ppmMultiply;
  end;
end;

//function TfrmScreenObjectProperties.GetPestMethodAssigned(Grid: TRbwDataGrid4;
//  ACol: Integer): Boolean;
//begin
//  if PestRowOffset = 0 then
//  begin
//    result := False;
//    Assert(False);
//    Exit;
//  end;
//  result := Grid.Cells[ACol, PestMethodRow] <> '';
//end;

function TfrmScreenObjectProperties.GetPestModifier(Grid: TRbwDataGrid4;
  ACol: Integer): string;
//var
//  ItemIndex: Integer;
begin
  if PestRowOffset = 0 then
  begin
    result := '';
    Assert(False);
    Exit;
  end;
  result := Grid.Cells[ACol, PestModifierRow];
  if result = strNone then
  begin
    result := ''
  end;
end;

function TfrmScreenObjectProperties.GetPestModifierAssigned(Grid: TRbwDataGrid4;
  ACol: Integer): Boolean;
begin
  if PestRowOffset = 0 then
  begin
    result := False;
    Assert(False);
    Exit;
  end;
  result := Grid.Cells[ACol, PestModifierRow] <> '';
end;

procedure TfrmScreenObjectProperties.GetPestModifiers(
  Frame: TframeScreenObjectNoParam; Parameter: TParameterType;
  ScreenObjectList: TList);
var
  ValuesFunction: TGetBoundaryCollectionEvent;
  ColumnOffset: Integer;
  BoundaryCount: Integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowParamBoundary;
  Values: TCustomMF_BoundColl;
  BoundaryIndex: Integer;
  First: Boolean;
  Identical: Boolean;
  Method: TPestParamMethod;
  Modifier: string;
  PriorCanInvalidateModel: Boolean;
begin
  ValuesFunction := GetBoundaryValues;
  ColumnOffset := 2;

  BoundaryCount := -1;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.GetMfBoundary(Parameter);
    if (Boundary <> nil) and Boundary.Used then
    begin
      Values := ValuesFunction(Boundary);
      BoundaryCount := Values.TimeListCount(frmGoPhast.PhastModel);
      break;
    end;
  end;
  if BoundaryCount = -1 then
  begin
    Exit;
  end;

  Frame.rdgModflowBoundary.BeginUpdate;
  try
    for BoundaryIndex := 0 to BoundaryCount - 1 do
    begin
      First := True;
      Identical := True;
      Method := ppmMultiply;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.GetMfBoundary(Parameter);
        if (Boundary <> nil) and Boundary.Used then
        begin
          if First then
          begin
            Method := Boundary.PestBoundaryMethod[BoundaryIndex];
            First := False;
          end
          else
          begin
            Identical := Method = Boundary.PestBoundaryMethod[BoundaryIndex];
            if not Identical then
            begin
              break;
            end;
          end;
        end;
      end;
      if Identical then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColumnOffset+BoundaryIndex] := Method;
      end
      else
      begin
        Frame.rdgModflowBoundary.Cells[ColumnOffset+BoundaryIndex,PestMethodRow] := '';
      end;
    end;

    for BoundaryIndex := 0 to BoundaryCount - 1 do
    begin
      First := True;
      Identical := True;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        PriorCanInvalidateModel := AScreenObject.CanInvalidateModel;
        AScreenObject.CanInvalidateModel := False;
        try
          Boundary := AScreenObject.GetMfBoundary(Parameter);
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Modifier := Boundary.PestBoundaryFormula[BoundaryIndex];
              First := False;
            end
            else
            begin
              Identical := Modifier = Boundary.PestBoundaryFormula[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        finally
          AScreenObject.CanInvalidateModel := PriorCanInvalidateModel;
        end;
      end;
      if Identical then
      begin
        if Modifier = '' then
        begin
          Modifier := StrNone
        end;
        PestModifier[Frame.rdgModflowBoundary,
          ColumnOffset+BoundaryIndex] := Modifier;
      end
      else
      begin
        PestModifier[Frame.rdgModflowBoundary,
          ColumnOffset+BoundaryIndex] := '';
      end;
    end;
  finally
    Frame.rdgModflowBoundary.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.GetPhastBoundariesForSingleObject;
var
  UsedTimes: TRealList;
begin
  // Store boundary condition data.
  UsedTimes := TRealList.Create;
  try
    UsedTimes.Sorted := True;
    GetPhastFluxBoundaryForSingleObject(UsedTimes);
    GetPhastLeakyBoundaryForSingleObject(UsedTimes);
    GetPhastRiverBoundaryForSingleObject(UsedTimes);
    GetPhastSpecifiedHeadBoundaryForSingleObject(UsedTimes);
    GetPhastWellBoundaryForSingleObject(UsedTimes);
  finally
    UsedTimes.Free;
  end;
end;

procedure TfrmScreenObjectProperties.InitializePhastBoundaryControls;
begin
  InitializePhastSpecifiedHeadGrid;
  InitializePhastSpecifiedFluxGrid;
  InitializePhastLeakyBoundaryGrid;
  InitializePhastRiverBoundaryGrid;
  InitializePhastWellGrid;
  SetColWidthsInPhastBoundaryGrids;
  pcPhastBoundaries.ActivePageIndex := 0;
  comboWellIntervalStyleChange(nil);
  pnlBoundaries.Constraints.MinWidth := pnlBoundaries.Width;
end;

procedure TfrmScreenObjectProperties.SetColWidthsInPhastBoundaryGrids;
var
  GridList: TList;
  Index: Integer;
  Grid: TRbwDataGrid4;
  ColIndex: Integer;
begin
  GridList := TList.Create;
  try
    GridList.Add(dgSpecifiedHead);
    GridList.Add(dgBoundaryFlux);
    GridList.Add(dgBoundaryLeaky);
    GridList.Add(dgBoundaryRiver);
    GridList.Add(dgWell);
    for Index := 0 to GridList.Count - 1 do
    begin
      Grid := GridList[Index];
      for ColIndex := 0 to Grid.ColCount - 1 do
      begin
        if Grid.Columns[ColIndex].ButtonUsed and (Grid.ColWidths[ColIndex] < Grid.Columns[ColIndex].ButtonWidth + 40) then
        begin
          Grid.ColWidths[ColIndex] := Grid.Columns[ColIndex].ButtonWidth + 40;
        end;
      end;
    end;
  finally
    GridList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.InitializePhastWellGrid;
begin
  dgWell.Cells[Ord(nicTime), 0] := StrTime;
  dgWell.Cells[Ord(nicBoundaryValue), 0] := StrPumpingRate;
  dgWell.Cells[Ord(nicSolution), 0] := StrSolution;
  dgWell.Cells[Ord(nicTime), 1] := '0';
  dgWell.Row := 1;
  dgWell.Column := 2;
  dgWell.Columns[Ord(nicBoundaryValue)].AutoAdjustColWidths := False;
  dgWell.Columns[Ord(nicSolution)].AutoAdjustColWidths := False;
  dgWell.Columns[Ord(nicBoundaryValue)].ButtonFont := Font;
  dgWell.Columns[Ord(nicSolution)].ButtonFont := Font;
end;

procedure TfrmScreenObjectProperties.InitializePhastRiverBoundaryGrid;
begin
  dgBoundaryRiver.Cells[Ord(nicTime), 0] := StrTime;
  dgBoundaryRiver.Cells[Ord(nicBoundaryValue), 0] := StrHead;
  dgBoundaryRiver.Cells[Ord(nicSolution), 0] := StrAssociatedSolution;
  dgBoundaryRiver.Cells[Ord(nicTime), 1] := '0';
  dgBoundaryRiver.Col := 2;
  dgBoundaryRiver.RowHeights[0] := dgBoundaryRiver.RowHeights[0] * 2;
  dgBoundaryRiver.Columns[Ord(nicBoundaryValue)].AutoAdjustColWidths := False;
  dgBoundaryRiver.Columns[Ord(nicSolution)].AutoAdjustColWidths := False;
  dgBoundaryRiver.Columns[Ord(nicBoundaryValue)].ButtonFont := Font;
  dgBoundaryRiver.Columns[Ord(nicSolution)].ButtonFont := Font;
end;

procedure TfrmScreenObjectProperties.InitializePhastLeakyBoundaryGrid;
begin
  dgBoundaryLeaky.Cells[Ord(ibcTime), 0] := StrTime;
  dgBoundaryLeaky.Cells[Ord(ibcBoundaryValue), 0] := StrHead;
  dgBoundaryLeaky.Cells[Ord(ibcBoundaryInterpolate), 0] := StrInterpolateHead;
  dgBoundaryLeaky.Cells[Ord(ibcSolution), 0] := StrAssociatedSolution;
  dgBoundaryLeaky.Cells[Ord(ibcSolutionInterpolate), 0]
    := StrInterpolateSolution;
  dgBoundaryLeaky.Cells[Ord(ibcTime), 1] := '0';
  dgBoundaryLeaky.Col := 2;
  dgBoundaryLeaky.RowHeights[0] := dgBoundaryLeaky.RowHeights[0] * 2;
  dgBoundaryLeaky.Columns[Ord(ibcBoundaryValue)].AutoAdjustColWidths := False;
  dgBoundaryLeaky.Columns[Ord(ibcSolution)].AutoAdjustColWidths := False;
  dgBoundaryLeaky.Columns[Ord(ibcBoundaryValue)].ButtonFont := Font;
  dgBoundaryLeaky.Columns[Ord(ibcSolution)].ButtonFont := Font;
end;

procedure TfrmScreenObjectProperties.InitializePhastSpecifiedFluxGrid;
begin
  dgBoundaryFlux.Cells[Ord(ibcTime), 0] := StrTime;
  dgBoundaryFlux.Cells[Ord(ibcBoundaryValue), 0] := StrFlux;
  dgBoundaryFlux.Cells[Ord(ibcBoundaryInterpolate), 0] := StrInterpolateFlux;
  dgBoundaryFlux.Cells[Ord(ibcSolution), 0] := StrAssociatedSolution;
  dgBoundaryFlux.Cells[Ord(ibcSolutionInterpolate), 0]
    := StrInterpolateSolution;
  dgBoundaryFlux.Cells[Ord(ibcTime), 1] := '0';
  dgBoundaryFlux.Col := 2;
  dgBoundaryFlux.RowHeights[0] := dgBoundaryFlux.RowHeights[0] * 2;
  dgBoundaryFlux.Columns[Ord(ibcBoundaryValue)].AutoAdjustColWidths := False;
  dgBoundaryFlux.Columns[Ord(ibcSolution)].AutoAdjustColWidths := False;
  dgBoundaryFlux.Columns[Ord(ibcBoundaryValue)].ButtonFont := Font;
  dgBoundaryFlux.Columns[Ord(ibcSolution)].ButtonFont := Font;
end;

procedure TfrmScreenObjectProperties.InitializePhastSpecifiedHeadGrid;
begin
  dgSpecifiedHead.Cells[Ord(ibcTime), 0] := StrTime;
  dgSpecifiedHead.Cells[Ord(ibcBoundaryValue), 0] := StrHead;
  dgSpecifiedHead.Cells[Ord(ibcBoundaryInterpolate), 0] := StrInterpolateHead;
  dgSpecifiedHead.Cells[Ord(ibcSolution), 0] := StrAssociatedSolution;
  dgSpecifiedHead.Cells[Ord(ibcSolutionInterpolate), 0]
    := StrInterpolateSolution;
  dgSpecifiedHead.Cells[Ord(ibcTime), 1] := '0';
  dgSpecifiedHead.Col := 2;
  dgSpecifiedHead.RowHeights[0] := dgSpecifiedHead.RowHeights[0] * 2;
  dgSpecifiedHead.Columns[Ord(ibcBoundaryValue)].AutoAdjustColWidths := False;
  dgSpecifiedHead.Columns[Ord(ibcSolution)].AutoAdjustColWidths := False;
  dgSpecifiedHead.Columns[Ord(ibcBoundaryValue)].ButtonFont := Font;
  dgSpecifiedHead.Columns[Ord(ibcSolution)].ButtonFont := Font;
end;

procedure TfrmScreenObjectProperties.InitializeVertexGrid;
begin
  dgVerticies.Cells[Ord(vcSection), 0] := StrSectionNumber;
  dgVerticies.Cells[Ord(vcX), 0] := StrX;
  dgVerticies.Cells[Ord(vcY), 0] := StrY;
  dgVerticies.Cells[Ord(vcNewSection), 0] := StrNewSection;
end;

procedure TfrmScreenObjectProperties.SetSelectedMfBoundaryNode;
var
  SelectedMfBoundaryNode: TTreeNode;
begin
  SelectedMfBoundaryNode := jvtlModflowBoundaryNavigator.Items.GetFirstNode;
  while SelectedMfBoundaryNode <> nil do
  begin
    if SelectedMfBoundaryNode.StateIndex <> 1 then
    begin
      break;
    end;
    SelectedMfBoundaryNode := SelectedMfBoundaryNode.GetNext;
  end;
  if SelectedMfBoundaryNode = nil then
  begin
    SelectedMfBoundaryNode := jvtlModflowBoundaryNavigator.Items.GetFirstNode;
  end;
  jvtlModflowBoundaryNavigator.Selected := SelectedMfBoundaryNode;
end;

procedure TfrmScreenObjectProperties.SetSelectedSutraBoundaryNode;
var
  SelectedSutraBoundaryNode: TTreeNode;
begin
  SelectedSutraBoundaryNode := jvpltvSutraFeatures.Items.GetFirstNode;
  while SelectedSutraBoundaryNode <> nil do
  begin
    if SelectedSutraBoundaryNode.StateIndex <> 1 then
    begin
      break;
    end;
    SelectedSutraBoundaryNode := SelectedSutraBoundaryNode.GetNext;
  end;
  if SelectedSutraBoundaryNode = nil then
  begin
    SelectedSutraBoundaryNode := jvpltvSutraFeatures.Items.GetFirstNode;
  end;
  if SelectedSutraBoundaryNode = nil then
  begin
    jvplSutraFeatures.ActivePage := jvspSutraBlank;
  end
  else
  begin
    jvpltvSutraFeatures.Selected := SelectedSutraBoundaryNode;
  end;
end;

procedure TfrmScreenObjectProperties.CreateUzfNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FUZF_Node := nil;
  if frmGoPhast.PhastModel.UzfIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection  <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.UzfPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspUzf.PageIndex;
    frameScreenObjectUZF.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FUZF_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateUzMf6fNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FUZF_Mf6_Node := nil;
  if frmGoPhast.PhastModel.UzfMf6IsSelected
    and (frmGoPhast.ModelSelection = msModflow2015)
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.UzfMf6Package.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspUzfMf6.PageIndex;
    frameScreenObjectUzfMf6.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FUZF_Mf6_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateCfpRechargeNode;
var
  Node: TJvPageIndexNode;
begin
  FCRCH_Node := nil;
  if frmGoPhast.PhastModel.CfpRechargeIsSelected(nil)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      StrCRCHConduitRechar)
      as TJvPageIndexNode;
    Node.PageIndex := jvspCfpRechargeFraction.PageIndex;
    frameCfpRechargeFraction1.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FCRCH_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSfrNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSFR_Node := nil;
  if frmGoPhast.PhastModel.SfrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and not AScreenObject.Closed
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.SFRPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSFR.PageIndex;
    frameScreenObjectSFR.ISFROPT :=
      frmGoPhast.PhastModel.ModflowPackages.SFRPackage.ISFROPT;
    frameScreenObjectSFR.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSFR_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSfr6Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSFR6_Node := nil;
  if frmGoPhast.PhastModel.Sfr6IsSelected
    and (frmGoPhast.ModelSelection = msModflow2015)
    and (AScreenObject.ViewDirection = vdTop)
    and not AScreenObject.Closed then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.SfrModflow6Package.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSFR6.PageIndex;
    frameScreenObjectSfr6.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSFR6_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateStrNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSTR_Node := nil;
  if frmGoPhast.PhastModel.StrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and not AScreenObject.Closed
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.STRPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSTR.PageIndex;
    frameScreenObjectSTR.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSTR_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSwiObsNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWiObs_Node := nil;
  if frmGoPhast.PhastModel.SwiObsUsed(nil)
    and (AScreenObject.Count = 1)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.SwiPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSWI_Obs.PageIndex;
    frameSwiObs.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWiObs_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateHobNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FHob_Node := nil;
  if frmGoPhast.PhastModel.HobIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (AScreenObject.Count = 1)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.HobPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspHOB.PageIndex;
    frameHeadObservations.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FHob_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateHfbNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FHfb_Node := nil;
  if frmGoPhast.PhastModel.HfbIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (AScreenObject.Count > 1) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.HFBPackage.PackageIdentifier)
      as TJvPageIndexNode;
    if frmGoPhast.ModelSelection = msModflow2015 then
    begin
      Node.PageIndex := jvspHFB_MF6.PageIndex;
      frameHfbMf6.pnlCaption.Caption := Node.Text;
    end
    else
    begin
      Node.PageIndex := jvspHFB.PageIndex;
      frameHfbBoundary.pnlCaption.Caption := Node.Text;
    end;
    Node.ImageIndex := 1;
    FHfb_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateHydmodNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FHydmod_Node := nil;
  if frmGoPhast.PhastModel.HydmodIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.HydmodPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspHydmod.PageIndex;
    frameHydmod.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FHydmod_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMvrNode;
var
  Node: TJvPageIndexNode;
begin
  FMvr_Node := nil;
  if frmGoPhast.PhastModel.MvrIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.MvrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMvr.PageIndex;
    frameMVR.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMvr_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateParams(var Params: TCreateParams);
begin
  inherited;
  Params.ExStyle := Params.ExStyle or WS_EX_APPWINDOW;
  Params.WndParent := 0;
end;

procedure TfrmScreenObjectProperties.CreateLakMf6Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FLAKMf6_Node := nil;
  if frmGoPhast.PhastModel.LakMf6IsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection = msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.LakMf6Package.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspLakMf6.PageIndex;
    frameLakMf6.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FLAKMf6_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateLakNode;
var
  Node: TJvPageIndexNode;
begin
  FLAK_Node := nil;
  if frmGoPhast.PhastModel.LakIsSelected
    and (frmGoPhast.ModelSelection  <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.LakPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspLak.PageIndex;
    frameLak.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FLAK_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMnw2Node;
var
  Node: TJvPageIndexNode;
begin
  FMNW2_Node := nil;
  if frmGoPhast.PhastModel.Mnw2IsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.MNW2Package.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMNW2.PageIndex;
    frameMNW2.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMNW2_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMnw1Node;
var
  Node: TJvPageIndexNode;
begin
  FMNW1_Node := nil;
  if frmGoPhast.PhastModel.Mnw1IsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.MNW1Package.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMNW1.PageIndex;
    frameMNW1.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMNW1_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateResNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FRES_Node := nil;
  if frmGoPhast.PhastModel.ResIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.ResPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspRES.PageIndex;
    frameRes.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FRES_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSWR_Rain_Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWR_Rain_Node := nil;
  if frmGoPhast.PhastModel.SwrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Rain in ' +
      frmGoPhast.PhastModel.ModflowPackages.SwrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSWR_Rain.PageIndex;
    frameSWR_Rain.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWR_Rain_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSWR_Reach_Node(
  AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWR_Reach_Node := nil;
  if frmGoPhast.PhastModel.SwrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Reaches in ' +
      frmGoPhast.PhastModel.ModflowPackages.SwrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSwrReaches.PageIndex;
    frameSwrReach.frameSwr.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWR_Reach_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSWR_Stage_Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWR_Stage_Node := nil;
  if frmGoPhast.PhastModel.SwrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.PhastModel.ModflowPackages.SwrPackage.StageSpecification = smArray)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Stage in ' +
      frmGoPhast.PhastModel.ModflowPackages.SwrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSWR_Stage.PageIndex;
    frameSWR_Stage.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWR_Stage_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSwtPestObsNode(
  AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSwtPestObs_Node := nil;
  if frmGoPhast.PhastModel.SwtIsSelected
    and (AScreenObject.Count = 1) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.SwtPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSwtPestObs.PageIndex;
    framePestObsSwt.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSwtPestObs_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateTvkNode;
var
  Node: TJvPageIndexNode;
begin
  FTvkNode := nil;
  if frmGoPhast.PhastModel.TvkIsSelected
    and  (frmGoPhast.ModelSelection = msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.TvkPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspTvk.PageIndex;
    frameScreenObjectTvk.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FTvkNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateTvsNode;
var
  Node: TJvPageIndexNode;
begin
  FTvsNode := nil;
  if frmGoPhast.PhastModel.TvsIsSelected
    and  (frmGoPhast.ModelSelection = msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.TvsPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspTvs.PageIndex;
    frameScreenObjectTvs.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FTvsNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSWR_DirectRunoff_Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWR_DirectRunoff_Node := nil;
  if frmGoPhast.PhastModel.SwrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Direct Runoff in ' +
      frmGoPhast.PhastModel.ModflowPackages.SwrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSWR_DirectRunoff.PageIndex;
    frameSWR_DirectRunoff.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWR_DirectRunoff_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSWR_Evap_Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWR_Evap_Node := nil;
  if frmGoPhast.PhastModel.SwrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Evaporation in ' +
      frmGoPhast.PhastModel.ModflowPackages.SwrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSWR_Evap.PageIndex;
    frameSWR_Evap.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWR_Evap_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSWR_LatInflow_Node(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSWR_LatInflow_Node := nil;
  if frmGoPhast.PhastModel.SwrIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Lateral Inflow in ' +
      frmGoPhast.PhastModel.ModflowPackages.SwrPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspSWR_LatInfl.PageIndex;
    frameSWR_LatInfl.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSWR_LatInflow_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateEtsNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FETS_Node := nil;
  if frmGoPhast.PhastModel.EtsIsSelected
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.EtsPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspETS.PageIndex;
    frameEtsParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FETS_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateEvtNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FEVT_Node := nil;
  if frmGoPhast.PhastModel.EvtIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.EvtPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspEVT.PageIndex;
    frameEvtParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FEVT_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateRchNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FRCH_Node := nil;
  if frmGoPhast.PhastModel.RchIsSelected
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.RchPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspRCH.PageIndex;
    frameRchParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FRCH_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateDrtNode;
var
  Node: TJvPageIndexNode;
begin
  FDRT_Node := nil;
  if frmGoPhast.PhastModel.DrtIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.DrtPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspDRT.PageIndex;
    frameDrtParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FDRT_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateDrnNode;
var
  Node: TJvPageIndexNode;
begin
  FDRN_Node := nil;
  if frmGoPhast.PhastModel.DrnIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.DrnPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspDRN.PageIndex;
    frameDrnParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FDRN_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateRivNode;
var
  Node: TJvPageIndexNode;
begin
  FRIV_Node := nil;
  if frmGoPhast.PhastModel.RivIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.RivPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspRIV.PageIndex;
    frameRivParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FRIV_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateChobNode;
begin
  CreateFluxNode(FChob_Node, frmGoPhast.PhastModel.ModflowPackages.ChobPackage,
    frameChob, jvspCHOB, frmGoPhast.PhastModel.HeadFluxObservations);
end;

procedure TfrmScreenObjectProperties.CreateCSubNode;
var
  Node: TJvPageIndexNode;
begin
  FCSUB_Node := nil;
  if (frmGoPhast.ModelSelection = msModflow2015) and
    frmGoPhast.PhastModel.CSubIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.CsubPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspCSUB.PageIndex;
    frameCSUB.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FCSUB_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateDrobNode;
begin
  CreateFluxNode(FDrob_Node, frmGoPhast.PhastModel.ModflowPackages.DrobPackage,
    frameDrob, jvspDROB, frmGoPhast.PhastModel.DrainObservations);
end;

procedure TfrmScreenObjectProperties.CreateGbobNode;
begin
  CreateFluxNode(FGbob_Node, frmGoPhast.PhastModel.ModflowPackages.GbobPackage,
    frameGbob, jvspGBOB, frmGoPhast.PhastModel.GhbObservations);
end;

procedure TfrmScreenObjectProperties.CreateRvobNode;
begin
  CreateFluxNode(FRvob_Node, frmGoPhast.PhastModel.ModflowPackages.RvobPackage,
    frameRvob, jvspRVOB, frmGoPhast.PhastModel.RiverObservations);
end;

procedure TfrmScreenObjectProperties.CreateStobNode;
begin
  CreateFluxNode(FStob_Node, frmGoPhast.PhastModel.ModflowPackages.StobPackage,
    frameStob, jvspSTOB, frmGoPhast.PhastModel.StreamObservations);
end;

procedure TfrmScreenObjectProperties.CreateMt3d_LktNode;
var
  Node: TJvPageIndexNode;
  Used: Boolean;
begin
  FMt3d_LKT_Node := nil;
  if frmGoPhast.ModelSelection = msModflow2015 then
  begin
    //LKT is not currently supported with MF6.
//    Used := frmGoPhast.PhastModel.LakMf6IsSelected and
//      frmGoPhast.PhastModel.Mt3d_LktIsSelected
    Used := False
  end
  else
  begin
    Used := frmGoPhast.PhastModel.LakIsSelected and
      frmGoPhast.PhastModel.Mt3d_LktIsSelected(nil);
  end;
  if Used then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.Mt3dLkt.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMTD_Lkt.PageIndex;
    frameMT3D_LKT.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3d_LKT_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3d_SftNode;
var
  Node: TJvPageIndexNode;
  Used: Boolean;
begin
  FMt3d_SFT_Node := nil;
  if frmGoPhast.ModelSelection = msModflow2015 then
  begin
    //SFT is not currently supported with MF6.
    Used := False
  end
  else
  begin
    Used := frmGoPhast.PhastModel.SfrIsSelected and
      frmGoPhast.PhastModel.Mt3d_SftIsSelected
  end;
  if Used then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.Mt3dSft.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3D_SFT.PageIndex;
    frameMT3D_SFT.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3d_SFT_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3d_UztRechNode;
var
  Node: TJvPageIndexNode;
  Used: Boolean;
begin
  FMt3d_UZT_Rech_Node := nil;
  if frmGoPhast.ModelSelection = msModflow2015 then
  begin
  // UZT in MODFLOW 6 is different from UZT in MODFLOW-2005.
    Used := False
  end
  else
  begin
    Used := frmGoPhast.PhastModel.UzfIsSelected and
      (frmGoPhast.PhastModel.Mt3d_UztIsSelected
      or frmGoPhast.PhastModel.Mt3dIsSelected)
  end;
  if Used then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, StrRechargeConcIn +
      frmGoPhast.PhastModel.ModflowPackages.Mt3dUnsatTransport.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3D_UZT_Rech.PageIndex;
    frameMt3d_UZT_Rech.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3d_UZT_Rech_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3d_Uzf_Seep_Node;
var
  Node: TJvPageIndexNode;
begin
  FMt3d_Uzf_Seep_Node := nil;
  // UZT is not currently supported with MODFLOW 6.
  if frmGoPhast.PhastModel.UzfSeepageUsed
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, StrUZFSinkConcIn +
      frmGoPhast.PhastModel.ModflowPackages.Mt3dmsSourceSink.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3D_Uzf_Ssm_Conc.PageIndex;
    frameMT3D_Uzf_Ssm_Conc.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3d_Uzf_Seep_Node := Node;
  end;
end;



procedure TfrmScreenObjectProperties.CreateMt3d_UztSatNode;
var
  Node: TJvPageIndexNode;
begin
  FMt3d_UZT_Sat_Node := nil;
  // UZT is not currently supported with MODFLOW 6.
  if frmGoPhast.PhastModel.Mt3d_UztEtIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, StrSatETConcIn +
      frmGoPhast.PhastModel.ModflowPackages.Mt3dUnsatTransport.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3D_UZT_Sat.PageIndex;
    frameMt3d_UZT_Sat.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3d_UZT_Sat_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3d_UztUnsatNode;
var
  Node: TJvPageIndexNode;
begin
  FMt3d_UZT_Unsat_Node := nil;
  // UZT is not currently supported with MODFLOW 6.
  if frmGoPhast.PhastModel.Mt3d_UztEtIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, StrUnsatETConcIn +
      frmGoPhast.PhastModel.ModflowPackages.Mt3dUnsatTransport.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3D_UZT_Unsat.PageIndex;
    frameMt3d_UZT_Unsat.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3d_UZT_Unsat_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3dmsSsmNode;
var
  Node: TJvPageIndexNode;
begin
  FMt3dmsSsm_Node := nil;
  if frmGoPhast.PhastModel.Mt3dmsSsmIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.Mt3dmsSourceSink.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3DMS_SSM.PageIndex;
    frameMT3DMS_SSM.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3dmsSsm_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3dmsTobFluxNode;
var
  Node: TJvPageIndexNode;
begin
  FMt3dmsTobFlux_Node := nil;
  if frmGoPhast.PhastModel.Mt3dmsTobIsSelected
    {and (frmGoPhast.ModelSelection <> msModflow2015)} then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      StrFluxObserv +
      frmGoPhast.PhastModel.ModflowPackages.Mt3dmsTransObs.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3DMS_TOB_Flux.PageIndex;
    frameMt3dmsFluxObs.lblFluxObservations.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3dmsTobFlux_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateMt3dmsTobConcNode;
var
  Node: TJvPageIndexNode;
begin
  FMt3dmsTobConc_Node := nil;
  if frmGoPhast.PhastModel.Mt3dmsTobIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (AScreenObject.Count = 1)
    {and (frmGoPhast.ModelSelection <> msModflow2015)} then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      StrConcentrationObserv +
      frmGoPhast.PhastModel.ModflowPackages.Mt3dmsTransObs.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMT3DMS_TOB_Conc.PageIndex;
    frameMt3dmsTobConc.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMt3dmsTobConc_Node := Node;
  end;
end;


procedure TfrmScreenObjectProperties.CreateModpathNode;
var
  Node: TJvPageIndexNode;
begin
  FModpath_Node := nil;
  if frmGoPhast.PhastModel.MODPATHIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.MODPATH.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspModpath.PageIndex;
//    frameModpath.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FModpath_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateWelNode;
var
  Node: TJvPageIndexNode;
begin
  FWEL_Node := nil;
  if frmGoPhast.PhastModel.WelIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.WelPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspWell.PageIndex;
    frameWellParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FWEL_Node := Node;   
  end;
end;

procedure TfrmScreenObjectProperties.CSubChanged(Sender: TObject);
begin
  if (FCSub_Node <> nil) and (FCSub_Node.StateIndex <> 3) then
  begin
    FCSub_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFarmWelNode;
var
  Node: TJvPageIndexNode;
begin
  FFarmWell_Node := nil;
  if frmGoPhast.PhastModel.FarmProcess3IsSelected
    or frmGoPhast.PhastModel.FarmProcess4WellSelected then
  begin
    if frmGoPhast.PhastModel.FarmProcess3IsSelected then
    begin
      Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format(StrFarmWellsInS,
        [frmGoPhast.PhastModel.ModflowPackages.FarmProcess.PackageIdentifier]))
        as TJvPageIndexNode;
    end
    else
    begin
      Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format(StrFarmWellsInS,
        [frmGoPhast.PhastModel.ModflowPackages.FarmWells4.PackageIdentifier]))
        as TJvPageIndexNode;
    end;

    Node.PageIndex := jvspFarmWell.PageIndex;
    frameFarmWell.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFarmWell_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4AddedDemandNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4AddedDemandNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Added Demand in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4AddedDemand.PageIndex;
    frameFmp4AddedDemand.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4AddedDemandNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4AddedDemandRunoffSplitNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4AddedDemandRunoffSplitNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Added Demand Runoff Split in WATER_BALANCE_SUBREGION')
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4AddedDemandRunoffSplit.PageIndex;
    frameFmp4AddedDemandRunoffSplit.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4AddedDemandRunoffSplitNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4BareEvapNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4BareEvapNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientBareEvapArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Potential Evaporation Bare in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmClimate4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4BareEvap.PageIndex;
    frameFmp4BareEvap.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4BareEvapNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4BarePrecipitationConsumptionFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4BarePrecipitationConsumptionFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Bare Precipitation Consumption Fraction in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmProcess4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4BarePrecipitationConsumptionFraction.PageIndex;
    frameFmp4BarePrecipitationConsumptionFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4BarePrecipitationConsumptionFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4BareRunoffFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4BareRunoffFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientBareRunoffFractionArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Bare Runoff Fraction in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmProcess4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4BareRunoffFraction.PageIndex;
    frameFmp4BareRunoffFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4BareRunoffFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4ConsumptiveUseNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4ConsumptiveUseNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientConsumptiveUseIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Consumptive Use in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4ConsumptiveUse.PageIndex;
    frameFmp4ConsumptiveUse.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4ConsumptiveUseNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4CropCoefficientNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4CropCoefficientNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientCropCoefficientIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Crop Coefficient in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4CropCoefficient.PageIndex;
    frameFmp4CropCoefficient.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4CropCoefficientNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4CropHasSalinityDemandNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4CropHasSalinityDemandNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientCropHasSalinityDemandIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Crop has Salinity Demand in SALINITY_FLUSH_IRRIGATION')
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4CropHasSalinityDemand.PageIndex;
    frameFmp4CropHasSalinityDemand.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4CropHasSalinityDemandNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4DirectRechargeNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4DirectRechargeNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientDirectRechargeArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Direct Recharge in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmClimate4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4DirectRecharge.PageIndex;
    frameFmp4DirectRecharge.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4DirectRechargeNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4PrecipPotConsumptionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4PrecipPotConsumptionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientPrecipPotConsumptionArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Precipitation Potential Consumption in CLIMATE')
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4PrecipPotConsumption.PageIndex;
    frameFmp4PrecipPotConsumption.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4PrecipPotConsumptionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4RootDepthNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4RootDepthNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientRootDepthIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Root Depth in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4RootDepth.PageIndex;
    frameFmp4RootDepth.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4RootDepthNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4TranspirationFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4TranspirationFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientTranspirationFractionIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Transpiration Fraction in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4TranspirationFraction.PageIndex;
    frameFmp4TranspirationFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4TranspirationFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4EfficiencyImprovementNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4EfficiencyImprovementNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientEfficiencyImprovementArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Efficiency Improvement in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmProcess4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4EfficiencyImprovement.PageIndex;
    frameFmp4EfficiencyImprovement.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4EfficiencyImprovementNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4EfficiencyNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4EfficiencyNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientEfficiencyArrayIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Efficiency in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmProcess4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4Efficiency.PageIndex;
    frameFmp4Efficiency.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4EfficiencyNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4EvaporationIrrigationFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4EvaporationIrrigationFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientEvaporationIrrigationFractionIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Evaporation Irrigation Fraction in LAND_USE')
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4EvaporationIrrigationFraction.PageIndex;
    frameFmp4EvaporationIrrigationFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4EvaporationIrrigationFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4FractionOfIrrigToSurfaceWaterNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4FractionOfIrrigToSurfaceWaterNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Frac Excess Irrig to SW in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4FractionOfIrrigToSurfaceWater.PageIndex;
    frameFmp4FractionOfIrrigToSurfaceWater.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4FractionOfIrrigToSurfaceWaterNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4FractionOfPrecipToSurfaceWaterNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4FractionOfPrecipToSurfaceWaterNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Frac Excess Precip to SW in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4FractionOfPrecipToSurfaceWater.PageIndex;
    frameFmp4FractionOfPrecipToSurfaceWater.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4FractionOfPrecipToSurfaceWaterNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4IrrigationNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4IrrigationNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientIrrigationIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Irrigation in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4Irrigation.PageIndex;
    frameFmp4Irrigation.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4IrrigationNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4LandUseAreaFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4LandUseAreaFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientLandUseAreaFractionIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Land Use Area Fraction in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4LandUseAreaFraction.PageIndex;
    frameFmp4LandUseAreaFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4LandUseAreaFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultAddedDemandNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultAddedDemandNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Added Demand in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4AddedDemandMult.PageIndex;
    frameFmp4MultAddedDemand.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultAddedDemandNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultConsumptiveUseNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultConsumptiveUseNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientConsumptiveUseMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Consumptive Use in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4ConsumptiveUseMult.PageIndex;
    frameFmp4MultConsumptiveUse.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultConsumptiveUseNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultCropCoefficientNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultCropCoefficientNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientCropCoefficientMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Crop Coefficients in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4CropCoefficientMult.PageIndex;
    frameFmp4MultCropCoefficients.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultCropCoefficientNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultCropHasSalinityDemandNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultCropHasSalinityDemandNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientCropHasSalinityDemandMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Crop has Salinity Demand in SALINITY_FLUSH_IRRIGATION')
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4CropHasSalinityDemandMult.PageIndex;
    frameFmp4MultCropHasSalinityDemand.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultCropHasSalinityDemandNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultEvaporationIrrigationFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultEvaporationIrrigationFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, 'Evaporation Irrigation Fraction in LAND_USE')
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4EvaporationIrrigationFractionMult.PageIndex;
    frameFmp4MultEvaporationIrrigationFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultEvaporationIrrigationFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultFractionOfIrrigToSurfaceWaterNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultFractionOfIrrigToSurfaceWaterNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Frac Excess Irrig to SW in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4FractionOfIrrigToSurfaceWaterMult.PageIndex;
    frameFmp4MultFractionOfIrrigToSurfaceWater.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultFractionOfIrrigToSurfaceWaterNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultFractionOfPrecipToSurfaceWaterNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultFractionOfPrecipToSurfaceWaterNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Frac Excess Precip to SW in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4FractionOfPrecipToSurfaceWaterMult.PageIndex;
    frameFmp4MultFractionOfPrecipToSurfaceWater.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultFractionOfPrecipToSurfaceWaterNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultIrrigationNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultIrrigationNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientIrrigationMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Irrigaton in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4IrrigationMult.PageIndex;
    frameFmp4MultIrrigation.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultIrrigationNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultLandUseAreaFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultLandUseAreaFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientLandUseAreaFractionMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Land Use Area Fraction in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4LandUseAreaFractionMult.PageIndex;
    frameMultLandUseAreaFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultLandUseAreaFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultRootDepthNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultRootDepthNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientRootDepthMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Root Depth in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4RootDepthMult.PageIndex;
    frameFmp4MultRootDepth.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultRootDepthNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4MultTranspirationFractionNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4MultTranspirationFractionNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientTranspirationFractionMultIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('Transpiration Fraction in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4TranspirationFractionMult.PageIndex;
    frameFmp4MultTranspirationFraction.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4MultTranspirationFractionNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFmp4NrdInfilLocationNode;
var
  Node: TJvPageIndexNode;
begin
  FFmp4NrdInfilLocationNode := nil;
  if frmGoPhast.PhastModel.FarmProcess4TransientNrdInfilLocIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format('NRD Infiltration Location in %s',
      [frmGoPhast.PhastModel.ModflowPackages.FarmSurfaceWater4.PackageIdentifier]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFmp4NrdInfilLoc.PageIndex;
    frameFmp4NrdInfilLocation.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFmp4NrdInfilLocationNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFarmPrecipNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
  Fmp3used: Boolean;
  Farm4Used: Boolean;
  PackageName: string;
begin
  FFarmPrecip_Node := nil;
  Fmp3used := frmGoPhast.PhastModel.FarmProcess3IsSelected
    and (frmGoPhast.PhastModel.ModflowPackages.
    FarmProcess.Precipitation = pSpatiallyDistributed);
  Farm4Used := frmGoPhast.PhastModel.FarmProcess4TransientPrecipIsSelected;
  if (Fmp3used or Farm4Used)
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    if Fmp3used then
    begin
      PackageName := frmGoPhast.PhastModel.ModflowPackages.FarmProcess.PackageIdentifier;
    end
    else
    begin
      Assert(Farm4Used);
      PackageName := frmGoPhast.PhastModel.ModflowPackages.FarmClimate4.PackageIdentifier;
    end;
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format(StrFarmPrecipInS,
      [PackageName]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFarmPrecip.PageIndex;
    frameFarmPrecip.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFarmPrecip_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFarmRefEvapNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
  Farm3Used: Boolean;
  Farm4Used: Boolean;
  PackageName: string;
begin
  FFarmRefEvap_Node := nil;
  Farm3Used := frmGoPhast.PhastModel.FarmProcess3IsSelected
    and (frmGoPhast.PhastModel.ModflowPackages.
    FarmProcess.ConsumptiveUse in
    [cuPotentialAndReferenceET, cuCropCoefficient]);
  Farm4Used := frmGoPhast.PhastModel.FarmProcess4TransientRefEtIsSelected;
  if (Farm3Used or Farm4Used)
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    if Farm3Used then
    begin
      PackageName := frmGoPhast.PhastModel.ModflowPackages.FarmProcess.PackageIdentifier;
    end
    else
    begin
      Assert(Farm4Used);
      PackageName := frmGoPhast.PhastModel.ModflowPackages.FarmClimate4.PackageIdentifier;
    end;
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format(StrFarmRefEvapIn,
      [PackageName]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspFarmRefEvap.PageIndex;
    frameFarmRefEvap.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFarmRefEvap_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFarmCropIDNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
  NodeText: string;
begin
  FFarmCropID_Node := nil;
  if (frmGoPhast.PhastModel.FarmProcess3IsSelected
    or frmGoPhast.PhastModel.FarmProcess4TransientCropsUsed(nil))
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    if frmGoPhast.PhastModel.FarmProcess3IsSelected then
    begin
      NodeText := Format(StrCropIDInS,
        [frmGoPhast.PhastModel.ModflowPackages.FarmProcess.PackageIdentifier]);
    end
    else
    begin
      NodeText := Format(StrLandUseIDInS,
        [frmGoPhast.PhastModel.ModflowPackages.FarmLandUse.PackageIdentifier]);
    end;
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, NodeText)
      as TJvPageIndexNode;
    Node.PageIndex := jvspFarmCropID.PageIndex;
    frameFarmCropID.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FFarmCropID_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFarmIDNode(
  AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FFarmID_Node := nil;
  if AScreenObject.ViewDirection = vdTop then
  begin
    if frmGoPhast.PhastModel.FarmProcess3IsSelected or
      frmGoPhast.PhastModel.FarmProcess4TransientFarmIsSelected then
    begin
      Node := nil;
      if frmGoPhast.PhastModel.FarmProcess3IsSelected then
      begin
        Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format(StrFarmIDInS,
          [frmGoPhast.PhastModel.ModflowPackages.FarmProcess.PackageIdentifier]))
          as TJvPageIndexNode;
      end
      else if frmGoPhast.PhastModel.FarmProcess4TransientFarmIsSelected then
      begin
        Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil, Format(StrFarmIDInS,
          [frmGoPhast.PhastModel.ModflowPackages.FarmProcess4.PackageIdentifier]))
          as TJvPageIndexNode;
      end
      else
      begin
        Assert(False);
      end;
      Node.PageIndex := jvspFarmID.PageIndex;
      frameFarmID.pnlCaption.Caption := Node.Text;
      Node.ImageIndex := 1;
      FFarmID_Node := Node;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.CreateGageNode;
var
  Node: TJvPageIndexNode;
begin
  FGage_Node := nil;
  if frmGoPhast.PhastModel.SfrIsSelected
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      Format(StrGAGEForS, [StringReplace(
      frmGoPhast.PhastModel.ModflowPackages.SfrPackage.PackageIdentifier,
      ':', '', [rfReplaceAll])]))
      as TJvPageIndexNode;
    Node.PageIndex := jvspGAGE.PageIndex;
    lblGageCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FGage_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateGhbNode;
var
  Node: TJvPageIndexNode;
begin
  FGHB_Node := nil;
  if frmGoPhast.PhastModel.GhbIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.GhbBoundary.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspGHB.PageIndex;
    frameGhbParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FGHB_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateGwtCncNode;
var
  Node: TJvPageIndexNode;
begin
  FGwtCnc_Node := nil;
  if frmGoPhast.PhastModel.GwtCncIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.GwtCncPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspGwtCNC.PageIndex;
    frameGwtCNC.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FGwtCnc_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateGwtSrcNode;
var
  Node: TJvPageIndexNode;
begin
  FGwtSrc_Node := nil;
  if frmGoPhast.PhastModel.GwtSrcIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.GwtSrcPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspGwtSrc.PageIndex;
    frameGwtSrc.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FGwtSrc_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraObsNode;
var
  Node: TJvPageIndexNode;
  LocalModel: TPhastModel;
begin
  FSutraObs_Node := nil;
  LocalModel := frmGoPhast.PhastModel;
  if (LocalModel.ModelSelection in SutraSelection)
    and (LocalModel.SutraMesh <> nil)
    and ((LocalModel.SutraMesh.MeshType in [mt2D, mtProfile])
    or (rgElevationCount.ItemIndex in [1,2])) then
  begin
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      StrSutraObservations) as TJvPageIndexNode;
    Node.PageIndex := jvspSutraObservations.PageIndex;
    frameSutraObservations.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraObs_Node := Node;
    frameSutraObservations.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraLakeNode;
var
  Node: TJvPageIndexNode;
begin
  FSutraLake_Node := nil;
  if ShouldCreateSutraLakeBoundary then
  begin
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      'Lake') as TJvPageIndexNode;
    Node.PageIndex := jvspSutraLake.PageIndex;
    frameSutraLake.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraLake_Node := Node;
    frameSutraLake.RefreshNodeState;
  end;
end;


procedure TfrmScreenObjectProperties.CreateSutraSpecPressNode;
var
  Node: TJvPageIndexNode;
  NodeName: string;
begin
  FSutraSpecPressure_Node := nil;
  if ShouldCreateSutraBoundary then
  begin
    NodeName := '';
    case frmGoPhast.PhastModel.SutraOptions.TransportChoice of
      tcSolute, tcEnergy, tcFreezing:
        begin
          NodeName := StrSpecifiedPressure;
        end;
      tcSoluteHead:
        begin
          NodeName := StrSutraSpecifiedHead;
        end;
      else
        Assert(False);
    end;
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      NodeName) as TJvPageIndexNode;
    Node.PageIndex := jvspSutraSpecifiedPressure.PageIndex;
    frameSutraSpecifiedPressure.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraSpecPressure_Node := Node;
    frameSutraSpecifiedPressure.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraSpecTempConcNode;
var
  Node: TJvPageIndexNode;
  TransportChoice: TTransportChoice;
begin
  FSutraSpecTempConc_Node := nil;
  if ShouldCreateSutraBoundary then
  begin
    Node := nil;
    TransportChoice := frmGoPhast.PhastModel.SutraOptions.TransportChoice;
    case TransportChoice of
      tcSolute, tcSoluteHead:
        begin
          Node := jvpltvSutraFeatures.Items.AddChild(nil,
            StrSpecifiedConc) as TJvPageIndexNode;
        end;
      tcEnergy, tcFreezing:
        begin
          Node := jvpltvSutraFeatures.Items.AddChild(nil,
            StrSpecifiedTemp) as TJvPageIndexNode;
        end;
      else Assert(False);
    end;
    Node.PageIndex := jvspSutraSpecTempConc.PageIndex;
    frameSutraSpecTempConc.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraSpecTempConc_Node := Node;
    frameSutraSpecTempConc.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraStateObsNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FSutraStateObsNode := nil;
  if  (frmGoPhast.ModelSelection in SutraSelection)
    and (AScreenObject.Count = 1)// and frmGoPhast.PhastModel.PestUsed
    then
  begin
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      StrSutraStateCalibrat) as TJvPageIndexNode;
    Node.PageIndex := jvspSutraStateObs.PageIndex;
    frameSutraPestObsState.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    Node.StateIndex := 1;
    FSutraStateObsNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraSpecPresObsNode;
begin
  CreateFluxNode(FSutraSpecPresObs_Node, StrSpecPressureObserv,
    frameSutraSpecPresObs, jvspSutraSpecPresObs,
    frmGoPhast.PhastModel.SutraFluxObs.SpecPres);
end;

procedure TfrmScreenObjectProperties.CreateSutraSpecConcObsNode;
begin
  CreateFluxNode(FSutraSpecConcObs_Node, StrSpecifiedConcTemp,
    frameSutraSpecUObs, jvspSutraSpecUObs,
    frmGoPhast.PhastModel.SutraFluxObs.SpecConc);
end;

procedure TfrmScreenObjectProperties.CreateSutraSpecifiedFluidFlowObsNode;
begin
  CreateFluxNode(FSutraSpecFluidFlowObs_Node, StrSpecifiedFlowObser,
    frameSutraSpecifiedFluidFlowObs, jvspSutraSpecFlowObs,
    frmGoPhast.PhastModel.SutraFluxObs.FluidFlow);
end;

procedure TfrmScreenObjectProperties.CreateSutraFluidFluxNode;
var
  Node: TJvPageIndexNode;
begin
  FSutraFluidFlux_Node := nil;
  if ShouldCreateSutraBoundary then
  begin
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      StrFluidFlux) as TJvPageIndexNode;
    Node.PageIndex := jvspSutraFluidFlux.PageIndex;
    frameSutraFluidFlux.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraFluidFlux_Node := Node;
    frameSutraFluidFlux.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraMassEnergyFluxNode;
var
  Node: TJvPageIndexNode;
  TransportChoice: TTransportChoice;
begin
  FSutraMassEnergyFlux_Node := nil;
  if ShouldCreateSutraBoundary then
  begin
    Node := nil;
    TransportChoice := frmGoPhast.PhastModel.SutraOptions.TransportChoice;
    case TransportChoice of
      tcSolute, tcSoluteHead:
        begin
          Node := jvpltvSutraFeatures.Items.AddChild(nil,
            StrMassFlux) as TJvPageIndexNode;
        end;
      tcEnergy, tcFreezing:
        begin
          Node := jvpltvSutraFeatures.Items.AddChild(nil,
            StrEnergyFlux) as TJvPageIndexNode;
        end;
      else Assert(False);
    end;
    Node.PageIndex := jvspSutraMassEnergyFlux.PageIndex;
    frameSutraMassEnergyFlux.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraMassEnergyFlux_Node := Node;
    frameSutraMassEnergyFlux.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraGeneralizedFlowNode;
var
  Node: TJvPageIndexNode;
begin
  FSutraGeneralizedFlowNode := nil;
  if ShouldCreateSutraGeneralBoundary then
  begin
//    Node := nil;
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      'Generalized Flow') as TJvPageIndexNode;
    Node.PageIndex := jvspGeneralizedFlow.PageIndex;
    frameSutraGeneralizedFlowBoundary.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraGeneralizedFlowNode := Node;
    frameSutraGeneralizedFlowBoundary.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraGeneralizedTransportNode;
var
  Node: TJvPageIndexNode;
begin
  FSutraGeneralizedTransportNode := nil;
  if ShouldCreateSutraGeneralBoundary then
  begin
//    Node := nil;
    Node := jvpltvSutraFeatures.Items.AddChild(nil,
      'Generalized Transport') as TJvPageIndexNode;
    Node.PageIndex := jvspGeneralizedTransport.PageIndex;
    frameSutraGeneralizeTransBoundary.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FSutraGeneralizedTransportNode := Node;
    frameSutraGeneralizeTransBoundary.RefreshNodeState;
  end;
end;

procedure TfrmScreenObjectProperties.CreateSutraGenFlowObsNode;
begin
  CreateFluxNode(FSutraGenFlowObs_Node, StrGeneralizedFlowObs,
    frameSutraGenFlowObs, jvspSutraGenFlowObs,
    frmGoPhast.PhastModel.SutraFluxObs.GenFlow);
end;

procedure TfrmScreenObjectProperties.CreateSutraGenTransObsNode;
begin
  CreateFluxNode(FSutraGenTransObs_Node, StrGeneralizedTranspor,
    frameSutraGenTransObs, jvspSutraGenTransObs,
    frmGoPhast.PhastModel.SutraFluxObs.GenTrans);
end;

procedure TfrmScreenObjectProperties.CreateMawNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FMAW_Node := nil;
  if (frmGoPhast.ModelSelection = msModflow2015) and
    frmGoPhast.PhastModel.MawIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (AScreenObject.Count = 1) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.MAWPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMAW.PageIndex;
    frameMAW.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMAW_Node := Node;
  end;
end;


procedure TfrmScreenObjectProperties.CreateMf6Obs_Node(
  AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FMf6Obs_Node := nil;
  if frmGoPhast.PhastModel.Mf6ObsIsSelected
    and (AScreenObject.ViewDirection = vdTop) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.Mf6ObservationUtility.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspMf6Obs.PageIndex;
    frameObsMf6.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FMf6Obs_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateChdNode;
var
  Node: TJvPageIndexNode;
begin
  FCHD_Node := nil;
  if frmGoPhast.PhastModel.ChdIsSelected then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.ChdBoundary.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspCHD.PageIndex;
    frameChdParam.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FCHD_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateCfpPipeNode(AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FCfpPipe_Node := nil;
  if frmGoPhast.PhastModel.CfpPipesSelected(nil)
    and (AScreenObject.Count > 1) and not AScreenObject.Closed
    {and (AScreenObject.ElevationCount = ecOne)}
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.ConduitFlowProcess.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspCfpPipes.PageIndex;
    frameCfpPipes.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FCfpPipe_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateCfpFixedHeadNode(
  AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FCfpFixedHead_Node := nil;
  if frmGoPhast.PhastModel.CfpPipesSelected(nil)
    and (AScreenObject.ElevationCount in [ecOne, ecTwo])
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    if frmGoPhast.ModelSelection = msModflowOwhm2 then
    begin
      Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
        'CFP: Boundary Conditions')
        as TJvPageIndexNode;
    end
    else
    begin
      Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
        StrCFPFixedHeads)
        as TJvPageIndexNode;
    end;
    Node.PageIndex := jvspCfpFixedHeads.PageIndex;
    frameCfpFixedHeads.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FCfpFixedHead_Node := Node;
  end;
end;

procedure TfrmScreenObjectProperties.CreateRipNode(
  AScreenObject: TScreenObject);
var
  Node: TJvPageIndexNode;
begin
  FRipNode := nil;
  if frmGoPhast.PhastModel.RipIsSelected
    and (AScreenObject.ViewDirection = vdTop)
    and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    Node := jvtlModflowBoundaryNavigator.Items.AddChild(nil,
      frmGoPhast.PhastModel.ModflowPackages.RipPackage.PackageIdentifier)
      as TJvPageIndexNode;
    Node.PageIndex := jvspRip.PageIndex;
    frameRip.pnlCaption.Caption := Node.Text;
    Node.ImageIndex := 1;
    FRipNode := Node;
  end;
end;

procedure TfrmScreenObjectProperties.UpdateNodeState(Node: TJvPageIndexNode);
begin
  if IsLoaded  and (Node <> nil) then
  begin
    if Node.StateIndex = 1 then
    begin
      Node.StateIndex := 2;
    end;
  end;
end;

function TfrmScreenObjectProperties.ShouldStoreBoundary(Node: TJvPageIndexNode;
  Boundary: TFormulaProperty): boolean;
begin
  result := (Node <> nil) and ((Node.StateIndex = 2)
    or ((Node.StateIndex = 3) and Boundary.Used));
end;

procedure TfrmScreenObjectProperties.GetSwrReaches(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwrReachBoundary;
begin
  if not frmGoPhast.PhastModel.SwrIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowSwrReaches;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FSWR_Reach_Node <> nil then
  begin
    FSWR_Reach_Node.StateIndex := Ord(State)+1;
  end;
  frameSwrReach.GetData(FNewProperties, FSWR_Reach_Node);

end;

procedure TfrmScreenObjectProperties.GetSwiObsBoundary(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSwiObsBoundary;
begin
  if not frmGoPhast.PhastModel.SwiObsUsed(nil) then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowSwiObservations;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FSWiObs_Node <> nil then
  begin
    FSWiObs_Node.StateIndex := Ord(State)+1;
  end;
  frameSwiObs.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetSfrBoundary(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TSfrBoundary;
begin
  if not frmGoPhast.PhastModel.SfrIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowSfrBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FSFR_Node <> nil then
  begin
    FSFR_Node.StateIndex := Ord(State)+1;
  end;
  frameScreenObjectSFR.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetSfr6Boundary(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TSfrMf6Boundary;
begin
  if not frmGoPhast.PhastModel.Sfr6IsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowSfr6Boundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FSFR6_Node <> nil then
  begin
    FSFR6_Node.StateIndex := Ord(State)+1;
  end;
  frameScreenObjectSfr6.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetStrBoundary(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TStrBoundary;
begin
  if not frmGoPhast.PhastModel.StrIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowStrBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FSTR_Node <> nil then
  begin
    FSTR_Node.StateIndex := Ord(State)+1;
  end;
  frameScreenObjectSTR.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetMnw1Boundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMnw1Boundary;
begin
  if not frmGoPhast.PhastModel.Mnw1IsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowMnw1Boundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FMNW1_Node <> nil then
  begin
    FMNW1_Node.StateIndex := Ord(State)+1;
  end;
  frameMNW1.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetMnw2Boundary(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMnw2Boundary;
begin
  if not frmGoPhast.PhastModel.Mnw2IsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowMnw2Boundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FMNW2_Node <> nil then
  begin
    FMNW2_Node.StateIndex := Ord(State)+1;
  end;
  frameMNW2.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFhbHeadBoundary
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFhbHeadBoundary;
begin
  if not frmGoPhast.PhastModel.FhbIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFhbHeadBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFhbHead_Node <> nil then
  begin
    FFhbHead_Node.StateIndex := Ord(State)+1;
  end;
  frameFhbHead.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFarmPrecip
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmpPrecipBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess3IsSelected
    and not frmGoPhast.PhastModel.FarmProcess4TransientPrecipIsSelected
    then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpPrecip;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FFarmPrecip_Node <> nil then
  begin
    FFarmPrecip_Node.StateIndex := Ord(State)+1;
  end;
  frameFarmPrecip.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFarmRefEvap
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmpRefEvapBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess3IsSelected
    and not frmGoPhast.PhastModel.FarmProcess4TransientRefEtIsSelected
//    and not frmGoPhast.PhastModel.FarmProcess4TransientFarmIsSelected
    then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpRefEvap;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FFarmRefEvap_Node <> nil then
  begin
    FFarmRefEvap_Node.StateIndex := Ord(State)+1;
  end;
  frameFarmRefEvap.GetData(FNewProperties);

//  if FFarmCropID_Node <> nil then
//  begin
//    FFarmCropID_Node.StateIndex := Ord(State)+1;
//  end;
//  frameFarmCropID.GetData(FNewProperties);

  if frmGoPhast.PhastModel.FarmProcess3IsSelected then
  begin
    if FFarmID_Node <> nil then
    begin
      FFarmID_Node.StateIndex := Ord(State)+1;
    end;
    frameFarmID.GetData(FNewProperties);
  end;
end;

procedure TfrmScreenObjectProperties.GetCfpPipes
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TCfpPipeBoundary;
begin
  if not frmGoPhast.PhastModel.CfpIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowCfpPipes;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FCfpPipe_Node <> nil then
  begin
    FCfpPipe_Node.StateIndex := Ord(State)+1;
  end;
  frameCfpPipes.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetCfpFixedHeads
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TCfpFixedBoundary;
begin
  if not frmGoPhast.PhastModel.CfpIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowCfpFixedHeads;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FCfpFixedHead_Node <> nil then
  begin
    FCfpFixedHead_Node.StateIndex := Ord(State)+1;
  end;
  frameCfpFixedHeads.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetRip
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TRipBoundary;
begin
  if not frmGoPhast.PhastModel.RipIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowRipBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FRipNode <> nil then
  begin
    FRipNode.StateIndex := Ord(State)+1;
  end;
  frameRip.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFarmCropID
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmpCropIDBoundary;
begin
  if (not frmGoPhast.PhastModel.FarmProcess3IsSelected)
   and (not frmGoPhast.PhastModel.FarmProcess4TransientCropsUsed(nil)) then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpCropID;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FFarmCropID_Node <> nil then
  begin
    FFarmCropID_Node.StateIndex := Ord(State)+1;
  end;
  frameFarmCropID.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFarmID(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmpFarmIDBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess3IsSelected
    and not frmGoPhast.PhastModel.FarmProcess4TransientFarmIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpFarmID;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FFarmID_Node <> nil then
  begin
    FFarmID_Node.StateIndex := Ord(State)+1;
  end;
  frameFarmID.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFhbFlowBoundary
  (const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFhbFlowBoundary;
begin
  if not frmGoPhast.PhastModel.FhbIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFhbFlowBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFhbFlow_Node <> nil then
  begin
    FFhbFlow_Node.StateIndex := Ord(State)+1;
  end;
  frameFhbFlow.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetHfbBoundary(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: THfbBoundary;
begin
  if not frmGoPhast.PhastModel.HfbIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowHfbBoundary;
    if frmGoPhast.ModelSelection = msModflow2015 then
    begin
      UpdateHfbBoundaryState(Boundary, ScreenObjectIndex, State);
    end
    else
    begin
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
  end;
  if FHFB_Node <> nil then
  begin
    FHFB_Node.StateIndex := Ord(State)+1;
  end;
  if frmGoPhast.ModelSelection = msModflow2015 then
  begin
    frameHfbMf6.GetData(FNewProperties);
  end
  else
  begin
    frameHfbBoundary.GetData(FNewProperties);
  end;
end;

procedure TfrmScreenObjectProperties.GetChildModels(const ScreenObjectList: TList);
var
  AScreenObject: TScreenObject;
  ItemPosition: Integer;
begin
  if clbChildModels.Enabled then
  begin
    AScreenObject := ScreenObjectList[0];
    EnableChildModelList(AScreenObject);
    ItemPosition := FChildModels.IndexOf(AScreenObject.ChildModel)+1;
    clbChildModels.Checked[ItemPosition] := True;
  end;
end;


procedure TfrmScreenObjectProperties.GetCncBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  GwtCncBoundary: TCncBoundary;
begin
  if not frmGoPhast.PhastModel.GwtCncIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    GwtCncBoundary := AScreenObject.GwtCncBoundary;
    UpdateBoundaryState(GwtCncBoundary, ScreenObjectIndex, State);
  end;
  if FGwtCnc_Node <> nil then
  begin
    FGwtCnc_Node.StateIndex := Ord(State)+1;
  end;
  frameGwtCnc.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetHydmod(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  HydmodData: THydmodData;
begin
  if not frmGoPhast.PhastModel.HydmodIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    HydmodData := AScreenObject.ModflowHydmodData;
    UpdateBoundaryState(HydmodData, ScreenObjectIndex, State);
  end;
  if Fhydmod_Node <> nil then
  begin
    Fhydmod_Node.StateIndex := Ord(State)+1;
  end;
  frameHydmod.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetHeadObservations(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: THobBoundary;
begin
  if not frmGoPhast.PhastModel.HobIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowHeadObservations;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FHOB_Node <> nil then
  begin
    FHOB_Node.StateIndex := Ord(State)+1;
  end;
  frameHeadObservations.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetMt3dConcObservations(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dmsTransObservations;
begin
  if not frmGoPhast.PhastModel.Mt3dmsTobIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dmsTransObservations;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FMt3dmsTobConc_Node <> nil then
  begin
    FMt3dmsTobConc_Node.StateIndex := Ord(State)+1;
  end;
  frameMt3dmsTobConc.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.UpdateHfbBoundaryState(
  Boundary: THfbBoundary; ScreenObjectIndex: Integer;
  var State: TCheckBoxState);
begin
  if Boundary = nil then
  begin
    if ScreenObjectIndex = 0 then
    begin
      State := cbUnchecked;
    end
    else
    begin
      if State = cbChecked then
      begin
        State := cbGrayed;
      end;
    end;
  end
  else
  begin
    if Boundary.UsedMf6 then
    begin
      if ScreenObjectIndex = 0 then
      begin
        State := cbChecked;
      end
      else
      begin
        if State = cbUnchecked then
        begin
          State := cbGrayed;
        end;
      end;
    end
    else
    begin
      if ScreenObjectIndex = 0 then
      begin
        State := cbUnchecked;
      end
      else
      begin
        if State = cbChecked then
        begin
          State := cbGrayed;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.UpdateBoundaryState(
  Boundary: TFormulaProperty; ScreenObjectIndex: Integer;
  var State: TCheckBoxState);
begin
  if Boundary = nil then
  begin
    if ScreenObjectIndex = 0 then
    begin
      State := cbUnchecked;
    end
    else
    begin
      if State = cbChecked then
      begin
        State := cbGrayed;
      end;
    end;
  end
  else
  begin
    if Boundary.Used then
    begin
      if ScreenObjectIndex = 0 then
      begin
        State := cbChecked;
      end
      else
      begin
        if State = cbUnchecked then
        begin
          State := cbGrayed;
        end;
      end;
    end
    else
    begin
      if ScreenObjectIndex = 0 then
      begin
        State := cbUnchecked;
      end
      else
      begin
        if State = cbChecked then
        begin
          State := cbGrayed;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetUzfCollection(
  TimeList: TParameterTimeList;
  ScreenObjectList: TList;
  ColumnOffset: Integer; DataGrid: TRbwDataGrid4;
  Method: TGetBoundaryCollectionEvent);
var
  BoundaryIndex: Integer;
  RowIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  TimeIndex: Integer;
  AnotherBoundary: TUzfBoundary;
  ScreenObjectIndex: Integer;
  ValuesIdentical: Boolean;
  AnotherValues: TCustomMF_BoundColl;
  AScreenObject: TScreenObject;
  Boundary :TModflowBoundary;
  Values: TCustomMF_BoundColl;
begin
  if not frmGoPhast.PhastModel.UzfIsSelected then
  begin
    Exit;
  end;
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowUzfBoundary;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Method(Boundary);
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowUzfBoundary;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      AnotherValues := Method(AnotherBoundary);
      ValuesIdentical := Values.IsSame(AnotherValues);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime)
        + 1 +  + PestRowOffset;
      Assert(RowIndex >= 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex] :=
          Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

function TfrmScreenObjectProperties.DataSetsSpecified: Boolean;
var
  Index: Integer;
  Edit: TScreenObjectDataEdit;
begin
  result := False;
  for Index := 0 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    if Edit.Used <> cbUnchecked then
    begin
      result := True;
      Exit;
    end;
  end;
end;

destructor TfrmScreenObjectProperties.Destroy;
begin

  try
    inherited;
  except on EExternalException do
    begin
      // work around for bug in Microsoft OpenGL driver on 64 bit Windows.
      // do nothing;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.UpdateDrtReturnFlowLabels(Sender: TObject);
begin
  if Sender = rdeDrtLay then
  begin
    if rdeDrtLay.Text = '-1' then
    begin
      lblDrtRow.Caption := 'Farm';
      rdeDrtCol.Enabled := False;
    end
    else if rdeDrtLay.Text = '-2' then
    begin
      lblDrtRow.Caption := 'SWR Reach';
      rdeDrtCol.Enabled := False;
    end
    else
    begin
      lblDrtRow.Caption := 'Row';
      rdeDrtCol.Enabled := True;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.EnableWellTabfile;
begin
  frameWellParam.fedTabfile.ShowButton := ((FWEL_Node <> nil)
    and (FWEL_Node.StateIndex <> 1))
    and frmGoPhast.PhastModel.ModflowPackages.WelPackage.UseTabFilesInThisModel;
  frameWellParam.fedTabfile.ReadOnly :=
    not frameWellParam.fedTabfile.ShowButton;
end;

function TfrmScreenObjectProperties.EtsColCount: Integer;
begin
  result := 6;
  if frmGoPhast.PhastModel.EtsTimeVaryingLayers then
  begin
    Inc(result);
  end;
  result := result + (frmGoPhast.PhastModel.ModflowPackages.EtsPackage.SegmentCount - 1) * 2;
  for var Index := 1 to frameEtsParam.clbParameters.Items.Count - 1 do
  begin
    if frameEtsParam.clbParameters.State[Index] <> cbUnchecked then
    begin
      Inc(result,2);
    end;
//    if frmGoPhast.PhastModel.EtsTimeVaryingLayers then
//    begin
//      Inc(result);
//    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetModflowBoundaryCollection(
  DataGrid: TRbwDataGrid4; ValuesFunction: TGetBoundaryCollectionEvent;
  ColumnOffset: Integer; ScreenObjectList: TList; Parameter: TParameterType;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowParamBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowParamBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
begin
  DataGrid.BeginUpdate;
  try
    AScreenObject := ScreenObjectList[0];
    Boundary := AScreenObject.GetMfBoundary(Parameter);
    if Boundary = nil then
    begin
      Values := nil;
    end
    else
    begin
      Values := ValuesFunction(Boundary);
    end;
    ValuesIdentical := True;
    for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      AnotherBoundary := AScreenObject.GetMfBoundary(Parameter);
      if (Boundary = nil) and (AnotherBoundary = nil) then
      begin
        ValuesIdentical := True;
      end
      else if (Boundary = nil) or (AnotherBoundary = nil) then
      begin
        ValuesIdentical := False;
      end
      else
      begin
        ValuesIdentical := Values.IsSame(ValuesFunction(AnotherBoundary));
      end;
      if not ValuesIdentical then
      begin
        break;
      end;
    end;
    if ValuesIdentical and (Values <> nil) then
    begin
      for TimeIndex := 0 to Values.Count - 1 do
      begin
        Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
        RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1 + PestRowOffset;
        Assert(RowIndex >= 1 + PestRowOffset);
        for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
        begin
          DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
            := Item.BoundaryFormula[BoundaryIndex];
        end;
      end;
    end;
  finally
    DataGrid.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.GetReservoirBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TModflowBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  Method: TPestParamMethod;
  Identical: Boolean;
  First: Boolean;
  Modifier: string;
begin
  AScreenObject := ScreenObjectList[0];
  Boundary := AScreenObject.ModflowResBoundary;
  if Boundary = nil then
  begin
    Values := nil;
  end
  else
  begin
    Values := Boundary.Values;
  end;
  ValuesIdentical := True;
  for ScreenObjectIndex := 1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowResBoundary;
    if (Boundary = nil) and (AnotherBoundary = nil) then
    begin
      ValuesIdentical := True;
    end
    else if (Boundary = nil) or (AnotherBoundary = nil) then
    begin
      ValuesIdentical := False;
    end
    else
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;

//  GetPestModifiers(frameRes, Parameter, ScreenObjectList);
  for BoundaryIndex := 0 to 1 do
  begin
    Identical := True;
    First := True;
    Method := ppmMultiply;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowResBoundary;
      if (Boundary <> nil) and Boundary.Used then
      begin
        if First then
        begin
          Method := Boundary.PestBoundaryMethod[BoundaryIndex];
          First := False;
        end
        else
        begin
          Identical := Method = Boundary.PestBoundaryMethod[BoundaryIndex];
          if not Identical then
          begin
            break;
          end;
        end;
      end;
    end;
    if Identical and not First then
    begin
      frameRes.PestMethod[ColumnOffset + BoundaryIndex] := Method;
    end
    else
    begin
      frameRes.PestMethodAssigned[ColumnOffset + BoundaryIndex] := False;
    end;
  end;

  for BoundaryIndex := 0 to 1 do
  begin
    Identical := True;
    First := True;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowResBoundary;
      if (Boundary <> nil) and Boundary.Used then
      begin
        if First then
        begin
          Modifier := Boundary.PestBoundaryFormula[BoundaryIndex];
          First := False;
        end
        else
        begin
          Identical := Modifier = Boundary.PestBoundaryFormula[BoundaryIndex];
          if not Identical then
          begin
            break;
          end;
        end;
      end;
    end;
    if Identical and not First then
    begin
      frameRes.PestModifier[ColumnOffset + BoundaryIndex] := Modifier;
    end
    else
    begin
      frameRes.PestModifierAssigned[ColumnOffset + BoundaryIndex] := False;
    end;
  end;

  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1 +  + PestRowOffset;
      Assert(RowIndex >= 1+ + PestRowOffset);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dmsChemBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dmsConcBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TMt3dmsConcBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  FirstIndex: integer;
  ColIndex: Integer;
begin
  FirstIndex := -1;
  Boundary := nil;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dmsConcBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      FirstIndex := ScreenObjectIndex;
      break;
    end;
  end;
  if FirstIndex < 0 then
  begin
    frameMT3DMS_SSM.seNumberOfTimes.AsInteger := 0;
    if Assigned(frameMT3DMS_SSM.seNumberOfTimes.OnChange) then
    begin
      frameMT3DMS_SSM.seNumberOfTimes.OnChange(frameMT3DMS_SSM.seNumberOfTimes);
    end;
    Exit;
  end;
  for ColIndex := ColumnOffset to DataGrid.ColCount - 1 do
  begin
    for RowIndex := DataGrid.FixedRows to DataGrid.RowCount - 1 do
    begin
      DataGrid.Cells[ColIndex,RowIndex] := '';
    end;
  end;
  Assert(Boundary <> nil);
  Values := Boundary.Values;
  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.Mt3dmsConcBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1 + PestRowOffset;
      Assert(RowIndex >= 1 + PestRowOffset);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dmsUztRechBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUztRchConcBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TMt3dUztRchConcBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  FirstIndex: integer;
  ColIndex: Integer;
begin
  FirstIndex := -1;
  Boundary := nil;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dUzfRechConc;
    if (Boundary <> nil) and Boundary.Used then
    begin
      FirstIndex := ScreenObjectIndex;
      break;
    end;
  end;
  if FirstIndex < 0 then
  begin
    frameMt3d_UZT_Rech.seNumberOfTimes.AsInteger := 0;
    if Assigned(frameMt3d_UZT_Rech.seNumberOfTimes.OnChange) then
    begin
      frameMt3d_UZT_Rech.seNumberOfTimes.OnChange(frameMt3d_UZT_Rech.seNumberOfTimes);
    end;
    Exit;
  end;
  for ColIndex := ColumnOffset to DataGrid.ColCount - 1 do
  begin
    for RowIndex := DataGrid.FixedRows to DataGrid.RowCount - 1 do
    begin
      DataGrid.Cells[ColIndex,RowIndex] := '';
    end;
  end;
  Assert(Boundary <> nil);
  Values := Boundary.Values;
  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.Mt3dUzfRechConc;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1+PestRowOffset;
      Assert(RowIndex >= 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dUzfSeepageConcCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUzSsmSinkConcBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TMt3dUzSsmSinkConcBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  FirstIndex: integer;
  ColIndex: Integer;
begin
  FirstIndex := -1;
  Boundary := nil;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dUzSsmSinkConcBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      FirstIndex := ScreenObjectIndex;
      break;
    end;
  end;
  if FirstIndex < 0 then
  begin
    frameMT3D_Uzf_Ssm_Conc.seNumberOfTimes.AsInteger := 0;
    if Assigned(frameMT3D_Uzf_Ssm_Conc.seNumberOfTimes.OnChange) then
    begin
      frameMT3D_Uzf_Ssm_Conc.seNumberOfTimes.OnChange(frameMT3D_Uzf_Ssm_Conc.seNumberOfTimes);
    end;
    Exit;
  end;
  for ColIndex := ColumnOffset to DataGrid.ColCount - 1 do
  begin
    for RowIndex := DataGrid.FixedRows to DataGrid.RowCount - 1 do
    begin
      DataGrid.Cells[ColIndex,RowIndex] := '';
    end;
  end;
  Assert(Boundary <> nil);
  Values := Boundary.Values;
  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.Mt3dUzSsmSinkConcBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1;
      Assert(RowIndex >= 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dmsUztUnsatBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUztUnsatEtConcBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TMt3dUztUnsatEtConcBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  FirstIndex: integer;
  ColIndex: Integer;
begin
  FirstIndex := -1;
  Boundary := nil;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dUztUnsatEtConcBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      FirstIndex := ScreenObjectIndex;
      break;
    end;
  end;
  if FirstIndex < 0 then
  begin
    frameMt3d_UZT_Unsat.seNumberOfTimes.AsInteger := 0;
    if Assigned(frameMt3d_UZT_Unsat.seNumberOfTimes.OnChange) then
    begin
      frameMt3d_UZT_Unsat.seNumberOfTimes.OnChange(frameMt3d_UZT_Unsat.seNumberOfTimes);
    end;
    Exit;
  end;
  for ColIndex := ColumnOffset to DataGrid.ColCount - 1 do
  begin
    for RowIndex := DataGrid.FixedRows to DataGrid.RowCount - 1 do
    begin
      DataGrid.Cells[ColIndex,RowIndex] := '';
    end;
  end;
  Assert(Boundary <> nil);
  Values := Boundary.Values;
  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.Mt3dUztUnsatEtConcBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1+PestRowOffset;
      Assert(RowIndex >= 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dmsUztSatBoundaryCollection(
  DataGrid: TRbwDataGrid4; ColumnOffset: Integer; ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUztSatEtConcBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TMt3dUztSatEtConcBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  FirstIndex: integer;
  ColIndex: Integer;
begin
  FirstIndex := -1;
  Boundary := nil;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dUztSatEtConcBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      FirstIndex := ScreenObjectIndex;
      break;
    end;
  end;
  if FirstIndex < 0 then
  begin
    frameMt3d_UZT_Unsat.seNumberOfTimes.AsInteger := 0;
    if Assigned(frameMt3d_UZT_Unsat.seNumberOfTimes.OnChange) then
    begin
      frameMt3d_UZT_Unsat.seNumberOfTimes.OnChange(frameMt3d_UZT_Unsat.seNumberOfTimes);
    end;
    Exit;
  end;
  for ColIndex := ColumnOffset to DataGrid.ColCount - 1 do
  begin
    for RowIndex := DataGrid.FixedRows to DataGrid.RowCount - 1 do
    begin
      DataGrid.Cells[ColIndex,RowIndex] := '';
    end;
  end;
  Assert(Boundary <> nil);
  Values := Boundary.Values;
  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.Mt3dUztSatEtConcBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1+PestRowOffset;
      Assert(RowIndex >= 1);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetLakeBoundaryCollection(
  ScreenObjectList: TList;
  TimeList: TParameterTimeList);
var
  RowIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TLakBoundary;
  Values: TCustomMF_BoundColl;
  ValuesIdentical: Boolean;
  ScreenObjectIndex: Integer;
  AnotherBoundary: TLakBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  BoundaryIndex: Integer;
  FirstIndex: integer;
  ColIndex: Integer;
  ExternalLakeTable: TExternalLakeTable;
  BathItem: TLakeTableItem;
  Index: integer;
  DataGrid: TRbwDataGrid4;
  ColumnOffset: Integer;
begin
  DataGrid := frameLak.rdgModflowBoundary;
  ColumnOffset := 2;

  for BoundaryIndex := LakMinimumStagePosition to LakWithdrawalPosition do
  begin
    frameLak.PestMethod[BoundaryIndex + ColumnOffset] :=
      TLakBoundary.DefaultBoundaryMethod(BoundaryIndex);
  end;

  frameLak.tabBathymetry.TabVisible := (ScreenObjectList.Count = 1)
    and frmGoPhast.PhastModel.LakBathymetryUsed;
  frameLak.tabLakeProperties.TabVisible :=
    frameLak.tabBathymetry.TabVisible or frameLak.tabObservations.TabVisible;
  frameLak.pcLake.ActivePageIndex := 0;
  FirstIndex := -1;
  Boundary := nil;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowLakBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      FirstIndex := ScreenObjectIndex;
      break;
    end;
  end;
  if FirstIndex < 0 then
  begin
    frameLak.seNumberOfTimes.AsInteger := 0;
    if Assigned(frameLak.seNumberOfTimes.OnChange) then
    begin
      frameLak.seNumberOfTimes.OnChange(frameLak.seNumberOfTimes);
    end;
    frameLak.rdeLakeID.Text := '';
    frameLak.rdeInitialStage.Text := '';
    frameLak.rdeCenterLake.Text := '';
    frameLak.rdeSill.Text := '';
    frameLak.rdgLakeTable.BeginUpdate;
    try
      for Index := 1 to frameLak.rdgLakeTable.RowCount - 1 do
      begin
        frameLak.rdgLakeTable.Cells[Ord(bcStage), Index] := '';
        frameLak.rdgLakeTable.Cells[Ord(bcVolume), Index] := '';
        frameLak.rdgLakeTable.Cells[Ord(bcSurfaceArea), Index] := '';
      end;
    finally
      frameLak.rdgLakeTable.EndUpdate;
    end;

    Exit;
  end;
  for ColIndex := ColumnOffset to DataGrid.ColCount - 1 do
  begin
    for RowIndex := DataGrid.FixedRows to DataGrid.RowCount - 1 do
    begin
      DataGrid.Cells[ColIndex,RowIndex] := '';
    end;
  end;
  Assert(Boundary <> nil);
  Values := Boundary.Values;

  for BoundaryIndex := LakMinimumStagePosition to LakWithdrawalPosition do
  begin
    frameLak.PestModifier[BoundaryIndex + ColumnOffset] :=
      Boundary.PestBoundaryFormula[BoundaryIndex];
    frameLak.PestMethod[BoundaryIndex + ColumnOffset] :=
      Boundary.PestBoundaryMethod[BoundaryIndex];
  end;

  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowLakBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      for BoundaryIndex := LakMinimumStagePosition to LakWithdrawalPosition do
      begin
        if Boundary.PestBoundaryFormula[BoundaryIndex] <>
          AnotherBoundary.PestBoundaryFormula[BoundaryIndex] then
        begin
          frameLak.PestModifierAssigned[BoundaryIndex + ColumnOffset] := False;
        end;
        if Boundary.PestBoundaryMethod[BoundaryIndex] <>
          AnotherBoundary.PestBoundaryMethod[BoundaryIndex] then
        begin
          frameLak.PestMethodAssigned[BoundaryIndex + ColumnOffset] := False;
        end;
      end;
    end;
  end;

  ValuesIdentical := True;
  if ScreenObjectList.Count = 1 then
  begin
    frameLak.framePestObsLak.InitializeControls;
    frameLak.framePestObsLak.SpecifyObservationTypes(LakeGageOutputTypes);
    frameLak.framePestObsLak.GetData(Boundary.Observations);
  end;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowLakBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Values.IsSame(AnotherBoundary.Values);
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Values <> nil) then
  begin
    for TimeIndex := 0 to Values.Count - 1 do
    begin
      Item := Values[TimeIndex] as TCustomModflowBoundaryItem;
      RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1+PestRowOffset;
      Assert(RowIndex >= 1+PestRowOffset);
      for BoundaryIndex := 0 to Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        DataGrid.Cells[ColumnOffset + BoundaryIndex, RowIndex]
          := Item.BoundaryFormula[BoundaryIndex];
      end;
    end;
  end;

  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowLakBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Boundary.InitialStage = AnotherBoundary.InitialStage;
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Boundary <> nil) then
  begin
    frameLak.rdeInitialStage.Text := FloatToStr(Boundary.InitialStage);
  end
  else
  begin
    frameLak.rdeInitialStage.Text := '';
  end;

  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowLakBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Boundary.CenterLake = AnotherBoundary.CenterLake;
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Boundary <> nil) then
  begin
    frameLak.rdeCenterLake.Text := IntToStr(Boundary.CenterLake);
  end
  else
  begin
    frameLak.rdeCenterLake.Text := '';
  end;

  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowLakBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Boundary.Sill = AnotherBoundary.Sill;
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Boundary <> nil) then
  begin
    frameLak.rdeSill.Text := FloatToStr(Boundary.Sill);
  end
  else
  begin
    frameLak.rdeSill.Text := '';
  end;

  ValuesIdentical := True;
  for ScreenObjectIndex := FirstIndex+1 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    AnotherBoundary := AScreenObject.ModflowLakBoundary;
    if (AnotherBoundary <> nil) and AnotherBoundary.Used then
    begin
      ValuesIdentical := Boundary.LakeID = AnotherBoundary.LakeID;
    end;
    if not ValuesIdentical then
    begin
      break;
    end;
  end;
  if ValuesIdentical and (Boundary <> nil) then
  begin
    frameLak.rdeLakeID.Text := IntToStr(Boundary.LakeID);
  end
  else
  begin
    frameLak.rdeLakeID.Text := '';
  end;

  if frameLak.tabBathymetry.TabVisible then
  begin
    AScreenObject := ScreenObjectList[0];
    Boundary := AScreenObject.ModflowLakBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      ExternalLakeTable := Boundary.ExternalLakeTable;
      frameLak.rgBathChoice.ItemIndex := Ord(ExternalLakeTable.LakeTableChoice);
      frameLak.feLakeBathymetry.FileName := ExternalLakeTable.FullLakeTableFileName;
      frameLak.SetFeLakeBathymetryColor(frameLak.feLakeBathymetry.FileName);
      frameLak.rdgLakeTable.BeginUpdate;
      try
        for Index := 0 to ExternalLakeTable.LakeTable.Count - 1 do
        begin
          if Index + 1 = frameLak.rdgLakeTable.RowCount then
          begin
            Break;
          end;
          BathItem := ExternalLakeTable.LakeTable[Index];
          frameLak.rdgLakeTable.Cells[Ord(bcStage), Index+1] :=
            FloatToStr(BathItem.Stage);
          frameLak.rdgLakeTable.Cells[Ord(bcVolume), Index+1] :=
            FloatToStr(BathItem.Volume);
          frameLak.rdgLakeTable.Cells[Ord(bcSurfaceArea), Index+1] :=
            FloatToStr(BathItem.SurfaceArea);
        end;
      finally
        frameLak.rdgLakeTable.EndUpdate;
      end;
    end;
  end;
end;


procedure TfrmScreenObjectProperties.GetModflowBoundaryTimes(
  ScreenObjectList: TList; Parameter: TParameterType;
  TimeList: TParameterTimeList);
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowParamBoundary;
  TimeIndex: Integer;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  ParamIndex: Integer;
  Time2: TParameterTime;
  ParamItem: TModflowParamItem;
  Time1: TParameterTime;
begin
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.GetMfBoundary(Parameter);
    if Boundary <> nil then
    begin
      // get all the times associated with the boundary.
      for TimeIndex := 0 to Boundary.Values.Count - 1 do
      begin
        Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
        Time := TParameterTime.Create;
        Time.StartTime := Item.StartTime;
        Time.EndTime := Item.EndTime;
        TimeList.Add(Time);
      end;
      for ParamIndex := 0 to Boundary.Parameters.Count - 1 do
      begin
        ParamItem := Boundary.Parameters[ParamIndex];
        for TimeIndex := 0 to ParamItem.Param.Count - 1 do
        begin
          Item := ParamItem.Param[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
      if (Boundary = AScreenObject.ModflowRchBoundary)
        and frmGoPhast.PhastModel.RchTimeVaryingLayers then
      begin
        for TimeIndex := 0 to AScreenObject.ModflowRchBoundary.RechargeLayers.Count - 1 do
        begin
          Item := AScreenObject.ModflowRchBoundary.RechargeLayers[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
      if (Boundary = AScreenObject.ModflowEvtBoundary) then
      begin
        if frmGoPhast.PhastModel.EvtTimeVaryingLayers then
        begin
          for TimeIndex := 0 to AScreenObject.ModflowEvtBoundary.EvapotranspirationLayers.Count - 1 do
          begin
            Item := AScreenObject.ModflowEvtBoundary.EvapotranspirationLayers[TimeIndex] as TCustomModflowBoundaryItem;
            Time := TParameterTime.Create;
            Time.StartTime := Item.StartTime;
            Time.EndTime := Item.EndTime;
            TimeList.Add(Time);
          end;
        end;
        for TimeIndex := 0 to AScreenObject.ModflowEvtBoundary.EvtSurfDepthCollection.Count - 1 do
        begin
          Item := AScreenObject.ModflowEvtBoundary.EvtSurfDepthCollection[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
      if (Boundary = AScreenObject.ModflowEtsBoundary) then
      begin
        if frmGoPhast.PhastModel.EtsTimeVaryingLayers then
        begin
          for TimeIndex := 0 to AScreenObject.ModflowEtsBoundary.EvapotranspirationLayers.Count - 1 do
          begin
            Item := AScreenObject.ModflowEtsBoundary.EvapotranspirationLayers[TimeIndex] as TCustomModflowBoundaryItem;
            Time := TParameterTime.Create;
            Time.StartTime := Item.StartTime;
            Time.EndTime := Item.EndTime;
            TimeList.Add(Time);
          end;
        end;
        for TimeIndex := 0 to AScreenObject.ModflowEtsBoundary.EtsSurfDepthCollection.Count - 1 do
        begin
          Item := AScreenObject.ModflowEtsBoundary.EtsSurfDepthCollection[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
  end;
  // Sort the times in ascending order.
  TimeList.Sort;
  // get rid of duplicate times.
  for TimeIndex := TimeList.Count - 1 downto 1 do
  begin
    Time1 := TimeList[TimeIndex];
    Time2 := TimeList[TimeIndex - 1];
    if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
    begin
      TimeList.Delete(TimeIndex);
    end;
  end;
end;

function TfrmScreenObjectProperties.GetBoundaryValues(
  Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := Boundary.Values;
end;

procedure TfrmScreenObjectProperties.GetModflowBoundaryValues(
  Parameter: TParameterType; ScreenObjectList: TList;
  TimeList: TParameterTimeList; DataGrid: TRbwDataGrid4);
var
  ValuesFunction: TGetBoundaryCollectionEvent;
  ColumnOffset: integer;
begin
  ValuesFunction := GetBoundaryValues;
  ColumnOffset := 2;
  GetModflowBoundaryCollection(DataGrid, ValuesFunction, ColumnOffset,
    ScreenObjectList, Parameter, TimeList);
end;

procedure TfrmScreenObjectProperties.GetModflowTimeInterpolation(
  Frame: TframeScreenObjectParam; Parameter: TParameterType;
  ScreenObjectList: TList; Node: TJvPageIndexNode);
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowParamBoundary;
  FoundFirst: Boolean;
//  ShouldEnable: Boolean;
//  ParamIndex: Integer;
begin
//  ShouldEnable := frmGoPhast.ModelSelection = msModflow2015;
//  if ShouldEnable then
//  begin
//    ShouldEnable := False;
//    for ParamIndex := 1 to Frame.clbParameters.Items.Count - 1 do
//    begin
//      if Frame.clbParameters.State[ParamIndex] <> cbUnchecked then
//      begin
//        ShouldEnable := True;
//        break;
//      end;
//    end;
//  end;
//  Frame.comboTimeSeriesInterpolation.Enabled := ShouldEnable;
//  Frame.lblTimeSeriesInterpolation .Enabled := ShouldEnable;
  Frame.comboTimeSeriesInterpolation.Visible := False;
  Frame.lblTimeSeriesInterpolation.Visible := False;

  FoundFirst := False;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.GetMfBoundary(Parameter);
    if Boundary <> nil then
    begin
      if FoundFirst then
      begin
        if Frame.comboTimeSeriesInterpolation.ItemIndex <> Ord(Boundary.Interp) then
        begin
          Frame.comboTimeSeriesInterpolation.ItemIndex := -1;
        end;
      end
      else
      begin
        FoundFirst := True;
        Frame.comboTimeSeriesInterpolation.ItemIndex := Ord(Boundary.Interp);
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetModflowBoundaryParameters(
  Parameter: TParameterType; ScreenObjectList: TList;
  Frame: TframeScreenObjectParam; TimeList: TParameterTimeList);
var
  BoundaryItem: TModflowParamItem;
  Index: Integer;
  Parameters: TModflowParameters;
  List: TList;
  BoundIndex: Integer;
  ChdIndex: Integer;
  ParametersIdentical: Boolean;
  ItemIndex: Integer;
  ScreenObjectIndex: Integer;
  ColIndex, RowIndex: integer;
  Param: TModflowTransientListParameter;
  Item: TCustomModflowBoundaryItem;
  Boundary: TModflowParamBoundary;
  DataGrid: TRbwDataGrid4;
  AScreenObject: TScreenObject;
begin
  DataGrid := Frame.rdgModflowBoundary;
  for ItemIndex := 1 to Frame.clbParameters.Items.Count - 1 do
  begin
    if Frame.clbParameters.State[ItemIndex] in [cbChecked, cbGrayed] then
    begin
      Param := Frame.clbParameters.Items.Objects[ItemIndex] as TModflowTransientListParameter;
      List := TList.Create;
      try
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.GetMfBoundary(Parameter);
          if (Boundary <> nil)
            and (Boundary.Parameters.IndexOfParam(Param) >= 0) then
          begin
            List.Add(AScreenObject);
          end;
        end;
        if List.Count >= 1 then
        begin
          AScreenObject := List[0];
          Boundary := AScreenObject.GetMfBoundary(Parameter);
          Assert(Boundary <> nil);
          Parameters := Boundary.Parameters;
          Index := Parameters.IndexOfParam(Param);
          BoundaryItem := Parameters[Index] as TModflowParamItem;
          ParametersIdentical := True;
          for ScreenObjectIndex := 1 to List.Count - 1 do
          begin
            AScreenObject := List[ScreenObjectIndex];
            Boundary := AScreenObject.GetMfBoundary(Parameter);
            Assert(Boundary <> nil);
            Parameters := Boundary.Parameters;
            Index := Parameters.IndexOfParam(Param);
            ParametersIdentical := BoundaryItem.IsSame(Parameters[Index]);
            if not ParametersIdentical then
            begin
              break;
            end;
          end;
          if ParametersIdentical then
          begin
            ColIndex := DataGrid.Rows[0].IndexOfObject(Param);
            Assert(ColIndex >= 0);
            for ChdIndex := 0 to BoundaryItem.Param.Count - 1 do
            begin
              Item := BoundaryItem.Param[ChdIndex] as TCustomModflowBoundaryItem;
              RowIndex := TimeList.IndexOfTime(Item.StartTime, Item.EndTime) + 1 + PestRowOffset;
              Assert(RowIndex >= 1 + PestRowOffset);
              for BoundIndex := 0 to Boundary.Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
              begin
                DataGrid.Cells[ColIndex + BoundIndex, RowIndex] :=
                  Item.BoundaryFormula[BoundIndex];
              end;
            end;
          end;
        end;
      finally
        List.Free;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetMawBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMawBoundary;
begin
  if not frmGoPhast.PhastModel.MawIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowMawBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FMAW_Node <> nil then
  begin
    FMAW_Node.StateIndex := Ord(State)+1;
  end;
  frameMAW.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4AddedDemandBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4AddedDemandBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4AddedDemand;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4AddedDemandNode <> nil then
  begin
    FFmp4AddedDemandNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4AddedDemand.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4AddedDemandRunoffSplitBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4AddedDemandRunoffSplitBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Fmp4AddedDemandRunoffSplitBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4AddedDemandRunoffSplitNode <> nil then
  begin
    FFmp4AddedDemandRunoffSplitNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4AddedDemandRunoffSplit.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4BareEvapBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4BareEvapBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientBareEvapArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpBareEvap;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4BareEvapNode <> nil then
  begin
    FFmp4BareEvapNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4BareEvap.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4BarePrecipitationConsumptionFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4BarePrecipitationConsumptionFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Fmp4BarePrecipitationConsumptionFractionBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4BarePrecipitationConsumptionFractionNode <> nil then
  begin
    FFmp4BarePrecipitationConsumptionFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4BarePrecipitationConsumptionFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4BareRunoffFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4BareRunoffFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientBareRunoffFractionArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Fmp4BareRunoffFractionBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4BareRunoffFractionNode <> nil then
  begin
    FFmp4BareRunoffFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4BareRunoffFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4ConsumptiveUseBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4ConsumptiveUseBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientConsumptiveUseIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4ConsumptiveUse;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4ConsumptiveUseNode <> nil then
  begin
    FFmp4ConsumptiveUseNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4ConsumptiveUse.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4CropCoefficientBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4CropCoefficientBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientCropCoefficientIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4CropCoefficient;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4CropCoefficientNode <> nil then
  begin
    FFmp4CropCoefficientNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4CropCoefficient.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4CropHasSalinityDemandBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4CropHasSalinityDemandBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientCropHasSalinityDemandIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4CropHasSalinityDemand;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4CropHasSalinityDemandNode <> nil then
  begin
    FFmp4CropHasSalinityDemandNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4CropHasSalinityDemand.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4DirectRechargeBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4DirectRechargeBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientDirectRechargeArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpDirectRecharge;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4DirectRechargeNode <> nil then
  begin
    FFmp4DirectRechargeNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4DirectRecharge.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4EfficiencyBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4EfficiencyBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientEfficiencyArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Fmp4EfficiencyBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4EfficiencyNode <> nil then
  begin
    FFmp4EfficiencyNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4Efficiency.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4EfficiencyImprovementBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4EfficiencyImprovementBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientEfficiencyImprovementArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Fmp4EfficiencyImprovementBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4EfficiencyImprovementNode <> nil then
  begin
    FFmp4EfficiencyImprovementNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4EfficiencyImprovement.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4EvaporationIrrigationFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4EvaporationIrrigationFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientEvaporationIrrigationFractionIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4EvaporationIrrigationFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4EvaporationIrrigationFractionNode <> nil then
  begin
    FFmp4EvaporationIrrigationFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4EvaporationIrrigationFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4FractionOfIrrigToSurfaceWaterBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4FractionOfIrrigToSurfaceWaterBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4FractionOfIrrigToSurfaceWater;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4FractionOfIrrigToSurfaceWaterNode <> nil then
  begin
    FFmp4FractionOfIrrigToSurfaceWaterNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4FractionOfIrrigToSurfaceWater.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4FractionOfPrecipToSurfaceWaterBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4FractionOfPrecipToSurfaceWaterBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4FractionOfPrecipToSurfaceWater;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4FractionOfPrecipToSurfaceWaterNode <> nil then
  begin
    FFmp4FractionOfPrecipToSurfaceWaterNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4FractionOfPrecipToSurfaceWater.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4IrrigationBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4IrrigationBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientIrrigationIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4Irrigation;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4IrrigationNode <> nil then
  begin
    FFmp4IrrigationNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4Irrigation.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4LandUseAreaFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4LandUseAreaFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientLandUseAreaFractionIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4LandUseAreaFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4LandUseAreaFractionNode <> nil then
  begin
    FFmp4LandUseAreaFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4LandUseAreaFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultAddedDemandBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultAddedDemandBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientAddedDemandMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultAddedDemand;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultAddedDemandNode <> nil then
  begin
    FFmp4MultAddedDemandNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultAddedDemand.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultConsumptiveUseBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultConsumptiveUseBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientConsumptiveUseMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultConsumptiveUse;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultConsumptiveUseNode <> nil then
  begin
    FFmp4MultConsumptiveUseNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultConsumptiveUse.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultCropCoefficientBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultCropCoefficientBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientCropCoefficientMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultCropCoefficient;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultCropCoefficientNode <> nil then
  begin
    FFmp4MultCropCoefficientNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultCropCoefficients.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultCropHasSalinityDemandBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultCropHasSalinityDemandBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientCropHasSalinityDemandMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultCropHasSalinityDemand;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultCropHasSalinityDemandNode <> nil then
  begin
    FFmp4MultCropHasSalinityDemandNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultCropHasSalinityDemand.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultEvaporationIrrigationFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultEvaporationIrrigationFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultEvaporationIrrigationFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultEvaporationIrrigationFractionNode <> nil then
  begin
    FFmp4MultEvaporationIrrigationFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultEvaporationIrrigationFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultFractionOfIrrigToSurfaceWaterBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultFractionOfIrrigToSurfaceWaterBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultFractionOfIrrigToSurfaceWater;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultFractionOfIrrigToSurfaceWaterNode <> nil then
  begin
    FFmp4MultFractionOfIrrigToSurfaceWaterNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultFractionOfIrrigToSurfaceWater.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultFractionOfPrecipToSurfaceWaterBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultFractionOfPrecipToSurfaceWaterBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultFractionOfPrecipToSurfaceWater;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultFractionOfPrecipToSurfaceWaterNode <> nil then
  begin
    FFmp4MultFractionOfPrecipToSurfaceWaterNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultFractionOfPrecipToSurfaceWater.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultIrrigationBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultIrrigationBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientIrrigationMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultIrrigation;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultIrrigationNode <> nil then
  begin
    FFmp4MultIrrigationNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultIrrigation.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultLandUseAreaFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultLandUseAreaFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientLandUseAreaFractionMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultLandUseAreaFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultLandUseAreaFractionNode <> nil then
  begin
    FFmp4MultLandUseAreaFractionNode.StateIndex := Ord(State)+1;
  end;
  frameMultLandUseAreaFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultRootDepthBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultRootDepthBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientRootDepthMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultRootDepth;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultRootDepthNode <> nil then
  begin
    FFmp4MultRootDepthNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultRootDepth.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4MultTranspirationFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4MultTranspirationFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientTranspirationFractionMultIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4MultTranspirationFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4MultTranspirationFractionNode <> nil then
  begin
    FFmp4MultTranspirationFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4MultTranspirationFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4NrdInfilLocationBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4NrdInfilLocationBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientNrdInfilLocIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4NrdInfilLocationBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4NrdInfilLocationNode <> nil then
  begin
    FFmp4NrdInfilLocationNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4NrdInfilLocation.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4PrecipPotConsumptionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4PrecipPotConsumptionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientPrecipPotConsumptionArrayIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmpPrecipPotConsumption;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4PrecipPotConsumptionNode <> nil then
  begin
    FFmp4PrecipPotConsumptionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4PrecipPotConsumption.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4RootDepthBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4RootDepthBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientRootDepthIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4RootDepth;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4RootDepthNode <> nil then
  begin
    FFmp4RootDepthNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4RootDepth.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFmp4TranspirationFractionBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TFmp4TranspirationFractionBoundary;
begin
  if not frmGoPhast.PhastModel.FarmProcess4TransientTranspirationFractionIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowFmp4TranspirationFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FFmp4TranspirationFractionNode <> nil then
  begin
    FFmp4TranspirationFractionNode.StateIndex := Ord(State)+1;
  end;
  frameFmp4TranspirationFraction.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetLakeMf6Boundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TLakeMf6;
begin
  if not frmGoPhast.PhastModel.LakMf6IsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowLak6;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FLAKMf6_Node <> nil then
  begin
    FLAKMf6_Node.StateIndex := Ord(State)+1;
  end;
  frameLakMf6.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetMvrBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMvrBoundary;
begin
  if not frmGoPhast.PhastModel.MvrIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowMvr;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FMVR_Node <> nil then
  begin
    FMVR_Node.StateIndex := Ord(State)+1;
  end;
  frameMVR.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetMf6Obs(const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflow6Obs;
  procedure UpdateBoundaryState(
    Boundary: TModflow6Obs; ScreenObjectIndex: Integer;
    var State: TCheckBoxState);
  begin
    if Boundary = nil then
    begin
      if ScreenObjectIndex = 0 then
      begin
        State := cbUnchecked;
      end
      else
      begin
        if State = cbChecked then
        begin
          State := cbGrayed;
        end;
      end;
    end
    else
    begin
      if Boundary.Used then
      begin
        if ScreenObjectIndex = 0 then
        begin
          State := cbChecked;
        end
        else
        begin
          if State = cbUnchecked then
          begin
            State := cbGrayed;
          end;
        end;
      end
      else
      begin
        if ScreenObjectIndex = 0 then
        begin
          State := cbUnchecked;
        end
        else
        begin
          if State = cbChecked then
          begin
            State := cbGrayed;
          end;
        end;
      end;
    end;
  end;
begin
  if not frmGoPhast.PhastModel.Mf6ObsIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Modflow6Obs;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FMf6Obs_Node <> nil then
  begin
    FMf6Obs_Node.StateIndex := Ord(State)+1;
  end;
  frameObsMf6.GetData(FNewProperties);

end;

procedure TfrmScreenObjectProperties.GetMF_BoundaryTimes(var Times: TTimeArray;
  Frame: TframeScreenObjectNoParam);
var
  RowIndex: Integer;
  DataGrid: TRbwDataGrid4;
begin
  DataGrid := Frame.rdgModflowBoundary;
  SetLength(Times, DataGrid.RowCount);
  for RowIndex := 1 + PestRowOffset to DataGrid.RowCount - 1 do
  begin
    Times[RowIndex].TimeOK :=
      TryStrToFloat(DataGrid.Cells[0, RowIndex], Times[RowIndex].StartTime)
      and TryStrToFloat(DataGrid.Cells[1, RowIndex], Times[RowIndex].EndTime);
  end;
end;

procedure TfrmScreenObjectProperties.StoreMF_BoundColl(ColumnOffset: Integer;
  BoundaryValues: TCustomMF_BoundColl; const Times: TTimeArray;
  Frame: TframeScreenObjectNoParam);
var
  RowIndex: Integer;
  BoundIndex: Integer;
//  Value: string;
  BoundItem: TCustomModflowBoundaryItem;
  DataGrid: TRbwDataGrid4;
  ColIndex: integer;
  NewValue: string;
begin
  DataGrid := Frame.rdgModflowBoundary;

  for RowIndex := 1 + PestRowOffset to DataGrid.RowCount - 1 do
  begin
    if Times[RowIndex].TimeOK then
    begin
      for BoundIndex := 0 to BoundaryValues.TimeListCount(frmGoPhast.PhastModel) - 1 do
      begin
        ColIndex := BoundIndex + ColumnOffset;
        NewValue := DataGrid.Cells[ColIndex, RowIndex];
        if Frame.DeletedCells[ColIndex,RowIndex] or (NewValue <> '') then
        begin
          if RowIndex - 1 - PestRowOffset < BoundaryValues.Count then
          begin
            BoundItem := BoundaryValues.Items[RowIndex - 1 - PestRowOffset]
              as TCustomModflowBoundaryItem;
          end
          else
          begin
            BoundItem := BoundaryValues.Add as TCustomModflowBoundaryItem;
          end;
          BoundItem.StartTime := Times[RowIndex].StartTime;
          BoundItem.EndTime := Times[RowIndex].EndTime;
          BoundItem.BoundaryFormula[BoundIndex] := NewValue;
        end;
      end;
    end;
  end;
  for RowIndex := DataGrid.RowCount  to BoundaryValues.Count + PestRowOffset do
  begin
    for BoundIndex := 0 to BoundaryValues.TimeListCount(frmGoPhast.PhastModel) - 1 do
    begin
      BoundItem := BoundaryValues.Items[RowIndex - 1 - PestRowOffset]
        as TCustomModflowBoundaryItem;
      BoundItem.BoundaryFormula[BoundIndex] := '';
    end;
  end;

end;

procedure TfrmScreenObjectProperties.StoreModflowBoundaryValues(
  Frame: TframeScreenObjectNoParam; Times: TTimeArray;
  Boundary: TModflowBoundary);
var
  BoundaryValues: TCustomMF_BoundColl;
  ColumnOffset: integer;
begin
  ColumnOffset := 2;
  BoundaryValues := Boundary.Values;
  StoreMF_BoundColl(ColumnOffset, BoundaryValues, Times, Frame);
end;

procedure TfrmScreenObjectProperties.StoreModflowTimeInterpolation(
  Frame: TframeScreenObjectParam; ParamType: TParameterType;
  Node: TJvPageIndexNode);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TModflowParamBoundary;
begin
  if IsLoaded then
  begin
    if (Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Boundary := Item.ScreenObject.GetMfBoundary(ParamType);
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(Node, Boundary) then
      begin
        if Frame.comboTimeSeriesInterpolation.ItemIndex >= 0 then
        begin
          Boundary.Interp := TMf6InterpolationMethods(Frame.comboTimeSeriesInterpolation.ItemIndex);
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreModflowBoundaryParameters(
  Boundary: TModflowParamBoundary; Times: TTimeArray;
  Frame: TframeScreenObjectParam);
var
  ParamItem: TModflowParamItem;
  AssignToAll: Boolean;
  ParamPosition: Integer;
  Param: TModflowParameter;
  ColIndex: Integer;
  StartCol: Integer;
  RowIndex: Integer;
  Value: string;
  BoundItem: TCustomModflowBoundaryItem;
  BoundIndex: Integer;
  ValuesOK: Boolean;
  Values: TStringList;
  DataGrid: TRbwDataGrid4;
  CheckListBox: TJvxCheckListBox;
  CheckIndex: Integer;
  ParamIndex: Integer;
  CanSelect: Boolean;
begin
  DataGrid := Frame.rdgModflowBoundary;
  Values := TStringList.Create;
  try
    StartCol := Boundary.NonParameterColumns;
    for ColIndex := StartCol to DataGrid.ColCount - 1 do
    begin
      if ((ColIndex - StartCol) mod Boundary.Values.
        TimeListCount(frmGoPhast.PhastModel)) <> 0 then
      begin
        Continue;
      end;
      Param := DataGrid.Objects[ColIndex, 0] as TModflowParameter;
      ParamPosition := Frame.clbParameters.Items.IndexOfObject(Param);
      AssignToAll := Frame.clbParameters.State[ParamPosition] = cbChecked;
      ParamItem := nil;
      for RowIndex := 1 + PestRowOffset to DataGrid.RowCount - 1 do
      begin
        if Times[RowIndex].TimeOK then
        begin
          Values.Clear;
          ValuesOK := True;
          for BoundIndex := 0 to Boundary.Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
          begin
            CanSelect := True;
            Value := DataGrid.Cells[BoundIndex + ColIndex, RowIndex];
            if Assigned(DataGrid.OnSelectCell) then
            begin
              DataGrid.OnSelectCell(DataGrid, BoundIndex + ColIndex, RowIndex, CanSelect)
            end;
            if CanSelect then
            begin
              ValuesOK := Value <> '';
              if ValuesOK then
              begin
                Values.Add(Value);
              end
              else
              begin
                break;
              end;
            end
            else
            begin
              ValuesOK := True;
              Values.Add(Value);
            end;
          end;
          if ValuesOK then
          begin
            if ParamItem = nil then
            begin
              ParamItem := Boundary.Parameters.GetParamByName(Param.ParameterName);
              if ParamItem <> nil then
              begin
                ParamItem.Param.Clear;
              end;
            end;
            if (ParamItem = nil) and AssignToAll then
            begin
              ParamItem := Boundary.Parameters.Add;
              ParamItem.Param.Param := Param as TModflowTransientListParameter;
            end;
            if ParamItem = nil then
            begin
              break;
            end;
            BoundItem := ParamItem.Param.Add as TCustomModflowBoundaryItem;
            BoundItem.StartTime := Times[RowIndex].StartTime;
            BoundItem.EndTime := Times[RowIndex].EndTime;
            for BoundIndex := 0 to Boundary.Values.TimeListCount(frmGoPhast.PhastModel) - 1 do
            begin
              BoundItem.BoundaryFormula[BoundIndex] := Values[BoundIndex];
            end;
          end;
        end;
      end;
    end;
    CheckListBox := Frame.clbParameters;
    for CheckIndex := 1 to CheckListBox.Items.Count - 1 do
    begin
      if CheckListBox.State[CheckIndex] = cbUnchecked then
      begin
        Param := CheckListBox.Items.Objects[CheckIndex] as TModflowParameter;
        ParamIndex :=  Boundary.Parameters.IndexOfParam(
          Param as TModflowTransientListParameter);
        if ParamIndex >= 0 then
        begin
          Boundary.Parameters.Delete(ParamIndex);
        end;
      end;
    end;
  finally
    Values.Free;
  end;
end;

function TfrmScreenObjectProperties.GetModflow6TimeSeriesAllowed(
  DataGrid: TCustomRBWDataGrid; ACol: Integer): boolean;
var
  EtsLayerCol: Integer;
  FirstSegmentLayer: Integer;
begin
  result := (frmGoPhast.ModelSelection = msModflow2015)
    and ((DataGrid = frameRchParam.rdgModflowBoundary)
    or (DataGrid = frameChdParam.rdgModflowBoundary)
    or (DataGrid = frameCSUB.rdgModflowBoundary)
    or (DataGrid = frameDrnParam.rdgModflowBoundary)
    or (DataGrid = frameEtsParam.rdgModflowBoundary)
    or (DataGrid = frameGhbParam.rdgModflowBoundary)
    or (DataGrid = frameWellParam.rdgModflowBoundary)
    or (DataGrid = frameLakMf6.rdgModflowBoundary)
    or (DataGrid = frameMAW.rdgModflowBoundary) // Only rate and stage
//    or ((DataGrid = frameMAW.rdgModflowBoundary) and (ACol in [3,4])) // Only rate and stage
    or (DataGrid = frameRivParam.rdgModflowBoundary)
    or ((DataGrid = frameScreenObjectSfr6.rdgModflowBoundary) and (ACol < 9)) // all but upstream fraction and diversions.
    or (DataGrid = frameScreenObjectUzfMf6.rdgModflowBoundary)
    or ((DataGrid = frameGwtCnc.rdgModflowBoundary) and (ACol in [3,4]))
    or ((DataGrid = frameGwtSrc.rdgModflowBoundary) and (ACol in [3,4]))
    or (DataGrid = frameScreenObjectTvk.rdgModflowBoundary)
    or (DataGrid = frameScreenObjectTvs.rdgModflowBoundary)
    or (DataGrid.Parent is TframeLakeOutlet)
    )
  ;
  if (DataGrid = frameRchParam.rdgModflowBoundary)
    and frmGoPhast.PhastModel.RchTimeVaryingLayers
    and (ACol = 4 + GwtColumnCount) then
  begin
    // We are setting the formula for  the layer
    // to which the recharge will be applied.
    result := False;
  end;
  if (DataGrid = frameEtsParam.rdgModflowBoundary)
    and frmGoPhast.PhastModel.EtsTimeVaryingLayers then
  begin
    EtsLayerCol := 6 + GwtColumnCount +
      (frmGoPhast.PhastModel.ModflowPackages.EtsPackage.SegmentCount-1)*2;
    if ACol = EtsLayerCol then
    begin
      // We are setting the formula for  the layer
      // to which the evapotranspiration will be applied.
      result := False;
    end;
  end;
  if (DataGrid = frameEtsParam.rdgModflowBoundary) and
    (frmGoPhast.PhastModel.ModflowPackages.EtsPackage.SegmentCount > 1) then
  begin
    EtsLayerCol := 6 + GwtColumnCount +
      (frmGoPhast.PhastModel.ModflowPackages.EtsPackage.SegmentCount-1)*2;
    FirstSegmentLayer := 6 + GwtColumnCount;
    if (ACol >= FirstSegmentLayer) and (ACol < EtsLayerCol) then
    begin
      // We are setting the formula for  the segment fractions
      result := False;
    end;
  end;

end;

procedure TfrmScreenObjectProperties.GetModflowBoundaries(
  const AScreenObjectList: TList);
begin
  GetChdBoundary(AScreenObjectList);
  GetGhbBoundary(AScreenObjectList);
  GetWellBoundary(AScreenObjectList);
  GetRivBoundary(AScreenObjectList);
  GetDrnBoundary(AScreenObjectList);
  GetDrtBoundary(AScreenObjectList);
  GetRchBoundary(AScreenObjectList);
  GetEvtBoundary(AScreenObjectList);
  GetEtsBoundary(AScreenObjectList);
  GetResBoundary(AScreenObjectList);
  GetLakBoundary(AScreenObjectList);
  GetUzfBoundary(AScreenObjectList);
  GetSfrBoundary(AScreenObjectList);
  GetSfr6Boundary(AScreenObjectList);
  GetStrBoundary(AScreenObjectList);
  GetMnw1Boundary(AScreenObjectList);
  GetMnw2Boundary(AScreenObjectList);
  GetFhbHeadBoundary(AScreenObjectList);
  GetFhbFlowBoundary(AScreenObjectList);
  GetHeadObservations(AScreenObjectList);
  GetHfbBoundary(AScreenObjectList);
  GetHydmod(AScreenObjectList);
  GetFluxObservations(AScreenObjectList);
  GetFarmWell(AScreenObjectList);
  GetFarmPrecip(AScreenObjectList);
  GetFarmRefEvap(AScreenObjectList);
  GetFarmCropID(AScreenObjectList);
  GetFarmID(AScreenObjectList);
  GetCfpPipes(AScreenObjectList);
  GetCfpFixedHeads(AScreenObjectList);
  GetCfpRechargeBoundary(AScreenObjectList);
  GetMt3dmsChemBoundary(AScreenObjectList);
  GetMt3dConcObservations(AScreenObjectList);
  GetMt3dmsFluxObservations(AScreenObjectList);
  GetMt3d_UztRechBoundary(AScreenObjectList);
  GetMt3d_UztSatBoundary(AScreenObjectList);
  GetMt3d_UztUnsatBoundary(AScreenObjectList);
  GetMt3dUzfSeepageConcBoundary(AScreenObjectList);
  GetMt3dLktBoundary(AScreenObjectList);
  GetMt3dSftBoundary(AScreenObjectList);
  GetSwrReaches(AScreenObjectList);
  GetSwrRainBoundary(AScreenObjectList);
  GetSwrEvapBoundary(AScreenObjectList);
  GetSwrLatInflowBoundary(AScreenObjectList);
  GetSwrStageBoundary(AScreenObjectList);
  GetSwrDirectRunoffBoundary(AScreenObjectList);
  GetSwiObsBoundary(AScreenObjectList);
  GetRip(AScreenObjectList);
  GetMawBoundary(AScreenObjectList);
  GetCSubBoundary(AScreenObjectList);
  GetCncBoundary(AScreenObjectList);
  GetSrcBoundary(AScreenObjectList);

  GetMf6Obs(AScreenObjectList);
  GetLakeMf6Boundary(AScreenObjectList);
  GetMvrBoundary(AScreenObjectList);
  GetUzMf6Boundary(AScreenObjectList);

  GetFmp4EfficiencyBoundary(AScreenObjectList);
  GetFmp4EfficiencyImprovementBoundary(AScreenObjectList);
  GetFmp4BareRunoffFractionBoundary(AScreenObjectList);
  GetFmp4BarePrecipitationConsumptionFractionBoundary(AScreenObjectList);
  GetFmp4AddedDemandRunoffSplitBoundary(AScreenObjectList);
  GetFmp4BareEvapBoundary(AScreenObjectList);
  GetFmp4DirectRechargeBoundary(AScreenObjectList);
  GetFmp4PrecipPotConsumptionBoundary(AScreenObjectList);
  GetFmp4NrdInfilLocationBoundary(AScreenObjectList);
  GetFmp4LandUseAreaFractionBoundary(AScreenObjectList);
  GetFmp4MultLandUseAreaFractionBoundary(AScreenObjectList);
  GetFmp4CropCoefficientBoundary(AScreenObjectList);
  GetFmp4MultCropCoefficientBoundary(AScreenObjectList);
  GetFmp4ConsumptiveUseBoundary(AScreenObjectList);
  GetFmp4MultConsumptiveUseBoundary(AScreenObjectList);
  GetFmp4IrrigationBoundary(AScreenObjectList);
  GetFmp4MultIrrigationBoundary(AScreenObjectList);
  GetFmp4RootDepthBoundary(AScreenObjectList);
  GetFmp4MultRootDepthBoundary(AScreenObjectList);
  GetFmp4TranspirationFractionBoundary(AScreenObjectList);
  GetFmp4MultTranspirationFractionBoundary(AScreenObjectList);
  GetFmp4EvaporationIrrigationFractionBoundary(AScreenObjectList);
  GetFmp4MultEvaporationIrrigationFractionBoundary(AScreenObjectList);
  GetFmp4FractionOfPrecipToSurfaceWaterBoundary(AScreenObjectList);
  GetFmp4MultFractionOfPrecipToSurfaceWaterBoundary(AScreenObjectList);
  GetFmp4FractionOfIrrigToSurfaceWaterBoundary(AScreenObjectList);
  GetFmp4MultFractionOfIrrigToSurfaceWaterBoundary(AScreenObjectList);
  GetFmp4AddedDemandBoundary(AScreenObjectList);
  GetFmp4MultAddedDemandBoundary(AScreenObjectList);
  GetFmp4CropHasSalinityDemandBoundary(AScreenObjectList);
  GetFmp4MultCropHasSalinityDemandBoundary(AScreenObjectList);

  GetTvkBoundary(AScreenObjectList);
  GetTvsBoundary(AScreenObjectList);


  SetSelectedMfBoundaryNode;

  GetChildModels(AScreenObjectList);
end;

procedure TfrmScreenObjectProperties.GetFootprintWells;
begin
  frameScreenObjectFootprintWell.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetFormulaInterpretation(
  Frame: TframeScreenObjectCondParam; Parameter: TParameterType;
  ScreenObjectList: TList);
var
  First: Boolean;
  CondInterp: TFormulaInterpretation;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TSpecificModflowBoundary;
begin
  Frame.comboFormulaInterp.ItemIndex := 0;
  First := True;
  CondInterp := fiSpecific;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.GetMfBoundary(Parameter) as TSpecificModflowBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      if First then
      begin
        CondInterp := Boundary.FormulaInterpretation;
        Frame.comboFormulaInterp.ItemIndex := Ord(CondInterp);
        First := False;
      end
      else if CondInterp <> Boundary.FormulaInterpretation then
      begin
        Frame.comboFormulaInterp.ItemIndex := -1;
      end;
    end;
  end;
  if Assigned(Frame.comboFormulaInterp.OnChange) then
  begin
    Frame.comboFormulaInterp.OnChange(Frame.comboFormulaInterp);
  end;
end;

procedure TfrmScreenObjectProperties.StoreFormulaInterpretation(
  Frame: TframeScreenObjectCondParam; ParamType: TParameterType);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TSpecificModflowBoundary;
begin
  if Frame.comboFormulaInterp.ItemIndex >= 0 then
  begin
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Boundary := Item.ScreenObject.GetMfBoundary(ParamType)
        as TSpecificModflowBoundary;
      Assert(Boundary <> nil);
      Boundary.FormulaInterpretation := TFormulaInterpretation(
        Frame.comboFormulaInterp.ItemIndex);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetModflowBoundary(
  Frame: TframeScreenObjectParam; Parameter: TParameterType;
  ScreenObjectList: TList; Node: TJvPageIndexNode);
var
  TimeList: TParameterTimeList;
  ItemIndex: Integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowParamBoundary;
  TimeIndex: Integer;
  Time: TParameterTime;
  ParamIndex: Integer;
  ParamItem: TModflowParamItem;
  Param: TModflowTransientListParameter;
  ParamUsed: Boolean;
  ColIndex: Integer;
  RowIndex: Integer;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
begin
  Frame.rdgModflowBoundary.BeginUpdate;
  TimeList := TParameterTimeList.Create;
  try
    for ItemIndex := 0 to Frame.clbParameters.Items.Count - 1 do
    begin
      Frame.clbParameters.State[ItemIndex] := cbUnchecked;
    end;

    GetModflowBoundaryTimes(ScreenObjectList, Parameter, TimeList);

    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.GetMfBoundary(Parameter);
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if Node <> nil then
    begin
      Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.GetMfBoundary(Parameter);
      if Boundary <> nil then
      begin
        if (Boundary.Values.Count > 0)
          and (Frame.clbParameters.Items.Count > 0) then
        begin
          Frame.clbParameters.State[0] := cbChecked;
        end;
        // get all the times associated with the boundary.
        for ParamIndex := 0 to Boundary.Parameters.Count - 1 do
        begin
          ParamItem := Boundary.Parameters[ParamIndex];
          if ScreenObjectIndex = 0 then
          begin
            Param := ParamItem.Param.Param;
            if Param <> nil then
            begin
              ItemIndex := Frame.clbParameters.Items.IndexOf(Param.ParameterName);
              Frame.clbParameters.State[ItemIndex] := cbChecked;
            end;
          end;
        end;
      end;
      if ScreenObjectIndex > 0 then
      begin
        if (Frame.clbParameters.Items.Count > 0)
          and (Boundary <> nil)
          and (Frame.clbParameters.Checked[0] <> (Boundary.Values.Count > 0)) then
        begin
          Frame.clbParameters.State[0] := cbGrayed;
        end;
        for ItemIndex := 1 to Frame.clbParameters.Items.Count - 1 do
        begin
          if Frame.clbParameters.State[ItemIndex] = cbGrayed then
          begin
            Continue;
          end;
          Param := Frame.clbParameters.Items.Objects[ItemIndex]
            as TModflowTransientListParameter;
          ParamUsed := (Boundary <> nil) and
            (Boundary.Parameters.IndexOfParam(Param) >= 0);
          if Frame.clbParameters.Checked[ItemIndex] <> ParamUsed then
          begin
            Frame.clbParameters.State[ItemIndex] := cbGrayed;
          end;
        end;
      end;
    end;

    Frame.seNumberOfTimes.Value := TimeList.Count;
    if Assigned(Frame.seNumberOfTimes.OnChange) then
    begin
      Frame.seNumberOfTimes.OnChange(Frame.seNumberOfTimes);
    end;
    DataGrid := Frame.rdgModflowBoundary;
    for ColIndex := 1 to DataGrid.ColCount - 1 do
    begin
      for RowIndex := 1 to PestRowOffset do
      begin
        DataGrid.Cells[ColIndex, RowIndex] := '';
      end;
    end;
    for ColIndex := 0 to DataGrid.ColCount - 1 do
    begin
      for RowIndex := 1 + PestRowOffset to DataGrid.RowCount - 1 do
      begin
        DataGrid.Cells[ColIndex, RowIndex] := '';
      end;
    end;

    // display the times that are left.
    for TimeIndex := 0 to TimeList.Count - 1 do
    begin
      Time := TimeList[TimeIndex];
      DataGrid.Cells[0, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.StartTime);
      DataGrid.Cells[1, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.EndTime);
    end;
    GetModflowBoundaryValues(Parameter, ScreenObjectList, TimeList, DataGrid);
    GetModflowBoundaryParameters(Parameter, ScreenObjectList, Frame, TimeList);
    Frame.ClearDeletedCells;
  finally
    TimeList.Free;
    Frame.rdgModflowBoundary.EndUpdate;
  end;
end;

procedure TfrmScreenObjectProperties.StoreModflowBoundary(
  Frame: TframeScreenObjectParam; ParamType: TParameterType;
  Node: TJvPageIndexNode);
var
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TModflowParamBoundary;
begin
  if (Node = nil) then
  begin
    Beep;
    MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
    Exit;
  end;

  Assert(Node <> nil);
  GetMF_BoundaryTimes(Times, Frame);
  for Index := 0 to FNewProperties.Count - 1 do
  begin
    Item := FNewProperties[Index];
    Boundary := Item.ScreenObject.GetMfBoundary(ParamType);
    Assert(Boundary <> nil);
    if ShouldStoreBoundary(Node, Boundary) then
    begin
      if (Frame.clbParameters.Items.Count > 0)
        and not (Frame.clbParameters.State[0] in [cbChecked, cbGrayed]) then
      begin
        Boundary.Values.Clear
      end
      else
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end;
      StoreModflowBoundaryParameters(Boundary, Times, Frame);
    end
    else if Node.StateIndex = 1 then
    begin
      Boundary.Clear;
    end;

  end;
end;

procedure TfrmScreenObjectProperties.InitializeModflowBoundaryFrames(
  const AScreenObject: TScreenObject);
var
  Index: integer;
  ScreenObject: TScreenObject;
  TimeList: TModflowTimeList;
  StoredUpToDate: boolean;
  PriorCanInvalidateModel: Boolean;
  ColIndex: Integer;
  NumberOfSpecies: Integer;
begin
  StoredUpToDate := frmGoPhast.PhastModel.UpToDate;
  PriorCanInvalidateModel := AScreenObject.CanInvalidateModel;
  AScreenObject.CanInvalidateModel := False;
  try
    AScreenObject.CreateChdBoundary;
    frameChdParam.InitializeFrame(AScreenObject.ModflowChdBoundary);
    if (AScreenObject.ModflowChdBoundary <> nil)
      and not AScreenObject.ModflowChdBoundary.Used then
    begin
      AScreenObject.ModflowChdBoundary := nil;
    end;

    AScreenObject.CreateGhbBoundary;
    frameGhbParam.InitializeFrame(AScreenObject.ModflowGhbBoundary);
    if (AScreenObject.ModflowGhbBoundary <> nil)
      and not AScreenObject.ModflowGhbBoundary.Used then
    begin
      AScreenObject.ModflowGhbBoundary := nil;
    end;

    AScreenObject.CreateWelBoundary;
    frameWellParam.InitializeFrame(AScreenObject.ModflowWellBoundary);
    frameWellParam.fedTabfile.FileName := '';
    if (AScreenObject.ModflowWellBoundary <> nil)
      and not AScreenObject.ModflowWellBoundary.Used then
    begin
      AScreenObject.ModflowWellBoundary := nil;
    end;

    AScreenObject.CreateFarmWell;
    frameFarmWell.InitializeFrame(AScreenObject.ModflowFmpWellBoundary);
    if (AScreenObject.ModflowFmpWellBoundary <> nil)
      and not AScreenObject.ModflowFmpWellBoundary.Used then
    begin
      AScreenObject.ModflowFmpWellBoundary := nil;
    end;

    AScreenObject.CreateRivBoundary;
    frameRivParam.InitializeFrame(AScreenObject.ModflowRivBoundary);
    if (AScreenObject.ModflowRivBoundary <> nil)
      and not AScreenObject.ModflowRivBoundary.Used then
    begin
      AScreenObject.ModflowRivBoundary := nil;
    end;

    AScreenObject.CreateDrnBoundary;
    frameDrnParam.InitializeFrame(AScreenObject.ModflowDrnBoundary);
    if (AScreenObject.ModflowDrnBoundary <> nil)
      and not AScreenObject.ModflowDrnBoundary.Used then
    begin
      AScreenObject.ModflowDrnBoundary := nil;
    end;

    AScreenObject.CreateDrtBoundary;
    frameDrtParam.InitializeFrame(AScreenObject.ModflowDrtBoundary);
    comboDrtReturnObject.Items.Clear;
    for Index := 0 to frmGoPhast.PhastModel.ScreenObjectCount - 1 do
    begin
      ScreenObject := frmGoPhast.PhastModel.ScreenObjects[Index];
      if (ScreenObject.Count = 1)
        and (ScreenObject.ElevationCount = ecOne)
        and not ScreenObject.Deleted then
      begin
        comboDrtReturnObject.Items.AddObject(ScreenObject.Name, ScreenObject);
      end;
    end;
    if (AScreenObject.ModflowDrtBoundary <> nil)
      and not AScreenObject.ModflowDrtBoundary.Used then
    begin
      AScreenObject.ModflowDrtBoundary := nil;
    end;

    if frmGoPhast.PhastModel.RchTimeVaryingLayers then
    begin
      frameRchParam.rdgModflowBoundary.ColCount := 5 + GwtColumnCount;
    end
    else
    begin
      frameRchParam.rdgModflowBoundary.ColCount := 4 + GwtColumnCount;
    end;
    AScreenObject.CreateRchBoundary;
    frameRchParam.InitializeFrame(AScreenObject.ModflowRchBoundary);
    if frmGoPhast.PhastModel.RchTimeVaryingLayers then
    begin
      frameRchParam.rdgModflowBoundary.Columns[4 + GwtColumnCount].AutoAdjustColWidths := True;
      TimeList := AScreenObject.ModflowRchBoundary.RechargeLayers.TimeLists[0, frmGoPhast.PhastModel];
      frameRchParam.rdgModflowBoundary.Cells[4 + GwtColumnCount, 0] := TimeList.NonParamDescription;
      frameRchParam.rdgModflowBoundary.Columns[4 + GwtColumnCount].AutoAdjustColWidths := False;
      frameRchParam.rdgModflowBoundary.ColWidths[4 + GwtColumnCount] :=
        frameRchParam.rdgModflowBoundary.WidthNeededToFitText(4 + GwtColumnCount,0);
    end;
    if (AScreenObject.ModflowRchBoundary <> nil)
      and not AScreenObject.ModflowRchBoundary.Used then
    begin
      AScreenObject.ModflowRchBoundary := nil;
    end;

    if frmGoPhast.PhastModel.EvtTimeVaryingLayers then
    begin
      frameEvtParam.rdgModflowBoundary.ColCount := 6;
    end
    else
    begin
      frameEvtParam.rdgModflowBoundary.ColCount := 5;
    end;
    AScreenObject.CreateEvtBoundary;
    frameEvtParam.InitializeFrame(AScreenObject.ModflowEvtBoundary);
    if frmGoPhast.PhastModel.EvtTimeVaryingLayers then
    begin
      frameEvtParam.rdgModflowBoundary.Columns[5].AutoAdjustColWidths := True;
      TimeList := AScreenObject.ModflowEvtBoundary.EvapotranspirationLayers.TimeLists[0, frmGoPhast.PhastModel];
      frameEvtParam.rdgModflowBoundary.Cells[5, 0] := TimeList.NonParamDescription;
      frameEvtParam.rdgModflowBoundary.Columns[5].AutoAdjustColWidths := False;
      frameEvtParam.rdgModflowBoundary.ColWidths[5] :=
        frameEvtParam.rdgModflowBoundary.WidthNeededToFitText(5,0);
    end;

    for Index := 0 to AScreenObject.ModflowEvtBoundary.
      EvtSurfDepthCollection.TimeListCount(frmGoPhast.PhastModel) - 1 do
    begin
      frameEvtParam.rdgModflowBoundary.Columns[3+Index].WordWrapCaptions := True;
      TimeList := AScreenObject.ModflowEvtBoundary.EvtSurfDepthCollection.TimeLists[Index, frmGoPhast.PhastModel];
      frameEvtParam.rdgModflowBoundary.Cells[3+Index, 0] := TimeList.NonParamDescription;
      frameEvtParam.rdgModflowBoundary.Columns[3+Index].AutoAdjustColWidths := False;
      frameEvtParam.rdgModflowBoundary.ColWidths[3+Index] :=
        frameEvtParam.rdgModflowBoundary.WidthNeededToFitText(3+Index,0);
    end;
    if (AScreenObject.ModflowEvtBoundary <> nil)
      and not AScreenObject.ModflowEvtBoundary.Used then
    begin
      AScreenObject.ModflowEvtBoundary := nil;
    end;

    frameEtsParam.rdgModflowBoundary.ColCount := EtsColCount;

    AScreenObject.CreateEtsBoundary;
    frameEtsParam.InitializeFrame(AScreenObject.ModflowEtsBoundary);
    if frmGoPhast.PhastModel.EtsTimeVaryingLayers then
    begin
      frameEtsParam.rdgModflowBoundary.Columns[EtsColCount-1].WordWrapCaptions := True;
      TimeList := AScreenObject.ModflowEtsBoundary.EvapotranspirationLayers.TimeLists[0, frmGoPhast.PhastModel];
      frameEtsParam.rdgModflowBoundary.Cells[EtsColCount-1, 0] := TimeList.NonParamDescription;
      frameEtsParam.rdgModflowBoundary.Columns[EtsColCount-1].AutoAdjustColWidths := False;
      frameEtsParam.rdgModflowBoundary.ColWidths[EtsColCount-1] :=
        frameEtsParam.rdgModflowBoundary.WidthNeededToFitText(EtsColCount-1,0);
    end;

    NumberOfSpecies := 0;
    for Index := 0 to AScreenObject.ModflowEtsBoundary.
      EtsSurfDepthCollection.TimeListCount(frmGoPhast.PhastModel) - 1 do
    begin
      frameEtsParam.rdgModflowBoundary.Columns[4+Index + NumberOfSpecies].WordWrapCaptions := True;
      frameEtsParam.rdgModflowBoundary.Columns[4+Index + NumberOfSpecies].AutoAdjustColWidths := True;
      TimeList := AScreenObject.ModflowEtsBoundary.EtsSurfDepthCollection.TimeLists[Index, frmGoPhast.PhastModel];
      frameEtsParam.rdgModflowBoundary.Cells[4+Index + NumberOfSpecies, 0] := TimeList.NonParamDescription;
      frameEtsParam.rdgModflowBoundary.Columns[4+Index + NumberOfSpecies].AutoAdjustColWidths := False;
    end;
    if (AScreenObject.ModflowEtsBoundary <> nil)
      and not AScreenObject.ModflowEtsBoundary.Used then
    begin
      AScreenObject.ModflowEtsBoundary := nil;
    end;

    AScreenObject.CreateMt3dmsConcBoundary;
    frameMT3DMS_SSM.rdgModflowBoundary.ColCount := 2
      + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;
    frameMT3DMS_SSM.InitializeNoParamFrame(AScreenObject.Mt3dmsConcBoundary);
    if (AScreenObject.Mt3dmsConcBoundary <> nil)
      and not AScreenObject.Mt3dmsConcBoundary.Used then
    begin
      AScreenObject.Mt3dmsConcBoundary := nil;
    end;

    AScreenObject.CreateMt3dUzfRchConcBoundary;
    frameMt3d_UZT_Rech.rdgModflowBoundary.ColCount := 2
      + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;
    frameMt3d_UZT_Rech.InitializeNoParamFrame(AScreenObject.Mt3dUzfRechConc);
    for ColIndex := 2 to frameMt3d_UZT_Rech.rdgModflowBoundary.ColCount - 1 do
    begin
      frameMt3d_UZT_Rech.rdgModflowBoundary.Cells[ColIndex, 0] :=
        frameMt3d_UZT_Rech.rdgModflowBoundary.Cells[ColIndex, 0] + ' CUZINF';
    end;
    if (AScreenObject.Mt3dUzfRechConc <> nil)
      and not AScreenObject.Mt3dUzfRechConc.Used then
    begin
      AScreenObject.Mt3dUzfRechConc := nil;
    end;

    AScreenObject.CreateMt3dUztSatEtConcBoundary;
    frameMt3d_UZT_Sat.rdgModflowBoundary.ColCount := 2
      + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;
    frameMt3d_UZT_Sat.InitializeNoParamFrame(AScreenObject.Mt3dUztSatEtConcBoundary);
    for ColIndex := 2 to frameMt3d_UZT_Sat.rdgModflowBoundary.ColCount - 1 do
    begin
      frameMt3d_UZT_Sat.rdgModflowBoundary.Cells[ColIndex, 0] :=
        frameMt3d_UZT_Sat.rdgModflowBoundary.Cells[ColIndex, 0] + ' CGWET';
    end;
    if (AScreenObject.Mt3dUztSatEtConcBoundary <> nil)
      and not AScreenObject.Mt3dUztSatEtConcBoundary.Used then
    begin
      AScreenObject.Mt3dUztSatEtConcBoundary := nil;
    end;

    AScreenObject.CreateMt3dUztUnsatEtConcBoundary;
    frameMt3d_UZT_Unsat.rdgModflowBoundary.ColCount := 2
      + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;
    frameMt3d_UZT_Unsat.InitializeNoParamFrame(AScreenObject.Mt3dUztUnsatEtConcBoundary);
    for ColIndex := 2 to frameMt3d_UZT_Unsat.rdgModflowBoundary.ColCount - 1 do
    begin
      frameMt3d_UZT_Unsat.rdgModflowBoundary.Cells[ColIndex, 0] :=
        frameMt3d_UZT_Unsat.rdgModflowBoundary.Cells[ColIndex, 0] + ' CUZET';
    end;
    if (AScreenObject.Mt3dUztUnsatEtConcBoundary <> nil)
      and not AScreenObject.Mt3dUztUnsatEtConcBoundary.Used then
    begin
      AScreenObject.Mt3dUztUnsatEtConcBoundary := nil;
    end;

    AScreenObject.CreateMt3dUzSsmSinkConcBoundary;
    frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary.ColCount := 2
      + frmGoPhast.PhastModel.NumberOfMt3dChemComponents;
    frameMT3D_Uzf_Ssm_Conc.InitializeNoParamFrame(AScreenObject.Mt3dUzSsmSinkConcBoundary);
    for ColIndex := 2 to frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary.ColCount - 1 do
    begin
      frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary.Cells[ColIndex, 0] :=
        frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary.Cells[ColIndex, 0] + ' CGWET';
    end;
    if (AScreenObject.Mt3dUzSsmSinkConcBoundary <> nil)
      and not AScreenObject.Mt3dUzSsmSinkConcBoundary.Used then
    begin
      AScreenObject.Mt3dUzSsmSinkConcBoundary := nil;
    end;

    AScreenObject.CreateResBoundary;
    frameRes.InitializeNoParamFrame(AScreenObject.ModflowResBoundary);
    if (AScreenObject.ModflowResBoundary <> nil)
      and not AScreenObject.ModflowResBoundary.Used then
    begin
      AScreenObject.ModflowResBoundary := nil;
    end;

    AScreenObject.CreateLakBoundary;
    frameLak.InitializeNoParamFrame(AScreenObject.ModflowLakBoundary);
    if (AScreenObject.ModflowLakBoundary <> nil)
      and not AScreenObject.ModflowLakBoundary.Used then
    begin
      AScreenObject.ModflowLakBoundary := nil;
    end;

    frameScreenObjectUZF.rdgModflowBoundary.RowHeights[0] :=
      frameScreenObjectUZF.rdgModflowBoundary.DefaultRowHeight;
    AScreenObject.CreateUzfBoundary;
    frameScreenObjectUZF.InitializeNoParamFrame(AScreenObject.ModflowUzfBoundary);
    if frmGoPhast.PhastModel.ModflowPackages.UzfPackage.SimulateET then
    begin
      frameScreenObjectUZF.rdgModflowBoundary.ColCount := 6;
      // UZF ET Rates
      frameScreenObjectUZF.rdgModflowBoundary.Columns[3].WordWrapCaptions := True;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[3].AutoAdjustRowHeights := True;
      TimeList := AScreenObject.ModflowUzfBoundary.EvapotranspirationDemand.TimeLists[0, frmGoPhast.PhastModel];
      frameScreenObjectUZF.rdgModflowBoundary.Cells[3, 0] := TimeList.NonParamDescription;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[3].AutoAdjustColWidths := False;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[3].AutoAdjustRowHeights := False;
      frameScreenObjectUZF.rdgModflowBoundary.ColWidths[3] :=
        frameScreenObjectUZF.rdgModflowBoundary.WidthNeededToFitText(3,0);
      // UZF ET Extinction depth
      frameScreenObjectUZF.rdgModflowBoundary.Columns[4].WordWrapCaptions := True;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[4].AutoAdjustRowHeights := True;
      TimeList := AScreenObject.ModflowUzfBoundary.ExtinctionDepth.TimeLists[0, frmGoPhast.PhastModel];
      frameScreenObjectUZF.rdgModflowBoundary.Cells[4, 0] := TimeList.NonParamDescription;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[4].AutoAdjustColWidths := False;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[4].AutoAdjustRowHeights := False;
      frameScreenObjectUZF.rdgModflowBoundary.ColWidths[4] :=
        frameScreenObjectUZF.rdgModflowBoundary.WidthNeededToFitText(4,0);
      // UZF ET Extinction water content
      frameScreenObjectUZF.rdgModflowBoundary.Columns[5].WordWrapCaptions := True;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[5].AutoAdjustRowHeights := True;
      TimeList := AScreenObject.ModflowUzfBoundary.WaterContent.TimeLists[0, frmGoPhast.PhastModel];
      frameScreenObjectUZF.rdgModflowBoundary.Cells[5, 0] := TimeList.NonParamDescription;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[5].AutoAdjustColWidths := False;
      frameScreenObjectUZF.rdgModflowBoundary.Columns[5].AutoAdjustRowHeights := False;
      frameScreenObjectUZF.rdgModflowBoundary.ColWidths[5] :=
        frameScreenObjectUZF.rdgModflowBoundary.WidthNeededToFitText(5,0);
    end
    else
    begin
      frameScreenObjectUZF.rdgModflowBoundary.ColCount := 3;
    end;
    // dispose of UZF.
    if (AScreenObject.ModflowUzfBoundary <> nil)
      and not AScreenObject.ModflowUzfBoundary.Used then
    begin
      AScreenObject.ModflowUzfBoundary := nil;
    end;

    AScreenObject.CreateCfpRchFraction;
    if (AScreenObject.ModflowCfpRchFraction <> nil)
      and not AScreenObject.ModflowCfpRchFraction.Used then
    begin
      AScreenObject.ModflowCfpRchFraction := nil;
    end;

    AScreenObject.CreateSwrRainBoundary;
    frameSWR_Rain.InitializeNoParamFrame(AScreenObject.ModflowSwrRain);
    if (AScreenObject.ModflowSwrRain <> nil)
      and not AScreenObject.ModflowSwrRain.Used then
    begin
      AScreenObject.ModflowSwrRain := nil;
    end;

    AScreenObject.CreateSwrEvapBoundary;
    frameSWR_Evap.InitializeNoParamFrame(AScreenObject.ModflowSwrEvap);
    if (AScreenObject.ModflowSwrEvap <> nil)
      and not AScreenObject.ModflowSwrEvap.Used then
    begin
      AScreenObject.ModflowSwrEvap := nil;
    end;

    AScreenObject.CreateSwrLatInflowBoundary;
    frameSWR_LatInfl.InitializeNoParamFrame(AScreenObject.ModflowSwrLatInflow);
    if (AScreenObject.ModflowSwrLatInflow <> nil)
      and not AScreenObject.ModflowSwrLatInflow.Used then
    begin
      AScreenObject.ModflowSwrLatInflow := nil;
    end;

    AScreenObject.CreateSwrStageBoundary;
    frameSWR_Stage.InitializeNoParamFrame(AScreenObject.ModflowSwrStage);
    if (AScreenObject.ModflowSwrStage <> nil)
      and not AScreenObject.ModflowSwrStage.Used then
    begin
      AScreenObject.ModflowSwrStage := nil;
    end;

    AScreenObject.CreateSwrDirectRunoffBoundary;
    frameSWR_DirectRunoff.InitializeNoParamFrame(AScreenObject.ModflowSwrDirectRunoff);
    if (AScreenObject.ModflowSwrDirectRunoff <> nil)
      and not AScreenObject.ModflowSwrDirectRunoff.Used then
    begin
      AScreenObject.ModflowSwrDirectRunoff := nil;
    end;

    frameSwrReach.InitializeFrame;

  finally
    AScreenObject.CanInvalidateModel := PriorCanInvalidateModel;
    frmGoPhast.PhastModel.UpToDate := StoredUpToDate;
  end;
end;

function TfrmScreenObjectProperties.CanSetPoints: Boolean;
var
  Index: Integer;
  APoint: TPoint2D;
  TempScreenObject: TScreenObject;
begin
  if not IsLoaded then
  begin
    result := False;
    Exit;
  end;
  result := FStoredCanSetPoints;
  if FCanSetPointsOutOfDate then
  begin
    result := True;
    try
      TempScreenObject := frmGoPhast.PhastModel.ScreenObjectClass.Create(nil);
      try
        TempScreenObject.Capacity := dgVerticies.RowCount - 1;
        for Index := 1 to dgVerticies.RowCount - 1 do
        begin
          if not AssignPoint(Index, APoint) then
          begin
            Continue;
          end;
          try
            TempScreenObject.AddPoint(APoint,
              dgVerticies.Checked[Ord(vcNewSection),Index]);
          except
            on E: EScreenObjectError do
            begin
            end;
          end;
          if TempScreenObject.Count <> Index then
          begin
            result := False;
            Break;
          end;
        end;
      finally
        TempScreenObject.Free;
      end;
    finally
      FStoredCanSetPoints := result;
      FCanSetPointsOutOfDate := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreInterpolatedBoundary(
  Boundary: TCustomInterpolatedBoundary; DataGrid: TRbwDataGrid4);
var
  Time: Extended;
  InterpValuesCollection: TInterpValuesCollection;
  RowIndex: Integer;
  BoundaryValue: TRealPhastBoundaryCondition;
  SolutionValue: TIntegerPhastBoundaryCondition;
  InterpValueItem: TInterpValuesItem;
begin
  for RowIndex := 1 to DataGrid.RowCount - 1 do
  begin
    if TryStrToFloat(DataGrid.Cells[Ord(ibcTime), RowIndex], Time) then
    begin
      Assert(DataGrid.State[Ord(ibcBoundaryInterpolate), RowIndex] <> cbGrayed);
      Assert(DataGrid.State[Ord(ibcSolutionInterpolate), RowIndex] <> cbGrayed);

      if DataGrid.Checked[
        Ord(ibcBoundaryInterpolate), RowIndex] then
      begin
        InterpValuesCollection := DataGrid.Objects[
          Ord(ibcBoundaryInterpolate), RowIndex] as TInterpValuesCollection;
        InterpValueItem := InterpValuesCollection.Items[0] as TInterpValuesItem;
        BoundaryValue := Boundary.BoundaryValue.Add
          as TRealPhastBoundaryCondition;
        BoundaryValue.Time := Time;
        BoundaryValue.Assign(InterpValueItem);
      end
      else
      begin
        if DataGrid.Cells[Ord(ibcBoundaryValue), RowIndex] <> '' then
        begin
          BoundaryValue := Boundary.BoundaryValue.Add
            as TRealPhastBoundaryCondition;
          BoundaryValue.Time := Time;
          BoundaryValue.UsePHAST_Interpolation := False;
          BoundaryValue.FormulaExpression := DataGrid.Cells[
            Ord(ibcBoundaryValue), RowIndex];
        end;
      end;
      if DataGrid.Checked[Ord(ibcSolutionInterpolate), RowIndex] then
      begin
        InterpValuesCollection := DataGrid.Objects[
          Ord(ibcSolutionInterpolate), RowIndex] as TInterpValuesCollection;
        InterpValueItem := InterpValuesCollection.Items[0]
          as TInterpValuesItem;
        SolutionValue := Boundary.Solution.Add
          as TIntegerPhastBoundaryCondition;
        SolutionValue.Time := Time;
        SolutionValue.Assign(InterpValueItem);
      end
      else
      begin
        if DataGrid.Cells[Ord(ibcSolution), RowIndex] <> '' then
        begin
          SolutionValue := Boundary.Solution.Add
            as TIntegerPhastBoundaryCondition;
          SolutionValue.Time := Time;
          SolutionValue.UsePHAST_Interpolation := False;
          SolutionValue.FormulaExpression := DataGrid.Cells[
            Ord(ibcSolution), RowIndex];
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreNonInterpolatedBoundary(Boundary: TCustomInterpolatedBoundary; DataGrid: TRbwDataGrid4);
var
  Time: Extended;
  RowIndex: Integer;
  BoundaryValue: TRealPhastBoundaryCondition;
  SolutionValue: TIntegerPhastBoundaryCondition;
begin
  for RowIndex := 1 to DataGrid.RowCount - 1 do
  begin
    if TryStrToFloat(DataGrid.Cells[Ord(nicTime), RowIndex], Time) then
    begin
        if DataGrid.Cells[Ord(nicBoundaryValue), RowIndex] <> '' then
        begin
          BoundaryValue := Boundary.BoundaryValue.Add
            as TRealPhastBoundaryCondition;
          BoundaryValue.Time := Time;
          BoundaryValue.UsePHAST_Interpolation := False;
          BoundaryValue.FormulaExpression := DataGrid.Cells[
            Ord(nicBoundaryValue), RowIndex];
        end;

        if DataGrid.Cells[Ord(nicSolution), RowIndex] <> '' then
        begin
          SolutionValue := Boundary.Solution.Add
            as TIntegerPhastBoundaryCondition;
          SolutionValue.Time := Time;
          SolutionValue.UsePHAST_Interpolation := False;
          SolutionValue.FormulaExpression := DataGrid.Cells[
            Ord(nicSolution), RowIndex];
        end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.ShowOrHideTabs;
var
  CanSetData: boolean;
begin
  CanSetData := (cbEnclosedCells.State <> cbUnchecked)
    or (cbIntersectedCells.State <> cbUnchecked)
    or (cbInterpolation.State <> cbUnchecked);
  tabBoundaries.TabVisible := CanSetData and
    (frmGoPhast.ModelSelection = msPhast) and
    (rgEvaluatedAt.ItemIndex = 1) and
    ((FScreenObjectList = nil) or (FScreenObjectList.Count = 1));
  tabDataSets.TabVisible := CanSetData and
    (frmGoPhast.PhastModel.DataArrayManager.DataSetCount > 0);
  tabModflowBoundaryConditions.TabVisible := CanSetData and
    (frmGoPhast.ModelSelection in ModflowSelection);
  tabSutraFeatures.TabVisible := CanSetData and
    (frmGoPhast.ModelSelection in SutraSelection);
  tabFootprintFeatures.TabVisible := CanSetData and
    (frmGoPhast.ModelSelection = msFootprint);
end;

procedure TfrmScreenObjectProperties.AssignNewDataSetFormula(
  DSIndex: Integer; const NewFormula: string);
var
  Item: TScreenObjectEditItem;
  Position: Integer;
  DataSet: TDataArray;
  Index: Integer;
  Edit: TScreenObjectDataEdit;
begin
  if IsLoaded and (NewFormula <> '') then
  begin
    Edit := FDataEdits[DSIndex];
    DataSet := Edit.DataArray;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Position := Item.ScreenObject.IndexOfDataSet(DataSet);
      if Position >= 0 then
      begin
        Item.ScreenObject.DataSetFormulas[Position] := NewFormula;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetListOfOkVariables(
  EvaluatedAt: TEvaluatedAt; Orientation: TDataSetOrientation;
  VariableList: TList; DataSetIndex: Integer;
  DSEdit: TScreenObjectDataEdit);
var
  VariablePosition: Integer;
  TempUsesList: TStringList;
  VariableName: string;
  DataSet: TDataArray;
  Index: Integer;
  Edit: TScreenObjectDataEdit;
  DataArrayManager: TDataArrayManager;
begin
  TempUsesList := DSEdit.UsedBy;
  DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
  for Index := 0 to DataArrayManager.DataSetCount - 1 do
  begin
    DataSet := DataArrayManager.DataSets[Index];
    if not DataSet.Visible then
    begin
      Continue;
    end;
    if DataSet is TCustomSparseDataSet then
    begin
      Continue;
    end;
    if (Index <> DataSetIndex)
      and (EvaluatedAt = DataSet.EvaluatedAt)
      and DataSet.Visible then
    begin
      VariableName := DataSet.Name;
//      OtherEdit := FDataEdits[GetDataSetIndexByName(VariableName)];
//      TempUsesList := OtherEdit.UsedBy;
      VariablePosition := TempUsesList.IndexOf(VariableName);
      if (VariablePosition < 0) and ((Orientation = dso3D)
        or (Orientation = DataSet.Orientation)) then
      begin
        Edit := FDataEdits[Index];
        // if the variable
        // (1) does not depend on the data set whose formula is being edited,
        // (2) it's orientation is OK, and
        // (3) the variable does not represent the TDataArray itself,
        // the variable can be used in the formula.
        VariableList.Add(Edit.Variable);
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.FormDestroy(Sender: TObject);
begin
  inherited;
//  frameIface.glsvViewer.Free;
//  frameModpathParticles.GLSceneViewer1.Free;

  FVertexCaptionFont.Free;
  FSectionCaptionFont.Free;
  FCaptionFont.Free;
  FCurrentEdit := nil;

  // If FUndoSetScreenObjectProperties was submitted, it will have
  // been set to nil.
  FUndoSetScreenObjectProperties.Free;

  FBoundaryPhastInterpolationList.Free;
  FNewProperties.Free;
  FOldProperties.Free;
  FDataEdits.Free;
  FChildModels.Free;
  FChildModelsScreenObjects.Free;
  FPestParameters.Free;
  FPestBlockParametersAndDataSets.Free;
  FPestNodeParametersAndDataSets.Free;
  FPestMethods.Free;
end;

procedure TfrmScreenObjectProperties.FormKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  inherited;
  if (ActiveControl is TRbwDataGrid4) and (ssCtrl in Shift)
    and (Key in [Ord('a'), Ord('A')]) then
  begin
    TRbwDataGrid4(ActiveControl).SelectAll;
  end;
end;

function TfrmScreenObjectProperties.GetDataSetIndexByName(const DataSetName:
  string):
  integer;
var
  Index: integer;
  DataSet: TDataArray;
  Edit: TScreenObjectDataEdit;
begin
  // GetDataSetIndexByName returns the position of the data set whose name is
  // DataSetName in FDataSetList.  If the data set isn't in FDataSetList,
  // GetDataSetIndexByName returns -1.
  result := -1;
  for Index := 0 to FDataEdits.Count - 1 do
  begin
    Edit := FDataEdits[Index];
    DataSet := Edit.DataArray;
    if DataSet.Name = DataSetName then
    begin
      result := Index;
      Exit;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.CheckForCircularReference(
  const Expression: TExpression; const DSetName: string;
  const EditIndex: integer; const OldFormulaOK: boolean;
  const OldFormula: string);
var
  Used: TStringList;
  Index: integer;
  VariableName: string;
  Edit: TScreenObjectDataEdit;
begin
  Assert(Expression <> nil);
  Used := TStringList.Create;
  try
    Edit := FDataEdits[EditIndex];
    Used.Assign(Expression.VariablesUsed);
    // Check that the formula does not result in
    // a circular reference.
    for Index := 0 to Used.Count - 1 do
    begin
      VariableName := Used[Index];
      if Edit.UsedBy.IndexOf(VariableName) >= 0 then
      begin
        Edit.Expression := nil;
        Beep;
        if OldFormulaOK then
        begin
          if MessageDlg(Format(StrErrorThereAppears, [VariableName, DSetName]),
            mtError, [mbYes, mbNo], 0) = mrYes then
          begin
            Edit.Formula := OldFormula;
            CreateFormula(EditIndex, OldFormula);
          end;
        end
        else
        begin
          MessageDlg(Format(StrErrorThereAppearsNoRevert,
            [VariableName, DSetName]), mtError, [mbOK], 0)
        end;
        Exit;
      end;
    end;
  finally
    Used.Free;
  end;
end;

procedure TfrmScreenObjectProperties.CreateVariable(const Edit: TScreenObjectDataEdit);
var
  NewName: string;
  DataType: TRbwDataType;
  Variable: TCustomVariable;
  TempFormulaCompiler: TRbwParser;
  DataSet: TDataArray;
  Local3DCompiler: TRbwParser;
  NewDisplayName: string;
begin
  // Create a variable to represent the dataset specified by Index in
  // each TRbwParser that needs it.
  DataSet := Edit.DataArray;
  TempFormulaCompiler := GetCompiler(DataSet.Orientation, DataSet.EvaluatedAt);

  Variable := nil;
  NewName := DataSet.Name;
  NewDisplayName := DataSet.DisplayName;

  Local3DCompiler := nil;
  case DataSet.EvaluatedAt of
    eaBlocks:
      begin
        Local3DCompiler := rparserThreeDFormulaElements;
      end;
    eaNodes:
      begin
        Local3DCompiler := rparserThreeDFormulaNodes;
      end;
  else
    Assert(False);
  end;

  DataType := DataSet.Datatype;
  case DataType of
    rdtDouble:
      begin
        Variable := TempFormulaCompiler.CreateVariable(NewName,
          DataSet.FullClassification, 0.0, NewDisplayName);
        if TempFormulaCompiler <> Local3DCompiler then
        begin
          Local3DCompiler.CreateVariable(NewName, DataSet.FullClassification, 0.0, NewDisplayName);
        end;
      end;
    rdtInteger:
      begin
        Variable := TempFormulaCompiler.CreateVariable(NewName,
          DataSet.FullClassification, 0, NewDisplayName);
        if TempFormulaCompiler <> Local3DCompiler then
        begin
          Local3DCompiler.CreateVariable(NewName, DataSet.FullClassification, 0, NewDisplayName);
        end;
      end;
    rdtBoolean:
      begin
        Variable := TempFormulaCompiler.CreateVariable(NewName,
          DataSet.FullClassification, False, NewDisplayName);
        if TempFormulaCompiler <> Local3DCompiler then
        begin
          Local3DCompiler.CreateVariable(NewName, DataSet.FullClassification, False, NewDisplayName);
        end;
      end;
    rdtString:
      begin
        Variable := TempFormulaCompiler.CreateVariable(NewName,
          DataSet.FullClassification, '0', NewDisplayName);
        if TempFormulaCompiler <> Local3DCompiler then
        begin
          Local3DCompiler.CreateVariable(NewName, DataSet.FullClassification, '0', NewDisplayName);
        end;
      end;
  else
    Assert(False);
  end;
  Edit.Variable := Variable;
end;

function TfrmScreenObjectProperties.GetElevationCompiler: TRbwParser;
var
  AScreenObject: TScreenObject;
begin
  // GetElevationCompiler returns the compiler that is appropriate
  // for specifying the elevation formula for a screen object based on the
  // direction from which the screen object is viewed and whether it is evaluated
  // by blocks or nodes.
  result := nil;
  AScreenObject := nil;
  if FScreenObject = nil then
  begin
    if FScreenObjectList.Count > 0 then
    begin
      AScreenObject := FScreenObjectList[0];
    end;
  end
  else
  begin
    AScreenObject := FScreenObject
  end;
  if AScreenObject = nil then
  begin
    result := nil;
  end
  else
  begin
    case rgEvaluatedAt.ItemIndex of
      0:
        begin
          case AScreenObject.ViewDirection of
            vdTop:
              begin
                result := rparserTopFormulaElements;
              end;
            vdFront:
              begin
                result := rparserFrontFormulaElements;
              end;
            vdSide:
              begin
                result := rparserSideFormulaElements;
              end;
          else
            Assert(False);
          end;
        end;
      1:
        begin
          case AScreenObject.ViewDirection of
            vdTop:
              begin
                result := rparserTopFormulaNodes;
              end;
            vdFront:
              begin
                result := rparserFrontFormulaNodes;
              end;
            vdSide:
              begin
                result := rparserSideFormulaNodes;
              end;
          else
            Assert(False);
          end;
        end;
    else
      result := nil;
    end;
  end;
end;

function TfrmScreenObjectProperties.GetCompiler(const Orientation:
  TDataSetOrientation; const EvaluatedAt: TEvaluatedAt): TRbwParser;
begin
  // GetCompiler returns the appropriate TRbwParser based on the
  // combination of Orientation and EvaluatedAt.
  result := nil;
  case EvaluatedAt of
    eaBlocks:
      begin
        case Orientation of
          dsoTop:
            begin
              result := rparserTopFormulaElements;
            end;
          dsoFront:
            begin
              result := rparserFrontFormulaElements;
            end;
          dsoSide:
            begin
              result := rparserSideFormulaElements;
            end;
          dso3D:
            begin
              result := rparserThreeDFormulaElements;
            end;
        else
          Assert(False);
        end;
      end;
    eaNodes:
      begin
        case Orientation of
          dsoTop:
            begin
              result := rparserTopFormulaNodes;
            end;
          dsoFront:
            begin
              result := rparserFrontFormulaNodes;
            end;
          dsoSide:
            begin
              result := rparserSideFormulaNodes;
            end;
          dso3D:
            begin
              result := rparserThreeDFormulaNodes;
            end;
        else
          Assert(False);
        end;
      end;
  else
    Assert(False);
  end;
end;

function TfrmScreenObjectProperties.GetCompilerByIndex(const Index: integer):
  TRbwParser;
var
  DataSet: TDataArray;
  Orientation: TDataSetOrientation;
  EvaluatedAt: TEvaluatedAt;
  Edit: TScreenObjectDataEdit;
begin
  // GetCompiler determines the Orientation and EvaluatedAt of the data set
  // at Index and returns the appropriate compiler based on that combination.
  Edit := FDataEdits[Index];
  DataSet := Edit.DataArray;
  Orientation := DataSet.Orientation;
  EvaluatedAt := DataSet.EvaluatedAt;

  result := GetCompiler(Orientation, EvaluatedAt);
end;

procedure TfrmScreenObjectProperties.GetGhbBoundary(ScreenObjectList: TList);
const
  HeadPosition = 0;
  ConductancePosition = 1;
  MultiplierPosition = 2;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectCondParam;
  Parameter: TParameterType;
  ColIndex: Integer;
  SpeciesIndex: Integer;
begin
  if not frmGoPhast.PhastModel.GhbIsSelected then
  begin
    Exit;
  end;
  Frame := frameGhbParam;
  Parameter := ptGHB;
  GetFormulaInterpretation(Frame, Parameter, ScreenObjectList);
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FGHB_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FGHB_Node);

  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+HeadPosition] :=
    TGhbBoundary.DefaultBoundaryMethod(HeadPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ConductancePosition] :=
    TGhbBoundary.DefaultBoundaryMethod(ConductancePosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+MultiplierPosition] :=
    TGhbBoundary.DefaultBoundaryMethod(MultiplierPosition);
  if frmGoPhast.PhastModel.GwtUsed or frmGoPhast.PhastModel.BuoyancyDensityUsed then
  begin
    for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
    begin
      ColIndex := SpeciesIndex + ColumnOffset+ConductancePosition+1;
      PestMethod[Frame.rdgModflowBoundary, ColIndex] :=
        TGhbBoundary.DefaultBoundaryMethod(ColIndex- ColumnOffset);
    end;
    for ColIndex := ColumnOffset to Frame.rdgModflowBoundary.ColCount - 1 do
    begin
      if not Frame.PestMethodAssigned[ColIndex] then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColIndex] := ppmMultiply;
      end;
    end;
  end;
  GetPestModifiers(Frame, Parameter, ScreenObjectList);

  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.GetWellBoundary(ScreenObjectList: TList);
const
  PumpingRatePosition = 0;
  MultiplierPosition = 1;
  GstStart = 2;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectCondParam;
  Parameter: TParameterType;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMfWellBoundary;
  First: Boolean;
  ColIndex: Integer;
  SpeciesIndex: Integer;
begin
  if not frmGoPhast.PhastModel.WelIsSelected then
  begin
    Exit;
  end;
  Frame := frameWellParam;
  Parameter := ptQ;
  GetFormulaInterpretation(Frame, Parameter, ScreenObjectList);
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FWEL_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FWEL_Node);

  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+PumpingRatePosition] :=
    TMfWellBoundary.DefaultBoundaryMethod(PumpingRatePosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+MultiplierPosition] :=
    TMfWellBoundary.DefaultBoundaryMethod(MultiplierPosition);
  GetPestModifiers(Frame, Parameter, ScreenObjectList);
  if frmGoPhast.PhastModel.GwtUsed then
  begin
    for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
    begin
      ColIndex := SpeciesIndex*2 + ColumnOffset+GstStart;
      PestMethod[Frame.rdgModflowBoundary, ColIndex] :=
        TMfWellBoundary.DefaultBoundaryMethod(ColIndex- ColumnOffset);
      PestMethod[Frame.rdgModflowBoundary, ColIndex+1] :=
        TMfWellBoundary.DefaultBoundaryMethod(ColIndex+1- ColumnOffset);
    end;
    for ColIndex := ColumnOffset to Frame.rdgModflowBoundary.ColCount - 1 do
    begin
      if not Frame.PestMethodAssigned[ColIndex] then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColIndex] := ppmMultiply;
      end;
    end;
  end;

  Frame.rdgModflowBoundary.HideEditor;
  First := True;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowWellBoundary;
    if (Boundary <> nil) and Boundary.Used then
    begin
      if First then
      begin
        frameWellParam.fedTabfile.FileName := Boundary.TabFileName;
        First := False;
      end
      else if frameWellParam.fedTabfile.FileName <> Boundary.TabFileName then
      begin
        frameWellParam.fedTabfile.FileName := '';
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.GetFarmWell(ScreenObjectList: TList);
const
  FmpWellMaxPumpingRatePosition = 0;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectCondParam;
  Parameter: TParameterType;
begin
  if not (frmGoPhast.PhastModel.FarmProcess3IsSelected
    or frmGoPhast.PhastModel.FarmProcess4WellSelected) then
  begin
    Exit;
  end;
  Frame := frameFarmWell;
  Parameter := ptQMAX;
  GetFormulaInterpretation(Frame, Parameter, ScreenObjectList);
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FFarmWell_Node);

  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+FmpWellMaxPumpingRatePosition] :=
    TFmpWellBoundary.DefaultBoundaryMethod(FmpWellMaxPumpingRatePosition);
  GetPestModifiers(Frame, Parameter, ScreenObjectList);

  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.GetRivBoundary(ScreenObjectList: TList);
const
  StagePosition = 0;
  ConductancePosition = 1;
  BottomPosition = 2;
  MultiplierPosition = 3;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectCondParam;
  Parameter: TParameterType;
  ColIndex: Integer;
  SpeciesIndex: Integer;
begin
  if not frmGoPhast.PhastModel.RivIsSelected then
  begin
    Exit;
  end;
  Frame := frameRivParam;
  Parameter := ptRIV;
  GetFormulaInterpretation(Frame, Parameter, ScreenObjectList);
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FRIV_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FRIV_Node);

  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+StagePosition] :=
    TRivBoundary.DefaultBoundaryMethod(StagePosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ConductancePosition] :=
    TRivBoundary.DefaultBoundaryMethod(ConductancePosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+BottomPosition] :=
    TRivBoundary.DefaultBoundaryMethod(BottomPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+MultiplierPosition] :=
    TRivBoundary.DefaultBoundaryMethod(MultiplierPosition);
  if frmGoPhast.PhastModel.GwtUsed then
  begin
    for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
    begin
      ColIndex := SpeciesIndex + ColumnOffset+MultiplierPosition+1;
      PestMethod[Frame.rdgModflowBoundary, ColIndex] :=
        TRivBoundary.DefaultBoundaryMethod(ColIndex- ColumnOffset);
    end;
    for ColIndex := ColumnOffset to Frame.rdgModflowBoundary.ColCount - 1 do
    begin
      if not Frame.PestMethodAssigned[ColIndex] then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColIndex] := ppmMultiply;
      end;
    end;
  end;
  GetPestModifiers(Frame, Parameter, ScreenObjectList);

  Frame.rdgModflowBoundary.HideEditor;
end;

function TfrmScreenObjectProperties.GetSfrParser(Sender: TObject): TRbwParser;
begin
  result := rparserThreeDFormulaElements;
end;

procedure TfrmScreenObjectProperties.GetSrcBoundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  GwtSrcBoundary: TSrcBoundary;
begin
  if not frmGoPhast.PhastModel.GwtSrcIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    GwtSrcBoundary := AScreenObject.GwtSrcBoundary;
    UpdateBoundaryState(GwtSrcBoundary, ScreenObjectIndex, State);
  end;
  if FGwtSrc_Node <> nil then
  begin
    FGwtSrc_Node.StateIndex := Ord(State)+1;
  end;
  frameGwtSrc.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetCfpRechargeBoundary(ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TCfpRchFractionBoundary;
begin
  if not frmGoPhast.PhastModel.CfpRechargeIsSelected(nil) then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowCfpRchFraction;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FCRCH_Node <> nil then
  begin
    FCRCH_Node.StateIndex := Ord(State)+1;
  end;

  frameCfpRechargeFraction1.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetUzfBoundary(ScreenObjectList: TList);
const
  ColOffset = 2;
  First = 0;
  Last = 3;
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TUzfBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  Gage1, Gage2: integer;
  FirstScreenObjectFound: boolean;
  State: TCheckBoxState;
  FormulaIndex: Integer;
  Frame: TframeScreenObjectNoParam;
  procedure GetUzfModifiers;
  var
    BoundaryIndex: Integer;
    FirstItem: Boolean;
    Identical: Boolean;
    Method: TPestParamMethod;
    ScreenObjectIndex: Integer;
    AScreenObject: TScreenObject;
    Boundary: TUzfBoundary;
    Modifier: string;
  begin
    Frame.rdgModflowBoundary.BeginUpdate;
    try
      for BoundaryIndex := First to Last do
      begin
        FirstItem := True;
        Identical := True;
        Method := ppmMultiply;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowUzfBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if FirstItem then
            begin
              Method := Boundary.PestBoundaryMethod[BoundaryIndex];
              FirstItem := False;
            end
            else
            begin
              Identical := Method = Boundary.PestBoundaryMethod[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          PestMethod[Frame.rdgModflowBoundary, ColOffset+BoundaryIndex] := Method;
        end
        else
        begin
          Frame.rdgModflowBoundary.Cells[ColOffset+BoundaryIndex,PestMethodRow] := '';
        end;
      end;

      for BoundaryIndex := First to Last do
      begin
        FirstItem := True;
        Identical := True;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowUzfBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if FirstItem then
            begin
              Modifier := Boundary.PestBoundaryFormula[BoundaryIndex];
              FirstItem := False;
            end
            else
            begin
              Identical := Modifier = Boundary.PestBoundaryFormula[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          if Modifier = '' then
          begin
            Modifier := StrNone
          end;
          PestModifier[Frame.rdgModflowBoundary,
            ColOffset+BoundaryIndex] := Modifier;
        end
        else
        begin
          PestModifier[Frame.rdgModflowBoundary,
            ColOffset+BoundaryIndex] := '';
        end;
      end;
    finally
      Frame.rdgModflowBoundary.EndUpdate;
    end;
  end;
begin
  if not frmGoPhast.PhastModel.UzfIsSelected then
  begin
    Exit;
  end;
  FirstScreenObjectFound := False;
  TimeList := TParameterTimeList.Create;
  try
    cbUzfGage1.AllowGrayed := False;
    cbUzfGage2.AllowGrayed := False;
    cbUzfGage3.AllowGrayed := False;
    Gage1 := -1;
    Gage2 := -1;
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowUzfBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FUZF_Node <> nil then
    begin
      FUZF_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowUzfBoundary;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
        for TimeIndex := 0 to Boundary.EvapotranspirationDemand.Count - 1 do
        begin
          Item := Boundary.EvapotranspirationDemand[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
        for TimeIndex := 0 to Boundary.ExtinctionDepth.Count - 1 do
        begin
          Item := Boundary.ExtinctionDepth[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
        for TimeIndex := 0 to Boundary.WaterContent.Count - 1 do
        begin
          Item := Boundary.WaterContent[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
        if not FirstScreenObjectFound then
        begin
          Gage1 := AScreenObject.ModflowUzfBoundary.GageOption1;
          Gage2 := AScreenObject.ModflowUzfBoundary.GageOption2;
        end
        else
        begin
          if Gage1 <> AScreenObject.ModflowUzfBoundary.GageOption1 then
          begin
            Gage1 := -1;
          end;
          if Gage2 <> AScreenObject.ModflowUzfBoundary.GageOption2 then
          begin
            Gage2 := -1;
          end;
        end;
        FirstScreenObjectFound := True;
      end;
    end;
    if not FirstScreenObjectFound then
    begin
      cbUzfGage1.Checked := False;
      cbUzfGage2.Checked := False;
    end
    else if Gage1 < 0 then
    begin
      cbUzfGage1.AllowGrayed := True;
      cbUzfGage1.State := cbGrayed;
      cbUzfGage2.AllowGrayed := True;
      cbUzfGage2.State := cbGrayed;
    end
    else
    begin
      case Gage1 of
        0:
          begin
            cbUzfGage1.Checked := False;
            cbUzfGage2.Checked := False;
          end;
        1:
          begin
            cbUzfGage1.Checked := True;
            cbUzfGage2.Checked := False;
          end;
        2:
          begin
            cbUzfGage1.Checked := True;
            cbUzfGage2.Checked := True;
          end;
        else
          Assert(False);
      end;
    end;
    if not FirstScreenObjectFound then
    begin
      cbUzfGage3.Checked := False;
    end
    else if Gage2 < 0 then
    begin
      cbUzfGage3.AllowGrayed := True;
      cbUzfGage3.State := cbGrayed;
    end
    else
    begin
      case Gage2 of
        0:
          begin
            cbUzfGage3.Checked := False;
          end;
        3:
          begin
            cbUzfGage3.Checked := True;
          end;
        else
          Assert(False);
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameScreenObjectUZF.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameScreenObjectUZF.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetUzfCollection(TimeList, ScreenObjectList, ColumnOffset,
        DataGrid, GetUzfInfiltrationRate);

      if frmGoPhast.PhastModel.ModflowPackages.UzfPackage.SimulateET then
      begin
        ColumnOffset := 3;
        GetUzfCollection(TimeList, ScreenObjectList, ColumnOffset,
          DataGrid, GetUzfEtRate);

        ColumnOffset := 4;
        GetUzfCollection(TimeList, ScreenObjectList, ColumnOffset,
          DataGrid, GetUzfEtExtinctionDepth);

        ColumnOffset := 5;
        GetUzfCollection(TimeList, ScreenObjectList, ColumnOffset,
          DataGrid, GetUzfEtExtinctionWaterContent);
      end;

      Frame := frameScreenObjectUZF;

      for FormulaIndex := First to Last do
      begin
        PestMethod[frameScreenObjectUZF.rdgModflowBoundary, ColOffset+FormulaIndex] :=
          TUzfBoundary.DefaultBoundaryMethod(FormulaIndex);
        GetUzfModifiers;
      end;

      Frame.rdgModflowBoundary.HideEditor;
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;

function TfrmScreenObjectProperties.GetUzfEtRate(Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TUzfBoundary).EvapotranspirationDemand
end;

function TfrmScreenObjectProperties.GetUzfEtExtinctionDepth(Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TUzfBoundary).ExtinctionDepth
end;

function TfrmScreenObjectProperties.GetUzfEtExtinctionWaterContent(Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TUzfBoundary).WaterContent
end;

function TfrmScreenObjectProperties.GetUzfInfiltrationRate(Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TUzfBoundary).Values;
end;

procedure TfrmScreenObjectProperties.GetUzMf6Boundary(
  const ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TUzfMf6Boundary;
begin
  if not frmGoPhast.PhastModel.UzfMf6IsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.ModflowUzfMf6Boundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;
  if FUZF_Mf6_Node <> nil then
  begin
    FUZF_Mf6_Node.StateIndex := Ord(State)+1;
  end;
  frameScreenObjectUzfMf6.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetDrnBoundary(ScreenObjectList: TList);
const
  ElevationPosition = 0;
  ConductancePosition = 1;
  DdrnPosition = 2;
  MultiplierPosition = 3;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectCondParam;
  Parameter: TParameterType;
begin
  if not frmGoPhast.PhastModel.DrnIsSelected then
  begin
    Exit;
  end;
  Frame := frameDrnParam;
  Parameter := ptDRN;
  GetFormulaInterpretation(Frame, Parameter, ScreenObjectList);
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FDRN_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FDRN_Node);

  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ElevationPosition] :=
    TDrnBoundary.DefaultBoundaryMethod(ElevationPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ConductancePosition] :=
    TDrnBoundary.DefaultBoundaryMethod(ConductancePosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+DdrnPosition] :=
    TDrnBoundary.DefaultBoundaryMethod(DdrnPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+MultiplierPosition] :=
    TDrnBoundary.DefaultBoundaryMethod(MultiplierPosition);
  GetPestModifiers(Frame, Parameter, ScreenObjectList);

  Frame.rdgModflowBoundary.HideEditor;
end;

function TfrmScreenObjectProperties.GetRechargeLayers(
  Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TRchBoundary).RechargeLayers;
end;

function TfrmScreenObjectProperties.GetEvapLayers(
  Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TEvtBoundary).EvapotranspirationLayers;
end;

function TfrmScreenObjectProperties.GetEtsLayers(
  Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TEtsBoundary).EvapotranspirationLayers;
end;

function TfrmScreenObjectProperties.GetEvapSurfaceDepth(
  Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TEvtBoundary).EvtSurfDepthCollection;
end;

function TfrmScreenObjectProperties.GetEtsSurfaceDepth(
  Boundary: TModflowBoundary): TCustomMF_BoundColl;
begin
  result := (Boundary as TEtsBoundary).EtsSurfDepthCollection;
end;

procedure TfrmScreenObjectProperties.GetRchBoundary(ScreenObjectList: TList);
const
  RechPosition = 0;
  MultPosition = 1;
  ColOffset = 2;
var
  Frame: TframeScreenObjectParam;
  Parameter: TParameterType;
  TimeList: TParameterTimeList;
  ValuesFunction: TGetBoundaryCollectionEvent;
  ColumnOffset: integer;
  SpeciesIndex: Integer;
  ColIndex: Integer;
begin
  if not frmGoPhast.PhastModel.RchIsSelected then
  begin
    Exit;
  end;
  Frame := frameRchParam;
  Parameter := ptRch;
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FRCH_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FRCH_Node);

  ColumnOffset := 3;
  if frmGoPhast.PhastModel.RchTimeVaryingLayers then
  begin
    TimeList := TParameterTimeList.Create;
    try
      GetModflowBoundaryTimes(ScreenObjectList, Parameter, TimeList);
      ColumnOffset := 4;
      ValuesFunction := GetRechargeLayers;

      GetModflowBoundaryCollection(Frame.rdgModflowBoundary, ValuesFunction,
        ColumnOffset + GwtColumnCount, ScreenObjectList, Parameter, TimeList);
    finally
      TimeList.Free;
    end;
  end;

  PestMethod[Frame.rdgModflowBoundary, ColOffset+RechPosition] :=
    TRchBoundary.DefaultBoundaryMethod(RechPosition);
  PestMethod[Frame.rdgModflowBoundary, ColOffset+MultPosition] :=
    TRchBoundary.DefaultBoundaryMethod(RechPosition);
  if frmGoPhast.PhastModel.GwtUsed then
  begin
    for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
    begin
      ColIndex := SpeciesIndex + ColumnOffset+RechPosition+1;
      PestMethod[Frame.rdgModflowBoundary, ColIndex] :=
        TRchBoundary.DefaultBoundaryMethod(ColIndex- ColumnOffset);
    end;
    for ColIndex := ColumnOffset to Frame.rdgModflowBoundary.ColCount - 1 do
    begin
      if not Frame.PestMethodAssigned[ColIndex] then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColIndex] := ppmMultiply;
      end;
    end;
  end;
  GetPestModifiers(Frame, Parameter, ScreenObjectList);

  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.GetEvtBoundary(ScreenObjectList: TList);
const
  RateBoundaryPosition = 0;
  SurfaceBoundaryPosition = 1;
  DepthBoundaryPosition = 2;
  ColOffset = 2;
var
  Frame: TframeScreenObjectParam;
  Parameter: TParameterType;
  TimeList: TParameterTimeList;
  ValuesFunction: TGetBoundaryCollectionEvent;
  ColumnOffset: integer;
  procedure GetSurfDepthModifiers;
  var
    BoundaryIndex: Integer;
    First: Boolean;
    Identical: Boolean;
    Method: TPestParamMethod;
    ScreenObjectIndex: Integer;
    AScreenObject: TScreenObject;
    Boundary: TEvtBoundary;
    Modifier: string;
  begin
    Frame.rdgModflowBoundary.BeginUpdate;
    try
      for BoundaryIndex := 1 to 2 do
      begin
        First := True;
        Identical := True;
        Method := ppmMultiply;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowEvtBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Method := Boundary.PestBoundaryMethod[BoundaryIndex];
              First := False;
            end
            else
            begin
              Identical := Method = Boundary.PestBoundaryMethod[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          PestMethod[Frame.rdgModflowBoundary, ColOffset+BoundaryIndex] := Method;
        end
        else
        begin
          Frame.rdgModflowBoundary.Cells[ColOffset+BoundaryIndex,PestMethodRow] := '';
        end;
      end;

      for BoundaryIndex := 1 to 2 do
      begin
        First := True;
        Identical := True;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowEvtBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Modifier := Boundary.PestBoundaryFormula[BoundaryIndex];
              First := False;
            end
            else
            begin
              Identical := Modifier = Boundary.PestBoundaryFormula[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          if Modifier = '' then
          begin
            Modifier := StrNone
          end;
          PestModifier[Frame.rdgModflowBoundary,
            ColOffset+BoundaryIndex] := Modifier;
        end
        else
        begin
          PestModifier[Frame.rdgModflowBoundary,
            ColOffset+BoundaryIndex] := '';
        end;
      end;
    finally
      Frame.rdgModflowBoundary.EndUpdate;
    end;
  end;
begin
  if not frmGoPhast.PhastModel.EvtIsSelected then
  begin
    Exit;
  end;
  Frame := frameEvtParam;
  Parameter := ptEvt;
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FEVT_Node);

  if frmGoPhast.PhastModel.EvtTimeVaryingLayers then
  begin
    TimeList := TParameterTimeList.Create;
    try
      GetModflowBoundaryTimes(ScreenObjectList, Parameter, TimeList);
      ColumnOffset := 5;
      ValuesFunction := GetEvapLayers;

      GetModflowBoundaryCollection(Frame.rdgModflowBoundary, ValuesFunction,
        ColumnOffset, ScreenObjectList, Parameter, TimeList);
    finally
      TimeList.Free;
    end;

  end;
  TimeList := TParameterTimeList.Create;
  try
    GetModflowBoundaryTimes(ScreenObjectList, Parameter, TimeList);
    ColumnOffset := 3;
    ValuesFunction := GetEvapSurfaceDepth;

    GetModflowBoundaryCollection(Frame.rdgModflowBoundary, ValuesFunction,
      ColumnOffset, ScreenObjectList, Parameter, TimeList);
  finally
    TimeList.Free;
  end;

  PestMethod[Frame.rdgModflowBoundary, ColOffset+RateBoundaryPosition] :=
    TEvtBoundary.DefaultBoundaryMethod(RateBoundaryPosition);
  PestMethod[Frame.rdgModflowBoundary, ColOffset+SurfaceBoundaryPosition] :=
    TEvtBoundary.DefaultBoundaryMethod(SurfaceBoundaryPosition);
  PestMethod[Frame.rdgModflowBoundary, ColOffset+DepthBoundaryPosition] :=
    TEvtBoundary.DefaultBoundaryMethod(DepthBoundaryPosition);
  GetPestModifiers(Frame, Parameter, ScreenObjectList);
  GetSurfDepthModifiers;

  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.GetEtsBoundary(ScreenObjectList: TList);
const
  RateBoundaryPosition = 0;
  SurfaceBoundaryPosition = 2;
  DepthBoundaryPosition = 3;
  MultiplierPosition = 1;
  ColOffset = 2;
var
  Frame: TframeScreenObjectParam;
  Parameter: TParameterType;
  TimeList: TParameterTimeList;
  ValuesFunction: TGetBoundaryCollectionEvent;
  ColumnOffset: integer;
  NumberOfSpecies: Integer;
  ColIndex: Integer;
  procedure GetEvtModifiers;
  var
    ValuesFunction: TGetBoundaryCollectionEvent;
    ColumnOffset: Integer;
    BoundaryCount: Integer;
    ScreenObjectIndex: Integer;
    AScreenObject: TScreenObject;
    Boundary: TEtsBoundary;
    Values: TCustomMF_BoundColl;
    BoundaryIndex: Integer;
    First: Boolean;
    Identical: Boolean;
    Method: TPestParamMethod;
    Modifier: string;
    StorageIndex: Integer;
  begin
    ValuesFunction := GetBoundaryValues;
    ColumnOffset := 2;

    BoundaryCount := -1;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowEtsBoundary;
      if (Boundary <> nil) and Boundary.Used then
      begin
        Values := ValuesFunction(Boundary);
        BoundaryCount := Values.TimeListCount(frmGoPhast.PhastModel);
        break;
      end;
    end;
    if BoundaryCount = -1 then
    begin
      Exit;
    end;

    Frame.rdgModflowBoundary.BeginUpdate;
    try
      for BoundaryIndex := 0 to BoundaryCount - 1 do
      begin
        if BoundaryIndex = 0 then
        begin
          StorageIndex := 0;
        end
        else
        begin
          StorageIndex := BoundaryIndex + EtsBoundaryStartConcentration -1;
        end;
        First := True;
        Identical := True;
        Method := ppmMultiply;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowEtsBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Method := Boundary.PestBoundaryMethod[StorageIndex];
              First := False;
            end
            else
            begin
              Identical := Method = Boundary.PestBoundaryMethod[StorageIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          PestMethod[Frame.rdgModflowBoundary, ColumnOffset+BoundaryIndex] := Method;
        end
        else
        begin
          Frame.rdgModflowBoundary.Cells[ColumnOffset+BoundaryIndex,PestMethodRow] := '';
        end;
      end;

      for BoundaryIndex := 0 to BoundaryCount - 1 do
      begin
        if BoundaryIndex = 0 then
        begin
          StorageIndex := 0;
        end
        else if BoundaryIndex = 1 then
        begin
          StorageIndex := 1;
        end
        else
        begin
          StorageIndex := BoundaryIndex + EtsBoundaryStartConcentration -1;
        end;
        First := True;
        Identical := True;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowEtsBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Modifier := Boundary.PestBoundaryFormula[StorageIndex];
              First := False;
            end
            else
            begin
              Identical := Modifier = Boundary.PestBoundaryFormula[StorageIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          if (Modifier = '') or (Modifier = '0') then
          begin
            Modifier := StrNone
          end;
          PestModifier[Frame.rdgModflowBoundary,
            ColumnOffset+BoundaryIndex] := Modifier;
        end
        else
        begin
          PestModifier[Frame.rdgModflowBoundary,
            ColumnOffset+BoundaryIndex] := '';
        end;
      end;
    finally
      Frame.rdgModflowBoundary.EndUpdate;
    end;
  end;
  procedure GetSurfDepthModifiers;
  var
    BoundaryIndex: Integer;
    First: Boolean;
    Identical: Boolean;
    Method: TPestParamMethod;
    ScreenObjectIndex: Integer;
    AScreenObject: TScreenObject;
    Boundary: TEtsBoundary;
    Modifier: string;
  begin
    Frame.rdgModflowBoundary.BeginUpdate;
    try
      for BoundaryIndex := SurfaceBoundaryPosition to DepthBoundaryPosition do
      begin
        First := True;
        Identical := True;
        Method := ppmMultiply;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowEtsBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Method := Boundary.PestBoundaryMethod[BoundaryIndex];
              First := False;
            end
            else
            begin
              Identical := Method = Boundary.PestBoundaryMethod[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          PestMethod[Frame.rdgModflowBoundary, ColOffset+BoundaryIndex+NumberOfSpecies] := Method;
        end
        else
        begin
          Frame.rdgModflowBoundary.Cells[ColOffset+BoundaryIndex,PestMethodRow+NumberOfSpecies] := '';
        end;
      end;

      for BoundaryIndex := SurfaceBoundaryPosition to DepthBoundaryPosition do
      begin
        First := True;
        Identical := True;
        for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
        begin
          AScreenObject := ScreenObjectList[ScreenObjectIndex];
          Boundary := AScreenObject.ModflowEtsBoundary;
          if (Boundary <> nil) and Boundary.Used then
          begin
            if First then
            begin
              Modifier := Boundary.PestBoundaryFormula[BoundaryIndex];
              First := False;
            end
            else
            begin
              Identical := Modifier = Boundary.PestBoundaryFormula[BoundaryIndex];
              if not Identical then
              begin
                break;
              end;
            end;
          end;
        end;
        if Identical then
        begin
          if Modifier = '' then
          begin
            Modifier := StrNone
          end;
          PestModifier[Frame.rdgModflowBoundary,
            ColOffset+BoundaryIndex+NumberOfSpecies] := Modifier;
        end
        else
        begin
          PestModifier[Frame.rdgModflowBoundary,
            ColOffset+BoundaryIndex+NumberOfSpecies] := '';
        end;
      end;
    finally
      Frame.rdgModflowBoundary.EndUpdate;
    end;
  end;
begin
  if not frmGoPhast.PhastModel.EtsIsSelected then
  begin
    Exit;
  end;
  Frame := frameEtsParam;
  Parameter := ptETS;
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FETS_Node);
  GetModflowTimeInterpolation(Frame, Parameter, ScreenObjectList, FETS_Node);

  NumberOfSpecies := GwtColumnCount;
  if frmGoPhast.PhastModel.EtsTimeVaryingLayers then
  begin
    TimeList := TParameterTimeList.Create;
    try
      GetModflowBoundaryTimes(ScreenObjectList, Parameter, TimeList);
      ColumnOffset := 5 + NumberOfSpecies
        + (frmGoPhast.PhastModel.ModflowPackages.EtsPackage.SegmentCount -1) * 2;
      ValuesFunction := GetEtsLayers;

      GetModflowBoundaryCollection(Frame.rdgModflowBoundary, ValuesFunction,
        ColumnOffset, ScreenObjectList, Parameter, TimeList);
    finally
      TimeList.Free;
    end;

  end;
  TimeList := TParameterTimeList.Create;
  try
    GetModflowBoundaryTimes(ScreenObjectList, Parameter, TimeList);
    ColumnOffset := 4;// + NumberOfSpecies;
    ValuesFunction := GetEtsSurfaceDepth;

    GetModflowBoundaryCollection(Frame.rdgModflowBoundary, ValuesFunction,
      ColumnOffset, ScreenObjectList, Parameter, TimeList);
  finally
    TimeList.Free;
  end;

  PestMethod[Frame.rdgModflowBoundary, ColOffset+RateBoundaryPosition] :=
    TEtsBoundary.DefaultBoundaryMethod(RateBoundaryPosition);
  PestMethod[Frame.rdgModflowBoundary, ColOffset+SurfaceBoundaryPosition+NumberOfSpecies] :=
    TEtsBoundary.DefaultBoundaryMethod(SurfaceBoundaryPosition);
  PestMethod[Frame.rdgModflowBoundary, ColOffset+DepthBoundaryPosition+NumberOfSpecies] :=
    TEtsBoundary.DefaultBoundaryMethod(DepthBoundaryPosition);
  PestMethod[Frame.rdgModflowBoundary, ColOffset+MultiplierPosition+NumberOfSpecies] :=
    TEtsBoundary.DefaultBoundaryMethod(MultiplierPosition);
  GetEvtModifiers;
  GetSurfDepthModifiers;
  if frmGoPhast.PhastModel.GwtUsed then
  begin
//    for SpeciesIndex := 0 to frmGoPhast.PhastModel.MobileComponents.Count - 1 do
//    begin
//      ColIndex := SpeciesIndex + ColumnOffset+RechPostion+1;
//      PestMethod[Frame.rdgModflowBoundary, ColIndex] :=
//        TRchBoundary.DefaultBoundaryMethod(ColIndex- ColumnOffset);
//    end;
    for ColIndex := ColumnOffset to Frame.rdgModflowBoundary.ColCount - 1 do
    begin
      if not Frame.PestMethodAssigned[ColIndex] then
      begin
        PestMethod[Frame.rdgModflowBoundary, ColIndex] := ppmMultiply;
      end;
    end;
  end;

  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.GetResBoundary(ScreenObjectList: TList);
const
  StartPosition = 0;
  EndPosition = 1;
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TModflowBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
begin
  PestMethod[frameRes.rdgModflowBoundary, 2] :=
    TResBoundary.DefaultBoundaryMethod(StartPosition);
  PestMethod[frameRes.rdgModflowBoundary, 3] :=
    TResBoundary.DefaultBoundaryMethod(EndPosition);

  if not frmGoPhast.PhastModel.ResIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowResBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
    if FRES_Node <> nil then
    begin
      FRES_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowResBoundary;
      // get all the times associated with the boundary.
      if Boundary <> nil then
      begin
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameRes.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameRes.rdgModflowBoundary;
    DataGrid.BeginUpdate;


    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetReservoirBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);
    finally
      DataGrid.EndUpdate;
    end;

  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dmsChemBoundary(ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dmsConcBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
  FoundFirst: boolean;
begin
  if not frmGoPhast.PhastModel.Mt3dIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dmsConcBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
   if FMt3dmsSsm_Node <> nil then
    begin
      FMt3dmsSsm_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dmsConcBoundary;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameMT3DMS_SSM.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameMT3DMS_SSM.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1 + PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetMt3dmsChemBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

    finally
      DataGrid.EndUpdate;
    end;

    FoundFirst := False;
    frameMT3DMS_SSM.cbSpecifiedConcentration.Checked := False;
    frameMT3DMS_SSM.cbMassLoading.Checked := False;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dmsConcBoundary;
      if Boundary <> nil then
      begin
        if FoundFirst then
        begin
          if frameMT3DMS_SSM.cbSpecifiedConcentration.Checked <> Boundary.SpecifiedConcBoundary then
          begin
            frameMT3DMS_SSM.cbSpecifiedConcentration.AllowGrayed := True;
            frameMT3DMS_SSM.cbSpecifiedConcentration.State := cbGrayed
          end;
          if frameMT3DMS_SSM.cbMassLoading.Checked <> Boundary.MassLoadingBoundary then
          begin
            frameMT3DMS_SSM.cbMassLoading.AllowGrayed := True;
            frameMT3DMS_SSM.cbMassLoading.State := cbGrayed
          end;
        end
        else
        begin
          frameMT3DMS_SSM.cbSpecifiedConcentration.Checked := Boundary.SpecifiedConcBoundary;
          frameMT3DMS_SSM.cbMassLoading.Checked := Boundary.MassLoadingBoundary;
          FoundFirst := True;
        end;
      end;
    end;

    frameMT3DMS_SSM.ClearDeletedCells;
  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3d_UztRechBoundary(ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUztRchConcBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
//  FoundFirst: boolean;
begin
  if not frmGoPhast.PhastModel.Mt3dIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUzfRechConc;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
   if FMt3d_UZT_Rech_Node <> nil then
    begin
      FMt3d_UZT_Rech_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUzfRechConc;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameMt3d_UZT_Rech.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameMt3d_UZT_Rech.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetMt3dmsUztRechBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

    finally
      DataGrid.EndUpdate;
    end;
  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3dLktBoundary(ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dLktConcBoundary;
begin
  if not frmGoPhast.PhastModel.Mt3d_LktIsSelected(nil) then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dLktConcBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FMt3d_LKT_Node <> nil then
  begin
    FMt3d_LKT_Node.StateIndex := Ord(State)+1;
  end;
  frameMT3D_LKT.GetData(FNewProperties);
end;

procedure TfrmScreenObjectProperties.GetMt3dSftBoundary(ScreenObjectList: TList);
var
  State: TCheckBoxState;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dSftBoundary;
begin
  if not frmGoPhast.PhastModel.Mt3d_SftIsSelected then
  begin
    Exit;
  end;
  State := cbUnchecked;
  for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[ScreenObjectIndex];
    Boundary := AScreenObject.Mt3dSftConcBoundary;
    UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
  end;

  if FMt3d_SFT_Node <> nil then
  begin
    FMt3d_SFT_Node.StateIndex := Ord(State)+1;
  end;
  frameMT3D_SFT.GetData(FNewProperties);
end;


procedure TfrmScreenObjectProperties.GetMt3dUzfSeepageConcBoundary(ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUzSsmSinkConcBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
//  FoundFirst: boolean;
begin
  if not frmGoPhast.PhastModel.Mt3dIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUzSsmSinkConcBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
   if FMt3d_Uzf_Seep_Node <> nil then
    begin
      FMt3d_Uzf_Seep_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUzSsmSinkConcBoundary;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameMT3D_Uzf_Ssm_Conc.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetMt3dUzfSeepageConcCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

    finally
      DataGrid.EndUpdate;
    end;
  finally
    TimeList.Free;
  end;
end;


procedure TfrmScreenObjectProperties.GetMt3d_UztSatBoundary(ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUztSatEtConcBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
//  FoundFirst: boolean;
begin
  if not frmGoPhast.PhastModel.Mt3dIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUztSatEtConcBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
   if FMt3d_UZT_Sat_Node <> nil then
    begin
      FMt3d_UZT_Sat_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUztSatEtConcBoundary;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameMt3d_UZT_Sat.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameMt3d_UZT_Sat.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetMt3dmsUztSatBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

    finally
      DataGrid.EndUpdate;
    end;
  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetMt3d_UztUnsatBoundary(ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TMt3dUztUnsatEtConcBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
//  FoundFirst: boolean;
begin
  if not frmGoPhast.PhastModel.Mt3dIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUztUnsatEtConcBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
   if FMt3d_UZT_Unsat_Node <> nil then
    begin
      FMt3d_UZT_Unsat_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.Mt3dUztUnsatEtConcBoundary;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameMt3d_UZT_Unsat.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameMt3d_UZT_Unsat.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.EndTime);
      end;

      ColumnOffset := 2;
      GetMt3dmsUztUnsatBoundaryCollection(DataGrid, ColumnOffset,
        ScreenObjectList, TimeList);

    finally
      DataGrid.EndUpdate;
    end;
  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetLakBoundary(ScreenObjectList: TList);
var
  TimeList: TParameterTimeList;
//  ColumnOffset: integer;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Boundary: TLakBoundary;
  Item: TCustomModflowBoundaryItem;
  Time: TParameterTime;
  TimeIndex: Integer;
  Time1: TParameterTime;
  Time2: TParameterTime;
  DataGrid: TRbwDataGrid4;
  State: TCheckBoxState;
  Gage0: TCheckBoxState;
  Gage1: TCheckBoxState;
  Gage2: TCheckBoxState;
  Gage4: TCheckBoxState;
  FirstGage: boolean;
  OutState0: TCheckBoxState;
  OutState1: TCheckBoxState;
  OutState2: TCheckBoxState;
  OutState4: TCheckBoxState;
begin
  if not frmGoPhast.PhastModel.LakIsSelected then
  begin
    Exit;
  end;
  TimeList := TParameterTimeList.Create;
  try
    State := cbUnchecked;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowLakBoundary;
      UpdateBoundaryState(Boundary, ScreenObjectIndex, State);
    end;
   if FLAK_Node <> nil then
    begin
      FLAK_Node.StateIndex := Ord(State)+1;
    end;
    for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
    begin
      AScreenObject := ScreenObjectList[ScreenObjectIndex];
      Boundary := AScreenObject.ModflowLakBoundary;
      if Boundary <> nil then
      begin
        // get all the times associated with the boundary.
        for TimeIndex := 0 to Boundary.Values.Count - 1 do
        begin
          Item := Boundary.Values[TimeIndex] as TCustomModflowBoundaryItem;
          Time := TParameterTime.Create;
          Time.StartTime := Item.StartTime;
          Time.EndTime := Item.EndTime;
          TimeList.Add(Time);
        end;
      end;
    end;
    // Sort the times in ascending order.
    TimeList.Sort;
    // get rid of duplicate times.
    for TimeIndex := TimeList.Count - 1 downto 1 do
    begin
      Time1 := TimeList[TimeIndex];
      Time2 := TimeList[TimeIndex - 1];
      if (Time1.StartTime = Time2.StartTime) and (Time1.EndTime = Time2.EndTime) then
      begin
        TimeList.Delete(TimeIndex);
      end;
    end;

    // display the times that are left.
    frameLak.seNumberOfTimes.Value := TimeList.Count;
    DataGrid := frameLak.rdgModflowBoundary;
    DataGrid.BeginUpdate;
    try
      for TimeIndex := 0 to TimeList.Count - 1 do
      begin
        Time := TimeList[TimeIndex];
        DataGrid.Cells[0, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.StartTime);
        DataGrid.Cells[1, TimeIndex + 1+PestRowOffset] := FloatToStr(Time.EndTime);
      end;

//      ColumnOffset := 2;
      GetLakeBoundaryCollection(ScreenObjectList, TimeList);

      FirstGage := True;
      Gage0 := cbUnChecked;
      Gage1 := cbUnChecked;
      Gage2 := cbUnChecked;
      Gage4 := cbUnChecked;
      for ScreenObjectIndex := 0 to ScreenObjectList.Count - 1 do
      begin
        AScreenObject := ScreenObjectList[ScreenObjectIndex];
        Boundary := AScreenObject.ModflowLakBoundary;
        if (Boundary <> nil) and Boundary.Used then
        begin
          if FirstGage then
          begin
            if Boundary.StandardGage then
            begin
              Gage0 := cbChecked;
              if Boundary.FluxCondGage then
              begin
                Gage1 := cbChecked;
              end
              else
              begin
                Gage1 := cbUnChecked;
              end;
              if Boundary.DeltaGage then
              begin
                Gage2 := cbChecked;
              end
              else
              begin
                Gage2 := cbUnChecked;
              end;
            end
            else
            begin
              Gage0 := cbUnChecked;
              Gage1 := cbUnChecked;
              Gage2 := cbUnChecked;
            end;

            if Boundary.Gage4 then
            begin
              Gage4 := cbChecked;
            end
            else
            begin
              Gage4 := cbUnChecked;
            end;

            FirstGage := False;
          end
          else
          begin
            if Boundary.StandardGage then
            begin
              OutState0 := cbChecked;
              if Boundary.FluxCondGage then
              begin
                OutState1 := cbChecked;
              end
              else
              begin
                OutState1 := cbUnChecked;
              end;
              if Boundary.DeltaGage then
              begin
                OutState2 := cbChecked;
              end
              else
              begin
                OutState2 := cbUnChecked;
              end;
            end
            else
            begin
              OutState0 := cbUnChecked;
              OutState1 := cbUnChecked;
              OutState2 := cbUnChecked;
            end;
            if Boundary.Gage4 then
            begin
              OutState4 := cbChecked;
            end
            else
            begin
              OutState4 := cbUnChecked;
            end;
            if Gage0 <> OutState0 then
            begin
              Gage0 := cbGrayed;
            end;
            if Gage1 <> OutState1 then
            begin
              Gage1 := cbGrayed;
            end;
            if Gage2 <> OutState2 then
            begin
              Gage2 := cbGrayed;
            end;
            if Gage4 <> OutState4 then
            begin
              Gage4 := cbGrayed;
            end;
          end;
        end;
      end;
      frameLak.cbGagStandard.State := Gage0;
      frameLak.cbGagFluxAndCond.State := Gage1;
      frameLak.cbGagDelta.State := Gage2;
      frameLak.cbGage4.State := Gage4;
      frameLak.cbGagStandard.OnClick(nil);
      frameLak.cbGagFluxAndCond.OnClick(nil);
      frameLak.cbGagDelta.OnClick(nil);
      frameLak.cbGage4.OnClick(nil);
    finally
      DataGrid.EndUpdate;
    end;
  finally
    TimeList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.GetDrtBoundary(ScreenObjectList: TList);
const
  ElevationPosition = 0;
  ConductancePosition = 1;
  ReturnPosition = 2;
  ColumnOffset = 2;
var
  Frame: TframeScreenObjectCondParam;
  Parameter: TParameterType;
  Index: Integer;
  AScreenObject: TScreenObject;
  First: Boolean;
  DrainReturn: TDrainReturn;
  FirstObject, FirstLocation, FirstCell: Boolean;
begin
  if not frmGoPhast.PhastModel.DrtIsSelected then
  begin
    Exit;
  end;
  rdeDrtLay.Text := '1';
  rdeDrtLay.Min := 1;
  if frmGoPhast.ModelSelection in [msModflowFmp, msModflowOwhm2] then
  begin
    if frmGoPhast.PhastModel.ModflowPackages.FarmProcess.IsSelected then
    begin
      rdeDrtLay.Min := -1;
    end;
    if frmGoPhast.PhastModel.ModflowPackages.SwrPackage.IsSelected then
    begin
      rdeDrtLay.Min := -2;
    end;
  end;
  comboDrtLocationChoice.ItemIndex := 0;
  comboDrtLocationChoiceChange(nil);
  rdeDrtCol.Text := '1';
  rdeDrtRow.Text := '1';
  rdeDrtX.Text := '0';
  rdeDrtY.Text := '0';
  rdeDrtZ.Text := '0';
  First := True;
  FirstObject := True;
  FirstLocation := True;
  FirstCell := True;
  for Index := 0 to ScreenObjectList.Count - 1 do
  begin
    AScreenObject := ScreenObjectList[Index];
    if (AScreenObject.ModflowDrtBoundary <> nil)
      and AScreenObject.ModflowDrtBoundary.Used then
    begin
      DrainReturn := AScreenObject.ModflowDrtBoundary.DrainReturn;
      if First then
      begin
        comboDrtLocationChoice.ItemIndex :=
          Ord(DrainReturn.ReturnChoice);
        comboDrtLocationChoiceChange(nil);
        First := False;
        case DrainReturn.ReturnChoice of
          rtNone: ; // do nothing
          rtObject:
            begin
              comboDrtReturnObject.ItemIndex :=
                comboDrtReturnObject.Items.IndexOf(
                DrainReturn.ReturnObject.ObjectName);
              FirstObject := False;
            end;
          rtLocation:
            begin
              rdeDrtX.Text := FloatToStr(DrainReturn.ReturnLocation.X);
              rdeDrtY.Text := FloatToStr(DrainReturn.ReturnLocation.Y);
              rdeDrtZ.Text := FloatToStr(DrainReturn.ReturnLocation.Z);
              FirstLocation := False;
            end;
          rtCell:
            begin
              rdeDrtCol.Text := IntToStr(DrainReturn.ReturnCell.Col);
              rdeDrtRow.Text := IntToStr(DrainReturn.ReturnCell.Row);
              rdeDrtLay.Text := IntToStr(DrainReturn.ReturnCell.Lay);
              UpdateDrtReturnFlowLabels(rdeDrtLay);
              FirstCell := False;
            end;
          else Assert(False);
        end;
      end
      else
      begin
        if comboDrtLocationChoice.ItemIndex <>
          Ord(DrainReturn.ReturnChoice) then
        begin
          comboDrtLocationChoice.ItemIndex := -1;
          comboDrtLocationChoiceChange(nil);
        end;
        case DrainReturn.ReturnChoice of
          rtNone: ; // do nothing
          rtObject:
            begin
              if FirstObject then
              begin
                comboDrtReturnObject.ItemIndex :=
                  comboDrtReturnObject.Items.IndexOf(
                  DrainReturn.ReturnObject.ObjectName);
                FirstObject := False;
              end
              else
              begin
                if comboDrtReturnObject.ItemIndex <>
                  comboDrtReturnObject.Items.IndexOf(
                  DrainReturn.ReturnObject.ObjectName) then
                begin
                  comboDrtReturnObject.ItemIndex := -1;
                end;
              end;
            end;
          rtLocation:
            begin
              if FirstLocation then
              begin
                rdeDrtX.Text := FloatToStr(DrainReturn.ReturnLocation.X);
                rdeDrtY.Text := FloatToStr(DrainReturn.ReturnLocation.Y);
                rdeDrtZ.Text := FloatToStr(DrainReturn.ReturnLocation.Z);
                FirstLocation := False;
              end
              else
              begin
                if rdeDrtX.Text <> FloatToStr(DrainReturn.ReturnLocation.X) then
                begin
                  rdeDrtX.Text := '';
                end;
                if rdeDrtY.Text <> FloatToStr(DrainReturn.ReturnLocation.Y) then
                begin
                  rdeDrtY.Text := '';
                end;
                if rdeDrtZ.Text <> FloatToStr(DrainReturn.ReturnLocation.Z) then
                begin
                  rdeDrtZ.Text := '';
                end;
              end;
            end;
          rtCell:
            begin
              if FirstCell then
              begin
                rdeDrtCol.Text := IntToStr(DrainReturn.ReturnCell.Col);
                rdeDrtRow.Text := IntToStr(DrainReturn.ReturnCell.Row);
                rdeDrtLay.Text := IntToStr(DrainReturn.ReturnCell.Lay);
                UpdateDrtReturnFlowLabels(rdeDrtLay);
                FirstCell := False;
              end
              else
              begin
                if rdeDrtCol.Text <> FloatToStr(DrainReturn.ReturnCell.Col) then
                begin
                  rdeDrtCol.Text := '';
                end;
                if rdeDrtRow.Text <> FloatToStr(DrainReturn.ReturnCell.Row) then
                begin
                  rdeDrtRow.Text := '';
                end;
                if rdeDrtLay.Text <> FloatToStr(DrainReturn.ReturnCell.Lay) then
                begin
                  rdeDrtLay.Text := '';
                  UpdateDrtReturnFlowLabels(rdeDrtLay);
                end;
              end;
            end;
          else Assert(False);
        end;
      end;
    end;
  end;
  Frame := frameDrtParam;
  Parameter := ptDRT;
  GetFormulaInterpretation(Frame, Parameter, ScreenObjectList);
  GetModflowBoundary(Frame, Parameter, ScreenObjectList, FDRT_Node);

  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ElevationPosition] :=
    TDrtBoundary.DefaultBoundaryMethod(ElevationPosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ConductancePosition] :=
    TDrtBoundary.DefaultBoundaryMethod(ConductancePosition);
  PestMethod[Frame.rdgModflowBoundary, ColumnOffset+ReturnPosition] :=
    TDrtBoundary.DefaultBoundaryMethod(ReturnPosition);
  GetPestModifiers(Frame, Parameter, ScreenObjectList);

  Frame.rdgModflowBoundary.HideEditor;
end;

procedure TfrmScreenObjectProperties.CreateBoundaryFormula(const DataGrid:
  TCustomRBWDataGrid; const ACol, ARow: integer; Formula: string;
  const Orientation: TDataSetOrientation; const EvaluatedAt: TEvaluatedAt);
var
  TempCompiler: TRbwParser;
  CompiledFormula: TExpression;
  ResultType: TRbwDataType;
  TestCol: Integer;
  CropIrrigationRequirement: TCropIrrigationRequirement;
  Divisor: integer;
  PestParamAllowed: Boolean;
  TimeSeriesAllowed: Boolean;
  Mf6TimesSeries: TTimesSeriesCollections;
  TimeSeries: TMf6TimeSeries;
  EtsLayerCol: Integer;
  DynamicTimeSeries: TDynamicTimeSeries;
begin
  PestParamAllowed := GetPestParameterAllowed(DataGrid, ACol);
  if Formula = '' then
  begin
    Formula := '0';
  end;

  TimeSeries := nil;
  DynamicTimeSeries := nil;
  TimeSeriesAllowed := GetModflow6TimeSeriesAllowed(DataGrid, ACol);
  if TimeSeriesAllowed then
  begin
    Mf6TimesSeries := frmGoPhast.PhastModel.Mf6TimesSeries;
    TimeSeries := Mf6TimesSeries.GetTimeSeriesByName(Formula);
    if TimeSeries <> nil then
    begin
      Formula := '1';
    end
    else
    begin
      DynamicTimeSeries := frameDynamicTimeSeries.GetTimeSeriesByName(Formula);
      if DynamicTimeSeries <> nil then
      begin
        Formula := '1';
      end;
    end;

  end;

  // CreateBoundaryFormula creates an Expression for a boundary condition
  // based on the text in DataGrid at ACol, ARow. Orientation, and EvaluatedAt
  // are used to chose the TRbwParser.
  TempCompiler := GetCompiler(Orientation, EvaluatedAt);
  try
    TempCompiler.Compile(Formula);

  except on E: ERbwParserError do
    begin
      Beep;
      raise ERbwParserError.Create(Format(StrErrorInFormulaS,
        [E.Message]));
      Exit;
    end
  end;
  CompiledFormula := TempCompiler.CurrentExpression;

  ResultType := rdtDouble;
  if DataGrid.Parent is TframeModflow6DynamicTimeSeries then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameGwtCnc.rdgModflowBoundary) and (ACol = 2) then
  begin
    ResultType := rdtBoolean;
  end
  else if (DataGrid = frameGwtSRC.rdgModflowBoundary) and (ACol = 2) then
  begin
    ResultType := rdtBoolean;
  end
  else if (DataGrid = dgSpecifiedHead) or (DataGrid = dgBoundaryFlux) or
    (DataGrid = dgBoundaryLeaky) then
  begin
    if ACol = 2 then
    begin
      ResultType := rdtDouble;
    end
    else if ACol = 4 then
    begin
      ResultType := rdtInteger;
    end
    else
    begin
      Assert(False);
    end;
  end
  else if (DataGrid = dgBoundaryRiver) or (DataGrid = dgWell) then
  begin
    if ACol = 2 then
    begin
      ResultType := rdtDouble;
    end
    else if ACol = 3 then
    begin
      ResultType := rdtInteger;
    end
    else
    begin
      Assert(False);
    end;
  end
  else if (DataGrid.Owner = frameFmp4CropHasSalinityDemand)
    or (DataGrid.Owner = frameFmp4MultCropHasSalinityDemand) then
  begin
    ResultType := rdtBoolean;
  end
  else if (DataGrid.Owner is TframeScreenObjectNoParam) then
  begin
    ResultType := rdtDouble;
    if (DataGrid = frameChdParam.rdgModflowBoundary)
      and IsChdActiveColumn(ACol) then
    begin
      ResultType := rdtBoolean;
    end
    else if (DataGrid = frameRchParam.rdgModflowBoundary)
      and frmGoPhast.PhastModel.RchTimeVaryingLayers
      and (ACol = 4 + GwtColumnCount) then
    begin
      // We are setting the formula for  the layer
      // to which the recharge will be applied.
      ResultType := rdtInteger;
    end
    else if (DataGrid = frameEvtParam.rdgModflowBoundary)
      and frmGoPhast.PhastModel.EvtTimeVaryingLayers
      and (ACol = 5) then
    begin
      // We are setting the formula for  the layer
      // to which the recharge will be applied.
      ResultType := rdtInteger;
    end
    else if (DataGrid = frameEtsParam.rdgModflowBoundary)
      and frmGoPhast.PhastModel.EtsTimeVaryingLayers then
    begin
      EtsLayerCol := 6 + GwtColumnCount +
        (frmGoPhast.PhastModel.ModflowPackages.EtsPackage.SegmentCount-1)*2;
      if ACol = EtsLayerCol then
      begin
        ResultType := rdtInteger;
      end;
    end
    else if DataGrid = frameFarmWell.rdgModflowBoundary then
    begin
      TestCol := ACol-2;
      CropIrrigationRequirement :=
        frmGoPhast.PhastModel.ModflowPackages.FarmProcess.CropIrrigationRequirement;
      Divisor := 1;
      case CropIrrigationRequirement of
        cirContinuously:
          begin
            Divisor := 2;
          end;
        cirOnlyWhenNeeded:
          begin
            Divisor := 3;
          end;
        else Assert(False);
      end;
      TestCol := TestCol mod Divisor;
      case TestCol of
        0:
          begin
            ResultType := rdtDouble;
          end;
        1:
          begin
            ResultType := rdtInteger;
          end;
        2:
          begin
            ResultType := rdtBoolean;
          end;
      end
    end
    else if DataGrid = frameFarmID.rdgModflowBoundary then
    begin
      ResultType := rdtInteger;
    end
    else if DataGrid = frameFarmCropID.rdgModflowBoundary then
    begin
      ResultType := rdtInteger;
    end
    else if DataGrid = frameFmp4EfficiencyImprovement.rdgModflowBoundary then
    begin
      ResultType := rdtBoolean;
    end
    else if DataGrid = frameFmp4Irrigation.rdgModflowBoundary then
    begin
      ResultType := rdtInteger;
    end
    else if DataGrid = frameFmp4MultIrrigation.rdgModflowBoundary then
    begin
      ResultType := rdtInteger;
    end

  end
  else if (DataGrid.Owner is TCustomframeFluxObs) then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid.Owner = frameScreenObjectSFR)
    or (DataGrid.Owner = frameMNW2)
    or (DataGrid.Owner is TframeCrossSection)
    or (DataGrid.Owner is TframeFlowTable) then
  begin
    ResultType := rdtDouble;
  end
  else if  (DataGrid.Owner = frameMNW1) then
  begin
    ResultType := rdtDouble;
    case TMnw1Columns(ACol) of
      mcDesiredPumpingRate, mcWaterQuality, mcWellRadius, mcConductance,
        mcSkinFactor, mcLimitingWaterLevel, mcReferenceElevation,
        mcNonLinearLossCoefficient, mcMinimumActiveRate,
        mcReactivationPumpingRate: ResultType := rdtDouble;
      mcWaterQualityGroup: ResultType := rdtInteger;
      else Assert(False);
    end;
  end
  else if (DataGrid.Owner is TframeSutraBoundary) then
  begin
    if ACol = 1 then
    begin
      ResultType := rdtBoolean;
    end
    else
    begin
      ResultType := rdtDouble;
    end;
  end
  else if (DataGrid = frameSutraGeneralizedFlowBoundary.rdgSutraFeature)
    or (DataGrid = frameSutraGeneralizeTransBoundary.rdgSutraFeature) then
  begin
    if ACol = 1 then
    begin
      ResultType := rdtBoolean;
    end
    else
    begin
      ResultType := rdtDouble;
    end;
  end
  else if (DataGrid = frameFarmPrecip.rdgModflowBoundary)
    or (DataGrid = frameFarmRefEvap.rdgModflowBoundary) then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameFarmCropID.rdgModflowBoundary) then
  begin
    ResultType := rdtInteger;
  end
  else if (DataGrid = frameFarmID.rdgModflowBoundary) then
  begin
    ResultType := rdtInteger;
  end
  else if (DataGrid = frameScreenObjectSfr6.rdgFormulas)
    or (DataGrid = frameScreenObjectSfr6.rdgModflowBoundary) then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameMAW.rdgModflowBoundary)
    or (DataGrid = frameMAW.frameWellScreens.Grid) then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameLakMf6.rdgModflowBoundary)
    or (DataGrid = frameLakMf6.frameLakeTable.Grid)
    or (DataGrid.Owner is TframeLakeOutlet)
    then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameCSUB.rdgModflowBoundary)
    or (DataGrid = frameCSUB.rdgSubGroups)
    then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameObsMf6.framePestObs.frameObservations.Grid)
    then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameScreenObjectTvk.rdgModflowBoundary)
    then
  begin
    ResultType := rdtDouble;
  end
  else if (DataGrid = frameScreenObjectTvs.rdgModflowBoundary)
    then
  begin
    ResultType := rdtDouble;
  end
  else
  begin
    Assert(False);
  end;

  if PestParamAllowed then
  begin
    PestParamAllowed :=
      frmGoPhast.PhastModel.GetPestParameterByName(
      CompiledFormula.DecompileDisplay) <> nil;
  end;

  if (ResultType = CompiledFormula.ResultType) or
    ((ResultType = rdtDouble) and (CompiledFormula.ResultType = rdtInteger))
      then
  begin
    if TimeSeries <> nil then
    begin
      DataGrid.Cells[ACol, ARow] := string(TimeSeries.SeriesName);
    end
    else if DynamicTimeSeries <> nil then
    begin
      DataGrid.Cells[ACol, ARow] := string(DynamicTimeSeries.SeriesName);
    end
    else
    begin
      DataGrid.Cells[ACol, ARow] := CompiledFormula.DecompileDisplay;
    end;
  end
  else if PestParamAllowed then
  begin
    if TimeSeries <> nil then
    begin
      DataGrid.Cells[ACol, ARow] := string(TimeSeries.SeriesName);
    end
    else if DynamicTimeSeries <> nil then
    begin
      DataGrid.Cells[ACol, ARow] := string(DynamicTimeSeries.SeriesName);
    end
    else
    begin
      DataGrid.Cells[ACol, ARow] := CompiledFormula.DecompileDisplay;
    end;
  end
  else
  begin
    if TimeSeries <> nil then
    begin
      DataGrid.Cells[ACol, ARow] := string(TimeSeries.SeriesName);
    end
    else if DynamicTimeSeries <> nil then
    begin
      DataGrid.Cells[ACol, ARow] := string(DynamicTimeSeries.SeriesName);
    end
    else
    begin
      Formula := AdjustFormula(Formula, CompiledFormula.ResultType, ResultType);
      TempCompiler.Compile(Formula);
      CompiledFormula := TempCompiler.CurrentExpression;
      DataGrid.Cells[ACol, ARow] := CompiledFormula.DecompileDisplay;
    end;
  end;
  if Assigned(DataGrid.OnSetEditText) then
  begin
    DataGrid.OnSetEditText(DataGrid, ACol, ARow, DataGrid.Cells[ACol, ARow]);
  end;
end;

function TfrmScreenObjectProperties.CreateMixtureFormula(const DataSetIndex:
  integer): TExpression;
var
  Formula: string;
  TempCompiler: TRbwParser;
  ResultType: TRbwDataType;
  Edit: TScreenObjectDataEdit;
begin
  result := nil;
  // Create a formula for a cell
  Formula := framePhastInterpolationData.edMixFormula.Text;
  TempCompiler := GetCompilerByIndex(DataSetIndex);
  try
    try
      TempCompiler.Compile(Formula);

    except on E: ErbwParserError do
      begin
        Beep;
        Edit := FDataEdits[DataSetIndex];
        MessageDlg(Format(StrErrorInMixtureFor,
          [Edit.DataArray.DisplayName, E.Message]), mtError, [mbOK], 0);
        Exit;
      end
    end;

    result := TempCompiler.CurrentExpression;
    framePhastInterpolationData.edMixFormula.Text := result.DecompileDisplay;
    ResultType := rdtDouble;
    // check that the formula is OK.
    if not (result.ResultType in [rdtDouble, rdtInteger]) then
    begin
      // If the formula is not OK, try to fix it.
      Beep;
      MessageDlg(StrTheFormulaYouEnte,
        mtError, [mbOK], 0);
      Formula := AdjustFormula(Formula, result.ResultType, ResultType);
      TempCompiler.Compile(Formula);
      result := TempCompiler.CurrentExpression;

      framePhastInterpolationData.edMixFormula.Text := result.DecompileDisplay;
    end;
  except
    raise;
  end;
end;

procedure TfrmScreenObjectProperties.CreateFormula(const DataSetIndex:
  integer; const NewFormula: string;
  const ShowError: boolean = True);
var
  Formula: string;
  TempCompiler: TRbwParser;
  CompiledFormula: TExpression;
  ResultType: TRbwDataType;
  Edit:  TScreenObjectDataEdit;
  PestParamOK: Boolean;
begin
  if NewFormula = '' then
  begin
    Exit;
  end;
  Edit := FDataEdits[DataSetIndex];
  // Create a formula for a cell

  PestParamOK := False;
  if Edit.DataArray <> nil then
  begin
    if (Edit.DataArray.Name = KSUTRAInitialLakeS)
      or (Edit.DataArray.Name = KSUTRAInitialLakeU)
      or (Edit.DataArray.Name = KSUTRALakeRecharge)
      or (Edit.DataArray.Name = KSUTRALakeDischarge)
      then
    begin
      PestParamOK := True;
    end;
  end;

  Formula := NewFormula;
  TempCompiler := GetCompilerByIndex(DataSetIndex);
  try
    try
      TempCompiler.Compile(Formula);

    except on E: ErbwParserError do
      begin
        Edit.Expression := nil;
        Beep;
        MessageDlg(Format(StrErrorInFormulaFor,
          [Edit.DataArray.DisplayName, E.Message]), mtError, [mbOK], 0);
        Exit;
      end
    end;

    CompiledFormula := TempCompiler.CurrentExpression;
    if CompiledFormula = nil then
    begin
      Formula := Edit.Formula;
      try
        TempCompiler.Compile(Formula);
        CompiledFormula := TempCompiler.CurrentExpression;
      except on E: ErbwParserError do
        begin
          Edit.Expression := nil;
          Beep;
          MessageDlg(Format(StrErrorInFormulaFor,
            [Edit.DataArray.DisplayName, E.Message]), mtError, [mbOK], 0);
          Exit;
        end
      end;
    end;

    Edit.Formula := CompiledFormula.DecompileDisplay;
    ResultType := Edit.DataArray.DataType;
    // check that the formula is OK.
    if (ResultType = CompiledFormula.ResultType) or
      ((ResultType = rdtDouble) and (CompiledFormula.ResultType = rdtInteger))
        then
    begin
      Edit.Expression := CompiledFormula;
    end
    else
    begin
      if (CompiledFormula.ResultType = rdtString) and PestParamOK then
      begin
        PestParamOK := frmGoPhast.PhastModel.GetPestParameterByName(Formula) <> nil;
      end;
      if PestParamOK then
      begin
        Edit.Expression := CompiledFormula;
      end
      else
      begin
        // If the formula is not OK, try to fix it.
        Edit.Expression := nil;
        if ShowError then
        begin
          Beep;
          MessageDlg(StrTheFormulaYouEnte, mtError, [mbOK], 0);
        end;
        Formula := AdjustFormula(Formula, CompiledFormula.ResultType, ResultType);
        TempCompiler.Compile(Formula);
        CompiledFormula := TempCompiler.CurrentExpression;
        Edit.Expression := CompiledFormula;
        Edit.Formula := CompiledFormula.DecompileDisplay;
      end;
    end;
  except
    Edit.Expression := nil;
    raise;
  end;
end;

function TfrmScreenObjectProperties.AssignPoint(const Row: integer;
  out APoint: TPoint2D): boolean;
begin
  result := TryStrToFloat(dgVerticies.Cells[Ord(vcX), Row], APoint.X)
    and TryStrToFloat(dgVerticies.Cells[Ord(vcY), Row], APoint.Y);
end;

procedure TfrmScreenObjectProperties.dgVerticiesBeforeDrawCell(Sender: TObject;
  ACol, ARow: Integer);
var
  Dummy: double;
begin
  inherited;
  if (TVertexColumn(ACol) in [vcX, vcY]) and (ARow >= dgVerticies.FixedRows)
    and (dgVerticies.Cells[ACol, ARow] <> '') then
  begin
    if not TryStrToFloat(dgVerticies.Cells[ACol, ARow], Dummy)
      or not CanSetPoints then
    begin
      dgVerticies.Canvas.Brush.Color := clRed;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.dgVerticiesEndUpdate(Sender: TObject);
begin
  inherited;

  if FSettingVerticies or (csReading in ComponentState) then
  begin
    Exit;
  end;
  UpdateVertices;
  if FVertexRowCount <> dgVerticies.RowCount then
  begin
    FVertexRowCount := dgVerticies.RowCount;
    dgVerticies.BeginUpdate;
    try
      UpdateVertexNumbers;
      UpdateSectionNumbers;
    finally
      dgVerticies.EndUpdate;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.dgVerticiesEnter(Sender: TObject);
begin
  inherited;
  FVertexRowCount := dgVerticies.RowCount;
end;

procedure TfrmScreenObjectProperties.dgVerticiesExit(Sender: TObject);
begin
  inherited;
  UpdateSectionNumbers;
end;

procedure TfrmScreenObjectProperties.dgVerticiesStateChange(Sender: TObject;
  ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  UpdateSectionNumbers;
end;

procedure TfrmScreenObjectProperties.UpdateDataSetLinkages(const Expression:
  TExpression; const DataSetIndex: integer; const DSName: string);
var
  TempUsesList, TempUsesList2: TStringList;
  UseList: TStringList;
  TempIndex: integer;
  DataSetName: string;
  DSIndex: integer;
  Edit, OtherEdit: TScreenObjectDataEdit;
  OtherDataSetIndex: integer;
begin
  // update the list of which variables depend on which
  // others.;
  TempUsesList := TStringList.Create;
  try
    // Put the list of variables used in Expression into TempUsesList.
    TempUsesList.Assign(Expression.VariablesUsed);
    // TempUsesList now has a list of the variables/datasets
    // in the expression.

    // Get the list of variables that depends on the DataSet whose
    // formula has been changed.
    Edit := FDataEdits[DataSetIndex];

    UseList := Edit.UsesList;
    // Add the additional variables that depend on it because
    // they depend on the variable/dataset being edited.
    UseList.AddStrings(TempUsesList);

    for TempIndex := 0 to TempUsesList.Count - 1 do
    begin
      // get the name of a variable
      DataSetName := TempUsesList[TempIndex];
      // get the row that has that variable.
      OtherDataSetIndex := GetDataSetIndexByName(DataSetName);
      if OtherDataSetIndex >= 0 then
      begin
        OtherEdit := FDataEdits[OtherDataSetIndex];
        // Get the list of variables that depends on it.
        OtherEdit.UsedBy.Add(Edit.DataArray.Name);
        // Add the additional variables that depend on it because
        // they depend on the variable/dataset being edited.
        OtherEdit.UsedBy.AddStrings(Edit.UsedBy);
      end;
    end;
  finally
    TempUsesList.Free;
  end;
  DSIndex := DataSetIndex;
  // Get the list of variables that depends on it.
  UseList := Edit.UsedBy;

  for OtherDataSetIndex := 0 to FDataEdits.Count - 1 do
  begin
    if DSIndex = OtherDataSetIndex then
    begin
      Continue;
    end;
    OtherEdit := FDataEdits[OtherDataSetIndex];
    TempUsesList2 := OtherEdit.UsedBy;
    if TempUsesList2.IndexOf(DSName) >= 0 then
    begin
      TempUsesList2.AddStrings(UseList);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.ValidateDataSetFormula(ShowError: boolean = True);
var
  Variable: TCustomValue;
  Index: integer;
  Used: TStringList;
  VariableName: string;
  Orientation: TDataSetOrientation;
  VariableList: TList;
  TempUsesList: TStringList;
  Expression: TExpression;
  VariablePosition: integer;
  OldFormula: string;
  OldFormulaOK: boolean;
  AFormula: string;
  Value: string;
  DSName: string;
  Tester: TRbwParser;
  CompilerList: TList;
  EditIndex: integer;
  OtherEdit: TScreenObjectDataEdit;
  NewEditIndex: integer;
  EvalAt: TEvaluatedAt;
begin
  if FCurrentEdit = nil then Exit;
  // ValidateDataSetFormula ensures that when a formula
  // for a data set has been entered, that the formula is valid.
  try
    if FCurrentEdit.Used = cbUnChecked then
    begin
      Exit;
    end;

    Value := reDataSetFormula.Text;
    if Trim(Value) = '' then
    begin
      Exit;
    end;

    DSName := FCurrentEdit.DataArray.Name;

    VariableList := TList.Create;
    // VariableList will hold a list of variables that can
    // be used in the function
    Used := TStringList.Create;
    // "Used" will be a list of variables that depend on
    // the data set whose formula will be edited.
    try
      Orientation := FCurrentEdit.DataArray.Orientation;
      EvalAt := FCurrentEdit.DataArray.EvaluatedAt;
      // Add the variable whose value is being set to "Used".

      Used.Assign(FCurrentEdit.UsesList);

      Used.Sorted := True;
      for EditIndex := 0 to FDataEdits.Count - 1 do
      begin
        OtherEdit := FDataEdits[EditIndex];
        if FCurrentEdit <> OtherEdit then
        begin
          VariableName := OtherEdit.DataArray.Name;
          TempUsesList := OtherEdit.UsesList;
          VariablePosition := TempUsesList.IndexOf(DSName);
          if (VariablePosition < 0)
            and (EvalAt = OtherEdit.DataArray.EvaluatedAt)
            and ((Orientation = dso3D)
            or (Orientation = OtherEdit.DataArray.Orientation)) then
          begin
            // if the variable does not depend on the
            // data set whose formula is being edited
            // and it's orientation is OK, the variable
            // can be used in the formula.
            VariableList.Add(OtherEdit.Variable);
          end;
        end;
      end;

      // if the user makes an invalid formula, it
      // may be necessary to restore it but only
      // if the formula that was already present
      // was OK to begin with.
      OldFormulaOK := FCurrentEdit.Expression <> nil;
      if OldFormulaOK then
      begin
        OldFormula := FCurrentEdit.Expression.DecompileDisplay;
      end;

      Tester := TRbwParser.Create(self);
      try
        AddGIS_Functions(Tester, frmGoPhast.PhastModel.ModelSelection,
          FCurrentEdit.DataArray.EvaluatedAt);
        // put the formula in the TfrmFormula.

        CompilerList := TList.Create;
        try
          CompilerList.Add(Tester);
          frmGoPhast.PhastModel.RefreshGlobalVariables(CompilerList);
        finally
          CompilerList.Free;
        end;

        AFormula := Value;

        // register the appropriate variables with the
        // parser.
        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          Tester.RegisterVariable(Variable);
        end;

        // show the variables and functions

        try
          Tester.Compile(AFormula);
        except on E: ErbwParserError do
          begin
            FCurrentEdit.Expression := nil;
            if ShowError then
            begin
              Beep;
              if OldFormulaOK then
              begin
                if MessageDlg(Format(StrSThisMightBeD, [E.Message]), mtError,
                  [mbYes, mbNo], 0) = mrYes then
                begin
                  NewEditIndex := GetDataSetIndexByName(DSName);
                  reDataSetFormula.Text := OldFormula;
                  CreateFormula(NewEditIndex, OldFormula);
                end;
              end
              else
              begin
                MessageDlg(Format(StrSThisMightBeDNoRevert, [E.Message]),
                  mtError, [mbOK], 0)
              end;
            end;
            Exit;
          end;
        end;

        FSetCellsColor := True;
        NewEditIndex := GetDataSetIndexByName(DSName);
        CreateFormula(NewEditIndex, AFormula);
        Expression := FCurrentEdit.Expression;

        if Expression <> nil then
        begin
          // Check that the formula does not result in
          // a circular reference.
          CheckForCircularReference(Expression, DSName, NewEditIndex,
            OldFormulaOK, OldFormula);
          if FCurrentEdit.Expression <> nil then
          begin
            FCurrentEdit.Formula := FCurrentEdit.Expression.DecompileDisplay;
          end;

          // update the list of which variables depend on which
          // others.;
          UpdateDataSetLinkages(Expression, NewEditIndex, DSName);
        end;
      finally
        Tester.Free;
      end;
    finally
      Used.Free;
      VariableList.Free;
      // Don't allow the user to click the OK button
      // if any formulas are invalid.
    end;
  finally
    EnableOK_Button;
  end;
end;

procedure TfrmScreenObjectProperties.ValidateEdFormula(const ed: TEdit);
var
  FunctionString: string;
  VariableList: TList;
  VarIndex, Index: integer;
  Variable: TCustomValue;
  Compiler: TRbwParser;
  CompiledFormula: TExpression;
  Tester: TRbwParser;
  AVar: TCustomValue;
begin
  // ValidateEdFormula ensures that when a formula has been entered at
  // one of the elevation edit boxes, that the formula is valid.
  inherited;
  try
    Assert((ed = edZ) or (ed = edHighZ) or (ed = edLowZ)
      or (ed = edLeakyHydraulicConductivity) or (ed = edLeakyThickness)
      or (ed = edRiverHydraulicConductivity) or (ed = edRiverWidth)
      or (ed = edRiverDepth) or (ed = edRiverBedThickness));
    if not ed.Enabled then
      Exit;
    if ed = edZ then
    begin
      FZFormula := nil;
    end
    else if ed = edHighZ then
    begin
      FHighZFormula := nil;
    end
    else if ed = edLowZ then
    begin
      FLowZFormula := nil;
    end
    else if (ed = edLeakyHydraulicConductivity) or (ed = edLeakyThickness)
      or (ed = edRiverHydraulicConductivity) or (ed = edRiverWidth)
      or (ed = edRiverDepth) or (ed = edRiverBedThickness) then
    begin
      // do nothing
    end
    else
    begin
      Assert(False);
    end;
    FunctionString := ed.Text;
    if (FunctionString = '') and (FScreenObject = nil) then
    begin
      Exit;
    end;

    CompiledFormula := nil;
    Compiler := GetElevationCompiler;
    if Compiler = nil then
    begin
      If IsLoaded then
      begin
        Beep;
        MessageDlg( StrYouMustSpecifyNod, mtInformation, [mbOK], 0);
      end;
    end
    else
    begin
      if ed.Enabled then
      begin
        ed.Color := clWindow;
      end
      else
      begin
        ed.Color := clBtnFace;
      end;
      VariableList := TList.Create;
      try
        for VarIndex := 0 to Compiler.VariableCount - 1 do
        begin
          AVar := Compiler.Variables[VarIndex];
          if VariableList.IndexOf(AVar) < 0 then
          begin
            VariableList.Add(AVar);
          end;
        end;

        Tester := TRbwParser.Create(self);
        try
          AddGIS_Functions(Tester, frmGoPhast.PhastModel.ModelSelection,
            TEvaluatedAt(rgEvaluatedAt.ItemIndex));
          for Index := 0 to VariableList.Count - 1 do
          begin
            Variable := VariableList[Index];
            Tester.RegisterVariable(Variable);
          end;

          try
            Tester.Compile(FunctionString);
          except on E: ERbwParserError do
            begin
              ed.Color := clRed;
              Beep;
              MessageDlg(Format(StrErrorInFormulaS, [E.Message]),
                mtError, [mbOK], 0);
              Exit;
            end;
          end;
        finally
          Tester.Free;
        end;

        try
          Compiler.Compile(FunctionString);
        except on E: ErbwParserError do
          begin
            ed.Color := clRed;
            Beep;
            MessageDlg(Format(StrErrorInFormulaS, [E.Message]),
              mtError, [mbOK], 0);
            Exit;
          end
        end;

        CompiledFormula := Compiler.CurrentExpression;
        // check that the formula is OK.
        if not (CompiledFormula.ResultType in [rdtDouble, rdtInteger]) then
        begin
          ed.Color := clRed;
          Beep;
          MessageDlg(StrErrorTheFormulaI, mtError, [mbOK], 0);
          Exit;
        end
        else
        begin
          FunctionString := CompiledFormula.DecompileDisplay;
          if FunctionString <> ed.Text then
          begin
            ed.Text := FunctionString;
            if Assigned(ed.OnChange) then
            begin
              ed.OnChange(ed);
            end;
          end;
        end
      finally
        VariableList.Free;
      end;
    end;
    if CompiledFormula <> nil then
    begin
      if ed = edZ then
      begin
        FZFormula := CompiledFormula;
      end
      else if ed = edHighZ then
      begin
        FHighZFormula := CompiledFormula;
      end
      else if ed = edLowZ then
      begin
        FLowZFormula := CompiledFormula;
      end
      else if (ed = edLeakyHydraulicConductivity) or (ed = edLeakyThickness)
        or (ed = edRiverHydraulicConductivity) or (ed = edRiverWidth)
        or (ed = edRiverDepth) or (ed = edRiverBedThickness) then
      begin
        // do nothing
      end
      else
      begin
        Assert(False);
      end;
    end;

  finally
    EnableOK_Button;
  end;
end;

Type
  TCustomEditCrack = class(TCustomEdit);

procedure TfrmScreenObjectProperties.btnFormulaClick(Sender: TObject);
var
  FunctionString: string;
  ed: TCustomEdit;
  VariableList: TList;
  VarIndex, Index: integer;
  Variable: TCustomValue;
  Compiler: TRbwParser;
  CompiledFormula: TExpression;
  AScreenObject: TScreenObject;
  ScreenObjectIndex: integer;
  AVar: TCustomValue;
  DataSetIndex: Integer;
  DataArray: TDataArray;
  UsedDataSets: TStringList;
  Edit: TScreenObjectDataEdit;
  UsedIndex: Integer;
  UsedArray: TDataArray;
  DataArrayManager: TDataArrayManager;
  DataSetPostion: Integer;
  ADataArray: TDataArray;
  SwrReaches: TSwrReachBoundary;
  FootprintWell: TFootprintWell;
  SutraLake: TSutraLake;
  ALake: TLakeMf6;
  PestParamOK: Boolean;
begin
{ TODO : See if some of this can be combined with ValidateEdFormula. }

  inherited;
  PestParamOK := False;
  // edit the formula that is not part of a data set or boundary data set.
  DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
  ed := nil;
  if Sender is TCustomEdit then
  begin
    ed := TCustomEdit(Sender);
    if (ed = frameLakMf6.edBottomElev)
      or (ed = frameLakMf6.edTopElev)
      or (ed = frameLakMf6.edLakebedK)
      or (ed = frameLakMf6.edLakebedThickness)
      or (ed = frameLakMf6.edConnLength)
      or (ed = frameSutraLake.btnedInitialStage)
      or (ed = frameSutraLake.btnedInitialU)
      or (ed = frameSutraLake.btnedFractionRechargeDiverted)
      or (ed = frameSutraLake.btnedFractionDischargeDiverted)
      then
    begin
      PestParamOK := True;
    end;
  end
  else if Sender = btnZ then
  begin
    ed := edZ;
    FZFormula := nil;
  end
  else if Sender = btnHighZ then
  begin
    ed := edHighZ;
    FHighZFormula := nil;
  end
  else if Sender = btnLowZ then
  begin
    ed := edLowZ;
    FLowZFormula := nil;
  end
  else if Sender = btnLeakyHydraulicConductivity then
  begin
    ed := edLeakyHydraulicConductivity;
  end
  else if Sender = btnLeakyThickness then
  begin
    ed := edLeakyThickness;
  end
  else if Sender = btnRiverHydraulicConductivity then
  begin
    ed := edRiverHydraulicConductivity;
  end
  else if Sender = btnRiverWidth then
  begin
    ed := edRiverWidth;
  end
  else if Sender = btnRiverDepth then
  begin
    ed := edRiverDepth;
  end
  else if Sender = btnRiverBedThickness then
  begin
    ed := edRiverBedThickness;
  end
  else if Sender = framePhastInterpolationBoundaries.btnEditMixtureFormula then
  begin
    ed := framePhastInterpolationBoundaries.edMixFormula;
  end
  else if Sender = frameCfpPipes.btnDiameter then
  begin
    ed := frameCfpPipes.edDiameter;
  end
  else if Sender = frameCfpPipes.btnTortuosity then
  begin
    ed := frameCfpPipes.edTortuosity;
  end
  else if Sender = frameCfpPipes.btnRoughnessHeight then
  begin
    ed := frameCfpPipes.edRoughnessHeight;
  end
  else if Sender = frameCfpPipes.btnLowerCriticalR then
  begin
    ed := frameCfpPipes.edLowerCriticalR;
  end
  else if Sender = frameCfpPipes.btnHigherCriticalR then
  begin
    ed := frameCfpPipes.edHigherCriticalR;
  end
  else if Sender = frameCfpPipes.btnConductancePermeability then
  begin
    ed := frameCfpPipes.edConductancePermeability;
  end
  else if Sender = frameCfpPipes.btnElevation then
  begin
    ed := frameCfpPipes.edElevation;
  end

  else if Sender = frameCfpPipes.btnCads then
  begin
    ed := frameCfpPipes.edCads;
  end

  else if Sender = frameCfpFixedHeads.btnFixedHead then
  begin
    ed := frameCfpFixedHeads.edFixedHead;
  end
  else if Sender = frameSwrReach.btnEditReachLength then
  begin
    ed := frameSwrReach.edReachLength
  end
  else if Sender = frameScreenObjectFootprintWell.btnPumpingRate then
  begin
    ed := frameScreenObjectFootprintWell.edPumpingRate;
  end
  else
  begin
    Assert(False);
  end;
  FunctionString := ed.Text;
  if (FunctionString = '') and (FScreenObject = nil) then
  begin
    if Sender = btnZ then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if AScreenObject.ElevationCount = ecOne then
        begin
          FunctionString := AScreenObject.ElevationFormula;
          break;
        end;
      end;
    end
    else if Sender = btnHighZ then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if AScreenObject.ElevationCount = ecTwo then
        begin
          FunctionString := AScreenObject.HigherElevationFormula;
          break;
        end;
      end;
    end
    else if Sender = btnLowZ then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if AScreenObject.ElevationCount = ecTwo then
        begin
          FunctionString := AScreenObject.LowerElevationFormula;
          break;
        end;
      end;
    end
    else if Sender = btnLeakyHydraulicConductivity then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if (AScreenObject.LeakyBoundary.BoundaryValue.Count > 0)
          or (AScreenObject.LeakyBoundary.Solution.Count > 0) then
        begin
          FunctionString := AScreenObject.LeakyBoundary.HydraulicConductivity;
          break;
        end;
      end;
    end
    else if Sender = btnLeakyThickness then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if (AScreenObject.LeakyBoundary.BoundaryValue.Count > 0)
          or (AScreenObject.LeakyBoundary.Solution.Count > 0) then
        begin
          FunctionString := AScreenObject.LeakyBoundary.Thickness;
          break;
        end;
      end;
    end
    else if Sender = btnRiverHydraulicConductivity then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if (AScreenObject.RiverBoundary.BoundaryValue.Count > 0)
          or (AScreenObject.RiverBoundary.Solution.Count > 0) then
        begin
          FunctionString :=
            AScreenObject.RiverBoundary.BedHydraulicConductivity;
          break;
        end;
      end;
    end
    else if Sender = btnRiverWidth then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if (AScreenObject.RiverBoundary.BoundaryValue.Count > 0)
          or (AScreenObject.RiverBoundary.Solution.Count > 0) then
        begin
          FunctionString := AScreenObject.RiverBoundary.Width;
          break;
        end;
      end;
    end
    else if Sender = btnRiverDepth then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if (AScreenObject.RiverBoundary.BoundaryValue.Count > 0)
          or (AScreenObject.RiverBoundary.Solution.Count > 0) then
        begin
          FunctionString := AScreenObject.RiverBoundary.Depth;
          break;
        end;
      end;
    end
    else if Sender = btnRiverBedThickness then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        if (AScreenObject.RiverBoundary.BoundaryValue.Count > 0)
          or (AScreenObject.RiverBoundary.Solution.Count > 0) then
        begin
          FunctionString := AScreenObject.RiverBoundary.BedThickness;
          break;
        end;
      end;
    end
    else if Sender = framePhastInterpolationBoundaries.btnEditMixtureFormula
      then
    begin
      FunctionString := framePhastInterpolationBoundaries.edMixFormula.Text;
    end
    else if Sender = frameCfpPipes.btnDiameter then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KPipeDiameter);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);

        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnTortuosity then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KTortuosity);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnRoughnessHeight then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KRoughnessHeight);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnLowerCriticalR then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KLowerCriticalR);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnHigherCriticalR then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KUpperCriticalR);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnConductancePermeability then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KPipeConductanceOrPer);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnElevation then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KCfpNodeElevation);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpPipes.btnCads then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KDrainableStorageWidth);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameCfpFixedHeads.btnFixedHead then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ADataArray := DataArrayManager.GetDataSetByName(KCfpFixedHeads);
        DataSetPostion := AScreenObject.IndexOfDataSet(ADataArray);
        if (DataSetPostion >= 0) then
        begin
          FunctionString := AScreenObject.DataSetFormulas[DataSetPostion];
          break;
        end;
      end;
    end
    else if Sender = frameSwrReach.btnEditReachLength then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        SwrReaches := AScreenObject.ModflowSwrReaches;
        if SwrReaches <> nil then
        begin
          FunctionString := SwrReaches.ReachLengthFormula;
          break;
        end;
      end;
    end
    else if Sender = frameScreenObjectFootprintWell.btnPumpingRate then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        FootprintWell := AScreenObject.FootprintWell;
        if FootprintWell <> nil then
        begin
          FunctionString := FootprintWell.Withdrawal;
          break;
        end;
      end;
    end
    else if Sender = frameSutraLake.btnedInitialStage then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        SutraLake := AScreenObject.SutraBoundaries.Lake;
        if SutraLake <> nil then
        begin
          FunctionString := SutraLake.InitialStage;
          break;
        end;
      end;
    end
    else if Sender = frameSutraLake.btnedInitialU then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        SutraLake := AScreenObject.SutraBoundaries.Lake;
        if SutraLake <> nil then
        begin
          FunctionString := SutraLake.InitialConcentrationOrTemperature;
          break;
        end;
      end;
    end
    else if Sender = frameSutraLake.btnedFractionRechargeDiverted then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        SutraLake := AScreenObject.SutraBoundaries.Lake;
        if SutraLake <> nil then
        begin
          FunctionString := SutraLake.FractionRechargeDiverted;
          break;
        end;
      end;
    end
    else if Sender = frameSutraLake.btnedFractionDischargeDiverted then
    begin
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        SutraLake := AScreenObject.SutraBoundaries.Lake;
        if SutraLake <> nil then
        begin
          FunctionString := SutraLake.FractionDischargeDiverted;
          break;
        end;
      end;
    end
    else if (ed.Parent = frameLakMf6.tabLakeProperties) then
    begin
//      ALake := nil;
      for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[ScreenObjectIndex];
        ALake := AScreenObject.ModflowLak6;
        if (ALake <> nil) and ALake.Used then
        begin
          if ed = frameLakMf6.edBottomElev then
          begin
            FunctionString := ALake.BottomElevation;
            break;
          end
          else if ed = frameLakMf6.edTopElev then
          begin
            FunctionString := ALake.TopElevation;
            break;
          end
          else if ed = frameLakMf6.edLakebedK then
          begin
            FunctionString := ALake.BedK;
            break;
          end
          else if ed = frameLakMf6.edLakebedThickness then
          begin
            FunctionString := ALake.BedThickness;
            break;
          end
          else if ed = frameLakMf6.edConnLength then
          begin
            FunctionString := ALake.ConnectionLength;
            break;
          end
//          else if ed = frameLakMf6.edConnWidth then
//          begin
//            FunctionString := ALake.ConnectionWidth;
//            break;
//          end
          else
          begin
            Assert(False);
          end;
        end;
      end;
    end
    else
    begin
      Assert(False);
    end;
  end;

  if (Sender = btnZ) or (Sender = btnHighZ) or (Sender = btnLowZ) then
  begin
    Compiler := GetElevationCompiler;
  end
  else if (ed = frameCfpPipes.edDiameter)
    or (ed = frameCfpPipes.edTortuosity)
    or (ed = frameCfpPipes.edRoughnessHeight)
    or (ed = frameCfpPipes.edLowerCriticalR)
    or (ed = frameCfpPipes.edHigherCriticalR)
    or (ed = frameCfpPipes.edConductancePermeability)
    or (ed = frameCfpPipes.edElevation)
    or (ed = frameCfpPipes.edCads)
    or (ed = frameCfpFixedHeads.edFixedHead)
    or (ed = frameSwrReach.edReachLength)
    then
  begin
    Compiler := GetCompiler(dso3D, eaBlocks);
  end
  else if Sender = frameScreenObjectFootprintWell.btnPumpingRate then
  begin
    Compiler := GetCompiler(dsoTop, eaBlocks);
  end
  else if (ed = frameSutraLake.btnedInitialStage)
    or (ed = frameSutraLake.btnedInitialU)
    or (ed = frameSutraLake.btnedFractionRechargeDiverted)
    or (ed = frameSutraLake.btnedFractionDischargeDiverted)
  then
  begin
    Compiler := GetCompiler(dsoTop, eaNodes);
  end
  else if (ed.Parent = frameLakMf6.tabLakeProperties) then
  begin
    Compiler := GetCompiler(dso3D, eaBlocks);
  end
  else
  begin
    Compiler := GetCompiler(dso3D, eaNodes);
  end;

  if Compiler = nil then
  begin
    Beep;
    MessageDlg(StrYouMustSpecifyNod, mtInformation, [mbOK], 0);
    Exit;
  end;

  VariableList := TList.Create;
  try
    UsedDataSets := TStringList.Create;
    try
      UsedDataSets.CaseSensitive  := False;
      UsedDataSets.Duplicates := dupIgnore;
      UsedDataSets.Sorted := True;
      if FScreenObject = nil then
      begin
        for ScreenObjectIndex := 0 to FScreenObjectList.Count - 1 do
        begin
          AScreenObject := FScreenObjectList[ScreenObjectIndex];
          for DataSetIndex := 0 to AScreenObject.DataSetCount - 1 do
          begin
            DataArray := AScreenObject.DataSets[DataSetIndex];
            UsedDataSets.AddObject(DataArray.Name, DataArray);
          end;
        end;
      end
      else
      begin
        for DataSetIndex := 0 to FScreenObject.DataSetCount - 1 do
        begin
          DataArray := FScreenObject.DataSets[DataSetIndex];
          UsedDataSets.AddObject(DataArray.Name, DataArray);
        end;
      end;

      for Index := 0 to FDataEdits.Count - 1 do
      begin
        Edit := FDataEdits[Index];
        if Edit.Used <> cbUnChecked then
        begin
          UsedDataSets.AddObject(Edit.DataArray.Name, Edit.DataArray);
        end;
      end;

//      DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
      for Index := 0 to DataArrayManager.DataSetCount - 1 do
      begin
        DataArray := DataArrayManager.DataSets[Index];
        if UsedDataSets.IndexOf(DataArray.Name) < 0 then
        begin
          if not DataArray.Visible then
          begin
            UsedDataSets.AddObject(DataArray.Name, DataArray);
            Continue;
          end;
          if DataArray is TCustomSparseDataSet then
          begin
            UsedDataSets.AddObject(DataArray.Name, DataArray);
            Continue;
          end;
          for UsedIndex := 0 to UsedDataSets.Count - 1 do
          begin
            UsedArray := UsedDataSets.Objects[UsedIndex] as TDataArray;
            if DataArray.IsListeningTo(UsedArray) then
            begin
              UsedDataSets.AddObject(DataArray.Name, DataArray);
              break;
            end;
          end;
        end;
      end;

      for VarIndex := 0 to Compiler.VariableCount - 1 do
      begin
        AVar := Compiler.Variables[VarIndex];
        if (frmGoPhast.PhastModel.GlobalVariables.
          IndexOfVariable(AVar.Name) < 0)
          and (UsedDataSets.IndexOf(AVar.Name) < 0) then
        begin
          VariableList.Add(Compiler.Variables[VarIndex]);
        end;
      end;
    finally
      UsedDataSets.Free;
    end;

//    with TfrmFormula.Create(nil) do
    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(TEvaluatedAt(rgEvaluatedAt.ItemIndex));
        RemoveGetVCont;
        RemoveHufFunctions;
        PopupParent := self;

        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          rbFormulaParser.RegisterVariable(Variable);
        end;

        IncludeTimeSeries := False;
        UpdateTreeList;
        Formula := FunctionString;

        ShowModal;
        if ResultSet then
        begin
          FunctionString := Formula;
        end
        else
        begin
          if FunctionString = '' then
            FunctionString := '0';
        end;
      finally
        Initialize;
//        Free;
      end;
    end;

    try
      Compiler.Compile(FunctionString);
    except on E: ErbwParserError do
      begin
        Beep;
        MessageDlg(Format(StrErrorInFormulaS, [E.Message]), mtError, [mbOK], 0);
        Exit;
      end
    end;

    if PestParamOK then
    begin
      PestParamOK :=
        frmGoPhast.PhastModel.GetPestParameterByName(FunctionString) <> nil;
    end;

    CompiledFormula := Compiler.CurrentExpression;
    // check that the formula is OK.
    if (not (CompiledFormula.ResultType in [rdtDouble, rdtInteger]))
      and (not PestParamOK) then
    begin
      TCustomEditCrack(ed).Color := clRed;
      Beep;
      MessageDlg(StrErrorTheFormulaI, mtError, [mbOK], 0);
      Exit;
    end
    else
    begin
      TCustomEditCrack(ed).Color := clWindow;
      FunctionString := CompiledFormula.DecompileDisplay;
      if FunctionString <> ed.Text then
      begin
        ed.Text := FunctionString;
        if Assigned(TCustomEditCrack(ed).OnChange) then
        begin
          TCustomEditCrack(ed).OnChange(ed);
        end;
        if Assigned(TCustomEditCrack(ed).OnExit) then
        begin
          TCustomEditCrack(ed).OnExit(ed);
        end;
      end;
    end
  finally
    VariableList.Free;
  end;
  if ed = edZ then
  begin
    FZFormula := CompiledFormula;
  end
  else if ed = edHighZ then
  begin
    FHighZFormula := CompiledFormula;
  end
  else if ed = edLowZ then
  begin
    FLowZFormula := CompiledFormula;
  end
  else if (ed = edLeakyHydraulicConductivity)
    or (ed = edLeakyThickness) or (ed = edRiverHydraulicConductivity)
    or (ed = edRiverWidth) or (ed = edRiverDepth)
    or (ed = edRiverBedThickness)
    or (ed = framePhastInterpolationBoundaries.edMixFormula)
    or (ed = frameCfpPipes.edDiameter)
    or (ed = frameCfpPipes.edTortuosity)
    or (ed = frameCfpPipes.edRoughnessHeight)
    or (ed = frameCfpPipes.edLowerCriticalR)
    or (ed = frameCfpPipes.edHigherCriticalR)
    or (ed = frameCfpPipes.edConductancePermeability)
    or (ed = frameCfpPipes.edElevation)
    or (ed = frameCfpPipes.edCads)
    or (ed = frameCfpFixedHeads.edFixedHead)
    or (ed = frameSwrReach.edReachLength)
    or (ed = frameScreenObjectFootprintWell.edPumpingRate)
    or (ed = frameSutraLake.btnedInitialStage)
    or (ed = frameSutraLake.btnedInitialU)
    or (ed = frameSutraLake.btnedFractionRechargeDiverted)
    or (ed = frameSutraLake.btnedFractionDischargeDiverted)
    or (ed.Parent = frameLakMf6.tabLakeProperties)
    then
  begin
    // do nothing
  end
  else
  begin
    Assert(False);
  end;
  EnableOK_Button;
end;

procedure TfrmScreenObjectProperties.btnImportVertexValuesClick(
  Sender: TObject);
var
  QuadTree: TRbwQuadTree;
  PointIndex: Integer;
  APoint: TPoint2D;
  VertexNumbers: TStringList;
  Keys: TStringList;
  RowIndex: Integer;
  Items: TStrings;
  Grid: TRbwDataGrid4;
  X: Double;
  Y: Double;
  VertexNumber: String;
  VIndex: Integer;
  ColIndex: Integer;
  ExistingKeyColumns: array of Integer;
  KeyIndex: Integer;
  KeyColumn: Integer;
  VValue: string;
  AScreenObject: TScreenObject;
begin
  inherited;
  if FScreenObject <> nil then
  begin
    AScreenObject := FScreenObject
  end
  else
  begin
    if FScreenObjectList.Count <> 1 then
    begin
      Exit;
    end;
    AScreenObject := FScreenObjectList[0];
  end;

  if AScreenObject = nil then
  begin
    Exit;
  end;
  Application.CreateForm(TfrmImportVertexValues, frmImportVertexValues);
  try
    if frmImportVertexValues.ShowModal = mrOK then
    begin
      QuadTree := TRbwQuadTree.Create(nil);
      VertexNumbers := TStringList.Create;
      Keys := TStringList.Create;
      try
        QuadTree.XMax := AScreenObject.MaxX;
        QuadTree.XMin := AScreenObject.MinX;
        QuadTree.YMax := AScreenObject.MaxY;
        QuadTree.YMin := AScreenObject.MinY;
        for PointIndex := 0 to AScreenObject.Count - 1 do
        begin
          APoint := AScreenObject.Points[PointIndex];
          QuadTree.AddPoint(APoint.x, APoint.y, Pointer(PointIndex));
        end;

        if tabVertexValues.TabVisible then
        begin
          VertexNumbers.Assign(rdgVertexValues.Cols[0]);
          VertexNumbers.Delete(0);
          Keys.Assign(rdgVertexValues.Rows[0]);
          Keys.Delete(0);
        end
        else
        begin
          ClearGrid(rdgVertexValues);
          rdgVertexValues.RowCount := 1;
          rdgVertexValues.ColCount := 2;
        end;

        Keys.CaseSensitive := False;

        Items := frmImportVertexValues.memoKeys.Lines;
        for RowIndex := 0 to Items.Count - 1 do
        begin
          if Keys.IndexOf(Items[RowIndex]) < 0 then
          begin
            Keys.Add(Items[RowIndex]);
          end;
        end;
        Keys.Insert(0, StrVertexNumbers);
        rdgVertexValues.ColCount := Keys.Count;
        rdgVertexValues.Rows[0].Assign(Keys);
        Keys.Delete(0);
        SetLength(ExistingKeyColumns, Items.Count);
        for RowIndex := 0 to Items.Count - 1 do
        begin
          ExistingKeyColumns[RowIndex] := Keys.IndexOf(Items[RowIndex]) + 1;
        end;

        Grid := frmImportVertexValues.frameValues.Grid;
        for RowIndex := 1 to Grid.RowCount - 1 do
        begin
          if TryStrToFloat(Grid.Cells[0,RowIndex], X)
            and TryStrToFloat(Grid.Cells[1,RowIndex], Y) then
          begin
            VertexNumber := IntToStr(Integer(QuadTree.NearestPointsFirstData(X, Y))+1);
            VIndex := VertexNumbers.IndexOf(VertexNumber);
            if VIndex < 0 then
            begin
              VertexNumbers.Add(VertexNumber);
              rdgVertexValues.RowCount := rdgVertexValues.RowCount + 1;
              rdgVertexValues.FixedRows := 1;
              rdgVertexValues.Cells[0, rdgVertexValues.RowCount-1] := VertexNumber;
              VIndex := rdgVertexValues.RowCount-1;
              for ColIndex := 1 to rdgVertexValues.ColCount - 1 do
              begin
                rdgVertexValues.Cells[ColIndex, VIndex] := '';
              end;
            end
            else
            begin
              Inc(VIndex);
            end;
            for KeyIndex := 2 to Grid.ColCount - 1 do
            begin
              VValue := Trim(Grid.Cells[KeyIndex, RowIndex]);
              if VValue <> '' then
              begin
                KeyColumn := ExistingKeyColumns[KeyIndex-2];
                rdgVertexValues.Cells[KeyColumn,VIndex] := VValue;
              end;
            end;
          end;
        end;
        tabVertexValues.TabVisible := True;
      finally
        Keys.Free;
        VertexNumbers.Free;
        QuadTree.Free;
      end;
    end;
  finally
    frmImportVertexValues.Free;
  end;
end;

procedure TfrmScreenObjectProperties.edHighZExit(Sender: TObject);
var
  NewFormula: string;
  Index: Integer;
  Item: TScreenObjectEditItem;
  List: TList;
begin
  inherited;
  if FFillingDataSetTreeView then Exit;
  if FScreenObject <> nil then
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      FillDataSetsTreeView(List);
    finally
      List.Free;
    end;
  end
  else
  begin
    FillDataSetsTreeView(FScreenObjectList);
  end;

  ValidateEdFormula(edHighZ);
  if IsLoaded and (FHighZFormula <> nil) then
  begin
    NewFormula := edHighZ.Text;
    if NewFormula <> '' then
    begin
      if FScreenObject <> nil then
      begin
        FScreenObject.HigherElevationFormula := NewFormula;
      end;
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.HigherElevationFormula := NewFormula;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.edLowZExit(Sender: TObject);
var
  NewFormula: string;
  Index: Integer;
  Item: TScreenObjectEditItem;
  List: TList;
begin
  inherited;
  if FFillingDataSetTreeView then Exit;
  if FScreenObject <> nil then
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      FillDataSetsTreeView(List);
    finally
      List.Free;
    end;
  end
  else
  begin
    FillDataSetsTreeView(FScreenObjectList);
  end;

  ValidateEdFormula(edLowZ);
  if IsLoaded and (FLowZFormula <> nil) then
  begin
    NewFormula := edLowZ.Text;
    if NewFormula <> '' then
    begin
      if FScreenObject <> nil then
      begin
        FScreenObject.LowerElevationFormula := NewFormula;
      end;
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.LowerElevationFormula := NewFormula;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbInterpolationClick(Sender: TObject);
var
  Index: integer;
  Item: TScreenObjectEditItem;
begin
  inherited;

  InvalidateAllDataSets;

  ShowOrHideTabs;
  EmphasizeValueChoices;
  if IsLoaded then
  begin
    DisableAllowGrayed(cbInterpolation);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.SetValuesByInterpolation := cbInterpolation.Checked;
    end;
  end;
end;


procedure TfrmScreenObjectProperties.edZExit(Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  NewFormula: string;
  List: TList;
begin
  inherited;
  if FFillingDataSetTreeView then Exit;
  if FScreenObject <> nil then
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      FillDataSetsTreeView(List);
    finally
      List.Free;
    end;
  end
  else
  begin
    FillDataSetsTreeView(FScreenObjectList);
  end;

  ValidateEdFormula(Sender as TEdit);
  if IsLoaded and (FZFormula <> nil) then
  begin
    NewFormula := edZ.Text;
    if NewFormula <> '' then
    begin
      if FScreenObject <> nil then
      begin
        FScreenObject.ElevationFormula := NewFormula;
      end;
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.ElevationFormula := NewFormula;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.rdeDrtLocationControlExit(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FDRT_Node);
  StoreDrtBoundary;
  UpdateDrtReturnFlowLabels(Sender);
end;

procedure TfrmScreenObjectProperties.rdeGridCellSizeExit(Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  NewCellSize: Extended;
begin
  inherited;
  if IsLoaded then
  begin
    if TryStrToFloat(rdeGridCellSize.Text, NewCellSize) then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CellSize := NewCellSize;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.rdeMinimumCellFractionChange(
  Sender: TObject);
var
  Fraction: Extended;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  if IsLoaded then
  begin
    if rdeMinimumCellFraction.Text <> '' then
    begin
      Fraction := rdeMinimumCellFraction.RealValue;
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.MinimumFraction := Fraction;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.rdgImportedDataSetEditText(Sender: TObject;
  ACol, ARow: Integer; const Value: string);
var
  ValueStorage: TValueArrayStorage;
  IntValue: Integer;
  FloatValue: double;
begin
  inherited;
  if IsLoaded and (ARow < rdgImportedData.RowCount) and (ARow > 0) then
  begin
    ValueStorage := rdgImportedData.Objects[ACol, 0] as TValueArrayStorage;
    Assert(ValueStorage <> nil);
    case rdgImportedData.Columns[ACol].Format of
      rcf4String:
        begin
          Assert(ValueStorage.DataType = rdtString);
          ValueStorage.StringValues[ARow-1] :=
            rdgImportedData.Cells[ACol, ARow];
        end;
      rcf4Integer:
        begin
          Assert(ValueStorage.DataType = rdtInteger);
          if TryStrToInt(rdgImportedData.Cells[ACol, ARow], IntValue) then
          begin
            ValueStorage.IntValues[ARow-1] := IntValue;
          end;
        end;
      rcf4Real:
        begin
          Assert(ValueStorage.DataType = rdtDouble);
          if TryStrToFloat(rdgImportedData.Cells[ACol, ARow], FloatValue) then
          begin
            ValueStorage.RealValues[ARow-1] := FloatValue;
          end;
        end;
      rcf4Boolean:
        begin
          Assert(ValueStorage.DataType = rdtBoolean);
          ValueStorage.BooleanValues[ARow-1] :=
            rdgImportedData.Checked[ACol, ARow];
        end;
      else Assert(False);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.reDataSetFormulaChange(Sender: TObject);
begin
  inherited;
  if FFormulaEdit = FCurrentEdit then
  begin
    ValidateDataSetFormula(False);
  end;
end;

procedure TfrmScreenObjectProperties.reDataSetFormulaEnter(Sender: TObject);
begin
  inherited;
  FFormulaEdit := FCurrentEdit;
end;

procedure TfrmScreenObjectProperties.reDataSetFormulaExit(Sender: TObject);
begin
  inherited;
  if FFormulaEdit = FCurrentEdit then
  begin
    ValidateDataSetFormula;
  end;
end;

procedure TfrmScreenObjectProperties.rgElevationCountClick(Sender: TObject);
var
  RowIndex: integer;
  DataSet: TDataArray;
  Index: integer;
  AScreenObject: TScreenObject;
  Item: TScreenObjectEditItem;
  NewElevationCount: TElevationCount;
  List: TList;
  Edit: TScreenObjectDataEdit;
  DsIndex: Integer;
  ShowWarning: Boolean;
  UsedDataSets: TStringList;
  TempFormula: string;
  LocalCompiler: TRbwParser;
  DataArray: TDataArray;
  AnotherDataArray: TDataArray;
  DataEdit: TScreenObjectDataEdit;
  DataArrayManager: TDataArrayManager;
begin
  inherited;
  if FFillingDataSetTreeView then Exit;
  if FScreenObject <> nil then
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      FillDataSetsTreeView(List);
    finally
      List.Free;
    end;
  end
  else
  begin
    FillDataSetsTreeView(FScreenObjectList);
  end;

  if rgElevationCount.ItemIndex = Ord(ecTwo) then
  begin
    if FScreenObject = nil then
    begin
      for Index := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[Index];
        if AScreenObject.Count > 1 then
        begin
          cbFillColor.Enabled := True;
          break;
        end
      end;
    end
    else
    begin
      cbFillColor.Enabled := FScreenObject.Count > 1;
    end;
  end
  else
  begin
    if FScreenObject = nil then
    begin
      for Index := 0 to FScreenObjectList.Count - 1 do
      begin
        AScreenObject := FScreenObjectList[Index];
        if AScreenObject.Closed then
        begin
          cbFillColor.Enabled := True;
          break;
        end
      end;
    end
    else
    begin
      cbFillColor.Enabled := FScreenObject.Closed;
    end;
  end;
  if not cbFillColor.Enabled then
    cbFillColor.Checked := False;

  if rgElevationCount.ItemIndex >=0 then
  begin
    edZ.Enabled := (rgElevationCount.ItemIndex = 1);
    btnZ.Enabled := edZ.Enabled;
    lblZ.Enabled := edZ.Enabled;
    edHighZ.Enabled := (rgElevationCount.ItemIndex = 2);
    btnHighZ.Enabled := edHighZ.Enabled;
    lblHighZ.Enabled := edHighZ.Enabled;
    edLowZ.Enabled := edHighZ.Enabled;
    btnLowZ.Enabled := edHighZ.Enabled;
    lblLowZ.Enabled := edHighZ.Enabled;
  end;


  case rgElevationCount.ItemIndex of
    0:
      begin
        for RowIndex := 0 to FDataEdits.Count - 1 do
        begin
          Edit := FDataEdits[RowIndex];
          DataSet := Edit.DataArray;
          if (DataSet.Orientation = dso3D)
            and (Edit.Used <> cbUnchecked) then
          begin
            Edit.Used := cbUnchecked;
            break;
          end;
        end;
      end;
    1:
      begin
        FFilledDataSetTreeView := True;
        try
          edZExit(edZ);
        finally
          FFilledDataSetTreeView := False;
        end;
      end;
    2:
      begin
        FFilledDataSetTreeView := True;
        try
          edHighZExit(edHighZ);
          edLowZExit(edLowZ);
        finally
          FFilledDataSetTreeView := False;
        end;
      end;
    else
    begin
      if edHighZ.Enabled then
      begin
        edZExit(edZ);
      end;
      if edHighZ.Enabled then
      begin
        edHighZExit(edHighZ);
        edLowZExit(edLowZ);
      end;
    end;
  end;
  if FScreenObject <> nil then
  begin
    clbChildModels.Enabled := CanSpecifyChildModels(FScreenObject);
  end
  else
  begin
    Assert(FScreenObjectList <> nil);
    if FScreenObjectList.Count = 1 then
    begin
      AScreenObject := FScreenObjectList[0];
      clbChildModels.Enabled := CanSpecifyChildModels(AScreenObject);
    end
    else
    begin
      clbChildModels.Enabled := False;
    end;
  end;
  if clbChildModels.Enabled then
  begin
    clbChildModels.Color := clWindow;
  end
  else
  begin
    clbChildModels.Color := clBtnFace;
  end;
  if IsLoaded and (rgElevationCount.ItemIndex >= 0) then
  begin
    ShowWarning := False;
    NewElevationCount:= TElevationCount(rgElevationCount.ItemIndex);

    UsedDataSets := TStringList.Create;
    try
      UsedDataSets.Sorted := True;
      UsedDataSets.Duplicates := dupIgnore;
      LocalCompiler := GetElevationCompiler;
      case rgElevationCount.ItemIndex of
        0: ;  // do nothing
        1:
          begin
            TempFormula := edZ.Text;
            if TempFormula <> '' then
            begin
              try
                LocalCompiler.Compile(TempFormula);
                UsedDataSets.AddStrings(LocalCompiler.CurrentExpression.VariablesUsed);
              except on ERbwParserError do
                begin
                  // do nothing
                end;
              end;
            end;
          end;
        2:
          begin
            TempFormula := edHighZ.Text;
            if TempFormula <> '' then
            begin
              try
                LocalCompiler.Compile(TempFormula);
                UsedDataSets.AddStrings(LocalCompiler.CurrentExpression.VariablesUsed);
              except on ERbwParserError do
                begin
                  // do nothing
                end;
              end;
            end;
            TempFormula := edLowZ.Text;
            if TempFormula <> '' then
            begin
              try
                LocalCompiler.Compile(TempFormula);
                UsedDataSets.AddStrings(LocalCompiler.CurrentExpression.VariablesUsed);
              except on ERbwParserError do
                begin
                  // do nothing
                end;
              end;
            end;
          end;
      end;
      for Index := 0 to UsedDataSets.Count - 1 do
      begin
        DataArray := frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(UsedDataSets[Index]);
        UsedDataSets.Objects[Index] := DataArray;
      end;
      Index := 0;
      UsedDataSets.Sorted := False;
      DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
      while Index < UsedDataSets.Count do
      begin
        DataArray := UsedDataSets.Objects[Index] as TDataArray;
        for DSIndex := 0 to DataArrayManager.DataSetCount - 1 do
        begin
          AnotherDataArray := DataArrayManager.DataSets[DSIndex];
          if UsedDataSets.IndexOfObject(AnotherDataArray) < 0 then
          begin
            if not AnotherDataArray.Visible then
            begin
              UsedDataSets.AddObject(AnotherDataArray.Name, AnotherDataArray);
            end
            else if AnotherDataArray is TCustomSparseDataSet then
            begin
              UsedDataSets.AddObject(AnotherDataArray.Name, AnotherDataArray);
            end
            else if DataArray.IsListeningTo(AnotherDataArray) then
            begin
              UsedDataSets.AddObject(AnotherDataArray.Name, AnotherDataArray);
            end;
          end;
        end;
        Inc(Index);
      end;
      for Index := 0 to FDataEdits.Count - 1 do
      begin
        DataEdit := FDataEdits[Index];
        if UsedDataSets.IndexOfObject(DataEdit.DataArray) >= 0 then
        begin
          DataEdit.Used := cbUnchecked;
          ShowWarning := True;
        end;
      end;
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties.Items[Index];
        Item.ScreenObject.ElevationCount := NewElevationCount;
      end;
    finally
      UsedDataSets.Free;
    end;
    if ShowWarning then
    begin
      Beep;
      if FNewProperties.Count = 1 then
      begin
        MessageDlg(StrThisObjectWillNo, mtWarning, [mbOK], 0);
      end
      else
      begin
        MessageDlg(StrTheseObjectsWillN, mtWarning, [mbOK], 0);
      end;

    end;
    case rgElevationCount.ItemIndex of
      0:
        begin
        end;
      1:
        begin
          edZExit(edZ);
        end;
      2:
        begin
          edHighZExit(edHighZ);
          edLowZExit(edLowZ);
        end;
      else
      begin
        if edHighZ.Enabled then
        begin
          edZExit(edZ);
        end;
        if edHighZ.Enabled then
        begin
          edHighZExit(edHighZ);
          edLowZExit(edLowZ);
        end;
      end;
    end;
  end;

  if (rgElevationCount.ItemIndex > 0)
    and (clbChildModels.CheckedIndex > 0) then
  begin
    clbChildModels.CheckedIndex := 0;
    clbChildModelsClickCheck(clbChildModels);
  end;

  FPriorElevationCount := rgElevationCount.ItemIndex;

  AScreenObject := nil;
  if FScreenObject <> nil then
  begin
    AScreenObject := FScreenObject;
  end
  else
  begin
    if (FScreenObjectList <> nil) and (FScreenObjectList.Count = 1) then
    begin
      AScreenObject := FScreenObjectList[0];
    end;
  end;
  CreateSutraFeatureNodes(AScreenObject);


  SetSelectedSutraBoundaryNode;

  if rgElevationCount.ItemIndex > 0 then
  begin
    cbInterpolation.Enabled := False;
    if cbInterpolation.Checked then
    begin
      cbInterpolation.Checked := False;
      cbInterpolationClick(nil);
    end;
  end
  else
  begin
    cbInterpolation.Enabled := True;
  end;
  EnableModpathObjectChoice;

end;

procedure TfrmScreenObjectProperties.cbSetGridCellSizeClick(Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  rdeGridCellSize.Enabled := cbSetGridCellSize.Checked;
  lblGridCellSize.Enabled := cbSetGridCellSize.Checked;
  EmphasizeValueChoices;
  if IsLoaded then
  begin
    DisableAllowGrayed(cbSetGridCellSize);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CellSizeUsed := cbSetGridCellSize.Checked;
    end;
    if cbSetGridCellSize.Checked then
    begin
      rdeGridCellSizeExit(nil);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.cbUzfGage1Click(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FUZF_Node);
  cbUzfGage2.Enabled := cbUzfGage1.Checked;
  cbUzfGage1.AllowGrayed := False;
  StoreUzfBoundary
end;

procedure TfrmScreenObjectProperties.cbUzfGage2Click(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FUZF_Node);
  cbUzfGage2.AllowGrayed := False;
  StoreUzfBoundary
end;

procedure TfrmScreenObjectProperties.cbUzfGage3Click(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FUZF_Node);
  cbUzfGage3.AllowGrayed := False;
  StoreUzfBoundary
end;

procedure TfrmScreenObjectProperties.cbVertexLabelVisibleClick(Sender: TObject);
begin
  inherited;
  cbVertexLabelVisible.AllowGrayed := False;
end;

procedure TfrmScreenObjectProperties.SetCheckBoxCaptions;
var
  NodeElemString: string;
begin
  if rgEvaluatedAt.ItemIndex >= 0 then
  begin
    NodeElemString := EvalAtToString(TEvaluatedAt(rgEvaluatedAt.ItemIndex),
         frmGoPhast.ModelSelection, True, False);
  end
  else
  begin
    NodeElemString := 'node or element';
  end;
  cbEnclosedCells.Caption := rsSetValueOfEnclosed + NodeElemString;
  cbIntersectedCells.Caption := rsSetValueOfIntersected + NodeElemString;
  cbInterpolation.Caption := rsSetValueOf + NodeElemString + rsByInterpolation;
  cbDuplicatesAllowed.Caption := Format(StrDuplicateSAllowed, [NodeElemString]);
  case frmGoPhast.ModelSelection of
    msUndefined, msPhast:
      begin
        cbSetGridCellSize.Caption := StrUseToSetGridElem;
        lblGridCellSize.Caption := StrGridElementSize;
      end;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflow2015, msModflowOwhm2:
      begin
        cbSetGridCellSize.Caption := StrUseToSetGridCell;
        lblGridCellSize.Caption := StrGridCellSize;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        cbSetGridCellSize.Caption := StrUseToSetMeshElem;
        lblGridCellSize.Caption := StrMeshElementSize;
      end;
    else Assert(False);
  end;
end;

procedure TfrmScreenObjectProperties.rgEvaluatedAtClick(Sender: TObject);
var
  Item: TScreenObjectEditItem;
  NewEvaluatedAt: TEvaluatedAt;
  ItemIndex, RowIndex: Integer;
  DataArray: TDataArray;
  List: TList;
  Edit: TScreenObjectDataEdit;
  AScreenObject: TScreenObject;
begin
  inherited;
  if FFillingDataSetTreeView then Exit;
  if FScreenObject <> nil then
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      FillDataSetsTreeView(List);
    finally
      List.Free;
    end;
  end
  else
  begin
    FillDataSetsTreeView(FScreenObjectList);
  end;

  SetCheckBoxCaptions;

  if edZ.Enabled then
  begin
    edZ.OnExit(edZ);
  end;
  if edHighZ.Enabled then
  begin
    edHighZ.OnExit(edHighZ);
  end;
  if edLowZ.Enabled then
  begin
    edLowZ.OnExit(edLowZ);
  end;

  if IsLoaded and (rgEvaluatedAt.ItemIndex >= 0) then
  begin
    NewEvaluatedAt := TEvaluatedAt(rgEvaluatedAt.ItemIndex);
    if (NewEvaluatedAt = eaBlocks) then
    begin
      pcPhastBoundaries.ActivePageIndex := Ord(btNone);
    end
    else
    begin
      rgBoundaryTypeClick(nil);
    end;
    for RowIndex := 0 to FDataEdits.Count - 1 do
    begin
      Edit := FDataEdits[RowIndex];
      DataArray := Edit.DataArray;
      if DataArray.EvaluatedAt <> NewEvaluatedAt then
      begin
        Edit.Used := cbUnchecked;
      end;
      if Edit.Used <> cbUnchecked then
      begin
        if Edit.Expression = nil then
        begin
          CreateFormula(RowIndex, Edit.Formula);
        end;
      end;
    end;
    for ItemIndex := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[ItemIndex];
      Item.ScreenObject.EvaluatedAt := NewEvaluatedAt;
      if NewEvaluatedAt = eaBlocks then
      begin
        Item.ScreenObject.SpecifiedHeadBoundary.Clear;
        Item.ScreenObject.LeakyBoundary.Clear;
        Item.ScreenObject.RiverBoundary.Clear;
        Item.ScreenObject.WellBoundary.Clear;
        Item.ScreenObject.FluxBoundary.Clear;
      end;
    end;
  end;
  ShowOrHideTabs;
  AScreenObject := nil;
  if FScreenObject <> nil then
  begin
    AScreenObject := FScreenObject;
  end
  else
  begin
    if (FScreenObjectList <> nil) and (FScreenObjectList.Count = 1) then
    begin
      AScreenObject := FScreenObjectList[0];
    end;
  end;
  CreateSutraFeatureNodes(AScreenObject);
  SetSelectedSutraBoundaryNode;
end;

procedure TfrmScreenObjectProperties.AssignPhastInterpolation(DataArray: TDataArray);
var
  Index: Integer;
  ScreenItem: TScreenObjectEditItem;
  InterpValues: TInterpValuesCollection;
  Item: TInterpValuesItem;
  NewDistance: Extended;
  NewValue: Extended;
begin
  if IsLoaded and (DataArray is TCustomPhastDataSet) then
  begin
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      ScreenItem := FNewProperties[Index];
      InterpValues := ScreenItem.ScreenObject.InterpValues;
      Item := InterpValues.ItemOfDataSet[DataArray];
      if Item = nil then
      begin
        Item := InterpValues.Add as TInterpValuesItem;
        Item.Values.Assign(DataArray);
      end;
      case framePhastInterpolationData.cbPhastInterpolation.State of
        cbUnchecked: Item.Values.UsePHAST_Interpolation := False;
        cbChecked: Item.Values.UsePHAST_Interpolation := True;
        cbGrayed: ; // do nothing
        else Assert(False);
      end;
      if Item.Values.UsePHAST_Interpolation then
      begin
        if (framePhastInterpolationData.rgInterpolationDirection.ItemIndex >= 0)
          and framePhastInterpolationData.rgInterpolationDirection.Enabled then
        begin
          Item.Values.InterpolationDirection := TInterpolationDirection(
            framePhastInterpolationData.rgInterpolationDirection.ItemIndex);
        end;
        if (framePhastInterpolationData.rdeDistance1.Text <> '') and
          framePhastInterpolationData.rdeDistance1.Enabled and
          TryStrToFloat(framePhastInterpolationData.rdeDistance1.Text,
          NewDistance) then
        begin
          Item.Values.Distance1 := NewDistance;
        end;
        if (framePhastInterpolationData.rdeDistance2.Text <> '') and
          framePhastInterpolationData.rdeDistance2.Enabled and
          TryStrToFloat(framePhastInterpolationData.rdeDistance2.Text,
          NewDistance) then
        begin
          Item.Values.Distance2 := NewDistance;
        end;
        if (framePhastInterpolationData.rdeValue1.Text <> '') and
          framePhastInterpolationData.rdeValue1.Enabled and
          TryStrToFloat(framePhastInterpolationData.rdeValue1.Text,
          NewValue) then
        begin
          Item.Values.RealValue1 := NewValue;
          Item.Values.IntValue1 := Round(NewValue);
        end;
        if (framePhastInterpolationData.rdeValue2.Text <> '') and
          framePhastInterpolationData.rdeValue2.Enabled and
          TryStrToFloat(framePhastInterpolationData.rdeValue2.Text,
          NewValue) then
        begin
          Item.Values.RealValue2 := NewValue;
          Item.Values.IntValue2 := Round(NewValue);
        end;
        if (framePhastInterpolationData.edMixFormula.Text <> '')
          and (Item.Values.InterpolationDirection = pidMix) then
        begin
          Item.Values.MixtureExpression :=
            framePhastInterpolationData.edMixFormula.Text;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationDatacbPhastInterpolationClick(Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
begin
  inherited;
    // respond to the user activating or deactivating PHAST-style interpolation for a
    // data set.
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  framePhastInterpolationData.cbPhastInterpolationClick(Sender);

  if IsLoaded and not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    FCurrentEdit.Invalidate;

    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      Item.Values.UsePHAST_Interpolation :=
        framePhastInterpolationData.cbPhastInterpolation.Checked;
    end;

    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.framePhastInterpolationDatardeDistance1Exit(
  Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
begin
  inherited;
    // respond to the user having finished editing the
    // PHAST-Interpolation distance 1
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  if not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    FCurrentEdit.Invalidate;

    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      Item.Values.Distance1 :=
        StrToFloat(framePhastInterpolationData.rdeDistance1.Text);
    end;
    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.framePhastInterpolationDatardeDistance2Exit(
  Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
begin
  inherited;
    // respond to the user having finished editing the
    // PHAST-Interpolation distance 2
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  if not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    FCurrentEdit.Invalidate;

    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      Item.Values.Distance2 :=
        StrToFloat(framePhastInterpolationData.rdeDistance2.Text);
    end;
    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.framePhastInterpolationDatardeValue1Exit(
  Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
begin
  inherited;
    // respond to the user having finished editing the
    // PHAST-Interpolation value 1
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  if not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    FCurrentEdit.Invalidate;
    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      if framePhastInterpolationData.rdeValue1.DataType = dtReal then
      begin
        Item.Values.RealValue1 :=
          StrToFloat(framePhastInterpolationData.rdeValue1.Text);
      end
      else if framePhastInterpolationData.rdeValue1.DataType = dtInteger then
      begin
        Item.Values.IntValue1 :=
          StrToInt(framePhastInterpolationData.rdeValue1.Text);
      end
      else
      begin
        Assert(False);
      end;
    end;
    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.framePhastInterpolationDatardeValue2Exit(
  Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
begin
  inherited;
    // respond to the user having finished editing the
    // PHAST-Interpolation value 2
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  if not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    FCurrentEdit.Invalidate;

    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      if framePhastInterpolationData.rdeValue2.DataType = dtReal then
      begin
        Item.Values.RealValue2 :=
          StrToFloat(framePhastInterpolationData.rdeValue2.Text);
      end
      else if framePhastInterpolationData.rdeValue2.DataType = dtInteger then
      begin
        Item.Values.IntValue2 :=
          StrToInt(framePhastInterpolationData.rdeValue2.Text);
      end
      else
      begin
        Assert(False);
      end;
    end;
    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationDatargInterpolationDirectionClick(Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
begin
  inherited;
    // respond to the user editing the PHAST-Interpolation
    // interpolation direction
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  framePhastInterpolationData.rgInterpolationDirectionClick(Sender);
  if not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    FCurrentEdit.Invalidate;
    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      Item.Values.InterpolationDirection
        := TInterpolationDirection(framePhastInterpolationData.
        rgInterpolationDirection.ItemIndex);
    end;
    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.frameRchParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FRCH_Node);
  frameRchParam.clbParametersStateChange(Sender, Index);
  StoreRchBoundary;
end;

procedure TfrmScreenObjectProperties.frameRchParamcomboFormulaInterpChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FRCH_Node);
  StoreRchBoundary;
end;

procedure TfrmScreenObjectProperties.frameRchParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreRchBoundary;
end;

procedure TfrmScreenObjectProperties.frameRchParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreRchBoundary;
end;

procedure TfrmScreenObjectProperties.frameRchParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FRCH_Node);
  frameRchParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateRchBoundary;
    StartParamCol := Item.ScreenObject.ModflowRchBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameRchParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameRchParam.rdgModflowBoundary.DistributingText then
  begin
    StoreRchBoundary;  
  end;
end;

procedure TfrmScreenObjectProperties.frameRchParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
  function IsMultiplierColumn(ACol: Integer): Boolean;
  const
    MultiplierPosition = 1;
    FirstMultiplierCol = 3;
    NonGWTProperties = 2;
    FirstDataColumn = 2;
  var
    DataColumnCount: Integer;
    DC: Integer;
  begin
    result := (ACol >= FirstMultiplierCol);
    if result then
    begin
      DataColumnCount := NonGWTProperties;
      if frmGoPhast.PhastModel.GwtUsed then
      begin
        Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
      end;
      DC := ACol-FirstDataColumn;
      result := ((DC mod DataColumnCount) = MultiplierPosition);
    end;
  end;
begin
  inherited;
  frameRchParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if CanSelect and IsMultiplierColumn(ACol) then
  begin
    if (frmGoPhast.ModelSelection = msModflow2015) then
    begin
      CanSelect := frmGoPhast.PhastModel.ModflowPackages.RchPackage.UseMultiplier;
    end
    else
    begin
      CanSelect := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameRchParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameRchParam.seNumberOfTimesChange(Sender);
  StoreRchBoundary;
end;

procedure TfrmScreenObjectProperties.frameResdgModflowBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  Orientation: TDataSetOrientation;
  DataGrid: TRbwDataGrid4;
  EvaluatedAt: TEvaluatedAt;
  NewValue: string;
begin
  inherited;
  DataGrid := Sender as TRbwDataGrid4;
  // Lakes and reservoirs can only be specified from the top.
  Orientation := dsoTop;
  // All the MODFLOW boundary conditions are evaluated at blocks.
  EvaluatedAt := eaBlocks;

  NewValue := DataGrid.Cells[ACol, ARow];
  if (NewValue = '') then
  begin
    NewValue := '0';
  end;

//  with TfrmFormula.Create(self) do
  with frmFormula do
  begin
    try
      Initialize;
      // GIS functions are not included and
      // Data sets are not included
      // because the variables will be evaluated for screen objects and
      // not at specific locations.

      PopupParent := self;

      // Show the functions and global variables.
      IncludeTimeSeries := GetModflow6TimeSeriesAllowed(DataGrid, ACol);
      if tabDynamicTimeSeries.TabVisible then
      begin
        DynamicTimesSeriesNames := frameDynamicTimeSeries. DynamicTimeSeriesNames
      end
      else
      begin
        DynamicTimesSeriesNames.Clear;
      end;
      UpdateTreeList;

      // put the formula in the TfrmFormula.
      Formula := NewValue;
      // The user edits the formula.
      ShowModal;
      if ResultSet then
      begin
        try
          CreateBoundaryFormula(DataGrid, ACol, ARow, Formula, Orientation,
            EvaluatedAt);
        except on E: Exception do
          begin
            Beep;
            MessageDlg(Format(StrErrorIn0sRow,
              [StrReservoirPackage,
              ARow + 1, ACol+1, E.Message]), mtError,[mbOK], 0);
            Exit;
          end;
        end;
      end;
    finally
      Initialize;
//      Free;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameResdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreResBoundary;
end;

procedure TfrmScreenObjectProperties.frameResdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FRES_Node);
  frameRes.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameRes.rdgModflowBoundary.DistributingText then
  begin
    StoreResBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameResseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameRes.seNumberOfTimesChange(Sender);
  StoreResBoundary;
end;

procedure TfrmScreenObjectProperties.frameRivParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FRIV_Node);
  frameRivParam.clbParametersStateChange(Sender, Index);
  StoreRivBoundary;
end;

procedure TfrmScreenObjectProperties.frameRivParamcomboFormulaInterpChange(
  Sender: TObject);
var
  Item: TScreenObjectEditItem;
begin
  inherited;
  UpdateNodeState(FRIV_Node);
  StoreRivBoundary;
  Item := FNewProperties[0];
  AssignConductanceCaptions(frameRivParam, Item.ScreenObject.ModflowRivBoundary);
end;

procedure TfrmScreenObjectProperties.frameRivParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreRivBoundary;
end;

procedure TfrmScreenObjectProperties.frameRivParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreRivBoundary;
end;

procedure TfrmScreenObjectProperties.frameRivParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FRIV_Node);
  frameRivParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateRivBoundary;
    StartParamCol := Item.ScreenObject.ModflowRivBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameRivParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameRivParam.rdgModflowBoundary.DistributingText then
  begin
    StoreRivBoundary;  
  end;
end;

procedure TfrmScreenObjectProperties.frameRivParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
  function IsMultiplierColumn(ACol: Integer): Boolean;
  const
    MultiplierPosition = 3;
    FirstMultiplierCol = 5;
    NonGWTProperties = 4;
    FirstDataColumn = 2;
  var
    DataColumnCount: Integer;
    DC: Integer;
  begin
    result := (ACol >= FirstMultiplierCol);
    if result then
    begin
      DataColumnCount := NonGWTProperties;
      if frmGoPhast.PhastModel.GwtUsed then
      begin
        Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
      end;
      DC := ACol-FirstDataColumn;
      result := ((DC mod DataColumnCount) = MultiplierPosition);
    end;
  end;
begin
  inherited;
  frameRivParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if CanSelect and IsMultiplierColumn(ACol) then
  begin
    if (frmGoPhast.ModelSelection = msModflow2015) then
    begin
      CanSelect := frmGoPhast.PhastModel.ModflowPackages.RivPackage.UseMultiplier;
    end
    else
    begin
      CanSelect := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameRivParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameRivParam.seNumberOfTimesChange(Sender);
  StoreRivBoundary;
end;

procedure TfrmScreenObjectProperties.frameFarmWellclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FFarmWell_Node);
  frameFarmWell.clbParametersStateChange(Sender, Index);
  StoreFarmWell;
end;

procedure TfrmScreenObjectProperties.frameFarmWellcomboFormulaInterpChange(
  Sender: TObject);
var
  Item: TScreenObjectEditItem;
begin
  inherited;
  UpdateNodeState(FFarmWell_Node);
  StoreFarmWell;
  Item := FNewProperties[0];
  AssignConductanceCaptions(frameFarmWell, Item.ScreenObject.ModflowFmpWellBoundary);
end;

procedure TfrmScreenObjectProperties.frameFarmWelldgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreFarmWell;
end;

procedure TfrmScreenObjectProperties.frameFarmWelldgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FFarmWell_Node);
  frameFarmWell.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateWelBoundary;
    StartParamCol := Item.ScreenObject.ModflowFmpWellBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameFarmWell, StartParamCol, ACol, ARow,Value);
  end;

  if not frameFarmWell.rdgModflowBoundary.DistributingText then
  begin
    StoreFarmWell;
  end;
end;

procedure TfrmScreenObjectProperties.frameFarmWellseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameFarmWell.seNumberOfTimesChange(Sender);
  StoreFarmWell;
end;

procedure TfrmScreenObjectProperties.frameFlowTable1btnDeleteFlowTableRowClick(
  Sender: TObject);
begin
  inherited;
  frameScreenObjectSFR.frameFlowTable1btnDeleteFlowTableRowClick(Sender);

end;

procedure TfrmScreenObjectProperties.frameFlowTable1btnInsertFlowTableRowClick(
  Sender: TObject);
begin
  inherited;
  frameScreenObjectSFR.frameFlowTable1btnInsertFlowTableRowClick(Sender);

end;

procedure TfrmScreenObjectProperties.frameFlowTable1dgSfrTableSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameScreenObjectSFR.frameFlowTable1.dgSfrTableSetEditText(Sender, ACol,
    ARow, Value);

end;

procedure TfrmScreenObjectProperties.frameFlowTable1seTableCountChange(
  Sender: TObject);
begin
  inherited;
  frameScreenObjectSFR.frameFlowTable1seTableCountChange(Sender);

end;

procedure TfrmScreenObjectProperties.frameFluxObsbtnAddOrRemoveFluxObservationsClick(
  Sender: TObject);
var
  List: TList;
begin
  inherited;
//  frmGoPhast.miManageFluxObservationsClick(nil);
  ShowAForm(TfrmManageFluxObservations);
  if FScreenObject = nil then
  begin
    GetFluxObservations(FScreenObjectList);
  end
  else
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      GetFluxObservations(List);
    finally
      List.Free;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameFmp4EfficiencyrdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameFmp4Efficiency.rdgModflowBoundarySetEditText(Sender, ACol, ARow,
    Value);

end;

procedure TfrmScreenObjectProperties.frameFmp4EfficiencyseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameFmp4Efficiency.seNumberOfTimesChange(Sender);

end;

procedure TfrmScreenObjectProperties.frameRVOBrdgObservationGroupsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    FRvob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameRVOBrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if IsLoaded then
  begin
    FRvob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameScreenObjectSFRdgFlowTimesSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameScreenObjectSFR.dgFlowTimesSetEditText(Sender, ACol, ARow, Value);

end;

procedure TfrmScreenObjectProperties.frameScreenObjectSFRjceButtonClick(
  Sender: TObject);
var
  FunctionString: string;
  ed: TJvComboEdit;
  VariableList: TList;
  VarIndex, Index: integer;
  Variable: TCustomValue;
  Compiler: TRbwParser;
  CompiledFormula: TExpression;
  AVar: TCustomValue;
  DataArrayManager: TDataArrayManager;
  DataArray: TDataArray;
  PestParamOK: Boolean;
  Param: TModflowSteadyParameter;
begin
{ TODO : See if some of this can be combined with ValidateEdFormula. }

  inherited;
  DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
  // edit the formula that is not part of a data set or boundary data set.
  ed := Sender as TJvComboEdit;

  { Support PEST here }
  PestParamOK := False;
  if (ed = frameMAW.edWellRadius)
    or (ed = frameMAW.edBottom)
    or (ed = frameMAW.edStartingHead)
    or (ed = frameMAW.edStartingHead)
    or (ed = frameLakMf6.edStartingStage)
    or (ed = frameMNW2.edWellRadius)
    or (ed = frameMNW2.edSkinRadius)
    or (ed = frameMNW2.edKSkin)
    or (ed = frameMNW2.edBCoefficient)
    or (ed = frameMNW2.edCCoefficient)
    or (ed = frameMNW2.edPCoefficient)
    or (ed = frameMNW2.edCellToWellConductance)
    or (ed = frameMNW2.edPartialPenetration)
    or (ed = frameScreenObjectSFR.jvcReachLength)
    or (ed = frameScreenObjectSFR.jceStreamTop)
    or (ed = frameScreenObjectSFR.jceSlope)
    or (ed = frameScreenObjectSFR.jceStreambedThickness)
    or (ed = frameScreenObjectSFR.jceStreambedK)
    or (ed = frameScreenObjectSFR.jceSaturatedVolumetricWater)
    or (ed = frameScreenObjectSFR.jceInitialVolumetricWater)
    or (ed = frameScreenObjectSFR.jceBrooksCoreyExponent)
    or (ed = frameScreenObjectSFR.jceMaxUnsaturatedKz)
    or (ed = frameScreenObjectSFR.jceSaturatedVolumetricWaterUpstream)
    or (ed = frameScreenObjectSFR.jceInitialVolumetricWaterUpstream)
    or (ed = frameScreenObjectSFR.jceBrooksCoreyExponentUpstream)
    or (ed = frameScreenObjectSFR.jceMaxUnsaturatedKzUpstream)
    or (ed = frameScreenObjectSFR.jceSaturatedVolumetricWaterDownstream)
    or (ed = frameScreenObjectSFR.jceInitialVolumetricWaterDownstream)
    or (ed = frameScreenObjectSFR.jceBrooksCoreyExponentDownstream)
    or (ed = frameScreenObjectSFR.jceMaxUnsaturatedKzDownstream)
    then
  begin
    PestParamOK := True;
  end;

  FunctionString := ed.Text;
  if (FunctionString = '') then
  begin
    FunctionString := '0';
  end;

  if (Sender = frameMAW.edWellRadius) or (Sender = frameMAW.edBottom)
    or (Sender = frameMAW.edStartingHead) then
  begin
    Compiler := rparserTopFormulaElements;
  end
  else
  begin
    Compiler := rparserThreeDFormulaElements;
  end;

  VariableList := TList.Create;
  try
    for VarIndex := 0 to Compiler.VariableCount - 1 do
    begin
      AVar := Compiler.Variables[VarIndex];
      if frmGoPhast.PhastModel.GlobalVariables.IndexOfVariable(AVar.Name) < 0 then
      begin
        DataArray := DataArrayManager.GetDataSetByName(AVar.Name);
        if DataArray <> nil then
        begin
          if not DataArray.Visible then
          begin
            Continue;
          end;
          if DataArray is TCustomSparseDataSet then
          begin
            Continue;
          end;
        end;
        VariableList.Add(Compiler.Variables[VarIndex]);
      end;
    end;

//    with TfrmFormula.Create(nil) do
    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(eaBlocks);
        RemoveGetVCont;
        RemoveHufFunctions;
        PopupParent := self;

        if ed <> frameLakMf6.edStartingStage then
        begin
          for Index := 0 to VariableList.Count - 1 do
          begin
            Variable := VariableList[Index];
            rbFormulaParser.RegisterVariable(Variable);
          end;
        end;

        IncludeTimeSeries := False;
        UpdateTreeList;
        Formula := FunctionString;

        ShowModal;
        if ResultSet then
        begin
          FunctionString := Formula;
        end
        else
        begin
          if FunctionString = '' then
            FunctionString := '0';
        end;
      finally
        Initialize;
//        Free;
      end;
    end;

    try
      Compiler.Compile(FunctionString);
    except on E: ErbwParserError do
      begin
        Beep;
        MessageDlg(Format(StrErrorInFormulaS, [E.Message]), mtError, [mbOK], 0);
        Exit;
      end
    end;

    if PestParamOK then
    begin
      Param := frmGoPhast.PhastModel.GetPestParameterByName(FunctionString);
      PestParamOK := (Param <> nil);
    end;

    CompiledFormula := Compiler.CurrentExpression;
    // check that the formula is OK.
    if (not PestParamOK) and
      (not (CompiledFormula.ResultType in [rdtDouble, rdtInteger])) then
    begin
      ed.Color := clRed;
      Beep;
      MessageDlg(StrErrorTheFormulaI, mtError, [mbOK], 0);
      Exit;
    end
    else
    begin
      ed.Color := clWindow;
      FunctionString := CompiledFormula.DecompileDisplay;
      if FunctionString <> ed.Text then
      begin
        ed.Text := FunctionString;
        if Assigned(ed.OnChange) then
        begin
          ed.OnChange(ed);
        end;
        if Assigned(ed.OnExit) then
        begin
          ed.OnExit(ed);
        end;
      end;
    end
  finally
    VariableList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.frameScreenObjectSFRpcSFRChange(
  Sender: TObject);
begin
  inherited;
  HelpKeyword := frameScreenObjectSFR.pcSFR.ActivePage.HelpKeyword;
  btnHelp.HelpKeyword := HelpKeyWord;
end;

procedure TfrmScreenObjectProperties.frameScreenObjectSFRrdgNetworkButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  NetworkColumn: TSfrNetworkColumns;  
  NewText: string;
begin
  inherited;
  NewText := '';
  NetworkColumn := TSfrNetworkColumns(ACol);
  case NetworkColumn of
    sncOutflowSegment:
      begin
        GetNearestOutflowSegment(NewText, ptSFR);
      end;
    sncDiversionSegment:
      begin
        GetNearestDiversionSegment(NewText, ptSFR);
      end;
    else
      Assert(False);
  end;
  if NewText <> '' then
  begin
    frameScreenObjectSFR.rdgNetwork.Cells[ACol, ARow] := NewText;
  end;
end;

procedure TfrmScreenObjectProperties.frameScreenObjectSTRdgModflowBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  NetworkColumn: TStrTimeColumns;
  NewText: string;
begin
  inherited;

  NewText := '';
  NetworkColumn := TStrTimeColumns(ACol);
  case NetworkColumn of
    stcDownstreamSegment:
      begin
        GetNearestOutflowSegment(NewText, ptSTR);
      end;
    stcDiversionSegment:
      begin
        GetNearestDiversionSegment(NewText, ptSTR);
      end;
    else
      begin
        frameChdParamdgModflowBoundaryButtonClick(Sender, ACol, ARow);
      end;
  end;
  if NewText <> '' then
  begin
    frameScreenObjectSTR.rdgModflowBoundary.Cells[ACol, ARow] := NewText;
  end;

end;

procedure TfrmScreenObjectProperties.UpdateSfrNode(Sender: TObject);
begin
  UpdateNodeState(FSFR_Node);
end;

procedure TfrmScreenObjectProperties.UpdateSfr6Node(Sender: TObject);
begin
  UpdateNodeState(FSFR6_Node);
end;

procedure TfrmScreenObjectProperties.UpdateStrNode(Sender: TObject);
begin
  UpdateNodeState(FSTR_Node);
end;

procedure TfrmScreenObjectProperties.UpdateSutraStateObsNode(Sender: TObject);
begin
  UpdateNodeState(FSutraStateObsNode);
end;

procedure TfrmScreenObjectProperties.frameScreenObjectUZFdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreUzfBoundary;
end;

procedure TfrmScreenObjectProperties.frameScreenObjectUZFdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FUZF_Node);
  frameScreenObjectUZF.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameScreenObjectUZF.rdgModflowBoundary.DistributingText then
  begin
    StoreUzfBoundary
  end;
end;

procedure TfrmScreenObjectProperties.frameScreenObjectUZFseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameScreenObjectUZF.seNumberOfTimesChange(Sender);
  StoreUzfBoundary;
end;

procedure TfrmScreenObjectProperties.frameSTOBrdgObservationGroupsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    FStob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameSTOBrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if IsLoaded then
  begin
    FStob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.SubObsChanged(Sender: TObject);
begin
  if (FSubPestObs_Node <> nil) and (FSubPestObs_Node.StateIndex <> 3) then
  begin
    FSubPestObs_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.SutraBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  VariableList: TList;
  Orientation: TDataSetOrientation;
  DataGrid: TRbwDataGrid4;
  EvaluatedAt: TEvaluatedAt;
  Index: integer;
  DataSet: TDataArray;
  NewValue: string;
  Variable: TCustomValue;
  Edit: TScreenObjectDataEdit;
  DataArrayManager: TDataArrayManager;
begin
  inherited;
  DataGrid := Sender as TRbwDataGrid4;
  VariableList := TList.Create;
  // VariableList will hold a list of variables that can
  // be used in the function
  try
    Orientation := dso3D;
    // All the SUTRA boundary conditions are evaluated at nodes.
    EvaluatedAt := eaNodes;

    DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
    for Index := 0 to DataArrayManager.DataSetCount - 1 do
    begin
      DataSet := DataArrayManager.DataSets[Index];
      if not DataSet.Visible then
      begin
        Continue;
      end;
      if DataSet is TCustomSparseDataSet then
      begin
        Continue;
      end;
      if (EvaluatedAt = DataSet.EvaluatedAt) then
      begin
        if ((Orientation = dso3D)
          or (Orientation = DataSet.Orientation)) then
        begin
          Edit := FDataEdits[Index];
          // if the variable does not depend on the
          // data set whose formula is being edited
          // and it's orientation is OK, the variable
          // can be used in the formula.
          VariableList.Add(Edit.Variable);
        end;
      end;
    end;

    NewValue := DataGrid.Cells[ACol, ARow];
    if (NewValue = '') then
    begin
      if ACol = 1 then
      begin
        NewValue := 'True';
      end
      else
      begin
        NewValue := '0';
      end;
    end;

    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(eaNodes);
        RemoveGetVCont;
        RemoveHufFunctions;
        PopupParent := self;

        // register the appropriate variables with the
        // parser.
        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          rbFormulaParser.RegisterVariable(Variable);
        end;

        // show the variables and functions
        IncludeTimeSeries := False;
        UpdateTreeList;

        // put the formula in the TfrmFormula.
        Formula := NewValue;
        // The user edits the formula.
        ShowModal;
        if ResultSet and (ModalResult = mrOK) then
        begin
          try
            CreateBoundaryFormula(DataGrid, ACol, ARow, Formula, Orientation,
              EvaluatedAt);
          except on E: Exception do
            begin
              Beep;
              MessageDlg(Format(StrErrorIn0sRow,
                ['SUTRA boundary',
                ARow + 1, ACol+1, E.Message]), mtError,[mbOK], 0);
              Exit;
            end;
           end;
      end;
      finally
        Initialize;
//        Free;
      end;
    end;

  finally
    VariableList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.SwtObsChanged(Sender: TObject);
begin
  if (FSwtPestObs_Node <> nil) and (FSwtPestObs_Node.StateIndex <> 3) then
  begin
    FSwtPestObs_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.tabModflowBoundaryConditionsShow(
  Sender: TObject);
begin
  inherited;
  jvspCSUBShow(nil);
end;

procedure TfrmScreenObjectProperties.frameSutraSpecPresObsrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if (FSutraSpecPresObs_Node <> nil)
    and (FSutraSpecPresObs_Node.StateIndex <> 3) then
  begin
    FSutraSpecPresObs_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameSutraSpecUObsrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if (FSutraSpecConcObs_Node <> nil)
    and (FSutraSpecConcObs_Node.StateIndex <> 3) then
  begin
    FSutraSpecConcObs_Node.StateIndex := 2;
  end;

end;

procedure TfrmScreenObjectProperties.frameSutraGenFlowObsrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if (FSutraGenFlowObs_Node <> nil)
    and (FSutraGenFlowObs_Node.StateIndex <> 3) then
  begin
    FSutraGenFlowObs_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameSutraGenTransObsrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if (FSutraGenTransObs_Node <> nil)
    and (FSutraGenTransObs_Node.StateIndex <> 3) then
  begin
    FSutraGenTransObs_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameSutraObservationsbtnDeleteClick(
  Sender: TObject);
begin
  inherited;
  frameSutraObservations.btnDeleteClick(Sender);
end;

procedure TfrmScreenObjectProperties.frameSutraObservationsbtnInsertClick(
  Sender: TObject);
begin
  inherited;
  frameSutraObservations.btnInsertClick(Sender);
end;

procedure TfrmScreenObjectProperties.frameSutraObservationsedNameExit(
  Sender: TObject);
begin
  inherited;
  frameSutraObservations.edNameExit(Sender);
end;

procedure TfrmScreenObjectProperties.frameSutraUObsbtnAddOrRemoveFluxObservationsClick(
  Sender: TObject);
var
  List: TList;
begin
  inherited;
  ShowAForm(TfrmManageSutraBoundaryObservations);
  if FScreenObject = nil then
  begin
    GetSutraObservations(FScreenObjectList);
  end
  else
  begin
    List := TList.Create;
    try
      List.Add(FScreenObject);
      GetSutraObservations(List);
    finally
      List.Free;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameSutraSpecifiedFluidFlowObsrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if (FSutraSpecFluidFlowObs_Node <> nil)
    and (FSutraSpecFluidFlowObs_Node.StateIndex <> 3) then
  begin
    FSutraSpecFluidFlowObs_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameSwiObsGridSetEditText(Sender: TObject;
  ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameSwiObs.frameSwiObsGridSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FSWiObs_Node);
end;

procedure TfrmScreenObjectProperties.frameSwrdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FSWR_Reach_Node);
  frameSwrReach.frameSwrdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

end;

procedure TfrmScreenObjectProperties.frameSWR_DirectRunoffdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreSwrDirectRunoffBoundary;
end;

procedure TfrmScreenObjectProperties.frameSWR_DirectRunoffdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FSWR_DirectRunoff_Node);
  frameSWR_DirectRunoff.rdgModflowBoundarySetEditText(Sender, ACol, ARow,
    Value);
  if not frameSWR_DirectRunoff.rdgModflowBoundary.DistributingText then
  begin
    StoreSwrDirectRunoffBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameSWR_DirectRunoffseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameSWR_DirectRunoff.seNumberOfTimesChange(Sender);
  StoreSwrDirectRunoffBoundary;
end;

procedure TfrmScreenObjectProperties.frameSWR_EvapdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreSwrEvapBoundary
end;

procedure TfrmScreenObjectProperties.frameSWR_EvapdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;

  UpdateNodeState(FSWR_Evap_Node);
  frameSWR_Evap.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameSWR_Evap.rdgModflowBoundary.DistributingText then
  begin
    StoreSwrEvapBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameSWR_EvapseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameSWR_Evap.seNumberOfTimesChange(Sender);
  StoreSwrEvapBoundary
end;

procedure TfrmScreenObjectProperties.frameSWR_LatInflcomboFormulaInterpChange(
  Sender: TObject);
begin
  inherited;
  StoreSwrLatInflowBoundary;
end;

procedure TfrmScreenObjectProperties.frameSWR_LatInfldgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
 StoreSwrLatInflowBoundary;
end;

procedure TfrmScreenObjectProperties.frameSWR_LatInfldgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FSWR_LatInflow_Node);
  frameSWR_LatInfl.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameSWR_LatInfl.rdgModflowBoundary.DistributingText then
  begin
    StoreSwrLatInflowBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameSWR_LatInflseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameSWR_LatInfl.seNumberOfTimesChange(Sender);
  StoreSwrLatInflowBoundary
end;

procedure TfrmScreenObjectProperties.frameSWR_RaindgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreSwrRainBoundary
end;

procedure TfrmScreenObjectProperties.frameSWR_RaindgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FSWR_Rain_Node);
  frameSWR_Rain.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameSWR_Rain.rdgModflowBoundary.DistributingText then
  begin
    StoreSwrRainBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameSWR_RainseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameSWR_Rain.seNumberOfTimesChange(Sender);
  StoreSwrRainBoundary
end;

procedure TfrmScreenObjectProperties.frameSWR_StagedgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreSwrStageBoundary;
end;

procedure TfrmScreenObjectProperties.frameSWR_StagedgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FSWR_Stage_Node);
  frameSWR_Stage.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameSWR_Stage.rdgModflowBoundary.DistributingText then
  begin
    StoreSwrStageBoundary;
  end;

end;

procedure TfrmScreenObjectProperties.frameSWR_StageseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameSWR_Stage.seNumberOfTimesChange(Sender);
    StoreSwrStageBoundary;
end;

procedure TfrmScreenObjectProperties.frameWellParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateWellNodeState;
  frameWellParam.clbParametersStateChange(Sender, Index);
  StoreWellBoundary;
end;

procedure TfrmScreenObjectProperties.frameWellParamcomboFormulaInterpChange(
  Sender: TObject);
var
  Item: TScreenObjectEditItem;
begin
  inherited;
  UpdateWellNodeState;
  StoreWellBoundary;
  Item := FNewProperties[0];
  AssignConductanceCaptions(frameWellParam, Item.ScreenObject.ModflowWellBoundary);
end;

procedure TfrmScreenObjectProperties.frameWellParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreWellBoundary;
end;

procedure TfrmScreenObjectProperties.frameWellParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreWellBoundary;
end;

procedure TfrmScreenObjectProperties.UpdateWellNodeState;
begin
  UpdateNodeState(FWEL_Node);
  EnableWellTabfile;
end;

procedure TfrmScreenObjectProperties.UzfMf6Changed(Sender: TObject);
begin
  if (FUZF_Mf6_Node <> nil) and (FUZF_Mf6_Node.StateIndex <> 3) then
  begin
    FUZF_Mf6_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameWellParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateWellNodeState;
  frameWellParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateWelBoundary;
    StartParamCol := Item.ScreenObject.ModflowWellBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameWellParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameWellParam.rdgModflowBoundary.DistributingText then
  begin
    StoreWellBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameWellParamfedTabfileChange(
  Sender: TObject);
begin
  inherited;
  frameWellParam.fedTabfileChange(Sender);
  if IsLoaded then
  begin
    FWellTabFileChanged := True;
    StoreWellBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameWellParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
  function IsMultiplierColl(ACol: Integer): Boolean;
  const
    MultiplierPosition = 1;
    FirstMultiplierCol = 3;
    NonGWTProperties = 2;
    FirstDataColumn = 2;
  var
    DataColumnCount: Integer;
    DC: Integer;
  begin
//    result := Odd(ACol);
    result := (ACol >= FirstMultiplierCol);
    if result then
    begin
      DataColumnCount := NonGWTProperties;
      if frmGoPhast.PhastModel.GwtUsed then
      begin
        Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
      end;
      DC := ACol-FirstDataColumn;
      result := ((DC mod DataColumnCount) = MultiplierPosition);
    end;
  end;
begin
  inherited;
  frameWellParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if CanSelect then
  begin
    if (ACol >= 2) and IsMultiplierColl(ACol) then
    begin
      if frmGoPhast.ModelSelection = msModflow2015 then
      begin
        CanSelect := frmGoPhast.PhastModel.ModflowPackages.WelPackage.UseMultiplier;
      end
      else
      begin
        CanSelect := False;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameWellParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameWellParam.seNumberOfTimesChange(Sender);
  StoreWellBoundary;
end;

procedure TfrmScreenObjectProperties.frmgrdDiversionsGridButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  NewText: string;
begin
  inherited;
  NewText := '';
  Assert(ACol = 0);
  GetNearestOutflowSegment(NewText, ptUndefined);
  if NewText <> '' then
  begin
    frameScreenObjectSfr6.frmgrdDiversions.Grid.Cells[ACol, ARow] := NewText;
  end;

end;

procedure TfrmScreenObjectProperties.frmgrdDownstreamSegmentsGridButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  NewText: string;
begin
  inherited;
  NewText := '';
  Assert(ACol = 0);
  GetNearestOutflowSegment(NewText, ptUndefined);
  if NewText <> '' then
  begin
    frameScreenObjectSfr6.frmgrdDownstreamSegments.Grid.Cells[ACol, ARow] := NewText;
  end;
//
end;

procedure TfrmScreenObjectProperties.SelectBoundaryCell;
var
  DataGrid: TRbwDataGrid4;
  ColIndex, RowIndex: integer;
begin
  DataGrid := nil;
  case TPhastBoundaryTypes(rgBoundaryType.ItemIndex) of
    btSpecifiedHead:
      begin
        DataGrid := dgSpecifiedHead;
      end;
    btFlux:
      begin
        DataGrid := dgBoundaryFlux;
      end;
    btLeaky:
      begin
        DataGrid := dgBoundaryLeaky;
      end;
    btNone, btRiver, btWell:
      begin
        Exit;
      end;
  else
    if rgBoundaryType.ItemIndex < 0 then
    begin
      Exit;
    end;

    Assert(False);
  end;

  Assert(DataGrid <> nil);
  for RowIndex := 1 to DataGrid.RowCount - 1 do
  begin
    for ColIndex := 3 to DataGrid.ColCount - 1 do
    begin
      if DataGrid.Columns[ColIndex].Format = rcf4Boolean then
      begin
        if DataGrid.Checked[ColIndex, RowIndex] then
        begin
          DataGrid.Column := ColIndex;
          DataGrid.Row := RowIndex;
          DataGrid.OnStateChange(DataGrid, ColIndex, RowIndex, cbChecked);
          Exit;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.rgBoundaryTypeClick(Sender: TObject);
var
  ItemIndex: Integer;
  Item: TScreenObjectEditItem;
  NewBoundaryType: TPhastBoundaryTypes;
begin
  inherited;

  seBoundaryTimes.Enabled := rgBoundaryType.ItemIndex <> 0;
  if (rgBoundaryType.ItemIndex < 0)
    or (rgBoundaryType.ItemIndex = pcPhastBoundaries.ActivePageIndex) then
  begin
    Exit;
  end;

  pcPhastBoundaries.ActivePageIndex := rgBoundaryType.ItemIndex;

  gbBoundaryPhastInterpolation.Caption := '';
  framePhastInterpolationBoundaries.cbPhastInterpolation.Checked := False;
  SelectBoundaryCell;
  if IsLoaded and (rgBoundaryType.ItemIndex >= 0) then
  begin
    NewBoundaryType := TPhastBoundaryTypes(rgBoundaryType.ItemIndex);
    for ItemIndex := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[ItemIndex];
      if NewBoundaryType <> btSpecifiedHead then
      begin
        Item.ScreenObject.SpecifiedHeadBoundary.Clear;
      end;
      if NewBoundaryType <> btFlux then
      begin
        Item.ScreenObject.FluxBoundary.Clear;
      end;
      if NewBoundaryType <> btLeaky then
      begin
        Item.ScreenObject.LeakyBoundary.Clear;
      end;
      if NewBoundaryType <> btRiver then
      begin
        Item.ScreenObject.RiverBoundary.Clear;
      end;
      if NewBoundaryType <> btWell then
      begin
        Item.ScreenObject.WellBoundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.seBoundaryTimesChange(Sender: TObject);
begin
  inherited;
  FDeletingPhastTime := True;
  try
    case TPhastBoundaryTypes(pcPhastBoundaries.ActivePageIndex) of
      btNone:
        begin
          FBoundaryGrid := nil;
        end;
      btSpecifiedHead:
        begin
          FBoundaryGrid := dgSpecifiedHead;
        end;
      btFlux:
        begin
          FBoundaryGrid := dgBoundaryFlux;
        end;
      btLeaky:
        begin
          FBoundaryGrid := dgBoundaryLeaky;
        end;
      btRiver:
        begin
          FBoundaryGrid := dgBoundaryRiver;
        end;
      btWell:
        begin
          FBoundaryGrid := dgWell;
        end;
    else
      FBoundaryGrid := nil;
    end;
    if FBoundaryGrid <> nil then
    begin
      FBoundaryGrid.RowCount := seBoundaryTimes.AsInteger + 1;
    end;
    StorePhastBoundary;
  finally
    FDeletingPhastTime := False;
  end;
end;

procedure TfrmScreenObjectProperties.dgBoundarySelectCell(Sender: TObject;
  ACol, ARow: Integer; var CanSelect: Boolean);
var
  AnObject: TObject;
  InterpValuesCollection: TInterpValuesCollection;
  Item: TInterpValuesItem;
  Index: integer;
  AScreenObject: TScreenObject;
  MixtureAllowed: boolean;
begin
  inherited;
    // Show the PHAST-style Interpolation values when the user clicks on a cell
    // in a boundary.  (Not just river boundaries.)
  CanSelect := ((ACol <> 1) or (ARow <> 1)) and (ARow > 0);
  if (Sender = dgSpecifiedHead) or (Sender = dgBoundaryFlux)
    or (Sender = dgBoundaryLeaky) then
  begin
    If ACol in [2,4] then
    begin
      CanSelect := not (Sender as TRbwDataGrid4).Checked[ACol+1,ARow];
    end;
  end;

  if not IsLoaded or (Sender as TRbwDataGrid4).Drawing then
    Exit;
  AScreenObject := FScreenObject;
  if AScreenObject = nil then
  begin
    AScreenObject := FScreenObjectList[0];
  end;

  if not (Sender as TRbwDataGrid4).Drawing
    and not (csCreating in ControlState) then
  begin
    MixtureAllowed := False;
    if (ACol >= 2) and (ARow > 0) then
    begin
      FBoundaryGrid := Sender as TRbwDataGrid4;
      FBoundaryRow := ARow;
      if (Sender = dgBoundaryRiver) or (Sender = dgWell) or Odd(ACol) then
      begin
        FBoundaryCol := ACol;
      end
      else
      begin
        FBoundaryCol := ACol + 1;
      end;

      if (Sender = dgSpecifiedHead) or (Sender = dgBoundaryFlux)
        or (Sender = dgBoundaryLeaky) then
      begin
        framePhastInterpolationBoundaries.Enabled :=
          (Sender as TRbwDataGrid4).Checked[FBoundaryCol,ARow];
      end
      else
      begin
        framePhastInterpolationBoundaries.Enabled := False;
      end;
//      framePhastInterpolationBoundaries.cbPhastInterpolation.Checked :=
//        framePhastInterpolationBoundaries.Enabled;
//      framePhastInterpolationBoundaries.cbPhastInterpolationClick(nil);

      AnObject := FBoundaryGrid.Objects[ACol, ARow];
      if AnObject = nil then
      begin
        // create InterpValuesCollection if it hasn't already been created.
        InterpValuesCollection := TInterpValuesCollection.Create(nil);
        FBoundaryPhastInterpolationList.Add(InterpValuesCollection);
        FBoundaryGrid.Objects[ACol, ARow] := InterpValuesCollection;
        if Odd(ACol) then
        begin
          FBoundaryGrid.Objects[ACol - 1, ARow] := InterpValuesCollection;
        end
        else
        begin
          FBoundaryGrid.Objects[ACol + 1, ARow] := InterpValuesCollection;
        end;
      end
      else
      begin
        InterpValuesCollection := AnObject as TInterpValuesCollection;
      end;
      if InterpValuesCollection.Count = 0 then
      begin
        Item := InterpValuesCollection.Add as TInterpValuesItem;
        if FBoundaryGrid = dgSpecifiedHead then
        begin
          if FBoundaryCol = Ord(ibcBoundaryInterpolate) then
          begin
            Item.Values.Assign(AScreenObject.
              SpecifiedHeadBoundary.BoundaryValue.GetDataSet(0));
          end
          else if FBoundaryCol = Ord(ibcSolutionInterpolate) then
          begin
            Item.Values.Assign(AScreenObject.
              SpecifiedHeadBoundary.Solution.
              GetDataSet(0));
          end
          else
          begin
            Assert(False);
          end;
        end
        else if FBoundaryGrid = dgBoundaryFlux then
        begin
          if FBoundaryCol = Ord(ibcBoundaryInterpolate) then
          begin
            Item.Values.Assign(AScreenObject.FluxBoundary.BoundaryValue.GetDataSet(0));
          end
          else if FBoundaryCol = Ord(ibcSolutionInterpolate) then
          begin
            Item.Values.Assign(AScreenObject.
              FluxBoundary.Solution.GetDataSet(0));
          end
          else
          begin
            Assert(False);
          end;
        end
        else if FBoundaryGrid = dgBoundaryLeaky then
        begin
          if FBoundaryCol = Ord(ibcBoundaryInterpolate) then
          begin
            Item.Values.Assign(AScreenObject.LeakyBoundary.BoundaryValue.GetDataSet(0));
          end
          else if FBoundaryCol = Ord(ibcSolutionInterpolate) then
          begin
            Item.Values.Assign(AScreenObject.
              LeakyBoundary.Solution.GetDataSet(0));
          end
          else
          begin
            Assert(False);
          end;
        end
        else if FBoundaryGrid = dgBoundaryRiver then
        begin
          if FBoundaryCol = Ord(nicBoundaryValue) then
          begin
            Item.Values.Assign(AScreenObject.RiverBoundary.BoundaryValue.GetDataSet(0));
          end
          else if FBoundaryCol = Ord(nicSolution) then
          begin
            Item.Values.Assign(AScreenObject.
              RiverBoundary.Solution.GetDataSet(0));
          end
          else
          begin
            Assert(False);
          end;
        end
        else if FBoundaryGrid = dgWell then
        begin
          if FBoundaryCol = Ord(nicBoundaryValue) then
          begin
            Item.Values.Assign(AScreenObject.
              WellBoundary.BoundaryValue.GetDataSet(0));
          end
          else if FBoundaryCol = Ord(nicSolution) then
          begin
            Item.Values.Assign(AScreenObject.
              WellBoundary.Solution.GetDataSet(0));
          end
          else
          begin
            Assert(False);
          end;
        end
        else
        begin
          Assert(False)
        end;
      end;

      if FBoundaryGrid = dgSpecifiedHead then
      begin
        if FBoundaryCol = Ord(ibcBoundaryInterpolate) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrSpecifiedHead;
          MixtureAllowed := False;
        end
        else if FBoundaryCol = Ord(ibcSolutionInterpolate) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrSolution;
          MixtureAllowed := True;
        end
        else
        begin
          Assert(False);
        end;
      end
      else if FBoundaryGrid = dgBoundaryFlux then
      begin
        if FBoundaryCol = Ord(ibcBoundaryInterpolate) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrSpecifiedFlux;
          MixtureAllowed := False;
        end
        else if FBoundaryCol = Ord(ibcSolutionInterpolate) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrAssociatedSolution;
          MixtureAllowed := True;
        end
        else
        begin
          Assert(False);
        end;
      end
      else if FBoundaryGrid = dgBoundaryLeaky then
      begin
        if FBoundaryCol = Ord(ibcBoundaryInterpolate) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrLeakyBoundaryHead;
          MixtureAllowed := False;
        end
        else if FBoundaryCol = Ord(ibcSolutionInterpolate) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrAssociatedSolution;
          MixtureAllowed := True;
        end
        else
        begin
          Assert(False);
        end;
      end
      else if FBoundaryGrid = dgBoundaryRiver then
      begin
        if FBoundaryCol = Ord(nicBoundaryValue) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrRiver;
          MixtureAllowed := False;
        end
        else if FBoundaryCol = Ord(nicSolution) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrAssociatedSolution;
          MixtureAllowed := True;
        end
        else
        begin
          Assert(False);
        end;
      end
      else if FBoundaryGrid = dgWell then
      begin
        if FBoundaryCol = Ord(nicBoundaryValue) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrWellRate;
          MixtureAllowed := False;
        end
        else if FBoundaryCol = Ord(nicSolution) then
        begin
          gbBoundaryPhastInterpolation.Caption := StrSolution;
          MixtureAllowed := True;
        end
        else
        begin
          Assert(False);
        end;
      end
      else
      begin
        Assert(False)
      end;

      gbBoundaryPhastInterpolation.Caption
        := gbBoundaryPhastInterpolation.Caption + ' '
        + FBoundaryGrid.Cells[1, ARow];

      framePhastInterpolationData.AssigningValues := True;
      framePhastInterpolationBoundaries.GetFirstData((InterpValuesCollection.
        Items[0] as TInterpValuesItem).Values);
      framePhastInterpolationData.AssigningValues := False;
      for Index := 1 to InterpValuesCollection.Count - 1 do
      begin
        framePhastInterpolationData.AssigningValues := True;
        framePhastInterpolationBoundaries.GetMoreData((InterpValuesCollection.
          Items[Index] as TInterpValuesItem).Values);
        framePhastInterpolationData.AssigningValues := False;
      end;

      framePhastInterpolationBoundaries.SetMixtureAllowed(MixtureAllowed);
    end
    else
    begin
      framePhastInterpolationBoundaries.Enabled := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.dgBoundaryRiverDistributeTextProgress(
  Sender: TObject; Position, Max: Integer);
begin
  inherited;
  seBoundaryTimes.AsInteger := dgBoundaryRiver.RowCount -1;
  seBoundaryTimesChange(nil);
end;

procedure TfrmScreenObjectProperties.dgBoundaryRowMoving(Sender: TObject;
  const Origin, Destination: Integer; var CanMove: Boolean);
begin
  inherited;
  CanMove := (Origin <> 1) and (Destination <> 1);
end;

procedure TfrmScreenObjectProperties.dgBoundaryDrawCell(Sender: TObject;
  ACol, ARow: Integer; Rect: TRect; State: TGridDrawState);
begin
  inherited;
  if (ACol = 1) and (ARow = 1) then
  begin
    with Sender as TRbwDataGrid4 do
    begin
      Canvas.Brush.Color := FixedColor;
      Canvas.FillRect(Rect);
      Canvas.TextRect(Rect, Rect.Left + 2, Rect.Top + 2, Cells[ACol, ARow]);
    end;
  end;
  if (Sender = dgSpecifiedHead)
  or (Sender = dgBoundaryFlux) or (Sender = dgBoundaryLeaky) then
  begin
    if (ARow >= 1) and (ACol >= 2) and not Odd(ACol) then
    begin
      with Sender as TRbwDataGrid4 do
      begin
        if Checked[ACol + 1, ARow] then
        begin
          Canvas.Brush.Color := FixedColor;
          Canvas.FillRect(Rect);
          Canvas.TextRect(Rect, Rect.Left + 2, Rect.Top + 2, StrInterpolated);
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.dgBoundaryFluxDistributeTextProgress(
  Sender: TObject; Position, Max: Integer);
begin
  inherited;
  seBoundaryTimes.AsInteger := dgBoundaryFlux.RowCount -1;
  seBoundaryTimesChange(nil);
end;

procedure TfrmScreenObjectProperties.dgBoundaryLeakyDistributeTextProgress(
  Sender: TObject; Position, Max: Integer);
begin
  inherited;
  seBoundaryTimes.AsInteger := dgBoundaryLeaky.RowCount -1;
  seBoundaryTimesChange(nil);
end;

procedure TfrmScreenObjectProperties.pcPhastBoundariesChange(Sender: TObject);
begin
  inherited;
  case TPhastBoundaryTypes(pcPhastBoundaries.ActivePageIndex) of
    btNone:
      begin
        Exit;
      end;
    btSpecifiedHead:
      begin
        seBoundaryTimes.Value := dgSpecifiedHead.RowCount - 1;
      end;
    btFlux:
      begin
        seBoundaryTimes.Value := dgBoundaryFlux.RowCount - 1;
      end;
    btLeaky:
      begin
        seBoundaryTimes.Value := dgBoundaryLeaky.RowCount - 1;
      end;
    btRiver:
      begin
        seBoundaryTimes.Value := dgBoundaryRiver.RowCount - 1;
      end;
    btWell:
      begin
        seBoundaryTimes.Value := dgWell.RowCount - 1;
      end;
  else
    Assert(False);
  end;
end;

procedure TfrmScreenObjectProperties.seWellIntervalsChange(Sender: TObject);
begin
  inherited;
  if seWellIntervals.Value = 0 then
  begin
    seWellIntervals.Value := 1;
  end;

  dgWellElevations.RowCount := seWellIntervals.AsInteger + 1;
  StorePhastWellBoundary;
end;

procedure TfrmScreenObjectProperties.comboWellIntervalStyleChange(Sender:
  TObject);
begin
  inherited;
  case comboWellIntervalStyle.ItemIndex of
    -1:
      begin
        // Elevation
        dgWellElevations.Cells[Ord(wicFirst), 0] := StrFirstValue;
        dgWellElevations.Cells[Ord(wicSecond), 0] := StrSecondValue;
        rdeWellLandSurfaceDatum.Enabled := True;
      end;
    0:
      begin
        // Elevation
        dgWellElevations.Cells[Ord(wicFirst), 0] := StrFirstElevation;
        dgWellElevations.Cells[Ord(wicSecond), 0] := StrSecondElevation;
        rdeWellLandSurfaceDatum.Enabled := False;
      end;
    1:
      begin
        // Depth
        dgWellElevations.Cells[Ord(wicFirst), 0] := StrFirstDepth;
        dgWellElevations.Cells[Ord(wicSecond), 0] := StrSecondDepth;
        rdeWellLandSurfaceDatum.Enabled := True;
      end;
  else
    Assert(False);
  end;
  lblWellLandSurfaceDatum.Enabled := rdeWellLandSurfaceDatum.Enabled;
  StorePhastWellBoundary;
end;

procedure TfrmScreenObjectProperties.StoreGhbBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectCondParam;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  if IsLoaded then
  begin
    if (FGHB_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FGHB_Node <> nil);
    Frame := frameGhbParam;
    ParamType := ptGHB;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateGhbBoundary;
    end;
    StoreFormulaInterpretation(Frame, ParamType);
    StoreModflowBoundary(Frame, ParamType, FGHB_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FGHB_Node);
    StorePestModifiers(Frame, ParamType, FGHB_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreResBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TResBoundary;
begin
  if IsLoaded then
  begin
    if (FRES_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FRES_Node <> nil);
    Frame := frameRes;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateResBoundary;
      Boundary := Item.ScreenObject.ModflowResBoundary;
      if ShouldStoreBoundary(FRES_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
        if Frame.PestModifierAssigned[2] then
        begin
          Boundary.PestStartHeadFormula := Frame.PestModifier[2];
        end;
        if Frame.PestModifierAssigned[3] then
        begin
          Boundary.PestEndHeadFormula := Frame.PestModifier[3];
        end;
        if Frame.PestMethodAssigned[2] then
        begin
          Boundary.PestStartHeadMethod := Frame.PestMethod[2];
        end;
        if Frame.PestMethodAssigned[3] then
        begin
          Boundary.PestEndHeadMethod := Frame.PestMethod[3];
        end;
      end
      else if FRES_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreMt3dmsChemBoundary;
var
  Frame: TframeScreenObjectSsm;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TMt3dmsConcBoundary;
begin
  if IsLoaded then
  begin
    if (FMt3dmsSsm_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FMt3dmsSsm_Node <> nil);

    Frame := frameMT3DMS_SSM;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateMt3dmsConcBoundary;
      Boundary := Item.ScreenObject.Mt3dmsConcBoundary;
      Assert(Boundary <> nil);
      case Frame.cbSpecifiedConcentration.State of
        cbUnchecked: Boundary.SpecifiedConcBoundary := False;
        cbChecked: Boundary.SpecifiedConcBoundary := True;
        cbGrayed: ;  // do nothing;
        else Assert(False);
      end;
      case Frame.cbMassLoading.State of
        cbUnchecked: Boundary.MassLoadingBoundary := False;
        cbChecked: Boundary.MassLoadingBoundary := True;
        cbGrayed: ;  // do nothing;
        else Assert(False);
      end;
      if ShouldStoreBoundary(FMt3dmsSsm_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end
      else if  FMt3dmsSsm_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreMt3d_UztRechBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TMt3dUztRchConcBoundary;
begin
  if IsLoaded then
  begin
    if (FMt3d_UZT_Rech_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FMt3d_UZT_Rech_Node <> nil);

    Frame := frameMt3d_UZT_Rech;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateMt3dUzfRchConcBoundary;
      Boundary := Item.ScreenObject.Mt3dUzfRechConc;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(FMt3d_UZT_Rech_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end
      else if  FMt3d_UZT_Rech_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreMt3dUzfSeepageConcBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TMt3dUzSsmSinkConcBoundary;
begin
  if IsLoaded then
  begin
    if (FMt3d_Uzf_Seep_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FMt3d_Uzf_Seep_Node <> nil);

    Frame := frameMT3D_Uzf_Ssm_Conc;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateMt3dUzSsmSinkConcBoundary;
      Boundary := Item.ScreenObject.Mt3dUzSsmSinkConcBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(FMt3d_Uzf_Seep_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end
      else if  FMt3d_Uzf_Seep_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreMt3d_UztSatBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TMt3dUztSatEtConcBoundary;
begin
  if IsLoaded then
  begin
    if (FMt3d_UZT_Sat_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FMt3d_UZT_Sat_Node <> nil);

    Frame := frameMt3d_UZT_Sat;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateMt3dUztSatEtConcBoundary;
      Boundary := Item.ScreenObject.Mt3dUztSatEtConcBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(FMt3d_UZT_Sat_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end
      else if  FMt3d_UZT_Sat_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreMt3d_UztUnsatBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TMt3dUztUnsatEtConcBoundary;
begin
  if IsLoaded then
  begin
    if (FMt3d_UZT_Unsat_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FMt3d_UZT_Unsat_Node <> nil);

    Frame := frameMt3d_UZT_Unsat;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateMt3dUztUnsatEtConcBoundary;
      Boundary := Item.ScreenObject.Mt3dUztUnsatEtConcBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(FMt3d_UZT_Unsat_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end
      else if  FMt3d_UZT_Unsat_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreLakBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TLakBoundary;
  IntValue: Integer;
  RealValue: Extended;
  DataSetIndex: integer;
  DataArray: TDataArray;
  Edit: TScreenObjectDataEdit;
  ItemIndex: integer;
  Stage: double;
  Volume: double;
  SurfaceArea: double;
  ExternalLakeTable: TExternalLakeTable;
  BathItem: TLakeTableItem;
  ColumnOffset: Integer;
  BoundaryIndex: Integer;
begin
  if IsLoaded then
  begin
    Frame := frameLak;
    GetMF_BoundaryTimes(Times, Frame);
    ColumnOffset := 2;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateLakBoundary;
      Boundary := Item.ScreenObject.ModflowLakBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(FLAK_Node, Boundary) then
      begin
        for BoundaryIndex := LakMinimumStagePosition to LakWithdrawalPosition do
        begin
          if frameLak.PestModifierAssigned[BoundaryIndex + ColumnOffset] then
          begin
            Boundary.PestBoundaryFormula[BoundaryIndex] :=
              frameLak.PestModifier[BoundaryIndex + ColumnOffset];
          end;
          if frameLak.PestMethodAssigned[BoundaryIndex + ColumnOffset] then
          begin
            Boundary.PestBoundaryMethod[BoundaryIndex] :=
              frameLak.PestMethod[BoundaryIndex + ColumnOffset];
          end;
        end;

        StoreModflowBoundaryValues(Frame, Times, Boundary);
        if frameLak.cbGagStandard.State <> cbGrayed then
        begin
          Boundary.StandardGage := frameLak.cbGagStandard.Checked;
        end;
        if frameLak.cbGagFluxAndCond.State <> cbGrayed then
        begin
          Boundary.FluxCondGage := frameLak.cbGagFluxAndCond.Checked;
        end;
        if frameLak.cbGagDelta.State <> cbGrayed then
        begin
          Boundary.DeltaGage := frameLak.cbGagDelta.Checked;
        end;
        if frameLak.cbGage4.State <> cbGrayed then
        begin
          Boundary.Gage4 := frameLak.cbGage4.Checked;
        end;
        if FNewProperties.Count = 1 then
        begin
          frameLak.framePestObsLak.SetData(Boundary.Observations,
            Item.ScreenObject.Name);
        end;
      end
      else if  FLAK_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;

    DataSetIndex := self.GetDataSetIndexByName(rsLakeID);
    Edit := FDataEdits[DataSetIndex];
    DataArray := Edit.DataArray;
    if TryStrToInt(frameLak.rdeLakeID.Text, IntValue) then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Boundary := Item.ScreenObject.ModflowLakBoundary;
        Assert(Boundary <> nil);

        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          Boundary.LakeID := IntValue;
        end;

        { TODO : See if UpdateScreenObjectData can be made to do this. }
//        DataSetIndex := self.GetDataSetIndexByName(rsLakeID);
//        Edit := FDataEdits[DataSetIndex];
//        DataArray := Edit.DataArray;
        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          if IntValue = 0 then
          begin
            Item.ScreenObject.RemoveDataSet(DataArray)
          end
          else
          begin
            DataSetIndex := Item.ScreenObject.AddDataSet(DataArray);
            Item.ScreenObject.DataSetFormulas[DataSetIndex] := IntToStr(IntValue)
          end;
        end
        else
        begin
          Item.ScreenObject.RemoveDataSet(DataArray)
        end;
      end;
    end
    else
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Boundary := Item.ScreenObject.ModflowLakBoundary;
        Assert(Boundary <> nil);

        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          if  (Boundary.LakeID = 0) then
          begin
            Boundary.LakeID := 1;
          end;
          IntValue := Boundary.LakeID;
        end
        else
        begin
          IntValue := 0;
        end;

        { TODO : See if UpdateScreenObjectData can be made to do this. }
        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          if IntValue = 0 then
          begin
            Item.ScreenObject.RemoveDataSet(DataArray)
          end
          else
          begin
            DataSetIndex := Item.ScreenObject.AddDataSet(DataArray);
            Item.ScreenObject.DataSetFormulas[DataSetIndex] := IntToStr(IntValue)
          end;
        end;
      end;
    end;

    if TryStrToInt(frameLak.rdeCenterLake.Text, IntValue) then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Boundary := Item.ScreenObject.ModflowLakBoundary;
        Assert(Boundary <> nil);
        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          Boundary.CenterLake := IntValue;
        end;
      end;
    end;
    if TryStrToFloat(frameLak.rdeInitialStage.Text, RealValue) then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Boundary := Item.ScreenObject.ModflowLakBoundary;
        Assert(Boundary <> nil);
        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          Boundary.InitialStage := RealValue;
        end;
      end;
    end;
    if TryStrToFloat(frameLak.rdeSill.Text, RealValue) then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Boundary := Item.ScreenObject.ModflowLakBoundary;
        Assert(Boundary <> nil);
        if ShouldStoreBoundary(FLAK_Node, Boundary) then
        begin
          Boundary.Sill := RealValue;
        end;
      end;
    end;
    if frameLak.tabBathymetry.TabVisible then
    begin
      Item := FNewProperties[0];
      Item.ScreenObject.CreateLakBoundary;
      Boundary := Item.ScreenObject.ModflowLakBoundary;
      Assert(Boundary <> nil);

      ExternalLakeTable := Boundary.ExternalLakeTable;
      ExternalLakeTable.LakeTableChoice := TLakeTableChoice(frameLak.rgBathChoice.ItemIndex);
      ExternalLakeTable.FullLakeTableFileName := frameLak.feLakeBathymetry.FileName;
      ItemIndex := 0;
      for Index := 1 to frameLak.rdgLakeTable.RowCount - 1 do
      begin
        if TryStrToFloat(frameLak.rdgLakeTable.Cells[Ord(bcStage), Index], Stage)
          and TryStrToFloat(frameLak.rdgLakeTable.Cells[Ord(bcVolume), Index], Volume)
          and TryStrToFloat(frameLak.rdgLakeTable.Cells[Ord(bcSurfaceArea), Index], SurfaceArea)
          then
        begin

          if ItemIndex < ExternalLakeTable.LakeTable.Count then
          begin
            BathItem := ExternalLakeTable.LakeTable[ItemIndex];
          end
          else
          begin
            BathItem := ExternalLakeTable.LakeTable.Add;
          end;

          BathItem.Stage := Stage;
          BathItem.Volume := Volume;
          BathItem.SurfaceArea := SurfaceArea;
          Inc(ItemIndex);
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreDrnBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectCondParam;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  if IsLoaded then
  begin
    if (FDRN_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FDRN_Node <> nil);
    Frame := frameDrnParam;
    ParamType := ptDRN;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateDrnBoundary;
    end;
    StoreFormulaInterpretation(Frame, ParamType);
    StoreModflowBoundary(Frame, ParamType, FDRN_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FDRN_Node);
    StorePestModifiers(Frame, ParamType, FDRN_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreRchBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TRchBoundary;
  ColumnOffset: Integer;
  BoundaryLayers: TCustomMF_BoundColl;
begin
  if IsLoaded then
  begin
    if (FRCH_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FRCH_Node <> nil);
    Frame := frameRchParam;
    ParamType := ptRCH;
    StoreModflowBoundary(Frame, ParamType, FRCH_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FRCH_Node);

    if frmGoPhast.PhastModel.ModflowTransientParameters.
      CountParam(ptRCH) > 0 then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CreateRchBoundary;
        Boundary := Item.ScreenObject.ModflowRchBoundary;
        Boundary.Values.Clear;
      end;
    end;

    if frmGoPhast.PhastModel.RchTimeVaryingLayers then
    begin
      GetMF_BoundaryTimes(Times, Frame);
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CreateRchBoundary;
        Boundary := Item.ScreenObject.ModflowRchBoundary;
        ColumnOffset := 4 + GwtColumnCount;
        BoundaryLayers := Boundary.RechargeLayers;
        if ShouldStoreBoundary(FRCH_Node, Boundary) then
        begin
          StoreMF_BoundColl(ColumnOffset, BoundaryLayers, Times, Frame);
        end
        else if  FRCH_Node.StateIndex = 1 then
        begin
          Boundary.Clear;
        end;
      end;
    end;
    StorePestModifiers(Frame, ParamType, FRCH_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreEvtBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TEvtBoundary;
  ColumnOffset: Integer;
  BoundaryLayers: TCustomMF_BoundColl;
  procedure StoreEvtSurfaceDepth(Node: TJvPageIndexNode);
  const
    ColumnOffset = 2;
  var
    Index: Integer;
    Item: TScreenObjectEditItem;
    Boundary: TEvtBoundary;
    DataGrid: TRbwDataGrid4;
    BoundaryIndex: Integer;
    Modifier: string;
  begin
    if (Node = nil) then
    begin
      Exit;
    end;

    Assert(Node <> nil);
    DataGrid := Frame.rdgModflowBoundary;

    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Boundary := Item.ScreenObject.ModflowEvtBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(Node, Boundary) then
      begin
        for BoundaryIndex := 1 to 2 do
        begin
          if DataGrid.Cells[ColumnOffset+BoundaryIndex,PestMethodRow] <> '' then
          begin
            Boundary.PestBoundaryMethod[BoundaryIndex] :=
              PestMethod[DataGrid, ColumnOffset+BoundaryIndex];
          end;
          if PestModifierAssigned[DataGrid, ColumnOffset+BoundaryIndex] then
          begin
            Modifier := PestModifier[DataGrid, ColumnOffset+BoundaryIndex];
            Boundary.PestBoundaryFormula[BoundaryIndex] := Modifier;
          end;
        end;
      end;
    end;
  end;
begin
  if IsLoaded then
  begin
    if (FEVT_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FEVT_Node <> nil);
    Frame := frameEvtParam;
    ParamType := ptEVT;
    StoreModflowBoundary(Frame, ParamType, FEVT_Node);

    if frmGoPhast.PhastModel.ModflowTransientParameters.
      CountParam(ptEVT) > 0 then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CreateEvtBoundary;
        Boundary := Item.ScreenObject.ModflowEvtBoundary;
        Boundary.Values.Clear;
      end;
    end;

    GetMF_BoundaryTimes(Times, Frame);
    if frmGoPhast.PhastModel.EvtTimeVaryingLayers then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CreateEvtBoundary;
        Boundary := Item.ScreenObject.ModflowEvtBoundary;
        ColumnOffset := 5;
        BoundaryLayers := Boundary.EvapotranspirationLayers;
        if ShouldStoreBoundary(FEVT_Node, Boundary) then
        begin
          StoreMF_BoundColl(ColumnOffset, BoundaryLayers, Times, Frame);
        end
        else if  FEVT_Node.StateIndex = 1 then
        begin
          Boundary.Clear;
        end;
      end;
    end;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateEvtBoundary;
      Boundary := Item.ScreenObject.ModflowEvtBoundary;
      ColumnOffset := 3;
      BoundaryLayers := Boundary.EvtSurfDepthCollection;
      if ShouldStoreBoundary(FEVT_Node, Boundary) then
      begin
        StoreMF_BoundColl(ColumnOffset, BoundaryLayers, Times, Frame);
      end
      else if  FEVT_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
    StorePestModifiers(Frame, ParamType, FEVT_Node);
    StoreEvtSurfaceDepth(FEVT_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreEtsBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TEtsBoundary;
  ColumnOffset: Integer;
  BoundaryLayers: TCustomMF_BoundColl;
  NumberOfSpecies: Integer;
  procedure StoreEtsPest(Node: TJvPageIndexNode);
  var
    Index: Integer;
    Item: TScreenObjectEditItem;
    Boundary: TEtsBoundary;
//    BoundaryValues: TCustomMF_BoundColl;
    DataGrid: TRbwDataGrid4;
    BoundaryIndex: Integer;
    Modifier: string;
    ColumnOffset: Integer;
    BoundaryCount: Integer;
    StorageIndex: Integer;
    ColIndex: Integer;
  begin
    if (Node = nil) then
    begin
      Exit;
    end;

    Assert(Node <> nil);
    DataGrid := Frame.rdgModflowBoundary;

    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Boundary := Item.ScreenObject.ModflowEtsBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(Node, Boundary) then
      begin
        ColumnOffset := 2;
//        BoundaryValues := Boundary.Values;
        BoundaryCount := 4;
//        BoundaryCount := BoundaryCount + Boundary.EtsSurfDepthCollection.TimeListCount(frmGoPhast.PhastModel);
        for BoundaryIndex := 0 to BoundaryCount - 1 do
        begin
          ColIndex := ColumnOffset+BoundaryIndex;
          StorageIndex := BoundaryIndex;
//          if ColIndex >= Frame.rdgModflowBoundary.ColCount then
//          begin
//            Continue
//          end;
//          if BoundaryIndex = 0 then
//          begin
//            StorageIndex := 0;
//          end
//          else if BoundaryIndex = 1 then
//          begin
//            StorageIndex := 1;
//          end
//          else
//          begin
//            StorageIndex := EtsBoundaryStartConcentration + BoundaryIndex -1;
//          end;
          if DataGrid.Cells[ColIndex,PestMethodRow] <> '' then
          begin
            Boundary.PestBoundaryMethod[StorageIndex] :=
              PestMethod[DataGrid, ColIndex];
          end;
          if PestModifierAssigned[DataGrid, ColIndex] then
          begin
            Modifier := PestModifier[DataGrid, ColIndex];
            Boundary.PestBoundaryFormula[StorageIndex] := Modifier;
          end;
        end;
      end;
    end
  end;
  procedure StoreEtsSurfaceDepth(Node: TJvPageIndexNode);
  const
    ColumnOffset = 2;
  var
    Index: Integer;
    Item: TScreenObjectEditItem;
    Boundary: TEtsBoundary;
    DataGrid: TRbwDataGrid4;
    BoundaryIndex: Integer;
    Modifier: string;
  begin
    if (Node = nil) then
    begin
      Exit;
    end;

    Assert(Node <> nil);
    DataGrid := Frame.rdgModflowBoundary;

    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Boundary := Item.ScreenObject.ModflowEtsBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(Node, Boundary) then
      begin
        for BoundaryIndex := 2 to 3 do
        begin
          if DataGrid.Cells[ColumnOffset+BoundaryIndex,PestMethodRow] <> '' then
          begin
            Boundary.PestBoundaryMethod[BoundaryIndex] :=
              PestMethod[DataGrid, ColumnOffset+BoundaryIndex];
          end;
          if PestModifierAssigned[DataGrid, ColumnOffset+BoundaryIndex] then
          begin
            Modifier := PestModifier[DataGrid, ColumnOffset+BoundaryIndex];
            Boundary.PestBoundaryFormula[BoundaryIndex] := Modifier;
          end;
        end;
      end;
    end;
  end;
begin
  if IsLoaded then
  begin
    if (FETS_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FETS_Node <> nil);
    Frame := frameEtsParam;
    ParamType := ptETS;
    StoreModflowBoundary(Frame, ParamType, FETS_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FETS_Node);

    if frmGoPhast.PhastModel.ModflowTransientParameters.
      CountParam(ptETS) > 0 then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CreateEtsBoundary;
        Boundary := Item.ScreenObject.ModflowEtsBoundary;
        Boundary.Values.Clear;
      end;
    end;

    NumberOfSpecies := GwtColumnCount;
    GetMF_BoundaryTimes(Times, Frame);
    if frmGoPhast.PhastModel.EtsTimeVaryingLayers then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.CreateEtsBoundary;
        Boundary := Item.ScreenObject.ModflowEtsBoundary;
        Assert(Boundary <> nil);
        ColumnOffset := 5 + NumberOfSpecies
          + (frmGoPhast.PhastModel.ModflowPackages.
          EtsPackage.SegmentCount-1)*2;
        BoundaryLayers := Boundary.EvapotranspirationLayers;
        if ShouldStoreBoundary(FETS_Node, Boundary) then
        begin
          StoreMF_BoundColl(ColumnOffset, BoundaryLayers, Times, Frame);
        end
        else if  FETS_Node.StateIndex = 1 then
        begin
          Boundary.Clear;
        end;
      end;
    end;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateEtsBoundary;
      Boundary := Item.ScreenObject.ModflowEtsBoundary;
      Assert(Boundary <> nil);
      ColumnOffset := 4;
      BoundaryLayers := Boundary.EtsSurfDepthCollection;
      if ShouldStoreBoundary(FETS_Node, Boundary) then
      begin
        StoreMF_BoundColl(ColumnOffset, BoundaryLayers, Times, Frame);
      end
      else if  (FETS_Node.StateIndex = 1) then
      begin
        Boundary.Clear;
      end;
    end;
    StoreEtsPest(FETS_Node);
    StoreEtsSurfaceDepth(FETS_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreDrtBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectCondParam;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TDrtBoundary;
  RealValue: double;
  IntValue: integer;
  ObjectIndex: integer;
begin
  if IsLoaded then
  begin
    if (FDRT_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FDRT_Node <> nil);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateDrtBoundary;
      Boundary := Item.ScreenObject.ModflowDrtBoundary;
      if comboDrtLocationChoice.ItemIndex >= 0 then
      begin
        Boundary.DrainReturn.ReturnChoice :=
          TReturnChoice(comboDrtLocationChoice.ItemIndex);
        if ShouldStoreBoundary(FDRT_Node, Boundary) then
        begin
          case Boundary.DrainReturn.ReturnChoice of
            rtNone: ; // do nothing.
            rtObject:
              begin
                ObjectIndex := comboDrtReturnObject.ItemIndex;
                if ObjectIndex >= 0 then
                begin
                  Boundary.DrainReturn.ReturnObject.ScreenObject :=
                    comboDrtReturnObject.Items.Objects[ObjectIndex];
                end;
              end;
            rtLocation:
              begin
                if TryStrToFloat(rdeDrtX.Text, RealValue) then
                begin
                  Boundary.DrainReturn.ReturnLocation.X := RealValue;
                end;
                if TryStrToFloat(rdeDrtY.Text, RealValue) then
                begin
                  Boundary.DrainReturn.ReturnLocation.Y := RealValue;
                end;
                if TryStrToFloat(rdeDrtZ.Text, RealValue) then
                begin
                  Boundary.DrainReturn.ReturnLocation.Z := RealValue;
                end;
              end;
            rtCell:
              begin
                if TryStrToInt(rdeDrtCol.Text, IntValue) then
                begin
                  Boundary.DrainReturn.ReturnCell.Col := IntValue;
                end;
                if TryStrToInt(rdeDrtRow.Text, IntValue) then
                begin
                  Boundary.DrainReturn.ReturnCell.Row := IntValue;
                end;
                if TryStrToInt(rdeDrtLay.Text, IntValue) then
                begin
                  Boundary.DrainReturn.ReturnCell.Lay := IntValue;
                end;
              end;
            else Assert(False);
          end;
        end;
      end;
    end;

    Frame := frameDrtParam;
    ParamType := ptDRT;
    StoreFormulaInterpretation(Frame, ParamType);
    StoreModflowBoundary(Frame, ParamType, FDRT_Node);
    StorePestModifiers(Frame, ParamType, FDRT_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreWellBoundary;
const
  PumpingRatePosition = 0;
  ColumnOffset = 2;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectCondParam;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  if IsLoaded then
  begin
    Assert(FWEL_Node <> nil);
    if (FWEL_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Frame := frameWellParam;
    ParamType := ptQ;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateWelBoundary;
      if FWellTabFileChanged then
      begin
        Item.ScreenObject.ModflowWellBoundary.TabFileName :=
          frameWellParam.fedTabfile.FileName;
      end;
    end;
    FWellTabFileChanged := False;
    StoreFormulaInterpretation(Frame, ParamType);
    StoreModflowBoundary(Frame, ParamType, FWEL_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FWEL_Node);

    StorePestModifiers(Frame, ParamType, FWEL_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreFarmWell;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectCondParam;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  if IsLoaded then
  begin
    if (FFarmWell_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FFarmWell_Node <> nil);
    Frame := frameFarmWell;
    ParamType := ptQMAX;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateFarmWell;
    end;
    StoreFormulaInterpretation(Frame, ParamType);
    StoreModflowBoundary(Frame, ParamType, FFarmWell_Node);
    StorePestModifiers(Frame, ParamType, FFarmWell_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreRivBoundary;
var
  ParamType: TParameterType;
  Frame: TframeScreenObjectCondParam;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  if IsLoaded then
  begin
    if (FRIV_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FRIV_Node <> nil);
    Frame := frameRivParam;
    ParamType := ptRiv;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateRivBoundary;
    end;
    StoreFormulaInterpretation(Frame, ParamType);
    StoreModflowBoundary(Frame, ParamType, FRIV_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FRIV_Node);
    StorePestModifiers(Frame, ParamType, FRIV_Node);
  end;
end;

procedure TfrmScreenObjectProperties.StoreSwrEvapBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TSwrEvapBoundary;
begin
  if IsLoaded then
  begin
    if (FSWR_Evap_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FSWR_Evap_Node <> nil);
    Frame := frameSWR_Evap;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateSwrEvapBoundary;
      Boundary := Item.ScreenObject.ModflowSwrEvap;
      if ShouldStoreBoundary(FSWR_Evap_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
        if Frame.PestModifierAssigned[2] then
        begin
          Boundary.PestValueFormula := Frame.PestModifier[2];
        end;
        if Frame.PestMethodAssigned[2] then
        begin
          Boundary.PestValueMethod := Frame.PestMethod[2];
        end;
      end
      else if FSWR_Evap_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreSwrLatInflowBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TSwrLatInflowBoundary;
begin
  if IsLoaded then
  begin
    if (FSWR_LatInflow_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FSWR_LatInflow_Node <> nil);
    Frame := frameSWR_LatInfl;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateSwrLatInflowBoundary;
      Boundary := Item.ScreenObject.ModflowSwrLatInflow;
      if ShouldStoreBoundary(FSWR_LatInflow_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
        if frameSWR_LatInfl.comboFormulaInterp.ItemIndex >= 1 then
        begin
          Boundary.FormulaInterpretation :=
            TFormulaInterpretation(frameSWR_LatInfl.comboFormulaInterp.ItemIndex)
        end;
        if Frame.PestModifierAssigned[2] then
        begin
          Boundary.PestValueFormula := Frame.PestModifier[2];
        end;
        if Frame.PestMethodAssigned[2] then
        begin
          Boundary.PestValueMethod := Frame.PestMethod[2];
        end;
      end
      else if FSWR_LatInflow_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreSwrRainBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TSwrRainBoundary;
begin
  if IsLoaded then
  begin
    if (FSWR_Rain_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FSWR_Rain_Node <> nil);
    Frame := frameSWR_Rain;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateSwrRainBoundary;
      Boundary := Item.ScreenObject.ModflowSwrRain;
      if ShouldStoreBoundary(FSWR_Rain_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);

        if Frame.PestModifierAssigned[2] then
        begin
          Boundary.PestValueFormula := Frame.PestModifier[2];
        end;
        if Frame.PestMethodAssigned[2] then
        begin
          Boundary.PestValueMethod := Frame.PestMethod[2];
        end;
      end
      else if FSWR_Rain_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreSwrStageBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TSwrStageBoundary;
begin
  if IsLoaded then
  begin
    if (FSWR_Stage_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FSWR_Stage_Node <> nil);

    Frame := frameSWR_Stage;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateSwrStageBoundary;
      Boundary := Item.ScreenObject.ModflowSwrStage;
      if ShouldStoreBoundary(FSWR_Stage_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
        if Frame.PestModifierAssigned[2] then
        begin
          Boundary.PestValueFormula := Frame.PestModifier[2];
        end;
        if Frame.PestMethodAssigned[2] then
        begin
          Boundary.PestValueMethod := Frame.PestMethod[2];
        end;
      end
      else if FSWR_Stage_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreSwrDirectRunoffBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Times: TTimeArray;
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TSwrDirectRunoffBoundary;
begin
  if IsLoaded then
  begin
    if (FSWR_DirectRunoff_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;
    Assert(FSWR_DirectRunoff_Node <> nil);

    Frame := frameSWR_DirectRunoff;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateSwrDirectRunoffBoundary;
      Boundary := Item.ScreenObject.ModflowSwrDirectRunoff;
      if ShouldStoreBoundary(FSWR_DirectRunoff_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
      end
      else if (FSWR_DirectRunoff_Node <> nil) and (FSWR_DirectRunoff_Node.StateIndex = 1) then
      begin
        Boundary.Clear;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StoreUzfBoundary;
var
  Frame: TframeScreenObjectNoParam;
  Index: Integer;
  Times: TTimeArray;
  Item: TScreenObjectEditItem;
  Boundary: TUzfBoundary;
  ColumnOffset: integer;
  Gage: integer;
  procedure StoreUzfPest(Node: TJvPageIndexNode);
  const
    ColumnOffset = 2;
    First = 0;
    Last = 3;
  var
    Index: Integer;
    Item: TScreenObjectEditItem;
    Boundary: TUzfBoundary;
    DataGrid: TRbwDataGrid4;
    BoundaryIndex: Integer;
    Modifier: string;
  begin
    if (Node = nil) then
    begin
      Exit;
    end;

    Assert(Node <> nil);
    DataGrid := Frame.rdgModflowBoundary;

    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Boundary := Item.ScreenObject.ModflowUzfBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(Node, Boundary) then
      begin
        for BoundaryIndex := First to Last do
        begin
          if DataGrid.Cells[ColumnOffset+BoundaryIndex,PestMethodRow] <> '' then
          begin
            Boundary.PestBoundaryMethod[BoundaryIndex] :=
              PestMethod[DataGrid, ColumnOffset+BoundaryIndex];
          end;
          if PestModifierAssigned [DataGrid, ColumnOffset+BoundaryIndex] then
          begin
            Modifier := PestModifier[DataGrid, ColumnOffset+BoundaryIndex];
            Boundary.PestBoundaryFormula[BoundaryIndex] := Modifier;
          end;
        end;
      end;
    end;
  end;
begin
  if IsLoaded then
  begin
    Frame := frameScreenObjectUZF;
    GetMF_BoundaryTimes(Times, Frame);
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateUzfBoundary;
      Boundary := Item.ScreenObject.ModflowUzfBoundary;
      Assert(Boundary <> nil);
      if ShouldStoreBoundary(FUZF_Node, Boundary) then
      begin
        StoreModflowBoundaryValues(Frame, Times, Boundary);
        if frmGoPhast.PhastModel.ModflowPackages.UzfPackage.SimulateET then
        begin
          ColumnOffset := 3;
          StoreMF_BoundColl(ColumnOffset, Boundary.EvapotranspirationDemand, Times, Frame);
          ColumnOffset := 4;
          StoreMF_BoundColl(ColumnOffset, Boundary.ExtinctionDepth, Times, Frame);
          ColumnOffset := 5;
          StoreMF_BoundColl(ColumnOffset, Boundary.WaterContent, Times, Frame);
        end;
      end
      else if  FUZF_Node.StateIndex = 1 then
      begin
        Boundary.Clear;
      end;
      Gage := 0;
      if cbUzfGage1.Checked then
      begin
        Gage := 1;
        if cbUzfGage2.Checked then
        begin
          Gage := 2;
        end;
      end;
      if not (cbUzfGage1.State = cbGrayed)
        and not (cbUzfGage2.State = cbGrayed) then
      begin
        Boundary.GageOption1 := Gage;
      end;
      Gage := 0;
      if cbUzfGage3.Checked then
      begin
        Gage := 3;
      end;
      if not (cbUzfGage3.State = cbGrayed) then
      begin
        Boundary.GageOption2 := Gage;
      end;
    end;
    StoreUzfPest(FUZF_Node);
  end;
end;


procedure TfrmScreenObjectProperties.StoreChdBoundary;
var
  Frame: TframeScreenObjectParam;
  ParamType: TParameterType;
  Index: Integer;
  Item: TScreenObjectEditItem;
  RowIndex: Integer;
  ColIndex: Integer;
begin
  if IsLoaded then
  begin
    if (FCHD_Node = nil) then
    begin
      Beep;
      MessageDlg(StrSomethingWentWrong, mtError, [mbOK], 0);
      Exit;
    end;

    Assert(FCHD_Node <> nil);
    Frame := frameChdParam;
    ParamType := ptCHD;
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.CreateChdBoundary;
    end;
    if frmGoPhast.ModelSelection = msModflow2015 then
    begin
      for RowIndex := 1 to Frame.rdgModflowBoundary.RowCount - 1 do
      begin
        for ColIndex := 3 to Frame.rdgModflowBoundary.ColCount - 1 do
        begin
          if IsChdEndHeadColumn(ColIndex) then
          begin
            Frame.rdgModflowBoundary.Cells[ColIndex,RowIndex] :=
              Frame.rdgModflowBoundary.Cells[ColIndex-1,RowIndex];
          end;
        end;
      end;
    end;
    StoreModflowBoundary(Frame, ParamType, FCHD_Node);
    StoreModflowTimeInterpolation(Frame, ParamType, FCHD_Node);
    StorePestModifiers(Frame, ParamType, FCHD_Node);
  end;
end;

procedure TfrmScreenObjectProperties.frameChdParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FCHD_Node);
  frameChdParam.clbParametersStateChange(Sender, Index);
  StoreChdBoundary;
end;

procedure TfrmScreenObjectProperties.frameChdParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreChdBoundary;
end;

function TfrmScreenObjectProperties.GetPestParameterAllowed(
  DataGrid: TCustomRBWDataGrid; ACol: Integer): boolean;
var
  DensityUsed: Boolean;
begin
  DensityUsed := frmGoPhast.PhastModel.BuoyancyDensityUsed;
 { Support PEST here }
  result :=
    (DataGrid = frameDrnParam.rdgModflowBoundary)
    or (DataGrid = frameGhbParam.rdgModflowBoundary)
    or (DataGrid = frameWellParam.rdgModflowBoundary)
    or (DataGrid = frameRivParam.rdgModflowBoundary)
    or (DataGrid = frameDrtParam.rdgModflowBoundary)
    or (DataGrid = frameScreenObjectStr.rdgModflowBoundary)
    or ((DataGrid = frameChdParam.rdgModflowBoundary) and (ACol in [3,4,5]))
    or ((DataGrid = frameFarmWell.rdgModflowBoundary) and (ACol = 2))
    or (DataGrid = frameFhbHead.rdgModflowBoundary)
    or (DataGrid = frameFhbFlow.rdgModflowBoundary)
    or ((DataGrid = frameRchParam.rdgModflowBoundary) and (ACol in [2,3]))
    or ((DataGrid = frameEvtParam.rdgModflowBoundary) and (ACol in [2,3,4]))
    or ((DataGrid = frameEtsParam.rdgModflowBoundary) and (ACol in [2,3,4,5]))
    or (DataGrid = frameScreenObjectUZF.rdgModflowBoundary)
    or (DataGrid = frameScreenObjectUzfMf6.rdgModflowBoundary)
    or ((DataGrid = frameScreenObjectSfr6.rdgModflowBoundary) and (ACol in [3..9]))
    or ((DataGrid = frameScreenObjectSfr6.rdgModflowBoundary) and (ACol = 10) and DensityUsed)
    or ((DataGrid = frameMAW.rdgModflowBoundary) and (ACol in [3, 4, 6, 7, 8, 10..13, 15, 16]))
    or ((DataGrid = frameLakMf6.rdgModflowBoundary) and (ACol in [3..9]))
    or (DataGrid = frameCSUB.rdgModflowBoundary)
    or ((DataGrid = frameHfbMf6.rdgModflowBoundary) and (frameHfbMf6.comboHfbParameters.ItemIndex <= 0))
    or (DataGrid = frameLak.rdgModflowBoundary)
    or (DataGrid = frameScreenObjectSfr6.rdgFormulas)
    or (DataGrid = frameMAW.frameWellScreens.Grid)
    or (DataGrid = frameLakMf6.frameLakeTable.Grid)
    or ((DataGrid = frameMNW1.rdgModflowBoundary) and (ACol in [2, 3, 5, 6, 7, 9, 10, 12, 14, 15]))
    or ((DataGrid = frameMNW2.rdgTimeTable) and (ACol in [2, 3, 4, 6, 7]))
    or ((DataGrid = frameMNW2.rdgVerticalScreens) and (ACol in [2..9]))
    or (DataGrid = frameRes.rdgModflowBoundary)
    or (DataGrid.Owner is  TframeLakeOutlet)
    or (DataGrid = frameScreenObjectSFR.dgFlowTimes)
    or (DataGrid = frameScreenObjectSFR.dgUp)
    or (DataGrid = frameScreenObjectSFR.dgDown)
    or ((DataGrid = frameSwrReach.frameSwr.rdgModflowBoundary) and (ACol in [3,5]))
    or (DataGrid = frameSWR_Rain.rdgModflowBoundary)
    or (DataGrid = frameSWR_Evap.rdgModflowBoundary)
    or (DataGrid = frameSWR_LatInfl.rdgModflowBoundary)
    or (DataGrid = frameSWR_Stage.rdgModflowBoundary)
    or ((DataGrid = frameSutraSpecifiedPressure.rdgSutraFeature) and (ACol in [2,3]))
    or ((DataGrid = frameSutraFluidFlux.rdgSutraFeature) and (ACol in [2,3]))
    or ((DataGrid = frameSutraMassEnergyFlux.rdgSutraFeature) and (ACol in [2]))
    or ((DataGrid = frameSutraSpecTempConc.rdgSutraFeature) and (ACol in [2]))
    or ((DataGrid = frameSutraGeneralizedFlowBoundary.rdgSutraFeature) and (ACol in [2..5, 8, 10]))
    or ((DataGrid = frameSutraGeneralizeTransBoundary.rdgSutraFeature) and (ACol in [2..5]))
    or ((DataGrid = frameGwtCnc.rdgModflowBoundary) and (ACol in [3,4]))
    or ((DataGrid = frameGwtSrc.rdgModflowBoundary) and (ACol in [3,4]))

    or (DataGrid = frameFarmRefEvap.rdgModflowBoundary)
    or (DataGrid = frameFarmPrecip.rdgModflowBoundary)
    or (DataGrid = frameFmp4AddedDemand.rdgModflowBoundary)
    or (DataGrid = frameFmp4AddedDemandRunoffSplit.rdgModflowBoundary)
    or (DataGrid = frameFmp4BareEvap.rdgModflowBoundary)
    or (DataGrid = frameFmp4BarePrecipitationConsumptionFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4BareRunoffFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4ConsumptiveUse.rdgModflowBoundary)
    or (DataGrid = frameFmp4CropCoefficient.rdgModflowBoundary)
    or (DataGrid = frameFmp4DirectRecharge.rdgModflowBoundary)
    or (DataGrid = frameFmp4Efficiency.rdgModflowBoundary)
    or (DataGrid = frameFmp4EvaporationIrrigationFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4FractionOfIrrigToSurfaceWater.rdgModflowBoundary)
    or (DataGrid = frameFmp4FractionOfPrecipToSurfaceWater.rdgModflowBoundary)
    or (DataGrid = frameFmp4LandUseAreaFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4PrecipPotConsumption.rdgModflowBoundary)
    or (DataGrid = frameFmp4RootDepth.rdgModflowBoundary)
    or (DataGrid = frameFmp4TranspirationFraction.rdgModflowBoundary)

    or (DataGrid = frameFmp4MultAddedDemand.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultConsumptiveUse.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultCropCoefficients.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultEvaporationIrrigationFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultFractionOfIrrigToSurfaceWater.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultFractionOfPrecipToSurfaceWater.rdgModflowBoundary)
    or (DataGrid = frameMultLandUseAreaFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultTranspirationFraction.rdgModflowBoundary)
    or (DataGrid = frameFmp4MultRootDepth.rdgModflowBoundary)
    or (DataGrid = frameScreenObjectTvk.rdgModflowBoundary)
    or (DataGrid = frameScreenObjectTvs.rdgModflowBoundary)
    ;
end;

procedure TfrmScreenObjectProperties.frameChdParamdgModflowBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  VariableList: TList;
  Orientation: TDataSetOrientation;
  DataGrid: TCustomRBWDataGrid;
  EvaluatedAt: TEvaluatedAt;
  Index: integer;
  DataSet: TDataArray;
  NewValue: string;
  Variable: TCustomValue;
  Edit: TScreenObjectDataEdit;
  DataArrayManager: TDataArrayManager;
  ASeries: TObSeries;
  ModelSelection: TModelSelection;
//  PestParamAllowed: Boolean;
begin
  inherited;
  DataGrid := Sender as TCustomRBWDataGrid;
  VariableList := TList.Create;
  // VariableList will hold a list of variables that can
  // be used in the function
  try
//    PestParamAllowed := GetPestParameterAllowed(DataGrid);

    // get the orientation of the data set.
    if DataGrid.Parent is TframeModflow6DynamicTimeSeries then
    begin
      if rgElevationCount.ItemIndex = 0 then
      begin
        Orientation := dsoTop;
      end
      else
      begin
        Orientation := dso3D;
      end;
    end
    else if (DataGrid = frameRchParam.rdgModflowBoundary)
      or (DataGrid = frameEvtParam.rdgModflowBoundary)
      or (DataGrid = frameEtsParam.rdgModflowBoundary)
      or (DataGrid = frameFarmCropID.rdgModflowBoundary)
      or (DataGrid = frameFarmID.rdgModflowBoundary)
      or (DataGrid = frameFarmPrecip.rdgModflowBoundary)
      or (DataGrid = frameFarmRefEvap.rdgModflowBoundary)
      or (DataGrid = frameMAW.rdgModflowBoundary)
      or (DataGrid = frameMAW.frameWellScreens.Grid)
      then
    begin
      Orientation := dsoTop;
    end
    else if (DataGrid.Owner is TframeScreenObjectCustomFmp4Boundary)
      or (DataGrid.Owner is TframeScreenObjectCustomFmp4MultBoundary) then
    begin
      Orientation := dsoTop;
    end
    else if DataGrid = frameObsMf6.framePestObs.frameObservations.Grid then
    begin
      if TryGetObsSeries(DataGrid.Cells[Ord(mp6ObsSeries), ARow], ASeries) then
      begin
        if ASeries = osMaw then
        begin
          Orientation := dsoTop;
        end
        else
        begin
          Orientation := dso3D;
        end;
      end
      else
      begin
        Orientation := dso3D;
      end;
    end
    else
    begin
      Orientation := dso3D;
    end;
    ModelSelection := frmGoPhast.ModelSelection;
    if ModelSelection in ModflowSelection then
    begin
    // All the MODFLOW boundary conditions are evaluated at blocks.
      EvaluatedAt := eaBlocks;
    end
    else if ModelSelection in SutraSelection then
    begin
    // All the SUTRA boundary conditions are evaluated at nodes.
      EvaluatedAt := eaNodes;
    end
    else
    begin
      EvaluatedAt := eaBlocks;
    end;

    DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
    for Index := 0 to DataArrayManager.DataSetCount - 1 do
    begin
      DataSet := DataArrayManager.DataSets[Index];
      if not DataSet.Visible then
      begin
        Continue;
      end;
      if DataSet is TCustomSparseDataSet then
      begin
        Continue;
      end;
      if (EvaluatedAt = DataSet.EvaluatedAt) then
      begin
        if ((Orientation = dso3D)
          or (Orientation = DataSet.Orientation)) then
        begin
          Edit := FDataEdits[Index];
          // if the variable does not depend on the
          // data set whose formula is being edited
          // and it's orientation is OK, the variable
          // can be used in the formula.
          VariableList.Add(Edit.Variable);
        end;
      end;
    end;

    NewValue := DataGrid.Cells[ACol, ARow];
    if (NewValue = '') then
    begin
      NewValue := '0';
    end;

//    with TfrmFormula.Create(self) do
    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(eaBlocks);
        RemoveGetVCont;
        RemoveHufFunctions;
        PopupParent := self;

        // register the appropriate variables with the
        // parser.
        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          rbFormulaParser.RegisterVariable(Variable);
        end;

        // show the variables and functions
        IncludeTimeSeries := GetModflow6TimeSeriesAllowed(DataGrid, ACol);
        if tabDynamicTimeSeries.TabVisible then
        begin
          DynamicTimesSeriesNames := frameDynamicTimeSeries. DynamicTimeSeriesNames
        end
        else
        begin
          DynamicTimesSeriesNames.Clear;
        end;
        UpdateTreeList;

        // put the formula in the TfrmFormula.
        Formula := NewValue;
        // The user edits the formula.
        ShowModal;
        if ResultSet then
        begin
          try
            CreateBoundaryFormula(DataGrid, ACol, ARow, Formula, Orientation,
              EvaluatedAt);
          except on E: Exception do
            begin
              Beep;
              MessageDlg(Format(StrErrorIn0sRow,
                ['A boundary package',
                ARow + 1, ACol+1, E.Message]), mtError,[mbOK], 0);
              Exit;
            end;
           end;
      end;
      finally
        Initialize;
//        Free;
      end;
    end;

  finally
    VariableList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.frameChdParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreChdBoundary;
end;

procedure TfrmScreenObjectProperties.UpdateNonParamCheckBox(
  Frame: TframeScreenObjectParam; ParamCol, ACol, ARow: Integer;
  const Value: string);
begin
  if (Frame.clbParameters.Items.Count > 0)
    and (Frame.clbParameters.State[0] = cbUnchecked)
    and (ARow >= Frame.rdgModflowBoundary.FixedRows + PestRowOffset)
    and (ACol >= 2) and (ACol < ParamCol) and (Value <> '') then
  begin
    Frame.clbParameters.Checked[0] := True;
  end;
end;

procedure TfrmScreenObjectProperties.frameChdParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FCHD_Node);
  frameChdParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateChdBoundary;
    StartParamCol := Item.ScreenObject.ModflowChdBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameChdParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameChdParam.rdgModflowBoundary.DistributingText then
  begin
    StoreChdBoundary;
  end;
end;

function TfrmScreenObjectProperties.IsChdActiveColumn(ACol: Integer): Boolean;
const
  ActivePosition = 0;
  FirstActiveCol = 2;
  NonGWTProperties = 4;
  FirstDataColumn = 2;
var
  DataColumnCount: Integer;
  DC: Integer;
begin
  result := (ACol >= FirstActiveCol);
  if result then
  begin
    DataColumnCount := NonGWTProperties;
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
    end;
    DC := ACol-FirstDataColumn;
    result := ((DC mod DataColumnCount) = ActivePosition);
  end;
end;

function TfrmScreenObjectProperties.IsChdEndHeadColumn(ACol: Integer): Boolean;
const
  EndHeadPosition = 2;
  FirstEndHeadCol = 4;
  NonGWTProperties = 4;
  FirstDataColumn = 2;
var
  DataColumnCount: Integer;
  DC: Integer;
begin
  result := (ACol >= FirstEndHeadCol);
  if result then
  begin
    DataColumnCount := NonGWTProperties;
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
    end;
    DC := ACol-FirstDataColumn;
    result := ((DC mod DataColumnCount) = EndHeadPosition);
  end;
end;

function TfrmScreenObjectProperties.IsChdMultiplierColumn(
  ACol: Integer): Boolean;
const
  MultiplierPosition = 3;
  FirstMultiplierCol = 5;
  NonGWTProperties = 4;
  FirstDataColumn = 2;
var
  DataColumnCount: Integer;
  DC: Integer;
begin
  result := (ACol >= FirstMultiplierCol);
  if result then
  begin
    DataColumnCount := NonGWTProperties;
    if frmGoPhast.PhastModel.GwtUsed then
    begin
      Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
    end;
    DC := ACol-FirstDataColumn;
    result := ((DC mod DataColumnCount) = MultiplierPosition);
  end;
end;

procedure TfrmScreenObjectProperties.frameChdParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
begin
  inherited;
  frameChdParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if  CanSelect and (frmGoPhast.ModelSelection = msModflow2015) and (ACol >= 3) then
  begin
    CanSelect := not IsChdEndHeadColumn(ACol);
  end;
  if  CanSelect and (ACol >= 4) then
  begin
    if IsChdMultiplierColumn(ACol) then
    begin
      if (frmGoPhast.ModelSelection = msModflow2015) then
      begin
        CanSelect := frmGoPhast.PhastModel.ModflowPackages.ChdBoundary.UseMultiplier;
      end
      else
      begin
        CanSelect := False;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameChdParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameChdParam.seNumberOfTimesChange(Sender);
  StoreChdBoundary
end;

procedure TfrmScreenObjectProperties.frameCHOBrdgObservationGroupsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    FChob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameCHOBrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if IsLoaded then
  begin
    FChob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameDrnParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FDRN_Node);
  frameDrnParam.clbParametersStateChange(Sender, Index);
  StoreDrnBoundary;
end;

procedure TfrmScreenObjectProperties.frameDrnParamcomboFormulaInterpChange(
  Sender: TObject);
var
  Item: TScreenObjectEditItem;
begin
  inherited;
  UpdateNodeState(FDRN_Node);
  StoreDrnBoundary;
  Item := FNewProperties[0];
  AssignConductanceCaptions(frameDrnParam, Item.ScreenObject.ModflowDrnBoundary);
end;

procedure TfrmScreenObjectProperties.frameDrnParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreDrnBoundary;
end;

procedure TfrmScreenObjectProperties.frameDrnParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreDrnBoundary
end;

procedure TfrmScreenObjectProperties.frameDrnParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FDRN_Node);
  frameDrnParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateDrnBoundary;
    StartParamCol := Item.ScreenObject.ModflowDrnBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameDrnParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameDrnParam.rdgModflowBoundary.DistributingText then
  begin
    StoreDrnBoundary;
  end;

end;

procedure TfrmScreenObjectProperties.frameDrnParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
begin
  inherited;
  frameDrnParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if CanSelect and (ACol = 4) and (frmGoPhast.ModelSelection <> msModflow2015) then
  begin
    CanSelect := False;
  end;
  if CanSelect and (ACol = 5) then
  begin
    if (frmGoPhast.ModelSelection <> msModflow2015) then
    begin
      CanSelect := False;
    end
    else
    begin
      CanSelect := frmGoPhast.PhastModel.ModflowPackages.DrnPackage.UseMultiplier;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameDrnParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameDrnParam.seNumberOfTimesChange(Sender);
  StoreDrnBoundary;
end;

procedure TfrmScreenObjectProperties.frameDROBrdgObservationGroupsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    FDrob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameDROBrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if IsLoaded then
  begin
    FDrob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameDrtParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FDRT_Node);
  frameDrtParam.clbParametersStateChange(Sender, Index);
  StoreDrtBoundary;
end;

procedure TfrmScreenObjectProperties.frameDrtParamcomboFormulaInterpChange(
  Sender: TObject);
var
  Item: TScreenObjectEditItem;
begin
  inherited;
  UpdateNodeState(FDRT_Node);
  StoreDrtBoundary;
  Item := FNewProperties[0];
  AssignConductanceCaptions(frameDrtParam, Item.ScreenObject.ModflowDrtBoundary);
end;

procedure TfrmScreenObjectProperties.frameDrtParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreDrtBoundary;
end;

procedure TfrmScreenObjectProperties.frameDrtParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FDRT_Node);
  frameDrtParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateDrtBoundary;
    StartParamCol := Item.ScreenObject.ModflowDrtBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameDrtParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameDrtParam.rdgModflowBoundary.DistributingText then
  begin
    StoreDrtBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameDrtParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameDrtParam.seNumberOfTimesChange(Sender);
  StoreDrtBoundary
end;

procedure TfrmScreenObjectProperties.frameEtsParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FETS_Node);
  frameEtsParam.clbParametersStateChange(Sender, Index);
  StoreEtsBoundary;
end;

procedure TfrmScreenObjectProperties.frameEtsParamcomboFormulaInterpChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FETS_Node);
  StoreEtsBoundary;
end;

procedure TfrmScreenObjectProperties.frameEtsParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreEtsBoundary;
end;

procedure TfrmScreenObjectProperties.frameEtsParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreEtsBoundary;
end;

procedure TfrmScreenObjectProperties.frameEtsParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FETS_Node);
  frameEtsParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateEtsBoundary;
    StartParamCol := Item.ScreenObject.ModflowEtsBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameEtsParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameEtsParam.rdgModflowBoundary.DistributingText then
  begin
    StoreEtsBoundary;  
  end;
end;

procedure TfrmScreenObjectProperties.frameEtsParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
var
  EtsPackage: TEtsPackageSelection;
  function IsMultiplierColumn(ACol: Integer): Boolean;
  begin
    result := Pos(StrEVTMultiplier, frameEtsParam.rdgModflowBoundary.Cells[ACol, 0]) > 0;
  end;
begin
  inherited;
  EtsPackage := frmGoPhast.PhastModel.ModflowPackages.EtsPackage;
  frameEtsParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if CanSelect and IsMultiplierColumn(ACol) then
  begin
    if (frmGoPhast.ModelSelection = msModflow2015) then
    begin
      CanSelect := EtsPackage.UseMultiplier;
    end
    else
    begin
      CanSelect := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameEtsParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameEtsParam.seNumberOfTimesChange(Sender);
  StoreEtsBoundary;
end;

procedure TfrmScreenObjectProperties.frameEvtParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FEVT_Node);
  frameEvtParam.clbParametersStateChange(Sender, Index);
  StoreEvtBoundary;
end;

procedure TfrmScreenObjectProperties.frameEvtParamcomboFormulaInterpChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FEVT_Node);
  StoreEvtBoundary;
end;

procedure TfrmScreenObjectProperties.frameEvtParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreEvtBoundary;
end;

procedure TfrmScreenObjectProperties.frameEvtParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FEVT_Node);
  frameEvtParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateEvtBoundary;
    StartParamCol := Item.ScreenObject.ModflowEvtBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameEvtParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameEvtParam.rdgModflowBoundary.DistributingText then
  begin
    StoreEvtBoundary;  
  end;
end;

procedure TfrmScreenObjectProperties.frameEvtParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameEvtParam.seNumberOfTimesChange(Sender);
  StoreEvtBoundary;
end;

procedure TfrmScreenObjectProperties.frameGBOBrdgObservationGroupsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    FGbob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameGBOBrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if IsLoaded then
  begin
    FGbob_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameGhbParamclbParametersStateChange(
  Sender: TObject; Index: Integer);
begin
  inherited;
  UpdateNodeState(FGHB_Node);
  frameGhbParam.clbParametersStateChange(Sender, Index);
  StoreGhbBoundary;
end;

procedure TfrmScreenObjectProperties.frameGhbParamcomboFormulaInterpChange(
  Sender: TObject);
var
  Item: TScreenObjectEditItem;
begin
  inherited;
  UpdateNodeState(FGHB_Node);
  StoreGhbBoundary;
  Item := FNewProperties[0];
  AssignConductanceCaptions(frameGhbParam, Item.ScreenObject.ModflowGhbBoundary);
end;

procedure TfrmScreenObjectProperties.frameGhbParamcomboTimeSeriesInterpolationChange(
  Sender: TObject);
begin
  inherited;
  StoreGhbBoundary;
end;

procedure TfrmScreenObjectProperties.frameGhbParamdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreGhbBoundary;
end;

procedure TfrmScreenObjectProperties.frameGhbParamdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
var
  Item: TScreenObjectEditItem;
  StartParamCol: Integer;
begin
  inherited;
  UpdateNodeState(FGHB_Node);
  frameGhbParam.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

  if (FNewProperties <> nil) and (FNewProperties.Count > 0) then
  begin
    Item := FNewProperties[0];
    Item.ScreenObject.CreateGhbBoundary;
    StartParamCol := Item.ScreenObject.ModflowGhbBoundary.NonParameterColumns;
    UpdateNonParamCheckBox(frameGhbParam, StartParamCol, ACol, ARow,Value);
  end;

  if not frameGhbParam.rdgModflowBoundary.DistributingText then
  begin
    StoreGhbBoundary;  
  end;
end;

procedure TfrmScreenObjectProperties.frameGhbParamrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
  function IsMultiplierColumn(ACol: Integer): Boolean;
  const
    MultiplierPosition = 2;
    FirstMultiplierCol = 4;
    NonGWTProperties = 3;
    FirstDataColumn = 2;
  var
    DataColumnCount: Integer;
    DC: Integer;
  begin
    result := (ACol >= FirstMultiplierCol);
    if result then
    begin
      DataColumnCount := NonGWTProperties;
      if frmGoPhast.PhastModel.GwtUsed then
      begin
        Inc(DataColumnCount, frmGoPhast.PhastModel.MobileComponents.Count);
      end;
      DC := ACol-FirstDataColumn;
      result := ((DC mod DataColumnCount) = MultiplierPosition);
    end;
  end;
begin
  inherited;
  frameGhbParam.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);
  if CanSelect and IsMultiplierColumn(ACol) then
  begin
    if (frmGoPhast.ModelSelection = msModflow2015) then
    begin
      CanSelect := frmGoPhast.PhastModel.ModflowPackages.GhbBoundary.UseMultiplier;
    end
    else
    begin
      CanSelect := False;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameGhbParamseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameGhbParam.seNumberOfTimesChange(Sender);
  StoreGhbBoundary;
end;

procedure TfrmScreenObjectProperties.frameGwtCnccomboChemSpeciesChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FGwtCnc_Node);
end;

procedure TfrmScreenObjectProperties.frameGwtCncrdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameGwtCnc.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FGwtCnc_Node);
end;

procedure TfrmScreenObjectProperties.frameGwtSRCcomboChemSpeciesChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FGwtSrc_Node);
end;

procedure TfrmScreenObjectProperties.frameGwtSRCrdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameGwtSRC.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FGwtSrc_Node);
end;

procedure TfrmScreenObjectProperties.frameHeadObservationsrdgHeadsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameHeadObservations.rdgObservationsSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FHOB_Node);
end;

procedure TfrmScreenObjectProperties.frameHeadObservationsseTimesChange(
  Sender: TObject);
begin
  inherited;
  frameHeadObservations.seTimesChange(Sender);
  if frameHeadObservations.seTimes.asInteger = 0 then
  begin
    if IsLoaded  and (FHOB_Node <> nil) then
    begin
      if FHOB_Node.StateIndex = 2 then
      begin
        FHOB_Node.StateIndex := 1;
      end;
    end;
  end
  else
  begin
    UpdateNodeState(FHOB_Node);
  end;
end;

procedure TfrmScreenObjectProperties.frameHfbBoundarybtnEditHfbHydraulicConductivityFormulaClick(
  Sender: TObject);
begin
  inherited;
  AssignHfbFormulas(frameHfbBoundary.edHydraulicConductivity);
end;

procedure TfrmScreenObjectProperties.frameHfbBoundarybtnEditHfbThicknessyFormulaClick(
  Sender: TObject);
begin
  inherited;
  AssignHfbFormulas(frameHfbBoundary.edBarrierThickness);
end;

procedure TfrmScreenObjectProperties.frameHfbMf6rdgModflowBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
begin
  inherited;
  AssignTransientHfbFormulas(ARow, ACol);
end;

procedure TfrmScreenObjectProperties.frameHfbMf6rdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FHFB_Node);
  frameHfbMf6.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);

end;

procedure TfrmScreenObjectProperties.frameHfbMf6rgAngleAdjustmentClick(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FHFB_Node);
end;

procedure TfrmScreenObjectProperties.frameHfbMf6seNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameHfbMf6.seNumberOfTimesChange(Sender);
  UpdateNodeState(FHFB_Node);
end;

procedure TfrmScreenObjectProperties.frameHydmodclbBasicClickCheck(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FHydmod_Node);
end;

procedure TfrmScreenObjectProperties.frameHydmodclbSFRClickCheck(
  Sender: TObject);
begin
  inherited;
  frameHydmod.clbSFRClickCheck(Sender);
  UpdateNodeState(FHydmod_Node);

end;

procedure TfrmScreenObjectProperties.frameHydmodclbSubClickCheck(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FHydmod_Node);

end;

procedure TfrmScreenObjectProperties.frameHydmodcomboLayerGroupChange(
  Sender: TObject);
begin
  inherited;
  frameHydmod.comboLayerGroupChange(Sender);

end;

procedure TfrmScreenObjectProperties.frameHydmodcomboNoDelayBedChange(
  Sender: TObject);
begin
  inherited;
  frameHydmod.comboNoDelayBedChange(Sender);

end;

procedure TfrmScreenObjectProperties.frameIfacerbHorizontalClick(
  Sender: TObject);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  RadioButton: TRadioButton;
begin
  inherited;
  if IsLoaded then
  begin
    RadioButton := Sender as TRadioButton;
    if RadioButton.Checked then
    begin
      frameIface.IFACE := TIface(RadioButton.Tag + 2);
    end;
    if frameIface.IFACE <> iIndeterminant then
    begin
      for Index := 0 to FNewProperties.Count - 1 do
      begin
        Item := FNewProperties[Index];
        Item.ScreenObject.IFACE := frameIface.IFACE;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameLakcbGagDeltaClick(Sender: TObject);
begin
  inherited;
  frameLak.cbGagDeltaClick(frameLak.cbGagDelta);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakcbGage4Click(Sender: TObject);
begin
  inherited;
  frameLak.cbGage4Click(frameLak.cbGage4);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakcbGagFluxAndCondClick(
  Sender: TObject);
begin
  inherited;
  frameLak.cbGagFluxAndCondClick(frameLak.cbGagFluxAndCond);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakcbGagStandardClick(
  Sender: TObject);
begin
  inherited;
  frameLak.cbGagStandardClick(frameLak.cbGagStandard);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FLAK_Node);
  frameLak.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  if not frameLak.rdgModflowBoundary.DistributingText then
  begin
    StoreLakBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameLakfeLakeBathymetryChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FLAK_Node);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakrdeCenterLakeChange(
  Sender: TObject);
begin
  inherited;
  frameLak.rdeCenterLakeChange(Sender);
  UpdateNodeState(FLAK_Node);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakrdeInitialStageChange(
  Sender: TObject);
begin
  inherited;
  UpdateNodeState(FLAK_Node);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakrdeLakeIDChange(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FLAK_Node);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakrdeSillChange(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FLAK_Node);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakrdgLakeTableEndUpdate(
  Sender: TObject);
begin
  inherited;

  if IsLoaded then
  begin
    UpdateNodeState(FLAK_Node);
    StoreLakBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameLakrgBathChoiceClick(Sender: TObject);
begin
  inherited;
  UpdateNodeState(FLAK_Node);
  frameLak.rgBathChoiceClick(Sender);
  StoreLakBoundary;
end;

procedure TfrmScreenObjectProperties.frameLakseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameLak.seNumberOfTimesChange(Sender);
  StoreLakBoundary;
end;


procedure TfrmScreenObjectProperties.frameMNW2pcMnw2Change(Sender: TObject);
begin
  inherited;
  HelpKeyWord := frameMNW2.pcMnw2.ActivePage.HelpKeyword;
  btnHelp.HelpKeyword := HelpKeyWord;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlescbLeftFaceClick(
  Sender: TObject);
begin
  inherited;
  if IsLoaded then
  begin
    (Sender as TCheckBox).AllowGrayed := False;
    frameModpathParticles.CreateParticles;
    StoreModPath;
  end;
end;
//
procedure TfrmScreenObjectProperties.frameModpathParticlesgbParticlesCheckBoxClick(
  Sender: TObject);
var
  Check: TCheckBox;
  Index: Integer;
  GB: TJvGroupBox;
begin
  inherited;
  frameModpathParticles.gbParticlesCheckBoxClick(Sender);
  GB := frameModpathParticles.gbParticles;
  GB.Handle;
  Check := GB.Components[0] as TCheckBox;
  for Index := 0 to GB.ControlCount - 1 do
  begin
    if GB.Controls[Index] <> Check then
    begin
      GB.Controls[Index].Enabled := Check.State <> cbUnChecked;
    end;
  end;
  if IsLoaded then
  begin
    Check.AllowGrayed := False;
    frameModpathParticles.CreateParticles;
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesrdgSpecificSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    frameModpathParticles.CreateParticles;
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.StoreModPath;
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  ScreenObject: TScreenObject;
  Particles: TParticleStorage;
  GridParticles: TGridDistribution;
  CylinderParticles: TCylSphereDistribution;
  SphereParticles: TCylSphereDistribution;
  CustomParticles: TParticles;
  RowIndex: Integer;
  Grid: TRbwDataGrid4;
  X: double;
  Y: double;
  Z: double;
  ParticleItem: TParticleLocation;
  TimeItem: TModpathTimeItem;
  DeleteRowList: TIntegerList;
  Time: double;
  RowAdded: Boolean;
  CheckBox: TCheckBox;
  ParticleCount: Integer;
begin
  if IsLoaded  and (FNewProperties <> nil) then
  begin
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      ScreenObject := Item.ScreenObject;
      Particles := ScreenObject.ModpathParticles;
      CheckBox := frameModpathParticles.gbParticles.Components[0] as TCheckBox;
      case CheckBox.State of
        cbUnchecked: Particles.Used := False;
        cbChecked: Particles.Used := True;
        cbGrayed: ; // do nothing
        else Assert(False);
      end;
      if Particles.Used then
      begin
        if frameModpathParticles.rgChoice.ItemIndex >= 0 then
        begin
          Particles.ParticleDistribution :=
            TParticleDistribution(frameModpathParticles.rgChoice.ItemIndex);
        end;
        case Particles.ParticleDistribution of
          pdGrid:
            begin
              GridParticles := Particles.GridParticles;
              if frameModpathParticles.cbLeftFace.State <> cbGrayed then
              begin
                GridParticles.LeftFace :=
                  frameModpathParticles.cbLeftFace.Checked;
              end;
              if frameModpathParticles.cbRightFace.State <> cbGrayed then
              begin
                GridParticles.RightFace :=
                  frameModpathParticles.cbRightFace.Checked;
              end;
              if frameModpathParticles.cbBackFace.State <> cbGrayed then
              begin
                GridParticles.BackFace :=
                  frameModpathParticles.cbBackFace.Checked;
              end;
              if frameModpathParticles.cbFrontFace.State <> cbGrayed then
              begin
                GridParticles.FrontFace :=
                  frameModpathParticles.cbFrontFace.Checked;
              end;
              if frameModpathParticles.cbBottomFace.State <> cbGrayed then
              begin
                GridParticles.BottomFace :=
                  frameModpathParticles.cbBottomFace.Checked;
              end;
              if frameModpathParticles.cbTopFace.State <> cbGrayed then
              begin
                GridParticles.TopFace :=
                  frameModpathParticles.cbTopFace.Checked;
              end;
              if frameModpathParticles.cbInternal.State <> cbGrayed then
              begin
                GridParticles.Internal :=
                  frameModpathParticles.cbInternal.Checked;
              end;
              if frameModpathParticles.seX.AsInteger > 0 then
              begin
                GridParticles.XCount := frameModpathParticles.seX.AsInteger;
              end;
              if frameModpathParticles.seY.AsInteger > 0 then
              begin
                GridParticles.YCount := frameModpathParticles.seY.AsInteger;
              end;
              if frameModpathParticles.seZ.AsInteger > 0 then
              begin
                GridParticles.ZCount := frameModpathParticles.seZ.AsInteger;
              end;
            end;
          pdCylinder:
            begin
              CylinderParticles := Particles.CylinderParticles;
              if frameModpathParticles.rgCylinderOrientation.ItemIndex >= 0 then
              begin
                CylinderParticles.Orientation :=
                  TParticleGroupOrientation(frameModpathParticles.
                  rgCylinderOrientation.ItemIndex);
              end;
              if frameModpathParticles.seCylParticleCount.AsInteger > 0 then
              begin
                CylinderParticles.CircleParticleCount :=
                  frameModpathParticles.seCylParticleCount.AsInteger;
              end;
              if frameModpathParticles.seCylLayerCount.AsInteger > 0 then
              begin
                CylinderParticles.LayerCount :=
                  frameModpathParticles.seCylLayerCount.AsInteger;
              end;
              if frameModpathParticles.seCylRadius.Value > 0 then
              begin
                CylinderParticles.Radius :=
                  frameModpathParticles.seCylRadius.Value;
              end;
            end;
          pdSphere:
            begin
              SphereParticles := Particles.SphereParticles;
              if frameModpathParticles.rgSphereOrientation.ItemIndex >= 0 then
              begin
                SphereParticles.Orientation :=
                  TParticleGroupOrientation(frameModpathParticles.
                  rgSphereOrientation.ItemIndex);
              end;
              if frameModpathParticles.seSphereParticleCount.AsInteger > 0 then
              begin
                SphereParticles.CircleParticleCount :=
                  frameModpathParticles.seSphereParticleCount.AsInteger;
              end;
              if frameModpathParticles.seSphereLayerCount.AsInteger > 0 then
              begin
                SphereParticles.LayerCount :=
                  frameModpathParticles.seSphereLayerCount.AsInteger;
              end;
              if frameModpathParticles.seSphereRadius.Value > 0 then
              begin
                SphereParticles.Radius :=
                  frameModpathParticles.seSphereRadius.Value;
              end;
            end;
          pdIndividual:
            begin
              if frameModpathParticles.seSpecificParticleCount.AsInteger > 0 then
              begin
                CustomParticles := Particles.CustomParticles;
                Grid := frameModpathParticles.rdgSpecific;
                DeleteRowList := TIntegerList.Create;
                try
                  for RowIndex := 1 to Grid.RowCount -1 do
                  begin
                    RowAdded := False;
                    while RowIndex-1 >= CustomParticles.Count do
                    begin
                      CustomParticles.Add;
                      RowAdded := True;
                    end;
                  
                    if TryStrToFloat(Grid.Cells[1,RowIndex], X)
                      and TryStrToFloat(Grid.Cells[2,RowIndex], Y)
                      and TryStrToFloat(Grid.Cells[3,RowIndex], Z) then
                    begin
                      ParticleItem := CustomParticles.Items[RowIndex-1] as TParticleLocation;
                      ParticleItem.X := X;
                      ParticleItem.Y := Y;
                      ParticleItem.Z := Z;
                    end
                    else if RowAdded then
                    begin
                      DeleteRowList.Add(RowIndex);
                    end;
                  end;
                  for RowIndex := DeleteRowList.Count - 1 downto 0 do
                  begin
                    CustomParticles.Delete(DeleteRowList[RowIndex]-1);
                  end;
                finally
                  DeleteRowList.Free;
                end;
              end;
            end;
          pdObjectLocation:
            begin

            end
          else Assert(False);
        end;
        if frameModpathParticles.seTimeCount.AsInteger >= 1 then
        begin
          ParticleCount := 0;
          for RowIndex := 0 to frameModpathParticles.seTimeCount.AsInteger - 1 do
          begin
            if tryStrToFloat(frameModpathParticles.rdgReleaseTimes.Cells[1,RowIndex+1], Time) then
            begin
              while ParticleCount >= Particles.ReleaseTimes.Count do
              begin
                Particles.ReleaseTimes.Add;
              end;
              TimeItem := Particles.ReleaseTimes.Items[ParticleCount] as TModpathTimeItem;
              TimeItem.Time := Time;
              Inc(ParticleCount);
            end
          end;
          while Particles.ReleaseTimes.Count > ParticleCount do
          begin
            Particles.ReleaseTimes.Delete(Particles.ReleaseTimes.Count-1);
          end;
        end
        else
        begin
          Particles.ReleaseTimes.Clear;
        end;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesrgChoiceClick(
  Sender: TObject);
begin
  inherited;
  if frameModpathParticles.rgChoice.ItemIndex >= 0 then
  begin
    frameModpathParticles.plParticlePlacement.ActivePageIndex :=
      frameModpathParticles.rgChoice.ItemIndex;
    if IsLoaded then
    begin
      frameModpathParticles.CreateParticles;
    end;
  end
  else
  begin
    frameModpathParticles.plParticlePlacement.ActivePage
      := frameModpathParticles.jvspBlank;
  end;
  StoreModPath;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesrgCylinderOrientationClick(
  Sender: TObject);
begin
  inherited;
  if isLoaded then
  begin
    frameModpathParticles.CreateParticles;
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesseCylRadiusClick(
  Sender: TObject);
begin
  inherited;
  if IsLoaded then
  begin
    frameModpathParticles.CreateParticles;
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesseSpecificParticleCountChange(
  Sender: TObject);
begin
  inherited;
  frameModpathParticles.UpdateRowCount;
  frameModpathParticles.seSpecificParticleCount.MinValue := 0;
  frameModpathParticles.CreateParticles;
  if IsLoaded then
  begin
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesseTimeCountChange(
  Sender: TObject);
begin
  inherited;
  if IsLoaded then
  begin
    frameModpathParticles.UpdateTimeRowCount;
    frameModpathParticles.seTimeCount.MinValue := 1;
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.frameModpathParticlesseXChange(
  Sender: TObject);
begin
  inherited;
  if IsLoaded then
  begin
    if Sender = frameModpathParticles.seSphereLayerCount then
    begin
      frameModpathParticles.seSphereLayerCount.MinValue := 2;
    end
    else
    begin
      (Sender as TJvSpinEdit).MinValue := 1;
    end;
    frameModpathParticles.CreateParticles;
    StoreModPath;
  end;
end;

procedure TfrmScreenObjectProperties.frameMT3DMScbMassLoadingClick(
  Sender: TObject);
begin
  inherited;
  frameMT3DMS_SSM.cbMassLoadingClick(Sender);
  StoreMt3dmsChemBoundary;
end;

procedure TfrmScreenObjectProperties.frameMT3DMScbSpecifiedConcentrationClick(
  Sender: TObject);
begin
  inherited;
  frameMT3DMS_SSM.cbSpecifiedConcentrationClick(Sender);
  StoreMt3dmsChemBoundary;
end;

procedure TfrmScreenObjectProperties.frameMT3DMSdgModflowBoundaryEndUpdate(
  Sender: TObject);
begin
  inherited;
  StoreMt3dmsChemBoundary;
end;

procedure TfrmScreenObjectProperties.frameMT3DMSdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FMt3dmsSsm_Node);
  frameMT3DMS_SSM.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
    if not frameMT3DMS_SSM.rdgModflowBoundary.DistributingText then
  begin
    StoreMt3dmsChemBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameMt3dmsFluxObsrdgObservationGroupsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if IsLoaded then
  begin
    FMt3dmsTobFlux_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameMt3dmsFluxObsrdgObservationGroupsStateChange(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
begin
  inherited;
  if IsLoaded then
  begin
    FMt3dmsTobFlux_Node.StateIndex := 2;
  end;
end;

procedure TfrmScreenObjectProperties.frameMT3DMSseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameMT3DMS_SSM.seNumberOfTimesChange(Sender);
  StoreMt3dmsChemBoundary;
end;

procedure TfrmScreenObjectProperties.frameMt3dmsTobConcrdgObservationsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMt3dmsTobConc.rdgObservationsSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3dmsTobConc_Node);
end;

procedure TfrmScreenObjectProperties.frameMt3dmsTobConcseTimesChange(
  Sender: TObject);
begin
  inherited;
  frameMt3dmsTobConc.seTimesChange(Sender);
  if frameMt3dmsTobConc.seTimes.asInteger = 0 then
  begin
    if IsLoaded  and (FMt3dmsTobConc_Node <> nil) then
    begin
      if FMt3dmsTobConc_Node.StateIndex = 2 then
      begin
        FMt3dmsTobConc_Node.StateIndex := 1;
      end;
    end;
  end
  else
  begin
    UpdateNodeState(FMt3dmsTobConc_Node);
  end;
end;

procedure TfrmScreenObjectProperties.frameMT3D_LKTrdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMT3D_LKT.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_LKT_Node);
end;

procedure TfrmScreenObjectProperties.frameMT3D_LKTrdgRunoffConcSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMT3D_LKT.rdgRunoffConcSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_LKT_Node);
end;

procedure TfrmScreenObjectProperties.frameMT3D_SFTrdgConstConcSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMT3D_SFT.rdgConstConcSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_SFT_Node);
end;

procedure TfrmScreenObjectProperties.frameMT3D_SFTrdgModflowBoundarySelectCell(
  Sender: TObject; ACol, ARow: Integer; var CanSelect: Boolean);
begin
  inherited;
  frameMT3D_SFT.rdgModflowBoundarySelectCell(Sender, ACol, ARow, CanSelect);

end;

procedure TfrmScreenObjectProperties.frameMT3D_SFTrdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMT3D_SFT.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_SFT_Node);
end;

procedure TfrmScreenObjectProperties.frameMT3D_SFTrdgPrecipSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMT3D_SFT.rdgPrecipSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_SFT_Node);
end;

procedure TfrmScreenObjectProperties.frameMT3D_SFTrdgRunoffSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameMT3D_SFT.rdgRunoffSetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_SFT_Node);
end;

procedure TfrmScreenObjectProperties.frameMT3D_SFTrdgSftInitConcAndDispSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
//  frameMT3D_SFT.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FMt3d_SFT_Node);

end;

procedure TfrmScreenObjectProperties.frameMT3D_Uzf_SeepagedgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
//  frameMT3D_Uzf_Seepage.rdgModflowBoundarySetEditText(Sender, ACol, ARow,
//  Value);
  UpdateNodeState(FMt3d_Uzf_Seep_Node);
  frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
    if not frameMT3D_Uzf_Ssm_Conc.rdgModflowBoundary.DistributingText then
  begin
    StoreMt3dUzfSeepageConcBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameMt3d_UZTdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FMt3d_UZT_Rech_Node);
  frameMt3d_UZT_Rech.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
    if not frameMt3d_UZT_Rech.rdgModflowBoundary.DistributingText then
  begin
    StoreMt3d_UztRechBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameMt3d_UZT_SatdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FMt3d_UZT_Sat_Node);
  frameMt3d_UZT_Sat.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
    if not frameMt3d_UZT_Sat.rdgModflowBoundary.DistributingText then
  begin
    StoreMt3d_UztSatBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameMt3d_UZT_UnsatdgModflowBoundarySetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  UpdateNodeState(FMt3d_UZT_Unsat_Node);
  frameMt3d_UZT_Unsat.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
    if not frameMt3d_UZT_Unsat.rdgModflowBoundary.DistributingText then
  begin
    StoreMt3d_UztUnsatBoundary;
  end;
end;

procedure TfrmScreenObjectProperties.frameMVRrdgModflowBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
begin
  inherited;
  if TSourcePackageChoice(frameMVR.comboSourcePackage.ItemIndex) <> spcLak then
  begin
    frameChdParamdgModflowBoundaryButtonClick(Sender, ACol, ARow);
  end
  else
  begin
    frameResdgModflowBoundaryButtonClick(Sender, ACol, ARow);
  end;
end;

procedure TfrmScreenObjectProperties.frameMVRseNumberOfTimesChange(
  Sender: TObject);
begin
  inherited;
  frameMVR.seNumberOfTimesChange(Sender);

end;

procedure TfrmScreenObjectProperties.frameObsMf6pgcMainChange(Sender: TObject);
begin
  inherited;
  if frameObsMf6.pgcMain.ActivePage = frameObsMf6.tabMAW then
  begin
    UpdateMawScrollWidth;
  end;
  if frameObsMf6.pgcMain.ActivePage = frameObsMf6.tabUZF then
  begin
    UpdateUzfScrollWidth;
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariescbPhastInterpolationClick(Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  framePhastInterpolationBoundaries.cbPhastInterpolationClick(Sender);
  if (FBoundaryCol < FBoundaryGrid.ColCount) and (FBoundaryRow < FBoundaryGrid.RowCount) then
  begin
    FBoundaryGrid.Checked[FBoundaryCol, FBoundaryRow] :=
      framePhastInterpolationBoundaries.cbPhastInterpolation.Checked;
    InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
      TInterpValuesCollection;
  end
  else
  begin
    InterpValuesCollection := nil;
  end;
  if (InterpValuesCollection <> nil)  then
  begin
    for Index := 0 to InterpValuesCollection.Count - 1 do
    begin
      InterpValuesItem := InterpValuesCollection.Items[Index] as
        TInterpValuesItem;
      InterpValuesItem.Values.UsePHAST_Interpolation :=
        framePhastInterpolationBoundaries.cbPhastInterpolation.Checked;
    end;
    if framePhastInterpolationBoundaries.cbPhastInterpolation.Checked then
    begin
      framePhastInterpolationData.AssigningValues := True;
      framePhastInterpolationBoundaries.GetFirstData((InterpValuesCollection.
        Items[0] as TInterpValuesItem).Values);
      framePhastInterpolationData.AssigningValues := False;
      for Index := 1 to InterpValuesCollection.Count - 1 do
      begin
        framePhastInterpolationData.AssigningValues := True;
        framePhastInterpolationBoundaries.GetMoreData((InterpValuesCollection.
          Items[Index] as TInterpValuesItem).Values);
        framePhastInterpolationData.AssigningValues := False;
      end;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.StorePhastLeakyBoundary;
var
  Item: TScreenObjectEditItem;
  LeakyBoundary: TLeakyBoundary;
  DataGrid: TRbwDataGrid4;
  Boundary: TCustomInterpolatedBoundary;
begin
  if IsLoaded then
  begin
    Assert(FNewProperties.Count = 1);
    Assert(comboSolutionType.ItemIndex >= 0);
    Item := FNewProperties.Items[0];
    LeakyBoundary := Item.ScreenObject.LeakyBoundary;
    LeakyBoundary.Clear;

    LeakyBoundary.Model := frmGoPhast.PhastModel;
    try
      LeakyBoundary.HydraulicConductivity := edLeakyHydraulicConductivity.Text;
      LeakyBoundary.Thickness := edLeakyThickness.Text;
    finally
      LeakyBoundary.Model := nil;
    end;

    Boundary := LeakyBoundary;
    DataGrid := dgBoundaryLeaky;
    StoreInterpolatedBoundary(Boundary, DataGrid);
  end;
end;

procedure TfrmScreenObjectProperties.StorePhastSpecifiedFlux;
var
  Item: TScreenObjectEditItem;
  FluxBoundary: TFluxBoundary;
  DataGrid: TRbwDataGrid4;
  Boundary: TCustomInterpolatedBoundary;
begin
  if IsLoaded then
  begin
    Assert(FNewProperties.Count = 1);
    Item := FNewProperties.Items[0];
    FluxBoundary := Item.ScreenObject.FluxBoundary;
    FluxBoundary.Clear;

    Boundary := FluxBoundary;
    DataGrid := dgBoundaryFlux;
    StoreInterpolatedBoundary(Boundary, DataGrid);
  end;
end;

procedure TfrmScreenObjectProperties.StorePhastRiverBoundary;
var
  Item: TScreenObjectEditItem;
  RiverBoundary: TRiverBoundary;
  DataGrid: TRbwDataGrid4;
  Boundary: TCustomInterpolatedBoundary;
begin
  if IsLoaded then
  begin
    Assert(FNewProperties.Count = 1);
    Item := FNewProperties.Items[0];
    RiverBoundary := Item.ScreenObject.RiverBoundary;
    RiverBoundary.Clear;

    RiverBoundary.Model := frmGoPhast.PhastModel;
    try
      RiverBoundary.BedHydraulicConductivity :=
        edRiverHydraulicConductivity.Text;
      RiverBoundary.BedThickness := edRiverBedThickness.Text;
      RiverBoundary.Depth := edRiverDepth.Text;
      RiverBoundary.Width := edRiverWidth.Text;
      RiverBoundary.Description := edRiverDescripton.Text;
    finally
      RiverBoundary.Model := nil;
    end;

    Boundary := RiverBoundary;
    DataGrid := dgBoundaryRiver;
    StoreNonInterpolatedBoundary(Boundary, DataGrid);
  end;
end;

procedure TfrmScreenObjectProperties.StorePhastWellBoundary;
var
  Item: TScreenObjectEditItem;
  WellBoundary: TWellBoundary;
  DataGrid: TRbwDataGrid4;
  Boundary: TCustomInterpolatedBoundary;
  NewValue: Extended;
  FirstElevation: Extended;
  Index: Integer;
  SecondElevation: Extended;
  WellInterval: TWellInterval;
begin
  if IsLoaded then
  begin
    Assert(FNewProperties.Count = 1);
    Item := FNewProperties.Items[0];
    WellBoundary := Item.ScreenObject.WellBoundary;
    WellBoundary.Clear;

    WellBoundary.Model := frmGoPhast.PhastModel;
    try
      WellBoundary.AllocateByPressureAndMobility :=
        cbWellPumpAllocation.Checked;
      WellBoundary.Description := edWellDescription.Text;
      if TryStrToFloat(rdeWellDiameter.Text, NewValue) then
      begin
        WellBoundary.Diameter := NewValue;
      end;
      if TryStrToFloat(rdeWellLandSurfaceDatum.Text, NewValue) then
      begin
        WellBoundary.LandSurfaceDatum := NewValue;
      end;
      if comboWellIntervalStyle.ItemIndex >= 0 then
      begin
        WellBoundary.WellElevationFormat :=
          TWellElevationFormat(comboWellIntervalStyle.ItemIndex);
      end;

      for Index := 1 to dgWellElevations.RowCount - 1 do
      begin
        if (dgWellElevations.Cells[Ord(wicFirst), Index] <> '')
        and (dgWellElevations.Cells[Ord(wicSecond), Index] <> '') then
        begin
          if not TryStrToFloat(dgWellElevations.Cells[Ord(wicFirst),
              Index], FirstElevation) then
          begin
            Continue;
          end;

          if not TryStrToFloat(dgWellElevations.Cells[Ord(wicSecond),
              Index], SecondElevation) then
          begin
            Continue;
          end;

          WellInterval := WellBoundary.Intervals.Add as TWellInterval;
          WellInterval.FirstElevation := FirstElevation;
          WellInterval.SecondElevation := SecondElevation;
        end;
      end
    finally
      WellBoundary.Model := nil;
    end;

    Boundary := WellBoundary;
    DataGrid := dgWell;
    StoreNonInterpolatedBoundary(Boundary, DataGrid);
  end;
end;

procedure TfrmScreenObjectProperties.StorePhastSpecifiedHeads;
var
  Item: TScreenObjectEditItem;
  HeadBoundary: TSpecifiedHeadBoundary;
  DataGrid: TRbwDataGrid4;
  Boundary: TCustomInterpolatedBoundary;
begin
  if IsLoaded then
  begin
    Assert(FNewProperties.Count = 1);
    Assert(comboSolutionType.ItemIndex >= 0);
    Item := FNewProperties.Items[0];
    HeadBoundary := Item.ScreenObject.SpecifiedHeadBoundary;
    HeadBoundary.Clear;

    HeadBoundary.Model := frmGoPhast.PhastModel;
    try
      HeadBoundary.SolutionType := TSolutionType(
        comboSolutionType.ItemIndex);
    finally
      HeadBoundary.Model := nil;
    end;

    Boundary := HeadBoundary;
    DataGrid := dgSpecifiedHead;
    StoreInterpolatedBoundary(Boundary, DataGrid);
  end;
end;

procedure TfrmScreenObjectProperties.dgBoundaryStateChanged(
  Sender: TObject; ACol, ARow: Integer; const Value: TCheckBoxState);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  CanSelectDummy: boolean;
  StoredAssigningValues: boolean;
begin
  inherited;
    // update the displayed PHAST-style Interpolation when the use clicks one of the
    // check boxes in a boundary table.
  if not IsLoaded then
    Exit;
  StoredAssigningValues := framePhastInterpolationData.AssigningValues;
  framePhastInterpolationData.AssigningValues := True;
  framePhastInterpolationBoundaries.cbPhastInterpolation.Checked :=
    (Sender as TRbwDataGrid4).Checked[ACol, ARow];
  framePhastInterpolationBoundaries.cbPhastInterpolationClick(nil);
  framePhastInterpolationData.AssigningValues := StoredAssigningValues;
  InterpValuesCollection := (Sender as TRbwDataGrid4).Objects[ACol, ARow] as
    TInterpValuesCollection;

  if framePhastInterpolationBoundaries.cbPhastInterpolation.Checked then
  begin
    if InterpValuesCollection <> nil then
    begin
      (InterpValuesCollection.
        Items[0] as TInterpValuesItem).Values.UsePHAST_Interpolation := True;
      framePhastInterpolationData.AssigningValues := True;
      framePhastInterpolationBoundaries.GetFirstData((InterpValuesCollection.
        Items[0] as TInterpValuesItem).Values);
      framePhastInterpolationData.AssigningValues := False;
      for Index := 1 to InterpValuesCollection.Count - 1 do
      begin
        framePhastInterpolationData.AssigningValues := True;
        framePhastInterpolationBoundaries.GetMoreData((InterpValuesCollection.
          Items[Index] as TInterpValuesItem).Values);
        framePhastInterpolationData.AssigningValues := False;
      end;
    end;

    CanSelectDummy := False;
    dgBoundarySelectCell(Sender, ACol, ARow, CanSelectDummy);

  end;
  StorePhastBoundary;
end;

procedure TfrmScreenObjectProperties.dgSpecifiedHeadDistributeTextProgress(
  Sender: TObject; Position, Max: Integer);
begin
  inherited;
  seBoundaryTimes.AsInteger := dgSpecifiedHead.RowCount -1;
  seBoundaryTimesChange(nil);
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariesrgInterpolationDirectionClick(
  Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
    // respond the the user clicking on the interpolation direction radio
    // buttons for a boundary condition.
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  framePhastInterpolationBoundaries.rgInterpolationDirectionClick(Sender);
  InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
    TInterpValuesCollection;
  if InterpValuesCollection <> nil then
  begin
    for Index := 0 to InterpValuesCollection.Count - 1 do
    begin
      InterpValuesItem := InterpValuesCollection.Items[Index] as
        TInterpValuesItem;
      InterpValuesItem.Values.InterpolationDirection :=
        TInterpolationDirection(framePhastInterpolationBoundaries.
        rgInterpolationDirection.ItemIndex);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariesrdeDistance1Exit(Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
    // Respond to the user finishing editing the PHAST-style Interpolation Distance 1
    // for a boundary condition.
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
    TInterpValuesCollection;
  for Index := 0 to InterpValuesCollection.Count - 1 do
  begin
    InterpValuesItem := InterpValuesCollection.Items[Index] as
      TInterpValuesItem;
    InterpValuesItem.Values.Distance1 :=
      StrToFloat(framePhastInterpolationBoundaries.rdeDistance1.Text);
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariesrdeDistance2Exit(Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
    // Respond to the user finishing editing the PHAST-style Interpolation Distance 2
    // for a boundary condition.
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
    TInterpValuesCollection;
  for Index := 0 to InterpValuesCollection.Count - 1 do
  begin
    InterpValuesItem := InterpValuesCollection.Items[Index] as
      TInterpValuesItem;
    InterpValuesItem.Values.Distance2 :=
      StrToFloat(framePhastInterpolationBoundaries.rdeDistance2.Text);
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariesrdeValue1Exit(Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
    // Respond to the user finishing editing the PHAST-style Interpolation value 1
    // for a boundary condition.
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
    TInterpValuesCollection;
  for Index := 0 to InterpValuesCollection.Count - 1 do
  begin
    InterpValuesItem := InterpValuesCollection.Items[Index] as
      TInterpValuesItem;
    if framePhastInterpolationBoundaries.rdeValue1.DataType = dtInteger then
    begin
      InterpValuesItem.Values.IntValue1 :=
        StrToInt(framePhastInterpolationBoundaries.rdeValue1.Text);
    end
    else if framePhastInterpolationBoundaries.rdeValue1.DataType = dtReal then
    begin
      InterpValuesItem.Values.RealValue1 :=
        StrToFloat(framePhastInterpolationBoundaries.rdeValue1.Text);
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariesrdeValue2Exit(Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
    // Respond to the user finishing editing the PHAST-style Interpolation value 2
    // for a boundary condition.
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
    TInterpValuesCollection;
  for Index := 0 to InterpValuesCollection.Count - 1 do
  begin
    InterpValuesItem := InterpValuesCollection.Items[Index] as
      TInterpValuesItem;
    if framePhastInterpolationBoundaries.rdeValue2.DataType = dtInteger then
    begin
      InterpValuesItem.Values.IntValue2 :=
        StrToInt(framePhastInterpolationBoundaries.rdeValue2.Text);
    end
    else if framePhastInterpolationBoundaries.rdeValue2.DataType = dtReal then
    begin
      InterpValuesItem.Values.RealValue2 :=
        StrToFloat(framePhastInterpolationBoundaries.rdeValue2.Text);
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

procedure TfrmScreenObjectProperties.dgBoundaryButtonClick(
  Sender: TObject; ACol, ARow: Integer);
var
  VariableList: TList;
  Orientation: TDataSetOrientation;
  DataGrid: TRbwDataGrid4;
  EvaluatedAt: TEvaluatedAt;
  Index: integer;
  DataSet: TDataArray;
  NewValue: string;
  Variable: TCustomValue;
  Edit: TScreenObjectDataEdit;
  DataArrayManager: TDataArrayManager;
begin
  inherited;
  DataGrid := Sender as TRbwDataGrid4;
  VariableList := TList.Create;
  // VariableList will hold a list of variables that can
  // be used in the function
  try
    // get the orientation of the data set.
    if (DataGrid = dgSpecifiedHead) or {(DataGrid = dgSpecifiedSolution) or}
    (DataGrid = dgBoundaryFlux) or (DataGrid = dgBoundaryLeaky) then
    begin
      Orientation := dso3D;
    end
    else if (DataGrid = dgBoundaryRiver) or (DataGrid = dgWell) then
    begin
      Orientation := dsoTop;
    end
    else
    begin
      Assert(False);
      Orientation := dso3D;
    end;
    // All the PHAST boundary conditions are evaluated at nodes.
    EvaluatedAt := eaNodes;

    DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
    for Index := 0 to DataArrayManager.DataSetCount - 1 do
    begin
      DataSet := DataArrayManager.DataSets[Index];
      if not DataSet.Visible then
      begin
        Continue;
      end;
      if DataSet is TCustomSparseDataSet then
      begin
        Continue;
      end;
      if (EvaluatedAt = DataSet.EvaluatedAt) then
      begin
        if ((Orientation = dso3D)
          or (Orientation = DataSet.Orientation)) then
        begin
          Edit := FDataEdits[Index];
          // if the variable does not depend on the
          // data set whose formula is being edited
          // and it's orientation is OK, the variable
          // can be used in the formula.
          VariableList.Add(Edit.Variable);
        end;
      end;
    end;

    NewValue := DataGrid.Cells[ACol, ARow];
    if (NewValue = '') then
    begin
      NewValue := '0';
    end;

//    with TfrmFormula.Create(self) do
    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(eaNodes);
        RemoveGetVCont;
        RemoveHufFunctions;
        PopupParent := self;

        // register the appropriate variables with the
        // parser.
        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          rbFormulaParser.RegisterVariable(Variable);
        end;

        // show the variables and functions
        IncludeTimeSeries := False;
        UpdateTreeList;

        // put the formula in the TfrmFormula.
        Formula := NewValue;
        // The user edits the formula.
        ShowModal;
        if ResultSet then
        begin
          try
            CreateBoundaryFormula(DataGrid, ACol, ARow, Formula, Orientation,
              EvaluatedAt);
          except on E: Exception do
            begin
              Beep;
              MessageDlg(Format(StrErrorIn0sRow,
                ['A boundary package',
                ARow + 1, ACol+1, E.Message]), mtError,[mbOK], 0);
              Exit;
            end;
           end;
      end;
      finally
        Initialize;
//        Free;
      end;
    end;

  finally
    VariableList.Free;
  end;
end;

procedure TfrmScreenObjectProperties.dgBoundarySetEditText(Sender: TObject;
  ACol, ARow: Integer; const Value: string);
begin
  inherited;
  if FDeletingPhastTime then
  begin
    Exit;
  end;
  StorePhastBoundary;
end;

procedure TfrmScreenObjectProperties.edLeakyHydraulicConductivityExit(
  Sender: TObject);
begin
  inherited;
  ValidateEdFormula(Sender as TEdit);
  StorePhastLeakyBoundary;
end;

procedure TfrmScreenObjectProperties.edRiverDescriptonExit(Sender: TObject);
begin
  inherited;
  StorePhastRiverBoundary;
end;

procedure TfrmScreenObjectProperties.edRiverExit(Sender: TObject);
begin
  inherited;
  ValidateEdFormula(Sender as TEdit);
  StorePhastRiverBoundary;
end;

procedure TfrmScreenObjectProperties.edWellExit(Sender: TObject);
begin
  inherited;
  StorePhastWellBoundary;
end;

procedure TfrmScreenObjectProperties.cbWellPumpAllocationClick(Sender: TObject);
begin
  inherited;
  StorePhastWellBoundary;
end;

procedure TfrmScreenObjectProperties.dgWellDistributeTextProgress(
  Sender: TObject; Position, Max: Integer);
begin
  inherited;
  seBoundaryTimes.AsInteger := dgWell.RowCount -1;
  seBoundaryTimesChange(nil);
end;

procedure TfrmScreenObjectProperties.dgWellElevationsDistributeTextProgress(
  Sender: TObject; Position, Max: Integer);
begin
  inherited;
  seWellIntervals.AsInteger := dgWellElevations.RowCount -1;
  seWellIntervalsChange(nil);
end;

procedure TfrmScreenObjectProperties.dgWellElevationsSetEditText(
  Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  StorePhastWellBoundary;
end;

procedure TfrmScreenObjectProperties.edNameExit(Sender: TObject);
var
  AString: string;
  Changed: boolean;
  NewName: string;
  Index: Integer;
  Item: TScreenObjectEditItem;
begin
  inherited;
  // edNameExit ensures that the value given for the name of a screen object
  // is valid.
  AString := edName.Text;
  NewName := TScreenObject.ValidName(AString);
  Changed := AString <> NewName;
  if Changed then
  begin
    edName.Text := NewName
  end;
  if IsLoaded then
  begin
    for Index := 0 to FNewProperties.Count - 1 do
    begin
      Item := FNewProperties[Index];
      Item.ScreenObject.Name := NewName;
    end;
  end;
end;

procedure TfrmScreenObjectProperties.btnCancelClick(Sender: TObject);
begin
  inherited;
  // If the user hasn't changed anything, don't force the user
  // to save the model.
  frmGoPhast.PhastModel.UpToDate := FPriorModelUpToDate;
end;

procedure TfrmScreenObjectProperties.btnCaptionFontClick(Sender: TObject);
var
  AScreenObject: TScreenObject;
begin
  inherited;
  if FScreenObject <> nil then
  begin
    dlgFontCaption.Font := FScreenObject.ObjectLabel.Font;
  end
  else
  begin
    AScreenObject := FScreenObjectList[0];
    dlgFontCaption.Font := AScreenObject.ObjectLabel.Font;
  end;
  if dlgFontCaption.Execute then
  begin
    FCaptionFont.Free;
    FCaptionFont := TFont.Create;
    FCaptionFont.Assign(dlgFontCaption.Font);
    FCaptionFontChanged := True;
  end;
end;

procedure TfrmScreenObjectProperties.splitterBoundaryMoved(Sender: TObject);
begin
  inherited;
  // See FInitialWidth for details.
  if Width - pnlBoundaries.Width < FInitialWidth then
  begin
    Width := pnlBoundaries.Width + FInitialWidth;
  end;
end;

procedure TfrmScreenObjectProperties.FormResize(Sender: TObject);
begin
  inherited;
  // See FInitialWidth for details.
  if Width - pnlBoundaries.Width < FInitialWidth then
  begin
    pnlBoundaries.Width := Width - FInitialWidth;
  end;
end;

procedure TfrmScreenObjectProperties.FormShow(Sender: TObject);
begin
  inherited;
  if frmDataSets <> nil then
  begin
    frmDataSets.Close;
  end;
  HelpKeyword := 'Object_Properties_Dialog_Box';
  frameScreenObjectSFR.zbChannel.InvalidateImage32;
  frameScreenObjectSFR.zbFlowDepthTable.InvalidateImage32;
  frameScreenObjectSFR.zbFlowWidthTable.InvalidateImage32;
  FCanSetPointsOutOfDate := True;
  HideGLViewersWithMicrosoftOpenGL;
end;

procedure TfrmScreenObjectProperties.comboSolutionTypeChange(Sender: TObject);
var
  NewTitle: string;
begin
  inherited;
  case comboSolutionType.ItemIndex of
    Ord(stAssociated):
      begin
        NewTitle := StrAssociatedSolution;
      end;
    Ord(stSpecified):
      begin
        NewTitle := StrSpecifiedSolution;
      end;
  else
    begin
      NewTitle := StrSolution;
    end;
  end;

  dgSpecifiedHead.Cells[Ord(ibcSolution), 0] := NewTitle;

  StorePhastSpecifiedHeads;
end;

procedure TfrmScreenObjectProperties.framePhastInterpolationDataedMixFormulaExit(
  Sender: TObject);
var
  Index: integer;
  Item: TInterpValuesItem;
  DataSet: TDataArray;
  DSName: string;
  VariableList: TList;
  Used: TStringList;
  Orientation: TDataSetOrientation;
  EvaluatedAt: TEvaluatedAt;
  VariableName: string;
  TempUsesList: TStringList;
  VariablePosition: integer;
  OldFormula, NewValue: string;
  Variable: TCustomValue;
  Expression: TExpression;
  Tester: TRbwParser;
  OtherEdit: TScreenObjectDataEdit;
  Edit: TScreenObjectDataEdit;
  DataArrayManager: TDataArrayManager;
begin
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  if not FUpdatingCurrentEdit and (FCurrentEdit <> nil) then
  begin
    DSName := FCurrentEdit.DataArray.Name;
    VariableList := TList.Create;
    // VariableList will hold a list of variables that can
    // be used in the function
    Used := TStringList.Create;
    // "Used" will be a list of variables that depend on
    // the data set whose formula will be edited.
    try
      Orientation := FCurrentEdit.DataArray.Orientation;
      EvaluatedAt := FCurrentEdit.DataArray.EvaluatedAt;
      // Add the variable whose value is being set to "Used".

      Used.Assign(FCurrentEdit.UsedBy);

      Used.Sorted := True;
      DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
      for Index := 0 to DataArrayManager.DataSetCount - 1 do
      begin
        DataSet := DataArrayManager.DataSets[Index];
        if not DataSet.Visible then
        begin
          Continue
        end;
        if DataSet is TCustomSparseDataSet then
        begin
          Continue;
        end;
        if (DataSet <> FCurrentEdit.DataArray)
          and (EvaluatedAt = DataSet.EvaluatedAt) then
        begin
          VariableName := DataSet.Name;
          OtherEdit := FDataEdits[GetDataSetIndexByName(VariableName)];
          TempUsesList := OtherEdit.UsedBy;
          VariablePosition := TempUsesList.IndexOf(DSName);
          if (VariablePosition < 0) and ((Orientation = dso3D)
            or (Orientation = DataSet.Orientation)) then
          begin
            Edit := FDataEdits[Index];
            // if the variable does not depend on the
            // data set whose formula is being edited
            // and it's orientation is OK, the variable
            // can be used in the formula.
            VariableList.Add(Edit.Variable);
          end;
        end;
      end;

      // if the user makes an invalid formula, it
      // may be necessary to restore it but only
      // if the formula that was already present
      // was OK to begin with.
      OldFormula := FOldMixFormula;
      NewValue := framePhastInterpolationData.edMixFormula.Text;
      if (NewValue = '') then
      begin
        NewValue := FortranFloatToStr(0.5);
      end;

      Tester := TRbwParser.Create(self);
      begin
        try
          AddGIS_Functions(Tester, frmGoPhast.PhastModel.ModelSelection,
            FCurrentEdit.DataArray.EvaluatedAt);
          // put the formula in the TfrmFormula.
          //Formula := NewValue;

          // register the appropriate variables with the
          // parser.
          for Index := 0 to VariableList.Count - 1 do
          begin
            Variable := VariableList[Index];
            Tester.RegisterVariable(Variable);
          end;

          try
            Tester.Compile(NewValue);
            Expression := Tester.CurrentExpression;
            framePhastInterpolationData.edMixFormula.Text := NewValue;
          except on E: ErbwParserError do
            begin
              framePhastInterpolationData.edMixFormula.Color := clRed;
              Beep;
              if MessageDlg(StrErrorThereAppearsCirc, mtError,
                [mbYes, mbNo], 0) = mrYes then
              begin
                framePhastInterpolationData.edMixFormula.Text :=
                  OldFormula;
                Expression :=
                  CreateMixtureFormula(FDataEdits.IndexOf(FCurrentEdit));
                framePhastInterpolationData.edMixFormula.Color := clBtnFace;
              end;
              Exit;
            end;
          end;
          framePhastInterpolationData.edMixFormula.Color := clBtnFace;

          if Expression <> nil then
          begin
            // Check that the formula does not result in
            // a circular reference.

            CheckForCircularReferencesInMixtureFormulas(Expression, DSName,
              OldFormula, FDataEdits.IndexOf(FCurrentEdit));

            // update the list of which variables depend on which
            // others.;
            UpdateDataSetLinkages(Expression, FDataEdits.IndexOf(FCurrentEdit), DSName);
          end;

        finally
          Tester.Free;
        end;
      end;
    finally
      Used.Free;
      VariableList.Free;
      // Don't allow the user to click the OK button if any formulas are invalid.
      EnableOK_Button;
    end;

    FCurrentEdit.Invalidate;

    DataSet := FCurrentEdit.DataArray;
    for Index := 0 to FCurrentEdit.InterpValue.Count - 1 do
    begin
      Item := FCurrentEdit.InterpValue.Items[Index] as TInterpValuesItem;
      Item.Values.MixtureFormula :=
        framePhastInterpolationData.edMixFormula.Text;
    end;
    AssignPhastInterpolation(DataSet);
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationBoundariesedMixFormulaExit(Sender: TObject);
var
  Index: integer;
  InterpValuesCollection: TInterpValuesCollection;
  InterpValuesItem: TInterpValuesItem;
begin
  inherited;
  if framePhastInterpolationData.AssigningValues then
  begin
    Exit;
  end;
  InterpValuesCollection := FBoundaryGrid.Objects[FBoundaryCol, FBoundaryRow] as
    TInterpValuesCollection;
  for Index := 0 to InterpValuesCollection.Count - 1 do
  begin
    InterpValuesItem := InterpValuesCollection.Items[Index] as
      TInterpValuesItem;
    InterpValuesItem.Values.MixtureFormula :=
      framePhastInterpolationBoundaries.edMixFormula.Text;
  end;
end;

procedure TfrmScreenObjectProperties.StorePestModifiers(
  Frame: TframeScreenObjectParam; ParamType: TParameterType;
  Node: TJvPageIndexNode);
var
  Index: Integer;
  Item: TScreenObjectEditItem;
  Boundary: TModflowParamBoundary;
  BoundaryValues: TCustomMF_BoundColl;
  DataGrid: TRbwDataGrid4;
  BoundaryIndex: Integer;
  Modifier: string;
  ColumnOffset: Integer;
  BoundaryCount: Integer;
begin
  if (Node = nil) then
  begin
    Exit;
  end;

  Assert(Node <> nil);
  DataGrid := Frame.rdgModflowBoundary;

  for Index := 0 to FNewProperties.Count - 1 do
  begin
    Item := FNewProperties[Index];
    Boundary := Item.ScreenObject.GetMfBoundary(ParamType);
    Assert(Boundary <> nil);
    if ShouldStoreBoundary(Node, Boundary) then
    begin
      ColumnOffset := 2;
      BoundaryValues := Boundary.Values;
      BoundaryCount := BoundaryValues.TimeListCount(frmGoPhast.PhastModel);
      for BoundaryIndex := 0 to BoundaryCount - 1 do
      begin
        if DataGrid.Cells[ColumnOffset+BoundaryIndex,PestMethodRow] <> '' then
        begin
          Boundary.PestBoundaryMethod[BoundaryIndex] :=
            PestMethod[DataGrid, ColumnOffset+BoundaryIndex];
        end;
        if PestModifierAssigned[DataGrid, ColumnOffset+BoundaryIndex] then
        begin
          Modifier := PestModifier[DataGrid, ColumnOffset+BoundaryIndex];
          Boundary.PestBoundaryFormula[BoundaryIndex] := Modifier;
        end;
      end;
    end;
  end;

end;

procedure TfrmScreenObjectProperties.StorePhastBoundary;
var
  NewBoundaryType: TPhastBoundaryTypes;
begin
  if IsLoaded then
  begin
    NewBoundaryType := TPhastBoundaryTypes(rgBoundaryType.ItemIndex);
    case NewBoundaryType of
      btNone: ;  // do nothing
      btSpecifiedHead: StorePhastSpecifiedHeads;
      btFlux: StorePhastSpecifiedFlux;
      btLeaky: StorePhastLeakyBoundary;
      btRiver: StorePhastRiverBoundary;
      btWell: StorePhastWellBoundary;
      else Assert(False)
    end;

  end;
end;

procedure TfrmScreenObjectProperties.framePhastInterpolationBoundariesExit(
  Sender: TObject);
begin
  inherited;
  StorePhastBoundary;
end;

procedure TfrmScreenObjectProperties.CheckForCircularReferencesInMixtureFormulas(
  var Expression: TExpression; const DSName, OldFormula: string;
  const EditIndex: integer);
var
  Used: TStringList;
  VariableName: string;
  VariablePosition: integer;
  TempUsesList3: TStringList;
  Index: integer;
  Edit: TScreenObjectDataEdit;
begin
  Used := TStringList.Create;
  try
    Used.Assign(Expression.VariablesUsed);
    // Check that the formula does not result in
    // a circular reference.
    for Index := 0 to Used.Count - 1 do
    begin
      VariableName := Used[Index];
      VariablePosition := GetDataSetIndexByName(VariableName);
      Edit := FDataEdits[VariablePosition];
      TempUsesList3 := Edit.UsedBy;
      if TempUsesList3.IndexOf(DSName) >= 0 then
      begin
        Beep;
        if MessageDlg(Format(StrErrorThereAppears2, [Used[Index]]), mtError,
          [mbYes, mbNo], 0) = mrYes then
        begin
          framePhastInterpolationData.edMixFormula.Text :=
            OldFormula;
          Expression :=
            CreateMixtureFormula(EditIndex);
        end;

        Exit;
      end;
    end;
  finally
    Used.Free;
  end;
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationDatabtnEditMixtureFormulaClick(Sender: TObject);
var
  NewFormula: string;
  Variable: TCustomValue;
  Index: integer;
  Used: TStringList;
  VariableName: string;
  Orientation: TDataSetOrientation;
  VariableList: TList;
  TempUsesList: TStringList;
  VariablePosition: integer;
  OldFormula: string;
  DataSet: TDataArray;
  NewValue: string;
  EvaluatedAt: TEvaluatedAt;
  DSName: string;
  Edit, OtherEdit: TScreenObjectDataEdit;
  DataArray: TDataArray;
  DataArrayManager: TDataArrayManager;
begin
  inherited;

  Edit := FCurrentEdit;
  DSName := Edit.DataArray.Name;
  VariableList := TList.Create;
  // VariableList will hold a list of variables that can
  // be used in the function
  Used := TStringList.Create;
  // "Used" will be a list of variables that depend on
  // the data set whose formula will be edited.
  try
    DataArray := Edit.DataArray;
    Orientation := DataArray.Orientation;
    EvaluatedAt := DataArray.EvaluatedAt;
    // Add the variable whose value is being set to "Used".

    Used.Assign(Edit.UsedBy);

    Used.Sorted := True;
    DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
    for Index := 0 to DataArrayManager.DataSetCount - 1 do
    begin
      DataSet := DataArrayManager.DataSets[Index];
      if not DataSet.Visible then
      begin
        Continue;
      end;
      if DataSet is TCustomSparseDataSet then
      begin
        Continue;
      end;
      if (Index <> FDataEdits.IndexOf(Edit))
        and (EvaluatedAt = DataSet.EvaluatedAt) then
      begin
        VariableName := DataSet.Name;
        OtherEdit := FDataEdits[GetDataSetIndexByName(VariableName)];
        TempUsesList := OtherEdit.UsedBy;
        VariablePosition := TempUsesList.IndexOf(DSName);
        if (VariablePosition < 0) and ((Orientation = dso3D)
          or (Orientation = DataSet.Orientation)) then
        begin
          Edit := FDataEdits[Index];
          // if the variable does not depend on the
          // data set whose formula is being edited
          // and it's orientation is OK, the variable
          // can be used in the formula.
          VariableList.Add(Edit.Variable);
        end;
      end;
    end;

    // if the user makes an invalid formula, it
    // may be necessary to restore it but only
    // if the formula that was already present
    // was OK to begin with.
    OldFormula := framePhastInterpolationData.edMixFormula.Text;
    NewValue := OldFormula;
    if (NewValue = '') then
    begin
      NewValue := FortranFloatToStr(0.5);
    end;
//    with TfrmFormula.Create(self) do
    with frmFormula do
    begin
      try
        Initialize;
        IncludeGIS_Functions(Edit.DataArray.EvaluatedAt);
        RemoveGetVCont;
        RemoveHufFunctions;
        PopupParent := self;

        // register the appropriate variables with the
        // parser.
        for Index := 0 to VariableList.Count - 1 do
        begin
          Variable := VariableList[Index];
          rbFormulaParser.RegisterVariable(Variable);
        end;

        // show the variables and functions
        IncludeTimeSeries := False;
        UpdateTreeList;

        // put the formula in the TfrmFormula.
        Formula := NewValue;
        // The user edits the formula.
        ShowModal;
        if ResultSet then
        begin
          NewFormula := Formula;
          if framePhastInterpolationData.edMixFormula.Text <> NewFormula then
          begin
            framePhastInterpolationData.edMixFormula.Text := NewFormula;
            framePhastInterpolationDataedMixFormulaExit(
              framePhastInterpolationData.edMixFormula);
          end;
        end;
      finally
        Initialize;
//        Free;
      end;
    end;
  finally
    Used.Free;
    VariableList.Free;
    // Don't allow the user to click the OK button if any formulas are invalid.
    EnableOK_Button;
  end;
end;

procedure TfrmScreenObjectProperties.pageMainChange(Sender: TObject);
begin
  inherited;
  HelpKeyWord := pageMain.ActivePage.HelpKeyword;
  if pageMain.ActivePage = tabModflowBoundaryConditions then
  begin
    if jvplModflowBoundaries.ActivePage.HelpKeyword <> '' then
    begin
      HelpKeyword := jvplModflowBoundaries.ActivePage.HelpKeyword
    end;
  end;
  if pageMain.ActivePage = tabSutraFeatures then
  begin
    if jvplSutraFeatures.ActivePage.HelpKeyword <> '' then
    begin
      HelpKeyword := jvplSutraFeatures.ActivePage.HelpKeyword
    end;
  end;
  btnHelp.HelpKeyword := HelpKeyWord;

  btnCopyVertices.Visible := pageMain.ActivePage = tabNodes;

  btnConvertTimeUnits.Visible :=
    (pageMain.ActivePage = tabModflowBoundaryConditions)
    or (pageMain.ActivePage = tabSutraFeatures);

  btnEditFeatureFormulas.Visible :=
    (pageMain.ActivePage = tabModflowBoundaryConditions)
    and (FScreenObjectList <> nil) and (FScreenObjectList.Count > 1);
end;

procedure TfrmScreenObjectProperties.
  framePhastInterpolationDataedMixFormulaEnter(Sender: TObject);
begin
  inherited;
  FOldMixFormula := framePhastInterpolationData.edMixFormula.Text;
end;

procedure TfrmScreenObjectProperties.EmphasizeValueChoices;
begin
  EmphasizeCheckBoxes([cbSetGridCellSize, cbEnclosedCells,
    cbIntersectedCells, cbInterpolation]);
  if DataSetsSpecified then
  begin
    EmphasizeCheckBoxes([cbEnclosedCells, cbIntersectedCells, cbInterpolation]);
  end;
end;

procedure TfrmScreenObjectProperties.frameDynamicTimeSeriesbtnAddGroupClick(
    Sender: TObject);
begin
  inherited;
  frameDynamicTimeSeries.btnAddGroupClick(Sender);
end;

procedure
    TfrmScreenObjectProperties.frameScreenObjectTvkrdgModflowBoundarySetEditText(
    Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameScreenObjectTvk.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FTvkNode);
end;

procedure
    TfrmScreenObjectProperties.frameScreenObjectTvsrdgModflowBoundarySetEditText(
    Sender: TObject; ACol, ARow: Integer; const Value: string);
begin
  inherited;
  frameScreenObjectTvs.rdgModflowBoundarySetEditText(Sender, ACol, ARow, Value);
  UpdateNodeState(FTvsNode);
end;

procedure TfrmScreenObjectProperties.SetMultipleScreenObjects(
  const Value: boolean);
begin
  FMultipleScreenObjects := Value;
  cbLineColor.AllowGrayed := Value;
  cbInterpolation.AllowGrayed := Value;
  cbIntersectedCells.AllowGrayed := Value;
  cbEnclosedCells.AllowGrayed := Value;
  cbFillColor.AllowGrayed := Value;
end;

{ TParameterTimeList }

procedure TParameterTimeList.Add(Item: TParameterTime);
begin
  FList.Add(Item);
end;

constructor TParameterTimeList.Create;
begin
  inherited;
  FList := TObjectList.Create;
end;

procedure TParameterTimeList.Delete(Index: integer);
begin
  FList.Delete(Index);
end;

destructor TParameterTimeList.Destroy;
begin
  FList.Free;
  inherited;
end;

function TParameterTimeList.GetCount: integer;
begin
  result := FList.Count;
end;

function TParameterTimeList.GetItems(Index: integer): TParameterTime;
begin
  result := FList[Index];
end;

function TParameterTimeList.IndexOfTime(const StartTime,
  EndTime: double): integer;
var
  Index: Integer;
  Time: TParameterTime;
  TempTime: TParameterTime;
  LowIndex, HighIndex, MiddleIndex, CompareResult: Integer;
begin
  result := -1;
  if Sorted and (Count > 0) then
  begin
    TempTime := TParameterTime.Create;
    try
      TempTime.StartTime := StartTime;
      TempTime.EndTime := EndTime;

      LowIndex := 0;
      HighIndex := Count - 1;
      if CompareStartAndEndTimes(Items[LowIndex], TempTime) = 0 then
      begin
        result := LowIndex;
        Exit;
      end
      else if CompareStartAndEndTimes(Items[HighIndex], TempTime) = 0 then
      begin
        result := HighIndex;
        Exit;
      end;
      while HighIndex - LowIndex > 1 do
      begin
        MiddleIndex := (LowIndex + HighIndex) shr 1;
        CompareResult := CompareStartAndEndTimes(Items[MiddleIndex], TempTime) + 1;
        case CompareResult of
          0:
            begin
              LowIndex := MiddleIndex;
            end;
          1:
            begin
              result := MiddleIndex;
              Exit;
            end;
          2:
            begin
              HighIndex := MiddleIndex;
            end;
        end;
      end;
    finally
      TempTime.Free;
    end;
  end
  else
  begin
    for Index := 0 to Count - 1 do
    begin
      Time := Items[Index];
      if (Time.StartTime = StartTime) and  (Time.EndTime = EndTime) then
      begin
        result := Index;
        Exit;
      end;
    end;
  end;
end;

procedure TParameterTimeList.SetItems(Index: integer;
  const Value: TParameterTime);
begin
  FList[Index] := Value;
end;

procedure TParameterTimeList.SetSorted(const Value: boolean);
begin
  if FSorted <> Value then
  begin
    FSorted := Value;
    if FSorted then
    begin
      Sort
    end;
  end;
end;

procedure TParameterTimeList.Sort;
begin
  FList.Sort(CompareStartAndEndTimes);
  FSorted := True;
end;

end.

