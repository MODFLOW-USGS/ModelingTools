unit Modflow2005ImporterUnit;

interface

// Windows is used so that AnsiCompareText will be inlined.
uses System.UITypes, Windows, SubscriptionUnit, SysUtils, Classes, Contnrs,
  JclSysUtils, ModflowPackageSelectionUnit, Dialogs, Types, Forms,
  SubPolygonUnit, ContourInterfaceUnit;

type
  TProgressHandler = procedure(Position, Total: integer) of object;

  TModelType = (mtParent, mtChild);

  TGridOrigin = (goUpperLeft, goLowerLeft);

  THeadFileType = (hftText, hftBinary);
  
  TCellAssignmentMethod = (camInterpolate, camIntersected);

  TImportParameters = Class
    ListFileName: string;
    XOrigin: double;
    YOrigin: double;
    GridAngle: double;
    textHandler: TTextHandler;
    ProgressHandler: TProgressHandler;
    ModelType: TModelType;
    NameFile: string;
    GridOrigin: TGridOrigin;
    Outline: TOutline;
    HeadFile: string;
    HeadFileType: THeadFileType;
    FlowFile: string;
    FirstCol: Integer;
    LastCol: Integer;
    FirstRow: Integer;
    LastRow: Integer;
    AssignmentMethod: TCellAssignmentMethod;
    destructor Destroy; override;
  end;

  TGridOutline = class(TOutline);

{
Import the MODFLOW-2005 model whose name file is ListFileName.
XOrigin, YOrigin are the X and Y coordinates of the corner of the model at
Row 1, Column1. GridAngle is the angle of the grid and textHandler
is a procedure passed in to handle data read by @name.

This procedure is implemented using classes in the implementation section.
The most important of these is TModflow2005Importer.  In
TModflow2005Importer.Create, instances of other classes are associated
with the symbols used to identify the packages in MODFLOW.
Other important base classes include TPackageImporter, TListImporter,
TArrayImporter, and TObjectArray.
}
procedure ImportModflow2005(ImportParameters: TImportParameters);
//procedure ImportModflow2005(const ListFileName: string;
//  XOrigin, YOrigin, GridAngle: double; textHandler: TTextHandler;
//  ProgressHandler: TProgressHandler; ModelType: TModelType;
//  const NameFile: string);

implementation

uses ModflowGridUnit, AbstractGridUnit, ScreenObjectUnit, GoPhastTypes,
  frmGoPhastUnit, PhastModelUnit, FastGEO, UndoItems, ValueArrayStorageUnit,
  DataSetUnit, Math, GIS_Functions, InterpolationUnit, RbwParser,
  ModflowTimeUnit, LayerStructureUnit, ModflowConstantHeadBoundaryUnit,
  ModflowParameterUnit, OrderedCollectionUnit, IntListUnit,
  ModflowTransientListParameterUnit, ModflowBoundaryUnit, ModflowWellUnit,
  ModflowGhbUnit, ModflowDrnUnit, ModflowRivUnit, ModflowRchUnit, ContourUnit,
  QuadTreeClass, ModflowEvtUnit, RealListUnit,
  ModflowSfrUnit, ModflowSfrReachUnit, ModflowSfrParamIcalcUnit,
  ModflowSfrTable, ModflowSfrFlows, ModflowSfrChannelUnit,
  ModflowSfrEquationUnit, ModflowSfrSegment, ModflowSfrUnsatSegment,
  ModflowHobUnit, ModflowHfbUnit, ModflowLakUnit, ModflowDrtUnit,
  ModflowEtsUnit, ModflowResUnit, ModflowUzfUnit, ModflowGageUnit,
  HufDefinition, FluxObservationUnit, ModflowMnw2Unit, ModflowSubsidenceDefUnit,
  ModflowHydmodUnit, ContourExport,
  Generics.Collections, ModflowStrUnit, ModflowStrWriterUnit,
  frmErrorsAndWarningsUnit, ModflowFhbUnit, StrUtils,
  ModflowSwrReachGeometryUnit, ModflowSwrReachUnit, ModflowSwrUnit,
  ModflowSwrDirectRunoffUnit, ModflowSwrStructureUnit, ModflowSwrTabfilesUnit,
  CustomModflowWriterUnit, ModflowSwrObsUnit, ModflowMnw1Unit,
  ReadModflowArrayUnit, System.IOUtils, DataSetNamesUnit;

resourcestring
  StrErrorInSPackage = 'Error in %s package input. In the first stress perio' +
  'd, you can not reuse data from a previous stress period.';
  StrRecharge = 'Recharge';
  StrObservationsWithIn = 'Observations with invalid reference stress period' +
  's have been skipped.';
  StrObservationName = 'Observation Name: "%0:s"; Reference Stress Period: %' +
  '1:d';
  StrInvalidStreamTribu = 'Invalid Stream tributary number (Segment number, ' +
  'Tributary Number, Stress Period)';
  Str0d1d2d = '%0:d, %1:d, %2:d';
  StrIncorrectParameter = 'Incorrect parameter definition in SFR package.';
  StrTheParameterInstan = 'The parameter instance "%0:s" is not defined for ' +
  'the SFR parameter "%1:s."';
  StrOriginalSegmentNum = 'Original segment number = %0:d in stress period %' +
  '1:d.';
  StrSIsNegativeOrZe = '%s is negative or zero at the following locations (L' +
  'ayer, Row, Column, Value).';
  Str0d1d2d3 = '%0:d, %1:d, %2:d, %3:g';
  StrUZFRoutingSpecifie = 'UZF routing specified incorrectly';
  StrInTheUZFPackage = 'In the UZF package, the option to route groundwater ' +
  'to lakes or streams has been activated. For this option to be used, the L' +
  'AK, SFR, or SWR package must be active; none of them are active. MODFLOW ' +
  'will ignore the groundwater routing option.';
//  StrConfinedStorageCoe = 'Confined_Storage_Coefficient';
//  StrTheFileYouSelecte = 'The file you selected is empty.';
  StrTheHeadFileYouSelecte = 'The head file you selected is empty.';
  StrTheFlowFileYouSelecte = 'The flow file you selected is empty.';
  StrImportedFromExisti = 'Imported from existing model on %s';
  StrInvalidReferenceSt = 'Invalid reference stress period.';
  StrOneOrMoreObservat = 'Observation %0:d in the observation group ' +
  '"%1:s" is invalid because its references stress period (%2:d) it is great' +
  'er than the number of stress periods.';

const
  StrParentModelHeads = 'ParentModelHeads';
  StrParentModelFlows = 'ParentModelFlows';

var
  DummyInteger: integer;
  DummyDouble: Double;
  NameFile: string;

const
  StrHydCondAlongRows = 'HYD. COND. ALONG ROWS';
  StrHorizAnisotropy = 'HORIZ. ANI. (COL./ROW)';
  StrVerticalHydCond = 'VERTICAL HYD. COND.';
  StrHorizToVertAnis = 'HORIZ. TO VERTICAL ANI.';
  StrQuasi3DVertHydCond = 'QUASI3D VERT. HYD. COND.';
  StrSpecificStorage = 'SPECIFIC STORAGE';
  StrSpecificYield = 'SPECIFIC YIELD';
  StrWetDry = 'WETDRY PARAMETER';
  StrStorageCoef = 'STORAGE COEFFICIENT';
  StrAll = 'ALL';
  StrNone = 'NONE';
  StrImportedRechargeSt = 'Imported_Recharge_StressPeriod';
  StrImportedRecharge = 'ImportedRecharge';
  StrImportedRechargeLa = 'Imported_Recharge_Layer_StressPeriod';
  StrImportedRechargeEl = 'Imported_Recharge_Elevation';
  StrImportedEvtEl = 'Imported_Evt_Elevation';
  StrImportedEvtLa = 'Imported_Evt_Layer_StressPeriod';
  StrImportedEvtSt = 'Imported_EvtRate_StressPeriod';
  StrImportedEvtSurfSt = 'Imported_EvtSurface_StressPeriod';
  StrImportedEvtExtinctDepthSt = 'Imported_EvtExtinctionDepth_StressPeriod';
  StrLAKEIDARRAY = 'LAKE ID ARRAY';
  StrLAKEBEDLEAKANCEARR = 'LAKEBED LEAKANCE ARRAY';
  StrImportedLakeBottom = 'Imported_Lake_Bottom';
  StrETLAYERINDEXIETS = 'ET LAYER INDEX (IETS)';
  StrETSURFACEETSS = 'ET SURFACE (ETSS)';
  StrEVAPOTRANSRATEET = 'EVAPOTRANS. RATE (ETSR)';
  StrEXTINCTIONDEPTHET = 'EXTINCTION DEPTH (ETSX)';
  StrImportedETSFractionalRate = 'Imported_ETS_FractionalRate_';
  StrImportedETSFractionalDepth = 'Imported_ETS_FractionalDepth_';
  StrETSImportedFractionalDepth = 'ETS_Imported_FractionalDepth_';
  StrETSImportedFractionalRate = 'ETS_Imported_FractionalRate_';
  StrTOPELEVATN = 'TOP ELEVATN: ';
  StrTHICKNESS = 'THICKNESS: ';
  StrCOLUMNTOROWANISOT = 'COLUMN TO ROW ANISOTROPY';
  StrPRIMARYSTORAGECOEF = 'PRIMARY STORAGE COEF';
  StrTRANSMISALONGROWS = 'TRANSMIS. ALONG ROWS';
  StrHYDCONDALONGROW = 'HYD. COND. ALONG ROWS';
  StrVERTHYDCONDTHICK = 'VERT HYD COND /THICKNESS';
  StrSECONDARYSTORAGECO = 'SECONDARY STORAGE COEF';
  StrWETDRYPARAMETER = 'WETDRY PARAMETER';
  StrNUMBEROFBEDSINSY = 'NUMBER OF BEDS IN SYSTEM';
  StrPRECONSOLIDATIONHEA = 'PRECONSOLIDATION HEAD';
  StrELASTICINTERBEDSTO = 'ELASTIC INTERBED STORAGE';
  StrVIRGININTERBEDSTOR = 'VIRGIN INTERBED STORAGE';
  StrSTARTINGCOMPACTION = 'STARTING COMPACTION';
  StrDELAYSTARTINGHEAD = 'DELAY STARTING HEAD';
  StrDELAYPRECOLSOLHEA = 'DELAY PRECOLSOL. HEAD';
  StrDELAYINITIALCOMPAC = 'DELAY INITIAL COMPACTION';
  StrDELAYINTERBEDTHICK = 'DELAY INTERBED THICKNESS';
  StrMF_GEOSTATICSTRESS = 'GEOSTATIC STRESS';
  StrMOISTSPECIFICGRAVI = 'MOIST SPECIFIC GRAVITY';
  StrSATSPECIFICGRAVIT = 'SAT. SPECIFIC GRAVITY';
  StrSILTANDCLAYTHICKN = 'SILT AND CLAY THICKNESS';
  StrELASTICSPECIFICSTO = 'ELASTIC SPECIFIC STORAGE';
  StrRECOMPRESSIONINDEX = 'RECOMPRESSION INDEX';
  StrINELASSPECIFICSTO = 'INELAS. SPECIFIC STORAGE';
  StrCOMPRESSIONINDEX = 'COMPRESSION INDEX';
  StrVOIDRATIO = 'VOID RATIO';
  StrPRECONSOLSTRESS = 'PRECONSOL.   STRESS';
  StrNDSys = 'ND_Sys';
  StrImportedUZFInfiltr = 'Imported_UZF_Infil_Str_P';
  StrImportedUZFEvapotr = 'Imported_UZF_ET_Str_P';
  StrImportedUZFExtinct = 'Imported_UZF_Extinct_Depth_Str_P';
  StrImportedUZFExWC = 'Imported_UZF_Extinct_Wat_Cont_Str_P';

const
  StrConstant1DRealArray = 'CONSTANT 1D REAL ARRAY:';
  StrVariable1DRealArray = 'VARIABLE 1D REAL ARRAY:';
  StrConstant2DRealArray = 'CONSTANT 2D REAL ARRAY:';
  StrConstant2DRealArrayForLayer = 'CONSTANT 2D REAL ARRAY FOR A LAYER:';
  StrVariable2DRealArray = 'VARIABLE 2D REAL ARRAY:';
  StrVariable2DRealArrayForLayer = 'VARIABLE 2D REAL ARRAY FOR A LAYER:';
  StrVariable2DRealArrayForCrossSection
    = 'VARIABLE 2D REAL ARRAY FOR CROSS SECTION:';
  StrConstant2DIntegerArrayForLayer = 'CONSTANT 2D INTEGER ARRAY FOR A LAYER:';
  StrConstant2DIntegerArray = 'CONSTANT 2D INTEGER ARRAY:';
  StrVariable2DIntegerArrayForLayer = 'VARIABLE 2D INTEGER ARRAY FOR A LAYER:';
  StrVariable2DIntegerArrayForCrossSection
    = 'VARIABLE 2D INTEGER ARRAY FOR CROSS SECTION:';
  StrVariable2DIntegerArray = 'VARIABLE 2D INTEGER ARRAY:';
  StrInitialHead = 'INITIAL HEAD';
  BoundaryArray = 'BOUNDARY ARRAY';
  StrHEADNG1 = 'HEADNG(1):';
  StrHEADNG2 = 'HEADNG(2):';
  StrIXSECICHFLGIFREF = 'IXSEC, ICHFLG, IFREFM, IPRTIM, STOPER:';
  StrHNOFLO = 'HNOFLO:';

Type
  TDoubleArray = array of double;
  T2DDoubleArray = array of array of double;
  T2DIntArray = array of array of integer;
  TSurfacePointArray = array of array of TPoint2D;
  T3DDoubleArray = array of T2DDoubleArray;
  T3DIntArray = array of T2DIntArray;

  TMultZoneImporter = class;

  TImportedStressPeriod = record
    PERLEN: double;
    NSTP: integer;
    TSMULT: double;
    ISSFLG: integer;
  end;

  TRealConstantRecord = record
    IsConstant: boolean;
    RealValue: double;
  end;

  TRealConstantRecordArray = array of TRealConstantRecord;

  TIntegerConstantRecord = record
    IsConstant: boolean;
    IntegerValue: integer;
  end;

  TIntegerConstantArray = array of TIntegerConstantRecord;

  TClusterRecord = record
  private
    FMultiplierName: string;
    FZoneName: string;
    function GetMultiplierName: string;
    function GetZoneName: string;
  public
    Layer: integer;
    ZoneValues: array of integer;
    property MultiplierName: string read GetMultiplierName write FMultiplierName;
    property ZoneName: string read GetZoneName write FZoneName;
  end;

  TClusterRecordArray = array of TClusterRecord;

  TInstanceRecord = record
    InstanceName: string;
    Clusters: TClusterRecordArray;
  end;

  TArrayParameterRecord = record
    PARNAM: string;
    PARTYP: string;
    Parval: Double;
    Instances: array of TInstanceRecord;
  end;

  TBool2DArray = array of array of Boolean;

  TGageImporter = class;
  TChdObsImporter = class;
  TPvalImporter = class;
  THydmodImporter = class;

  TPackageProgressHandler = procedure(Position: integer) of object;

  TModflow2005Importer = class(TObject)
  strict private
    FCenterPoints: TSurfacePointArray;
    FCornerPoints: TSurfacePointArray;
    FCellAreas: T2DDoubleArray;
  private
    FListFileName: string;
    FPackageIdentifiers: TStringList;
    FFile: TextFile;
    FPointsComputed: Boolean;
    FGageImporter: TGageImporter;
    FChobImporter: TChdObsImporter;
    FPvalImporter: TPvalImporter;
    FFileSize: Integer;
    FImportParameters: TImportParameters;
    FHydmodImporter: THydmodImporter;
    StressPeriodString: string;
    function GetCenterPoints: TSurfacePointArray;
    function GetCornerPoints: TSurfacePointArray;
    function GetCellAreas: T2DDoubleArray;
    property CenterPoints: TSurfacePointArray read GetCenterPoints;
    property CornerPoints: TSurfacePointArray read GetCornerPoints;
    property CellAreas: T2DDoubleArray read GetCellAreas;
    procedure HandlePackageProgress(Position: integer);
    procedure UpdateSubModelGrid;
    procedure ImportBoundaryHeads;
    procedure ImportBoundaryFlows;
    procedure InactivateCellsOutsideSubModel;
    // when extracting a submodel, BoundaryCells represent the cells on the
    // edge of the model.
    procedure IdentifyBoundaryCells(var ActiveCells, BoundaryCells: TBool2DArray);
    procedure UpdateProgress;
  public
    textHandler: TTextHandler;
    ProgressHandler: TProgressHandler;
    Constructor Create(ImportParameters: TImportParameters);
    Destructor Destroy; override;
    procedure ImportModel;
  end;

  TObjectType = (otPoint, otLine, otPolygon);

  TPackageImporter = class(TObject)
  private
    FImportedPackage: boolean;
    FProgressHandler: TPackageProgressHandler;
    procedure AssignConstant2DIntArray(Value: integer; Array2D: T2DIntArray);
    function CreateScreenObject(const Name: string): TScreenObject; overload;
    // List contains the @link(TLocation)s for the @link(TScreenObject);
    function AddBoundaryPoints(List: TList; Index: integer;
      ObjectType: TObjectType; var AScreenObject: TScreenObject): Boolean; virtual;
    function GetStressPeriodString(StressPeriodIndex: integer): string;
    procedure CreateTransientDataSet(StressPeriodIndex: integer;
      const Root: string; DataType: TRbwDataType; var DataSet: TDataArray);
  protected
    FComments: TStringList;
    FImporter: TModflow2005Importer;
    FPackageIdentifier: string;
    FModel: TPhastModel;
    FGrid: TModflowGrid;
    StressPeriodString: string;
    // @name is passed a label indicating the data that has been read from
    // the @link(FImporter) file and reads that data from the file and stores
    // it.
    procedure ReadData(const ALabel: string); virtual;
    // @name takes the data it has stored and modifies @link(FModel) to
    // include that data.  This often means that @link(TDataArray)s and
    // @link(TScreenObject)s are created.
    procedure HandlePackage; virtual;
    procedure Read1DRealArray(var DoubleArray: TOneDRealArray);
    procedure Read2DRealArray(var DoubleArray: T2DDoubleArray; const ArrayName: string);
    procedure AssignConstant2DArray(Value: double; Array2D: T2DDoubleArray);
    procedure AssignConstant1DArray(AnArray: TOneDRealArray; Value: double);
    // @name creates a @link(TScreenObject) that has a vertex at the center
    // of the each cell as seen from the top view of the model.  Each vertex
    // is a new section. When adding vertices, the loop over columns is
    // inside the loop over rows.
    procedure CreateOrRetrieveCellCenterScreenObject(var ScreenObject
      : TScreenObject);
    procedure AssignRealValuesToCellCenters(DataArray: TDataArray;
      ScreenObject: TScreenObject; ImportedData: T2DDoubleArray);
    procedure AssignIntegerValuesToCellCenters(DataArray: TDataArray;
      ScreenObject: TScreenObject; ImportedData: T2DIntArray);
    procedure AssignBooleanValuesToCellCenters(DataArray: TDataArray;
      ScreenObject: TScreenObject; ImportedData: T2DIntArray);
    procedure ReadVariable2DIntArray(IntArray: T2DIntArray);
    procedure CreateDataArrayAndAssignValues(ScreenObject: TScreenObject;
      const DataArrayName: string; ImportedValues: T2DDoubleArray); overload;
    procedure CreateDataArrayAndAssignValues(ScreenObject: TScreenObject;
      const DataArrayName: string; ImportedValues: T2DIntArray); overload;
    procedure CheckRealConstArray(out ConstantValue: double;
      out IsConstant: boolean; const ArrayToCheck: TRealConstantRecordArray);
    function FixArrayName(const ArrayName: string): string;
    procedure AssignImportedValues(ImportedValues: TValueArrayItem;
      ImportedData: T2DDoubleArray); overload;
    procedure AssignImportedValues(ImportedValues: TValueArrayItem;
      ImportedData: TDoubleArray); overload;
    function UniformArray(ImportedData: TDoubleArray): boolean;
    // Check if an array is constant despite being specified as a variable
    // array.
    procedure CheckVariableRealArrays(var ConstArray: TRealConstantRecordArray;
      VarArray: T3DDoubleArray);
    // Check if an array is constant despite being specified as a variable
    // array.
    procedure CheckVariableIntegerArrays(var ConstArray: TIntegerConstantArray;
      VarArray: T3DIntArray);
    function CreateScreenObjectAroundGrid(const Name: string): TScreenObject;
  public
    Constructor Create(Importer: TModflow2005Importer;
      const PackageIdentifier: string);
    Destructor Destroy; override;
    procedure ImportPackage(out NextPackageIndex: integer);
    property ImportedPackage: boolean read FImportedPackage;
  end;

  TObjectImporter = class(TPackageImporter)
    function ScreenObjectNameRoot: string; virtual; abstract;
    // List contains the @link(TLocation)s for the @link(TScreenObject);
    // ScreenObjectIndex is used in assigning the consecutive values to
    // the @link(TScreenObject) name.
    // LayerIndex is the MODFLOW layer for the @link(TScreenObject) and is used
    // in assigning the @link(TScreenObject) name.
    // If LayerIndex < 1, the layer will not be used the
    //  @link(TScreenObject) name.
    // StressPeriodIndex is the stress period (starting at zero)
    // for the @link(TScreenObject) and is used
    // in assigning the @link(TScreenObject) name.
    // If StressPeriodIndex < 0, the StressPeriodIndex will not be used the
    //  @link(TScreenObject) name.
    function CreateScreenObject(List: TList; var ScreenObjectIndex: integer;
      LayerIndex, StressPeriodIndex: integer; ObjectType: TObjectType)
      : TScreenObject; overload; virtual;
  end;

  TSubModelHeadImporter = class(TObjectImporter)
    function ScreenObjectNameRoot: string; override;
  end;

  TSubModelFlowImporter = class(TObjectImporter)
  private
    FSuffix: string;
  public
    function ScreenObjectNameRoot: string; override;
    property Suffix: string read FSuffix write FSuffix;
  end;

  TSubModelInactiveImporter = class(TObjectImporter)
    function ScreenObjectNameRoot: string; override;
  end;

  TNamImporter = class(TPackageImporter)
  private
    FUnitNumbers: TIntegerList;
    FFileNames: TStringList;
  protected
    procedure ReadData(const ALabel: string); override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TBasImporter = class;

  TDisImporter = class(TPackageImporter)
  private
    NLAY: integer;
    NROW: integer;
    NCOL: integer;
    NBOTM: integer;
    FHasFixedElevations: Boolean;
    FGridOrigin: TGridOrigin;
    FLayerThicknesses: T3DDoubleArray;
    FConstantLayerThicknesses : TRealConstantRecordArray;
    procedure ImportElevationsAndReleaseMemory;
    procedure CreateImportOutline;
    procedure SetGridLimitsFromOutline;
    function GetConstLayerThickness(LayIndex: Integer): double;
    function GetIsConstLayerThickness(LayIndex: Integer): Boolean;
    function GetVariableLayerThickness(LayIndex, RowIndex,
      ColIndex: Integer): double;
  strict private
    FBas: TBasImporter;
    FOriginPoint: TPoint2D;
    FGridAngle: Double;
    NPER: integer;
    ITMUNI: integer;
    LENUNI: integer;
    LAYCBD: array of integer;
    DELR: TOneDRealArray;
    DELC: TOneDRealArray;
    FElevations: T3DDoubleArray;
    FConstantElevations : TRealConstantRecordArray;
    FStressPeriods: array of TImportedStressPeriod;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadConstantDelrDelc;
    procedure ReadVariableDelrDelc;
    function GetLayerBottomIndex(Layer: Integer): integer;
    function GetConfiningBedBottomIndex(Layer: Integer): integer;
    procedure ReadConstantTopElev;
    procedure ReadConstantBottomElev;
    procedure ReadVariableTopElev;
    procedure ReadVariableBottomElev;
    procedure ImportStressPeriods;
    procedure ImportElevations;
    procedure ImportRowsAndColumns;
    procedure ReadStressPeriod;
    procedure InitializeView;
    procedure ReleaseMemory;
    procedure FixElevations;
    procedure GetLayerThicknesses;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      Bas: TBasImporter;
      XOrigin, YOrigin, GridAngle: double; GridOrigin: TGridOrigin);
    property IsConstLayerThickness[LayIndex: Integer]: Boolean
      read GetIsConstLayerThickness;
    property ConstLayerThickness[LayIndex: Integer]: double
      read GetConstLayerThickness;
    property VariableLayerThickness[LayIndex, RowIndex, ColIndex: Integer]: double
      read GetVariableLayerThickness;
  end;

  TMultZoneImporter = class(TPackageImporter)
  strict private
    FZoneArrays: array of T2DIntArray;
    FConstantZoneArrays : array of TIntegerConstantRecord;
    FZoneNames: TStringList;
    FMultArrays: array of T2DDoubleArray;
    FConstantMultArrays : array of TRealConstantRecord;
    FMultNames: TStringList;
    FCurrentMultName: string;
    FCurrentZoneName: string;
    procedure ReadNumberOfZones;
    procedure ReadNumberOfMultipliers;
    procedure ReadMultiplierName;
    procedure ReadConstantMultiplier;
    procedure ReadVariableMultiplier;
    procedure ReadMultiplierDefinedByFunction;
    procedure ReadZoneName;
    procedure ReadConstantZoneArray;
    procedure ReadVariableZoneArray;
    procedure ImportZones;
    procedure ImportMultipliers;
//    procedure ReleaseMemory;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Function IndexOfZone(Name: string): integer;
    function ConstantZone(Index: integer; Out ZoneValue: integer): boolean;
    function ZoneArray(Index: integer): T2DIntArray;
    Constructor Create(Importer: TModflow2005Importer);
    destructor Destroy; override;
  end;

  TArrayImporter = class(TObjectImporter)
  protected
    procedure CheckPositiveArrayValues(Values: T3DDoubleArray;
      ConstantRecordArray: TRealConstantRecordArray; Name: string;
      Bas: TBasImporter);
    procedure GetTimeStepStartAndEndTimes(TimeStepEndLists: TList;
      TimeStepStartLists: TList);
    // @name assigns values to the @link(TDataArray) named ImportArrayName.
    procedure Import2DDataSet(const ImportName, ImportArrayName: string;
      const TwoDConstRecord: TRealConstantRecord;
      const TwoDRealArray: T2DDoubleArray;
      const LayerFormulaSuffix: string = '');
    // @name sets initial values for ConstArray.
    procedure InitializeConstArray(ConstArray: TRealConstantRecordArray);
    // @name sets initial values for ConstArray.
    procedure InitializeConstIntArray(ConstArray: TIntegerConstantArray);
    procedure ImportDataSet(ImportName: string; ImportArrayName: string;
      var ThreeDConstRealArray: TRealConstantRecordArray;
      const ThreeDRealArray: T3DDoubleArray;
      const LayerFormulaSuffix: string = '');
  end;

  TArrayParameterImporter = class (TArrayImporter)
  protected
    FNextParameterIndex: integer;
    FParameters: array of TArrayParameterRecord;
    procedure ReadArrayParameter;
    function ReadInstance: boolean; virtual;
  end;

  TCustomFlowPackageImporter = class(TArrayParameterImporter)
  private
    FBas: TBasImporter;
  protected
    FIsSelected: boolean;
    ILPFCB: integer;
    HDRY: double;
    FStorageCoefficientChoice: Boolean;
    FComputeVkUsingCellThickness: Boolean;
    FComputeThicknessUsingStartingHead: Boolean;
    FNoCvCorrection: Boolean;
    FNoVerticalFlowCorrection: Boolean;
    FNoParameterCheck: boolean;
    LAYTYP: array of integer;
    LAYAVG: array of integer;
    CHANI: array of double;
    LAYVKA: array of integer;
    LAYWET: array of integer;
    FHk: T3DDoubleArray;
    FHorizontalAnisotropy: T3DDoubleArray;
    FVerticalK: T3DDoubleArray;
    FHorizontalToVerticalAnisotropy: T3DDoubleArray;
    FQuasiVerticalK: T3DDoubleArray;
    FSpecificStorage: T3DDoubleArray;
    FSpecificYield: T3DDoubleArray;
    FWetDry: T3DDoubleArray;
    FStorageCoefficient: T3DDoubleArray;
    FHkConst: TRealConstantRecordArray;
    FHorizontalAnisotropyConst: TRealConstantRecordArray;
    FVerticalKConst: TRealConstantRecordArray;
    FHorizontalToVerticalAnisotropyConst: TRealConstantRecordArray;
    FQuasiVerticalKConst: TRealConstantRecordArray;
    FSpecificStorageConst: TRealConstantRecordArray;
    FSpecificYieldConst: TRealConstantRecordArray;
    FWetDryConst: TRealConstantRecordArray;
    FStorageCoefficientConst: TRealConstantRecordArray;
    procedure ReadDataSets10to16Constant;
    procedure ReadDataSets10to16Variable;
    function PackageLabel: string; virtual; abstract;
    procedure ReadDataSet1Options;
    procedure ReadDataSets2to6;
    procedure ImportDataSet2;
    procedure ImportDataSet3;
    procedure ImportHorizontalAnisotropy;
    procedure ImportDataSet5;
    procedure ImportLpfParameters;
    procedure ImportHorizontalHydraulicConductivity;
    procedure ImportVerticalHydraulicConductivity;
    procedure ImportSpecificStorage;
    procedure ImportSpecificYield;
  public
    constructor Create(Importer: TModflow2005Importer; Bas: TBasImporter);
  end;

  TLpfImporter = class(TCustomFlowPackageImporter)
  private
    WETFCT: double;
    IWETIT: integer;
    IHDWET: integer;
    procedure ReadDataSet1;
    procedure ReadDataSet7;
    procedure ImportDataSet1(LpfPackage: TLpfSelection);
    procedure ImportDataSet6;
    procedure ImportDataSet7;
    procedure ImportWetDry;
  protected
    function ScreenObjectNameRoot: string; override;
    function PackageLabel: string; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  end;

  TUpwImporter = class(TCustomFlowPackageImporter)
  private
    IPHDRY: integer;
    procedure ReadDataSet1;
    procedure ImportDataSet1(UpwPackage: TUpwPackageSelection);
  protected
    function ScreenObjectNameRoot: string; override;
    function PackageLabel: string; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  end;

  TBcfImporter = class(TArrayImporter)
  private
    FIsSelected: Boolean;
    HDRY: double;
    WETFCT: double;
    IWDFLG: integer;
    IWETIT: integer;
    IHDWET: integer;
    NLAY: integer;
    LAYCON: TOneDIntegerArray;
    TRPY: TOneDRealArray;
    FConfinedStorage: T3DDoubleArray;
    FConfinedStorage_Const: TRealConstantRecordArray;
    FSpecificStorage: T3DDoubleArray;
    FSpecificStorage_Const: TRealConstantRecordArray;
    FTran_Const: TRealConstantRecordArray;
    FTran: T3DDoubleArray;
    FHY_Const: TRealConstantRecordArray;
    FHY: T3DDoubleArray;
    FVcont_Const: TRealConstantRecordArray;
    FVcont: T3DDoubleArray;
    FSpecificYield_Const: TRealConstantRecordArray;
    FSpecificYield: T3DDoubleArray;
    FWetDry_Const: TRealConstantRecordArray;
    FWetDry: T3DDoubleArray;
//    FModelLayer: Integer;
    FTransientModel: Boolean;
    FBas: TBasImporter;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure InitializeContArray(var ConstArray: TRealConstantRecordArray);
    procedure Initialize3DArray(var ThreeDArray: T3DDoubleArray);
    procedure ReadVariableAnisotropy;
    procedure ReadConstantAnisotropy;
    procedure ReadVariableArrays;
    procedure ReadConstantArrays;
    procedure ImportDataSet1;
    procedure ImportDataSets2And3;
    procedure CheckPositiveVcont(Values: T3DDoubleArray;
      ConstantRecordArray: TRealConstantRecordArray; Name: string;
      Bas: TBasImporter);
    procedure ConvertTranToKx;
    procedure ConvertConfinedStorageToSpecificStorage;
  protected
    function ScreenObjectNameRoot: string; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer; Bas: TBasImporter);
  end;

  THufRecord = record
    HUFNAME: string;
    HGUHANI: double;
    HGUVANI: double;
    PrintHK: integer;
    PrintHANI: integer;
    PrintVK: integer;
    PrintSS: integer;
    PrintSY: integer;
    PrintCode: integer;
  end;

  TKdepImporter = class;
  TLvdaImporter = class;

  TCustomHufImporter = class(TArrayParameterImporter)
  protected
    procedure AssignHufParametersZoneAndMultiplier;
  end;

  THufImporter = class(TCustomHufImporter)
  strict private
    HDRY: double;
    FHydrogeologicUnits: array of THufRecord;
    FNextHufIndexIndex: Integer;
    LTHUF: array of integer;
    LAYWT: array of double;
    WETFCT: double;
    IWETIT: Integer;
    IHDWET: Integer;
    NHUF: integer;
    NPHUF: integer;
    IOHUFHDS: integer;
    IOHUFFLWS: integer;
    IsConstTopHuf: Boolean;
    Top: T3DDoubleArray;
    IsConstThicknessHuf: Boolean;
    Thickness: T3DDoubleArray;
    FWetDry: T3DDoubleArray;
    FConstantTopElevations: array of TRealConstantRecord;
    FConstantThicknesses: array of TRealConstantRecord;
    HufPackage: THufPackageSelection;
    FWetDryConst: TRealConstantRecordArray;
    FIsSelected: Boolean;
  private
    FReadLthuf: Boolean;
    FReadKdep: boolean;
    FReadLvda: boolean;
    FKdepImporter: TKdepImporter;
    FLvdaImporter: TLvdaImporter;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadDataSet3;
    procedure ReadDataSet4;
    procedure ReadVariableWetDry;
    procedure ReadConstantWetDry;
    procedure ReadDataSet6;
    procedure ReadVariableHguGeometry;
    procedure ReadConstantHguGeometry;
    procedure ReadDataSet9;
    procedure ReadDataSet12;
    procedure ImportDataSet1;
    procedure ImportDataSet2;
    procedure ImportDataSet3;
    procedure ImportDataSet4;
    procedure ImportWetDry;
    procedure ImportHydrogeologicUnits;
    procedure ImportGeometry;
    function ReadInstance: boolean; override;
    procedure AssignSteadyParametersZoneAndMultiplier;
    procedure CreateParameters(HydrogeologicUnits: THydrogeologicUnits);
    procedure ReleaseMemory;
  protected
    function ScreenObjectNameRoot: string; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TKdepImporter = class(TCustomHufImporter)
  private
    FHufImporter: THufImporter;
    NPKDEP: integer;
    IFKDEP: integer;
    FGroundSurface: T2DDoubleArray;
    FConstantGroundSurface: double;
    FIsConstantGroundSurface: Boolean;
    FHufPackage: THufPackageSelection;
    procedure ReadDataSet1;
    procedure ReadVariableGroundSurface;
    procedure ReadConstantGroundSurface;
    procedure ImportReferenceChoice;
    procedure ImportReferenceLayer;
    procedure CreateParameters;
  protected
    function ScreenObjectNameRoot: string; override;
    function ReadInstance: boolean; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      HufImporter: THufImporter);
  end;

  TLvdaImporter = class(TArrayParameterImporter)
  private
    FHufImporter: THufImporter;
    NPLVDA: integer;
    procedure ReadDataSet1;
    procedure CreateParameters;
  protected
    function ScreenObjectNameRoot: string; override;
    function ReadInstance: boolean; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      HufImporter: THufImporter);
  end;

  TSolverImporter = class (TPackageImporter)
  protected
    procedure DeselectAllSolvers;
    procedure HandlePackage; override;
  end;

  TPcgImporter = class (TSolverImporter)
  private
    MXITER: integer;
    ITER1: integer;
    HCLOSEPCG: double;
    RCLOSEPCG: double;
    RELAXPCG: double;
    NBPOL: integer;
    IPRPCG: integer;
    MUTPCG: integer;
    DAMPPCG: double;
    DAMPPCGT: double;
    NPCOND: integer;
    IHCOFADD: integer;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TPcgnImporter = class (TSolverImporter)
  private
    ITER_MO, ITER_MI: integer;
    CLOSE_R, CLOSE_H: double;
    RELAX: double;
    IFILL, UNIT_PC, UNIT_TS: integer;
    ADAMP: integer;
    DAMP, DAMP_LB, RATE_D, CHGLIMIT: double;
    ACNVG: integer;
    CNVG_LB: double;
    MCNVG: integer;
    RATE_C: double;
    IPUNIT: integer;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TGmgImporter = class(TSolverImporter)
  private
    RCLOSE: double;
    IITER: integer;
    HCLOSE: double;
    MXITER: integer;
    DAMP: double;
    IADAMP: integer;
    IOUTGMG: integer;
    IUNITMHC: integer;
    ISM: integer;
    ISC: integer;
    DUP: double;
    DLOW: double;
    CHGLIMIT: double;
    RELAX: double;
    FGmgPackage: TGmgPackageSelection;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadPartialDataSet3;
    procedure ReadFullDataSet3;
    procedure ReadDataSet4;
    procedure ImportDataSet1;
    procedure ImportDataset2;
    procedure ImportDataSet3;
    procedure ImportDataSet4;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TSipImporter = class(TSolverImporter)
  private
    MXITER: integer;
    NPARM: integer;
    ACCL: double;
    HCLOSE: double;
    IPCALC: integer;
    WSEED: double;
    IPRSIP: integer;
    FSipPackage: TSIPPackageSelection;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TDe4Importer = class(TSolverImporter)
  private
    ITMX: integer;
    MXUP: integer;
    MXLOW: integer;
    MXBW: integer;
    IFREQ: integer;
    MUTD4: integer;
    ACCL: double;
    HCLOSE: double;
    IPRD4: integer;
    FDe4Package: TDE4PackageSelection;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TNwtImporter = class (TSolverImporter)
  private
    HEADTOL: double;
    FLUXTOL: double;
    MAXITEROUT: integer;
    THICKFACT: double;
    LINMETH: integer;
    IPRNWT: integer;
    IBOTAV: integer;
    FOption: TNewtonOption;
    FContinueNWT: Boolean;
    DBDTHETA: double;
    DBDKAPPA: double;
    DBDGAMMA: double;
    MOMFACT: double;
    BACKFLAG: Integer;
    MAXBACKITER: integer;
    BACKTOL: double;
    BACKREDUCE: double;
    IACL: integer;
    NORDER: integer;
    LEVEL: integer;
    NORTH: integer;
    IREDSYS: integer;
    RRCTOLS: double;
    IDROPTOL: integer;
    EPSRNS: double;
    HCLOSEXMD: double;
    MXITERXMD: integer;
    MAXITINNER: integer;
    ILUMETHOD: integer;
    LEVFILL: integer;
    STOPTOL: double;
    MSDR: integer;
    FNWTPackage: TNwtPackageSelection;
    procedure ReadDataSet1A;
    procedure ReadDataSet1C;
    procedure ReadDataSet1D;
    procedure ReadDataSet2B;
    procedure ReadDataSet2A;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
  end;

  TArrayMember = class(TObject)
    Constructor Create; virtual;
  end;

  TArrayMemberClass = class of TArrayMember;

  TObjectArray = class(TArrayMember)
  strict private
    FObjects: array of TArrayMember;
  private
    function GetArrayLength: integer;
    function GetObject(Index: integer): TArrayMember;
    procedure SetArrayLength(const Value: integer);
  strict protected
    property Objects[Index: integer]: TArrayMember
      read GetObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; virtual; abstract;
  public
    property ArrayLength: integer read GetArrayLength
      write SetArrayLength;
    Destructor Destroy; override;
  end;

  TLocation = class(TArrayMember)
    // @name starts at 1.
    Layer: integer;
    // @name starts at 1.
    Row: integer;
    // @name starts at 1.
    Column: integer;
    Used: Boolean;
    AuxilliaryVariables: array of double;
    FObservationGroups: TList;
    FObservationCells: TList;
    Constructor Create; override;
    Destructor Destroy; override;
    function SameObservations(ALocation: TLocation): boolean;
  end;

  TListInstanceObject = class(TObjectArray)
  private
    function GetLocations(Index: integer): TLocation;
  public
    Name: string;
    property Locations[Index: integer]: TLocation read GetLocations; default;
  end;

  TClusterObject = class(TArrayMember)
    MultiplierArray: string;
    ZoneArray: string;
    Zones: array of integer;
    function SimilarMultAndZone(Cluster: TClusterObject): boolean;
  end;

  TArrayInstanceObject = class(TObjectArray)
  private
    function GetCluster(Index: integer): TClusterObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    Name: string;
    property Clusters[Index: integer]: TClusterObject read GetCluster; default;
  end;

  TListParameterObject = class(TObjectArray)
  private
    function GetInstance(Index: integer): TListInstanceObject;
  public
    PARNAM: string;
    ModifiedParamName: string;
    PARTYP: string;
    Parval: Double;
    property Instances[Index: integer]: TListInstanceObject
      read GetInstance; default;
    function GetInstanceByName(const InstanceName: string): TListInstanceObject;
  end;

  TArrayParameterObject = class(TObjectArray)
  private
    function GetInstance(Index: integer): TArrayInstanceObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    PARNAM: string;
    ModifiedParamName: string;
    PARTYP: string;
    Parval: Double;
    property Instances[Index: integer]: TArrayInstanceObject
      read GetInstance; default;
    function GetInstanceByName(
      const InstanceName: string): TArrayInstanceObject;
  end;

  TListParamArray = class(TObjectArray)
  private
    function GetParams(Index: integer): TListParameterObject;
  public
    property Params[Index: integer]: TListParameterObject
      read GetParams; default;
    function GetParamByName(const ParamName: string): TListParameterObject;
  end;

  TArrayParamArray = class(TObjectArray)
  private
    function GetParams(Index: integer): TArrayParameterObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Params[Index: integer]: TArrayParameterObject
      read GetParams; default;
  end;

  TArrayStressPeriod = class(TArrayMember)
    Reuse: boolean;
    Parameters: array of string;
    Instances: array of string;
  end;

  TListStressPeriod = class(TObjectArray)
  private
    Reuse: boolean;
    Parameters: array of string;
    Instances: array of string;
    function GetBoundary(Index: integer): TLocation;
  public
    property Boundaries[Index: integer]: TLocation
      read GetBoundary; default;
    function IndexOfParameter(const ParameterName: string): integer;
  end;

  TArrayStressPeriodArray = class(TObjectArray)
  private
    function GetStressPeriod(Index: integer): TArrayStressPeriod;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property StressPeriods[Index: integer]: TArrayStressPeriod
      read GetStressPeriod; default;
  end;

  TListStressPeriodArray = class(TObjectArray)
  private
    function GetStressPeriod(Index: integer): TListStressPeriod;
  public
    property StressPeriods[Index: integer]: TListStressPeriod
      read GetStressPeriod; default;
  end;

  TChdInstanceObject = class(TListInstanceObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TChdParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TChdParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TChdStressPeriod = class(TListStressPeriod)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TChdStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TCustomFlowObservationImporter = class;

//  TPackageImporter = class(TObject)
//  private
//    FImportedPackage: boolean;
//    FProgressHandler: TPackageProgressHandler;
//    procedure AssignConstant2DIntArray(Value: integer; Array2D: T2DIntArray);
//    function CreateScreenObject(const Name: string): TScreenObject; overload;
//    procedure AddBoundaryPoints(List: TList; Index: integer; ObjectType: TObjectType; var AScreenObject: TScreenObject); virtual;
//  protected
//    FComments: TStringList;
//    FImporter: TModflow2005Importer;
//    FPackageIdentifier: string;
//    FModel: TPhastModel;
//    FGrid: TModflowGrid;
//    // @name is passed a label indicating the data that has been read from
//    // the @link(FImporter) file and reads that data from the file and stores
//    // it.
//    procedure ReadData(const ALabel: string); virtual;
//    // @name takes the data it has stored and modifies @link(FModel) to
//    // include that data.  This often means that @link(TDataArray)s and
//    // @link(TScreenObject)s are created.
//    procedure HandlePackage; virtual;
//    procedure Read1DRealArray(var DoubleArray: TOneDRealArray);
//    procedure Read2DRealArray(var DoubleArray: T2DDoubleArray);
//    procedure AssignConstant2DArray(Value: double; Array2D: T2DDoubleArray);
//    procedure AssignConstant1DArray(AnArray: TOneDRealArray; Value: double);
//    // @name creates a @link(TScreenObject) that has a vertex at the center
//    // of the each cell as seen from the top view of the model.  Each vertex
//    // is a new section. When adding vertices, the loop over columns is
//    // inside the loop over rows.
//    procedure CreateOrRetrieveCellCenterScreenObject(var ScreenObject
//      : TScreenObject);
//    procedure AssignRealValuesToCellCenters(DataArray: TDataArray;
//      ScreenObject: TScreenObject; ImportedData: T2DDoubleArray);
//    procedure AssignIntegerValuesToCellCenters(DataArray: TDataArray;
//      ScreenObject: TScreenObject; ImportedData: T2DIntArray);
//    procedure AssignBooleanValuesToCellCenters(DataArray: TDataArray;
//      ScreenObject: TScreenObject; ImportedData: T2DIntArray);
//    procedure ReadVariable2DIntArray(IntArray: T2DIntArray);
//    procedure CreateDataArrayAndAssignValues(ScreenObject: TScreenObject;
//      const DataArrayName: string; ImportedValues: T2DDoubleArray);
//    procedure CheckRealConstArray(out ConstantValue: double;
//      out IsConstant: boolean; const ArrayToCheck: TRealConstantRecordArray);
//    function FixArrayName(const ArrayName: string): string;
//    procedure AssignImportedValues(ImportedValues: TValueArrayItem;
//      ImportedData: T2DDoubleArray); overload;
//    procedure AssignImportedValues(ImportedValues: TValueArrayItem;
//      ImportedData: TDoubleArray); overload;
//    function UniformArray(ImportedData: TDoubleArray): boolean;
//    procedure CheckVariableRealArrays(var ConstArray: TRealConstantRecordArray;
//      VarArray: T3DDoubleArray);
//    procedure CheckVariableIntegerArrays(var ConstArray: TIntegerConstantArray;
//      VarArray: T3DIntArray);
//    function ScreenObjectNameRoot: string; virtual; abstract;
//    function CreateScreenObject(List: TList; var ScreenObjectIndex: integer;
//      LayerIndex, StressPeriodIndex: integer; ObjectType: TObjectType)
//      : TScreenObject; overload; virtual;
//  public
//    Constructor Create(Importer: TModflow2005Importer;
//      const PackageIdentifier: string);
//    Destructor Destroy; override;
//    procedure ImportPackage(out NextPackageIndex: integer);
//    property ImportedPackage: boolean read FImportedPackage;
//  end;

  TListImporter = class(TObjectImporter)
  private
    FParameters: TListParamArray;
    NP: integer;
    FAuxillaryVariables: TStringList;
    FNoPrint: Boolean;
    CurrentParameter: integer;
    CurrentInstance: integer;
    FCurrentStressPeriod: integer;
    ITMP: integer;
    NLST: integer;
    FStressPeriods: TListStressPeriodArray;
    FBoundaryIndex: Integer;
    FObsImporter: TCustomFlowObservationImporter;
    // @name creates a @link(TScreenObject) and adds it to the model.
    // The name of the object will incorporate the stress period number if
    // StressPeriodIndex is greater than or equal to 0.
    // List contains @link(TLocation)s which define where the vertices of
    // the @link(TScreenObject).
    // LayerIndex is used to help determine the @link(TScreenObject.Name)
    // as well as the elevation formula.
    procedure ImportNonParameterBoundaries(var ScreenObjectIndex: Integer);
    procedure ImportParameterBoundaries(ScreenObjectIndex: Integer);
    procedure ReadAuxilliaryVariableName;
    procedure ReadParameterName;
    procedure ReadInstanceName;
    procedure ReadFirstStressPeriodDataSet5WithParameters;
    procedure ReadFirstStressPeriodDataSet5WithoutParameters;
    procedure ReadNewStressPeriodDataSet5WithParameters;
    procedure ReadNewStressPeriodDataSet5WithoutParameters;
    procedure ReadParamNameForStressPeriod;
    procedure ReadInstanceNameForStressPeriod;
    procedure ReadDataSet1;
    procedure AssignObsGroupsToCells(CellList: TList);
  protected
    procedure CreateParameters;
    procedure InitializeStressPeriods; virtual;
    procedure InitializeCurrentStressPeriod; virtual;
    procedure ReadParameterValueAndLocationCount; virtual;
    procedure ReadNumberOfInstances; virtual;

    // List contains instances of TLocation;
    // Descendants may change ObjectType and perform additional actions.
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); virtual; abstract;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      virtual; abstract;
    procedure AssignObservations; virtual;
    procedure AssignObservationFactors(ScreenObject: TScreenObject;
      const ParamName: string; Boundaries: TList);
    procedure FillListOfCellsForStressPeriod(StressPeriodIndex: Integer;
      CellList: TList);
    function ParameterType: TParameterType; virtual; abstract;
    procedure ReleaseMemory;
    procedure HandleNonParamLocation(StressPeriodIndex: Integer;
      Boundary: TLocation); virtual;
    procedure HandleParamLocation(UsedStressPeriods: TIntegerList;
      Boundary: TLocation); virtual;
//    procedure HandleNonParamLocation; virtual;
//    procedure HandleParamLocation; virtual;
  public
    Constructor Create(Importer: TModflow2005Importer;
      const PackageIdentifier: string);
    Destructor Destroy; override;
  end;

  TFlowObservationLocation = class(TArrayMember)
  private
    LAYER: integer;
    ROW: integer;
    COLUMN: integer;
    FACTOR: double;
  end;

  TFlowObsLocArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TFlowObservationLocation;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TFlowObservationLocation
      read GetItem; default;
  end;

  TObservationTime = class(TArrayMember)
    OBSNAM: string;
    IREFSP: integer;
    TOFFSET: double;
    FLWOBS: double;
  end;

  TObsTimeArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TObservationTime;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TObservationTime
      read GetItem; default;
  end;

  TObservationGroup = class(TArrayMember)
  private
    FTimes: TObsTimeArray;
    FCells: TFlowObsLocArray;
    FGroup: TFluxObservationGroup;
    Constructor Create; override;
    Destructor Destroy; override;
  end;

  TObservations = class(TObjectArray)
  private
    function GetItem(Index: integer): TObservationGroup;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TObservationGroup
      read GetItem; default;
  end;

  TCustomFlowObservationImporter = class(TPackageImporter)
  private
    NQ: integer;
    IUOBSV: integer;
    TOMULT: double;
    FObservations: TObservations;
    FCurrentGroupIndex: Integer;
    FCurrentGroup: TObservationGroup;
    FCurrentTimeIndex: Integer;
    FCurrentLocationIndex: Integer;
    FIsActive: Boolean;
    NQCL: integer;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadDataSet3;
    procedure ReadDataSet4;
    procedure ReadDataSet5; virtual;
    procedure CreateObservationGroups;
  protected
    FDataSet1Label: string;
    FDataSet2Label: string;
    FDataSet3Label: string;
    FDataSet4Label: string;
    FDataSet5Label: string;
    FObsPrefix: string;
    FFlowObsGroups: TFluxObservationGroups;
    procedure ReadData(const ALabel: string); override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      const PackageIdentifier: string);
    Destructor Destroy; override;
  end;

  TChdLocationObject = class(TLocation)
    StartFactor: double;
    EndFactor: double;
  end;

  TCustomChdImporter = class(TListImporter)
  protected
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ParameterType: TParameterType; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string);override;
  end;

  TBasChdObjects = class(TObject)
  private
    FScreenObject: TScreenObject;
    FList: TList;
  public
    Constructor Create;
    Destructor Destroy; override;
  end;

  TBasImporter = class(TCustomChdImporter)
  private
    FIbound: T3DIntArray;
    FConstantIbound : TIntegerConstantArray;
    FDis: TDisImporter;
  strict private
    FHeading1: string;
    FHeading2: string;
    FChtoch: Boolean;
    FPrintTime: Boolean;
    FHNoFlo: double;
    FCrossSection: Boolean;
    FStrt: T3DDoubleArray;
    FConstantStrt : TRealConstantRecordArray;
    FSpecifiedHeadsList: TList;
    STOPER: double;
    procedure ImportInitialHead;
    procedure ImportActiveCells;
    procedure ReadHeading(var AHeading: string);
    procedure ReadDataSet1;
    procedure ReadVariableInitialHeadForLayer;
    procedure ReadVariableInitialHeadForCrossSection;
    procedure ReadConstantInitialHeadForLayer;
    procedure ReadConstantInitialHeadForCrossSection;
    procedure ReadVariableIboundForCrossSection;
    procedure ReadVariableIboundForLayer;
    procedure ReadConstantIboundForCrossSection;
    procedure ReadConstantIboundForLayer;
    procedure ReleaseMemory;
  private
    FInitialCHDLocations: array of array of TBooleanDynArray;
    FHasReadIBound: Boolean;
    procedure ImportSpecifiedHeads;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    function ScreenObjectNameRoot: string; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
    property Dis: TDisImporter read FDis write FDis;
  end;

  TChdImporter = class(TCustomChdImporter)
  private
    MXACTC: integer;
    FChdPackage: TModflowPackageSelection;
    FReadData: Boolean;
    FBasImporter: TBasImporter;
    function CreateScreenObject(List: TList;
      var ScreenObjectIndex: Integer; LayerIndex,
      StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject; override;
    procedure ReadDataSet2;
    procedure ReadParameterType;
    procedure ReadParameterLocations;
    procedure ReadNonParameterLocations;
    function ScreenObjectNameRoot: string; override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    procedure HandleNonParamLocation(StressPeriodIndex: Integer;
      Boundary: TLocation); override;
    procedure HandleParamLocation(UsedStressPeriods: TIntegerList;
      Boundary: TLocation); override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      BasImporter: TBasImporter);
    Destructor Destroy; override;
  end;

  TChdObsImporter = class(TCustomFlowObservationImporter)
  private
    FChdImporter: TChdImporter;
    FBasImporter: TBasImporter;
  protected
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      ChdImporter: TChdImporter; BasImporter: TBasImporter);
  end;


  TWelLocationObject = class(TLocation)
    PumpingRate: double;
  end;

  TWelInstanceObject = class(TListInstanceObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TWelParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TWelParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TWelStressPeriod = class(TListStressPeriod)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TWelStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TWellTabValue = class(TArrayMember)
    Time: double;
    Rate: double;
  end;

  TWellTabValues = class(TObjectArray)
  private
    function GetWellItems(Index: Integer): TWellTabValue;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    Layer: integer;
    Row: integer;
    Column: integer;
    property WellItems[Index: Integer]: TWellTabValue read GetWellItems; default;
  end;

  TWellTabFiles = class(TObjectArray)
  private
    function GetWellValues(Index: Integer): TWellTabValues;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property WellValues[Index: Integer]: TWellTabValues read GetWellValues; default;
  end;

  TWelImporter = class(TListImporter)
  private
    MXACTW: integer;
    IWELCB: integer;
    PSIRAMP: double;
    IUNITRAMP: integer;
    FWellTabFiles: TWellTabFiles;
    FTabCell: Integer;
    procedure ReadDataSet2;
    procedure ReadParameterType;
    procedure ReadParameterLocations;
    procedure ReadNonParameterLocations;
    function CreateScreenObject(List: TList;
      var ScreenObjectIndex: Integer; LayerIndex,
      StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ScreenObjectNameRoot: string; override;
    function ParameterType: TParameterType; override;
    procedure ReadPhiRamp;
    procedure ReadMaxTab;
    procedure ReadTabFile;
    procedure ImportTabFileWells(var ScreenObjectIndex: Integer);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TGhbLocationObject = class(TLocation)
    BHead: double;
    Conductance: double;
  end;

  TGhbInstanceObject = class(TListInstanceObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TGhbParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TGhbParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TGhbStressPeriod = class(TListStressPeriod)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TGhbStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TGhbImporter = class(TListImporter)
  private
    MXACTB: integer;
    IGHBCB: integer;
    procedure ReadDataSet2;
    procedure ReadParameterType;
    procedure ReadParameterLocations;
    procedure ReadNonParameterLocations;
    function CreateScreenObject(List: TList;
      var ScreenObjectIndex: Integer; LayerIndex,
      StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ScreenObjectNameRoot: string; override;
    function ParameterType: TParameterType; override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TGhbObsImporter = class(TCustomFlowObservationImporter)
  private
    FGhbImporter: TGhbImporter;
  protected
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      GhbImporter: TGhbImporter);
  end;

  TDrnLocationObject = class(TLocation)
    Elevation: double;
    Conductance: double;
  end;

  TDrnInstanceObject = class(TListInstanceObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrnParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrnParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrnStressPeriod = class(TListStressPeriod)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrnStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrnObsImporter = class;

  TDrnImporter = class(TListImporter)
  private
    MXACTD: integer;
    IDRNCB: integer;
    procedure ReadDataSet2;
    procedure ReadParameterType;
    procedure ReadParameterLocations;
    procedure ReadNonParameterLocations;
    function CreateScreenObject(List: TList;
      var ScreenObjectIndex: Integer; LayerIndex,
      StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ScreenObjectNameRoot: string; override;
    function ParameterType: TParameterType; override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TDrnObsImporter = class(TCustomFlowObservationImporter)
  private
    FDrnImporter: TDrnImporter;
  protected
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      DrnImporter: TDrnImporter);
  end;

  TDrtLocationObject = class(TDrnLocationObject)
    LayR: integer;
    RowR: integer;
    ColR: integer;
    Rfprop: double;
  end;

  TDrtInstanceObject = class(TListInstanceObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrtParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrtParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrtStressPeriod = class(TListStressPeriod)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrtStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TDrtImporter = class(TListImporter)
  private
    ReturnFlow: boolean;
    FCurrentDrtBoundary: TDrtLocationObject;
    procedure ReadParameterType;
    function CreateScreenObject(List: TList;
      var ScreenObjectIndex: Integer; LayerIndex,
      StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ScreenObjectNameRoot: string; override;
    function ParameterType: TParameterType; override;
    procedure ReadDataSet1DRT;
    procedure ReadParameterLocationsWithoutReturnFlow;
    procedure ReadParameterLocationsWithReturnFlow;
    procedure ReadNonParameterLocationsWithoutReturnFlow;
    procedure ReadNonParameterLocationsWithReturnFlow;
    procedure ReadAuxilliaryVariables;
    procedure ImportNonParameterBoundaries(var ScreenObjectIndex: Integer);
    procedure ImportParameterBoundaries(ScreenObjectIndex: Integer);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TRivLocationObject = class(TLocation)
    Stage: double;
    Conductance: double;
    Bottom: double;
  end;

  TRivInstanceObject = class(TListInstanceObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TRivParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TRivParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TRivStressPeriod = class(TListStressPeriod)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TRivStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TRivImporter = class(TListImporter)
  private
    MXACTR: integer;
    IRIVCB: integer;
    procedure ReadDataSet2;
    procedure ReadParameterType;
    procedure ReadParameterLocations;
    procedure ReadNonParameterLocations;
    function CreateScreenObject(List: TList;
      var ScreenObjectIndex: Integer; LayerIndex,
      StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ScreenObjectNameRoot: string; override;
    function ParameterType: TParameterType; override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TRivObsImporter = class(TCustomFlowObservationImporter)
  private
    FRivImporter: TRivImporter;
  protected
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      RivImporter: TRivImporter);
  end;


  TTransientArrayImporter = class(TPackageImporter)
  private
    NP: integer;
    CurrentParameter: Integer;
    CurrentInstance: integer;
    ZoneCount: integer;
    FCurrentStressPeriod: integer;
    FParams: TArrayParamArray;
    NCLU: integer;
    CurrentCluster: Integer;
    FStressPeriods: TArrayStressPeriodArray;
    FZoneImporter: TMultZoneImporter;
    FQuadTree: TRbwQuadTree;
    FPointLists: TObjectList<TPointList>;
    FEpsilon: Real;
    FRequiredType: string;
    FReuseLayerIndicator: TBooleanDynArray;
    FConstantLayerIndicators: TIntegerConstantArray;
    FVariableLayerIndicators: T3DIntArray;
    procedure ReadNumberOfParameters;
    procedure ReadParameterName;
    procedure ReadParameterType(RequiredType: string);
    procedure ReadParameterValue;
    procedure ReadNumberOfClusters;
    procedure ReadNumberOfInstances;
    procedure ReadInstanceName;
    procedure ReadMultiplierAndZoneArrayNames;
    procedure ReadNumberOfZones;
    procedure ReadZoneValues;
    procedure ReadParameterForStressPeriod;
    procedure ReadInstanceForStressPeriod;
    procedure InitializeStressPeriods;
    procedure ImportSharedData(const ALabel: string; out Handled: boolean);
    procedure InitializeCurrentStressPeriod(ReadParamArray: Integer);
    procedure InitializeReuseLayerIndicator;
    procedure ReadRealConstantArrayItem(Value: Double;
      var RealConstantArray: TRealConstantRecordArray);
    procedure ReadRealVariableArray(var VariableArray: T3DDoubleArray;
      const ArrayName: string);
    procedure ReadConstantIntArray(IntValue: Integer;
      var ConstantIntArray: TIntegerConstantArray);
    procedure ReadVariableIntArray(var VariableIntArray: T3DIntArray);
    procedure EvaluateTimeVaryingLayers(
      Package: TCustomTransientLayerPackageSelection);
    procedure CreateAssignedLayerDataSet(
      Package: TCustomTransientLayerPackageSelection; DataSetRoot: string;
      ScreenObjectName: string; var AssignedLayerDataSet: TDataArray);
    procedure CreateTransientParam(Param: TArrayParameterObject);
    function FindSimilarClusterAndAddScreenObject(ACluster: TClusterObject;
      ClusterList, ScreenObjectList: TList): boolean;
    procedure CreateScreenObjectFromCluster(ClusterList,
      ScreenObjectList: TList; var ObjectIndex: Integer;
      Cluster: TClusterObject; const ScreenObjectRoot,
      ImportedElevFormula: string;
      Package: TCustomTransientLayerPackageSelection);
    procedure CreateScreenObjectsFromClusters(Param: TArrayParameterObject;
      var ObjectIndex: Integer; ScreenObjectList, ClusterList: TList;
      const ScreenObjectRoot, ImportedElevFormula: string;
      Package: TCustomTransientLayerPackageSelection);
    Function CreateScreenObjectAroundZones(ZoneArray: T2DIntArray;
      Cluster: TClusterObject; const Name: string): TScreenObject;
    procedure InitializeQuadTree;
    // @name is the event handler for TContourCreator.OnExtractSegments
    procedure ImportSegments(Sender: TObject; const Segments: TLine2DArray);
    procedure CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex: Integer;
      const DataSetRoot, ScreenObjectRoot: string;
      Package: TCustomTransientLayerPackageSelection);
    procedure GetParamInstanceForCurrentStressPeriod(
      var Instance: TArrayInstanceObject;
      Param: TArrayParameterObject; StressPeriod: TArrayStressPeriod);
    procedure CreateScreenObjectsAroundValues(Values: T2DDoubleArray;
      const Root: string; DataArray: TDataArray;
      ValueList: TRealList); overload;
    procedure CreateScreenObjectsAroundValues(Values: T2DIntArray;
      const Root: string; DataArray: TDataArray;
      ValueList: TIntegerList); overload;
    procedure InitializeEpsilon;
  protected
    procedure CreateBoundary(ScreenObject: TScreenObject); virtual; abstract;
    procedure CreateTransientRealDataArray(StressPeriodIndex: Integer;
      Reuse: TBooleanDynArray; DataArrayRoot: string;
      ConstantValues: TRealConstantRecordArray; VariableValues: T3DDoubleArray;
      ImportedValueName: string);
  public
    Constructor Create(Importer: TModflow2005Importer;
      const PackageIdentifier: string; ZoneImporter: TMultZoneImporter);
    Destructor Destroy; override;
  end;

  TRchImporter = class(TTransientArrayImporter)
  private
    NRCHOP: integer;
    FConstantRecharge: TRealConstantRecordArray;
    FVariableRecharge: T3DDoubleArray;
    FReuseRecharge: TBooleanDynArray;
    FRchPackage: TRchPackageSelection;
    procedure InitializeReuseRecharge;
    procedure SetRechargeOption;
    procedure ReuseRchStressPeriodWithParameters(StressPeriodIndex: Integer;
      Param: TArrayParameterObject; ScreenObjectList: TList;
      const RechargeLayerName: string);
    procedure AssignTimeVaryingLayer(ScreenObject: TScreenObject;
      RechargeLayerName: string; StressPeriodIndex: Integer);
    procedure AssignParamRechargeRate(ScreenObject: TScreenObject;
      StressPeriodIndex: Integer; Cluster: TClusterObject;
      Param: TArrayParameterObject);
    procedure CreateRechargeRateDataSet(StressPeriodIndex: Integer);
    procedure AssignRchLayerNonParam(NewItemNeeded: Boolean;
      var LayerItem: TRchLayerItem; RchBoundary: TRchBoundary;
      RechargeLayerName: string; StressPeriodIndex: Integer);
    procedure AssignRechRateNonParam(RechargeName: string;
      NewItemNeeded: Boolean; var RchItem: TRchItem; RchBoundary: TRchBoundary;
      StressPeriodIndex: Integer);
    procedure CreateBoundary(ScreenObject: TScreenObject); override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      ZoneImporter: TMultZoneImporter);
  end;

  TCustomETImporter = class(TTransientArrayImporter)
  protected
    FReuseEtSurface: TBooleanDynArray;
    FReuseEtExtinctionDepth: TBooleanDynArray;
    FReuseEtRate: TBooleanDynArray;
    FConstantEtSurface: TRealConstantRecordArray;
    FVariableEtSurface: T3DDoubleArray;
    FConstantEtRate: TRealConstantRecordArray;
    FVariableEtRate: T3DDoubleArray;
    FConstantExtinctionDepth: TRealConstantRecordArray;
    FVariableExtinctionDepth: T3DDoubleArray;
    Package: TCustomTransientLayerPackageSelection;
    procedure InitializeReuseEtSurface;
    procedure InitializeReuseExtinctionDepth;
    procedure InitializeReuseEtRate;
    class function ImportedEtSurfaceName: string; virtual; abstract;
    class function ImportedEtSurfaceSP: string; virtual; abstract;
    class function EtExtinctionDepth_Name: string; virtual; abstract;
    class function EtExtinctionDepth_SP: string; virtual; abstract;
    procedure CreateEtSurfaceDataSet(StressPeriodIndex: Integer);
    procedure CreateEtExtinctionDepthDataSet(StressPeriodIndex: Integer);
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      virtual; abstract;
    procedure ReuseEtStressPeriodWithParameters(StressPeriodIndex: Integer;
      Param: TArrayParameterObject; ScreenObjectList: TList;
      const EvtLayerName, EvtSurfaceName, EvtDepthName: string);
    procedure AssignTimeVaryingLayer(ScreenObject: TScreenObject;
      EvtLayerName: string; StressPeriodIndex: Integer); virtual; abstract;
    procedure AssignSurfaceAndDepth(ScreenObject: TScreenObject;
      EvtSurfaceName, EvtDepthName: string; StressPeriodIndex: Integer);
      virtual; abstract;
    procedure AssignParamEvtRate(ScreenObject: TScreenObject;
      StressPeriodIndex: Integer; Cluster: TClusterObject;
      Param: TArrayParameterObject);
    class function ImportedEtRateName: string; virtual; abstract;
    class function ImportedEtValuesName: string; virtual; abstract;
    procedure CreateEvtRateDataSet(StressPeriodIndex: Integer);
    procedure AssignEtRateNonParam(EvtName: string;
      NewItemNeeded: Boolean; var EvtItem: TEvtItem;
      EvtBoundary: TModflowParamBoundary; StressPeriodIndex: Integer);
  end;

  TEvtImporter = class(TCustomETImporter)
  private
    NEVTOP: integer;
    FEvtPackage: TEvtPackageSelection;
    procedure SetEvtOption;
    procedure AssignEvtLayerNonParam(NewItemNeeded: Boolean;
      var LayerItem: TEvtLayerItem; EvtBoundary: TEvtBoundary;
      EvtLayerName: string; StressPeriodIndex: Integer);
    procedure AssignEvtSurfaceNonParam(EvtSurfaceName, EvtExtinctName: string;
      NewItemNeeded: Boolean; var EvtItem: TEvtSurfDepthItem;
      EvtBoundary: TEvtBoundary; StressPeriodIndex: Integer);
    procedure AssignSurfaceAndDepth(ScreenObject: TScreenObject;
      EvtSurfaceName, EvtDepthName: string; StressPeriodIndex: Integer); override;
    procedure CreateBoundary(ScreenObject: TScreenObject); override;
    class function ImportedEtSurfaceName: string; override;
    class function ImportedEtSurfaceSP: string; override;
    class function EtExtinctionDepth_Name: string; override;
    class function EtExtinctionDepth_SP: string; override;
    function GetBoundary(ScreenObject: TScreenObject):
      TModflowParamBoundary; override;
    procedure AssignTimeVaryingLayer(ScreenObject: TScreenObject;
      EvtLayerName: string; StressPeriodIndex: Integer); override;
    class function ImportedEtRateName: string; override;
    class function ImportedEtValuesName: string; override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      ZoneImporter: TMultZoneImporter);
  end;

  TEtsImporter = class(TCustomETImporter)
  private
    FCurrentSegment: Integer;
    FReuseSegmentDefinition: TBooleanDynArray;
    FConstantDepthProportions: array of TRealConstantRecordArray;
    FVariableDepthProportions: array of T3DDoubleArray;
    FConstantRateProportions: array of TRealConstantRecordArray;
    FVariableRateProportions: array of T3DDoubleArray;
    FEtsPackage: TEtsPackageSelection;
    NETSOP: integer;
    NETSEG: integer;
    procedure InitializeReuseSegmentDefinition;
    procedure CreateBoundary(ScreenObject: TScreenObject); override;
    procedure SetEtsOption;
    class function ImportedEtSurfaceName: string; override;
    class function ImportedEtSurfaceSP: string; override;
    class function EtExtinctionDepth_Name: string; override;
    class function EtExtinctionDepth_SP: string; override;
    function GetBoundary(ScreenObject: TScreenObject):
      TModflowParamBoundary; override;
    procedure AssignTimeVaryingLayer(ScreenObject: TScreenObject;
      EvtLayerName: string; StressPeriodIndex: Integer); override;
    procedure AssignSurfaceAndDepth(ScreenObject: TScreenObject;
      EvtSurfaceName, EvtDepthName: string;
      StressPeriodIndex: Integer); override;
    class function ImportedEtRateName: string; override;
    class function ImportedEtValuesName: string; override;
    procedure AssignEtsLayerNonParam(NewItemNeeded: Boolean;
      var LayerItem: TEvtLayerItem; EvtBoundary: TEtsBoundary;
      EvtLayerName: string; StressPeriodIndex: Integer);
    procedure AssignEtsSurfaceNonParam(EvtSurfaceName, EvtExtinctName: string;
      NewItemNeeded: Boolean; var EvtItem: TEtsSurfDepthItem;
      EvtBoundary: TEtsBoundary; StressPeriodIndex: Integer);
    function SegIndexToStr(SegIndex: integer): string;
    procedure CreateDepthFractionDataSet(SegmentIndex,
      StressPeriodIndex: Integer);
    procedure CreateRateFractionDataSet(SegmentIndex,
      StressPeriodIndex: Integer);
    procedure AssignSegments(LayerItem: TEtsSurfDepthItem;
      StressPeriodIndex: Integer);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      ZoneImporter: TMultZoneImporter);
  end;

  TSfrLocationObject = class(TLocation)
    SegmentNumber: integer;
    ReachNumber: integer;
    RCHLEN: double;
    STRTOP: double;
    SLOPE: double;
    STRTHICK: double;
    STRHC1: double;
    THTS: double;
    THTI: double;
    EPS: double;
    UHC: double;
  end;

  TFlowTableItem = class(TArrayMember)
    FLOWTAB: double;
    DPTHTAB: double;
    WDTHTAB: double;
  end;

  TFlowTableArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TFlowTableItem;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TFlowTableItem read GetItem;  default;
  end;

  TInflowRecord = record
    Time: double;
    Inflow: double;
  end;

  TSegment = class(TArrayMember)
    NSEG: integer;
    ICALC: integer;
    OUTSEG: integer;
    IUPSEG: integer;
    IPRIOR: integer;
    NSTRPTS: integer;
    FLOW: double;
    RUNOFF: double;
    ETSW: double;
    PPTSW: double;
    ROUGHCH: double;
    ROUGHBK: double;
    CDPTH: double;
    FDPTH: double;
    AWDTH: double;
    BWDTH: double;
    HCOND1: double;
    THICKM1: double;
    ELEVUP: double;
    WIDTH1: double;
    DEPTH1: double;
    THTS1: double;
    THTI1: double;
    EPS1: double;
    UHC1: double;
    HCOND2: double;
    THICKM2: double;
    ELEVDN: double;
    WIDTH2: double;
    DEPTH2: double;
    THTS2: double;
    THTI2: double;
    EPS2: double;
    UHC2: double;
    TableX: array[0..7] of double;
    TableZ: array[0..7] of double;
    InflowValues: array of TInflowRecord;
    FFlowTable: TFlowTableArray;
    Constructor Create; override;
    Destructor Destroy; override;
  end;

  TSegmentArray = class(TListStressPeriod)
  private
    function GetSegments(Index: integer): TSegment;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Segments[Index: integer]: TSegment read GetSegments;  default;
  end;

  TStressPeriodSegments = class(TObjectArray)
  private
    function GetSegmentArray(Index: integer): TSegmentArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property SegmentArrays[Index: integer]: TSegmentArray
      read GetSegmentArray;  default;
  end;

  TSfrInstanceObject = class(TListInstanceObject)
  private
    FSegments: TSegmentArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Segments: TSegmentArray read FSegments;
    Constructor Create; override;
    Destructor Destroy; override;
    function GetSegByNumber(NSEG: integer): TSegment;
  end;

  TSfrParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TSfrParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TSfrReaches = class(TObjectArray)
  private
    function GetReach(Index: integer): TSfrLocationObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Reaches[Index: integer]: TSfrLocationObject read GetReach; default;
  end;

  TSfrStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  // @name imports polyline sections into objects instead of points or polygons.
  TLineImporter = class(TListImporter)

  end;

  TSfrImporter = class(TLineImporter)
  private
    NSTRM: integer;
    DLEAK: double;
    ISFROPT: Integer;
    ISUZN: integer;
    NSFRSETS: integer;
    NSS: integer;
    ISTCB1: integer;
    ISTCB2: integer;
    NSTRAIL: integer;
    NPARSEG: integer;
    SfrCONST: double;
    FCurrentReachIndex: integer;
    FReaches: TSfrReaches;
    FCurrentReach: TSfrLocationObject;
    FCurrentSegments: TSegmentArray;
    FCurrentSegmentIndex: integer;
    FCurrentSegment: TSegment;
    FSfrPackage: TSfrPackageSelection;
    FSfrBoundary: TSfrBoundary;
    FStressPeriodSegments: TStressPeriodSegments;
    SegCount: integer;
    FParamUsed: Boolean;
    IRTFLG: integer;
    NUMTIM: integer;
    WEIGHT: double;
    FLWTOL: double;
    NUMTAB: integer;
    MAXVAL: integer;
    FSegmentStorage: TList;
    FItemStorage: TList;
    FLossFactorUsed: boolean;
    FLossFactor: Double;
    FIsSelected: Boolean;
    procedure ReadBasicData;
    procedure ReadIsfropt;
    procedure ReadUnsatParameters;
    procedure ReadParameterType;
    procedure ReadSegmentStart(IsParameter: boolean);
    procedure ReadSegment4b6a(const ALabel: string; IsParameter: boolean);
    procedure ReadSegment4c6b(const ALabel: string);
    procedure ReadSegment4d6c(const ALabel: string);
    procedure ReadTableXValues;
    procedure ReadTableZValues;
    procedure ReadFlowTableFlows;
    procedure ReadFlowTableDepths;
    procedure ReadFlowTableWidths;
    procedure ReadFirstDataSet5WithoutParameters;
    procedure ReadFirstDataSet5WithParameters;
    procedure ReadDataSet5WithoutParameters;
    procedure ReadDataSet5WithParameters;
    procedure ReadParameterValueAndLocationCount; override;
    procedure ReadNumberOfInstances; override;
    function CreateStream(List: TList;
      var ScreenObjectIndex: integer): TScreenObject;
    procedure AssignReachValues(List: TList; ScreenObject: TScreenObject);
    procedure AssignStartAndEndTimes;
    procedure InitializeCurrentStressPeriod; override;
    procedure AssignParamIcalcValues(IcalcIndex: Integer; Segment: TSegment);
    procedure AssignFlowTableValues(IcalcIndex: Integer; Segment: TSegment);
    procedure AssignSegmentFlowValues(IcalcIndex: Integer; Segment: TSegment);
    procedure AssignChannelValues(IcalcIndex: Integer;
      StressPeriodIndex: Integer; Segment: TSegment);
    procedure AssignEquationValues(IcalcIndex: Integer; Segment: TSegment);
    procedure AssignUpstreamValues(IcalcIndex: Integer;
      StressPeriodIndex: Integer; Segment: TSegment);
    procedure AssignDownstreamValues(Segment: TSegment;
      StressPeriodIndex: Integer; IcalcIndex: Integer);
    procedure AssignUnsatValues(Segment: TSegment; StressPeriodIndex: Integer;
      IcalcIndex: Integer);
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    procedure AssignSegmentProperties;
    procedure CreateParamInstances(ParameterSegments: TIntegerList);
    function DefaultInstanceName(StressPeriodIndex: integer): string;
    procedure AssignParameterSegmentProperties(PriorSegNumber: Integer);
    procedure ReadExternalFlows;
    procedure AssignExternalFlows(Segment: TSegment);
    procedure ReadLossFactor;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ScreenObjectNameRoot: string; override;
    function ParameterType: TParameterType; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TStrLocationObject = class(TLocation)
    SegmentNumber: integer;
    ReachNumber: integer;
    Flow: double;
    Stage: double;
    Condfact: double;
    Sbot: double;
    Stop: double;
    ParameterName: string;
    InstanceName: string;
    function LocationsMatch(AReach: TStrLocationObject): Boolean;
    constructor Create; override;
  end;

  TReachList = class(TList<TStrLocationObject>)
    StartTime: double;
    EndTime: Double;
    StressPeriod: integer;
    function LocationsMatch(ReachList: TReachList): boolean;
    function SegmentNumber: integer;
    function ParameterName: string;
  end;

  TSegmentList = TObjectList<TReachList>;

  TSegmentListList = TObjectList<TSegmentList>;

  TStrReaches = class(TObjectArray)
  private
    function GetReach(Index: integer): TStrLocationObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Reaches[Index: integer]: TStrLocationObject read GetReach; default;
  end;

  TStrInstanceObject = class(TListInstanceObject)
  private
    function GetReach(Index: integer): TStrLocationObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Reaches[Index: integer]: TStrLocationObject read GetReach; default;
  end;

  TStrParameterObject = class(TListParameterObject)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TStrParamArray = class(TListParamArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  TStrStressPeriod = class(TListStressPeriod)
  private
    function GetItem(Index: Integer): TStrLocationObject;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TStrLocationObject read GetItem; default;
  end;

  TStrStressPeriodArray = class(TListStressPeriodArray)
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  // @name is the channel characteristics for one reach in one stress period
  TChannelCharacteristics = class(TArrayMember)
    Width: double;
    Slope: double;
    Roughness: double;
  end;

  // @name is the channel characteristics for all the reaches in one stress period
  TChannelCharacteristicsArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TChannelCharacteristics;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TChannelCharacteristics read GetItem; default;
  end;

  // @name is the channel characteristics for all the reaches for all the stress periods.
  TChannelCharacteristicsStressPeriodArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TChannelCharacteristicsArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TChannelCharacteristicsArray read GetItem; default;
  end;

  // @name is the tributaries for one segment in one stress period
  TTributaries = class(TArrayMember)
    Itrib: array of Integer;
  end;

  // @name is the tributaries for all the segments in one stress period
  TTributariesArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TTributaries;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TTributaries read GetItem; default;
  end;

  // @name is the tributaries for all the segments for all the stress periods.
  TTributariesStressPeriodArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TTributariesArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TTributariesArray read GetItem; default;
  end;

  // @name is the diversion for one segment in one stress period
  TDiversion = class(TArrayMember)
    Iupseg: Integer;
  end;

  // @name is the diversions for all the segments in one stress period
  TDiversionArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TDiversion;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TDiversion read GetItem; default;
  end;

  // @name is the diversions for all the segments for all the stress periods.
  TDiversionStressPeriodArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TDiversionArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TDiversionArray read GetItem; default;
  end;

  // @name is a parameter and instance name for one stress period
  TParamInstance = class(TArrayMember)
    ParamName: string;
    InstanceName: string;
  end;

  // @name is all the parameter and instance names for one stress period
  TParamInstanceArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TParamInstance;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TParamInstance read GetItem; default;
  end;

  // @name is all the parameter and instance names for all the stress periods.
  TParamInstanceStressPeriodArray = class(TObjectArray)
  private
    function GetItem(Index: Integer): TParamInstanceArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: Integer]: TParamInstanceArray read GetItem; default;
  end;

  TStrItemList = TList<TStrItem>;
  TStrItemLists = TObjectList<TStrItemList>;

  TStrImporter = class(TLineImporter)
  private
    ICALC: integer;
    ACONST: double;
    NTRIB: Integer;
    NDIV: Integer;
    NSS: Integer;
    MXACTS: Integer;
    FReachIndex: Integer;
    FReachChanelIndex: Integer;
    FSegmentTributaryIndex: Integer;
    FSegmentDiversionIndex: Integer;
    FParamIndex: integer;
    FChannelCharacteristicsStressPeriodArray: TChannelCharacteristicsStressPeriodArray;
    FTributariesStressPeriodArray: TTributariesStressPeriodArray;
    FDiversionStressPeriodArray: TDiversionStressPeriodArray;
    FParamInstanceStressPeriodArray: TParamInstanceStressPeriodArray;
    FStrPackage: TStrPackageSelection;
    FScreenObjectsInAllStressPeriod: TObjectList<TList<TScreenObject>>;
    procedure ReadDataSet2;
    procedure ReadParameterType;
    procedure ReadInstance;
    procedure ReadReach;
    procedure ReadDataSet5;
    procedure AssignReach(ReachObject: TStrLocationObject);
    procedure ReadDataSet8;
    procedure ReadDataSet9;
    procedure ReadDataSet10;
    procedure ReadDataSet7A;
    procedure ReadDataSet7B;
    procedure SetLengthAndTimeUnit;
  protected
    function ScreenObjectNameRoot: string; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ParameterType: TParameterType; override;
    procedure InitializeStressPeriods; override;
    procedure InitializeCurrentStressPeriod; override;
    // @name is passed a label indicating the data that has been read from
    // the @link(FImporter) file and reads that data from the file and stores
    // it.
    procedure ReadData(const ALabel: string); override;
    // @name takes the data it has stored and modifies @link(FModel) to
    // include that data.  This often means that @link(TDataArray)s and
    // @link(TScreenObject)s are created.
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TStrObsImporter = class(TCustomFlowObservationImporter)
  private
    FStrImporter: TStrImporter;
  protected
    procedure ReadDataSet5; override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      StrImporter: TStrImporter);
  end;


  TMultLayerFactor = class(TArrayMember)
    Layer: integer;
    Proportion: double;
  end;

  TMultiLayerArray = class(TObjectArray)
  private
    function GetMultLayerFactor(Index: integer): TMultLayerFactor;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property MultLayerFactors[Index: integer]: TMultLayerFactor
      read GetMultLayerFactor; default;
  end;

  TMultiTimeObs = class(TArrayMember)
    Name: string;
    RefStressPeriod: integer;
    TimeOffset: double;
    HeadObservation: double;
  end;

  TMultiTimeObsArray = class(TObjectArray)
  private
    function GetMultiTimeObs(Index: integer): TMultiTimeObs;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property MultTimeObs[Index: integer]: TMultiTimeObs
      read GetMultiTimeObs; default;
  end;

  THeadObservation = class(TArrayMember)
    OBSNAM: string;
    Layer: integer;
    Row: integer;
    Column: integer;
    RowOffset: double;
    ColumnOffset: double;
    ITT: integer;
    FMultiLayers: TMultiLayerArray;
    FObsTimes: TMultiTimeObsArray;
    Constructor Create; override;
    Destructor Destroy; override;
  end;

  THeadObsevationArray = class(TObjectArray)
  private
    function GetHeadObservation(Index: integer): THeadObservation;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property HeadObservations[Index: integer]: THeadObservation
      read GetHeadObservation; default;
  end;

  THobImporter = class(TPackageImporter)
  private
    HOBDRY: double;
    TOMULTH: double;
    FHeadObservations: THeadObsevationArray;
    FHobPackage: THobPackageSelection;
    FCurrentObsIndex: Integer;
    FCurrentTimeIndex: integer;
    FCurrentObs: THeadObservation;
    FCurrentObsTime: TMultiTimeObs;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadDataSet3ObsName;
    procedure ReadDataSet3Observation;
    procedure ReadDataSet4;
    procedure ReadDataSet5;
    procedure ReadDataSet6ObsName;
    procedure ReadDataSet6Values;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  THfbLocation = class(TLocation)
    Row2: integer;
    Col2: integer;
    Factor: double;
  end;

  THfbLocations = class(TListInstanceObject)
  private
    function GetBarriers(Index: integer): THfbLocation;
  protected
    // @name returns @link(THfbLocation);
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Barriers[Index: integer]: THfbLocation read GetBarriers; default;
  end;

  THfbParam = class(TListParameterObject)
  protected
    // @name returns @link(THfbLocations);
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  THfbParamArray = class(TListParamArray)
  protected
    // @name returns @link(THfbParam);
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  THfbStressPeriod = class(TListStressPeriod)
  private
    function GetBarrierList(Index: integer): THfbLocations;
  protected
    // @name returns @link(THfbLocations);
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property BarrierList[Index: integer]: THfbLocations
      read GetBarrierList; default;
  end;

  THfbStressPeriodArray = class(TListStressPeriodArray)
  protected
    // @name returns @link(THfbStressPeriod);
    function ArrayMemberClass: TArrayMemberClass; override;
  end;

  THfbImporter = class(TListImporter)
  private
    NoPrintOption: boolean;
    NACTHFB: integer;
    ParameterNames: array of string;
    FParam: THfbParam;
    FCurrentLocation: integer;
    FLocations: THfbLocations;
    NHFBNP: integer;
    FHfbPackage: TModflowPackageSelection;
    procedure ReadParameterType;
    procedure DefineBarrier(Location: THfbLocation;
      const ParamName: string; var Count: integer);
    function ScreenObjectNameRoot: string; override;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ParameterType: TParameterType; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TLakeValues = class(TArrayMember)
    SSMN: double;
    SSMX: double;
    PRCPLK: double;
    EVAPLK: double;
    RNF: double;
    WTHDRW: double;
  end;

  TLakeValueArray = class(TObjectArray)
  private
    function GetLakeValues(Index: integer): TLakeValues;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    Reuse: boolean;
    property LakeValues[Index: integer]: TLakeValues
      read GetLakeValues; default;
  end;

  TLakeStressPeriodValues = class(TObjectArray)
  private
    function GetLakeValueArray(Index: integer): TLakeValueArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property LakeValueArray[Index: integer]: TLakeValueArray
      read GetLakeValueArray; default;
  end;

  TLakeBathRecord = record
    Depth: double;
    Volume: double;
    Area: double;
  end;

  TLakeBathArray = array[0..150] of TLakeBathRecord;

  TLakImporter = class(TTransientArrayImporter)
  private
    NLAKES: integer;
    THETA: double;
    NSSITR: integer;
    SSCNCR: double;
    SURFDEPTH: double;
    Stages: array of double;
    LakeTables: array of TLakeBathArray;
    MinStages: array of double;
    MaxStages: array of double;
    NSOL: integer;
    LKARR: T3DIntArray;
    FLakeOutline: T2DIntArray;
    FLakeBottom: T2DDoubleArray;
    BDLKNC: T3DDoubleArray;
    FConstantLkarr : TIntegerConstantArray;
    FConstantBdlknc : TRealConstantRecordArray;
    NSLMS: integer;
    IC: integer;
    FLakPackage: TLakePackageSelection;
    FCurrentLakeDefinition: integer;
    SubLakes: array of array of integer;
    Sills: array of array of double;
    FLakeStressPeriodValues: TLakeStressPeriodValues;
    FCurrentLakeValues: Integer;
    FCurrentStressPeriodValues: TLakeValueArray;
    FPriorStressPeriodValues: TLakeValueArray;
    FTABLEINPUT: boolean;
    FIsSelected: Boolean;
    procedure ReadDataSet9bNoAugmentation;
    procedure ReadDataSet9bWithAugmentation;
    procedure ReadDataSet9aNoLimits;
    procedure ReadDataSet9aWithLimits;
    procedure ReadSills;
    procedure ReadSublakes;
    procedure ReadNumberOfSublakes;
    procedure ReadConstantLakebedLeakance;
    procedure ReadVariableLakebedLeakance;
    procedure ReadConstantLakeID;
    procedure ReadVariableLakeID;
    procedure ReadDataSet4;
    procedure ReadLakeSolutes;
    procedure ReadNumberOfSolutes;
    procedure ReadLakeStage;
    procedure ReadLakeStageAndLimits;
    procedure ReadTransientControls;
    procedure ReadTheta;
    procedure ReadDataSet1b;
    procedure DefineLakeOutlines;
    procedure ReadLakeTable;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    procedure CreateBoundary(ScreenObject: TScreenObject); override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TResStage = class(TArrayMember)
    Ststage: double;
    Endstage: double;
  end;

  TResStressPeriod = class(TObjectArray)
  private
    function GetStages(Index: integer): TResStage;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Stages[Index: integer]: TResStage read GetStages; default;
  end;

  TResStressPeriods = class(TObjectArray)
  private
    function GetStressPeriods(Index: integer): TResStressPeriod;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property StressPeriods[Index: integer]: TResStressPeriod
      read GetStressPeriods; default;
  end;

  TResImporter = class(TTransientArrayImporter)
  private
    NRES: integer;
    NRESOP: integer;
    NPTS: integer;
    ConstantLandSurface: Boolean;
    ConstantVertK: Boolean;
    ConstantBedThick: Boolean;
    LandSurface: T2DDoubleArray;
    VertK: T2DDoubleArray;
    BedThickness: T2DDoubleArray;
    ConstantResLocation: Boolean;
    ResLocation: T2DIntArray;
    ConstantResLayer: Boolean;
    ResLayer: T2DIntArray;
    FStressPeriods: TResStressPeriods;
    FResPackage: TResPackageSelection;
    IRESPT: integer;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    procedure CreateBoundary(ScreenObject: TScreenObject); override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TUzfGage = class(TArrayMember)
    IUZROW: integer;
    IUZCOL: integer;
    IFTUNIT: integer;
    IUZOPT: integer;
  end;

  TUzfGageArray = class(TObjectArray)
  private
    function GetGage(Index: integer): TUzfGage;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Gages[Index: integer]: TUzfGage read GetGage; default;
  end;

  TUzfImporter = class(TTransientArrayImporter)
  private
    FEtStressPeriods: TArrayStressPeriodArray;
    FEtExtinctDepthStressPeriods: TArrayStressPeriodArray;
    FEtExtinctWaterContentStressPeriods: TArrayStressPeriodArray;
    NUZTOP: integer;
    IUZFOPT: integer;
    IRUNFLG: integer;
    IETFLG: integer;
    NTRAIL2: integer;
    NSETS2: integer;
    NUZGAG: integer;
    SURFDEP: double;
    FReuseInfiltration: TBooleanDynArray;
    FReuseET: TBooleanDynArray;
    FReuseExtictionDepth: TBooleanDynArray;
    FReuseExtictionWaterContent: TBooleanDynArray;
    FGages: TUzfGageArray;
    FCurrentGage: integer;
    FConstantInfiltration: TRealConstantRecordArray;
    FVariableInfiltration: T3DDoubleArray;
    FConstantET: TRealConstantRecordArray;
    FVariableET: T3DDoubleArray;
    FConstantExtinctDepth: TRealConstantRecordArray;
    FVariableExtinctDepth: T3DDoubleArray;
    FConstantExtinctWaterContent: TRealConstantRecordArray;
    FVariableExtinctWaterContent: T3DDoubleArray;
    IsConstIUZFBND: boolean;
    ConstIUZFBND: integer;
    IUZFBND: T2DIntArray;
    IsConstIRUNBND: boolean;
    ConstIRUNBND: integer;
    IRUNBND: T2DIntArray;
    IsConstVks: boolean;
    ConstVks: double;
    VKS: T2DDoubleArray;
    IsConstEps: boolean;
    ConstEps: double;
    EPS: T2DDoubleArray;
    IsConstThts: boolean;
    ConstThts: double;
    THTS: T2DDoubleArray;
    IsConstThti: boolean;
    ConstThti: double;
    THTI: T2DDoubleArray;
    FUzfPackage: TUzfPackageSelection;
    SPECIFYTHTR: boolean;
    SPECIFYTHTI: boolean;
    NOSURFLEAK: boolean;
    IsConstThtr: boolean;
    ConstThtr: double;
    THTR: T2DDoubleArray;
    SeepK: T2DDoubleArray;
    FLakImporter: TLakImporter;
    FSfrImporter: TSfrImporter;
    Fsmoothfact: double;
    FEtSquare: Boolean;
    FSpecifySurfK: Boolean;
    FRejectSurfK: Boolean;
    FSeepSurfK: Boolean;
    FNetFlux: Boolean;
    IsConstSeepK: Boolean;
    ConstSeepKhtr: Double;
    procedure CreateInfiltrationDataArray(StressPeriodIndex: integer);
    procedure CreateETDataArray(StressPeriodIndex: integer);
    procedure CreateExtinctionDepthDataArray(StressPeriodIndex: integer);
    procedure CreateExtinctionWaterContentDataArray(StressPeriodIndex: integer);
    procedure AssignEt(NewItemsNeeded: boolean; Boundary: TUzfBoundary;
      var EvtItem: TEvtItem; const EtRate: string; StressPeriodIndex: Integer);
    procedure AssignExtinctionDepth(NewItemsNeeded: boolean;
      Boundary: TUzfBoundary; var ExtinctDepthItem: TUzfExtinctDepthItem;
      const ExtinctionDepth: string; StressPeriodIndex: Integer);
    procedure AssignInfiltation(NewItemsNeeded: boolean; Boundary: TUzfBoundary;
      var InfiltrationItem: TRchItem; const InfiltationRate: string;
      StressPeriodIndex: Integer);
    procedure AssignWaterContent(NewItemsNeeded: boolean;
      Boundary: TUzfBoundary; var WaterContentItem: TUzfWaterContentItem;
      const WaterContent: string; StressPeriodIndex: Integer);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    procedure CreateBoundary(ScreenObject: TScreenObject); override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      LakImporter: TLakImporter; SfrImporter: TSfrImporter);
    Destructor Destroy; override;
  end;

  TGageType = (gtLake, gtStream);

  TGage = class(TArrayMember)
    GageType: TGageType;
    LakeNumber: integer;
    OUTTYPE: integer;
    GAGESEG: integer;
    GAGERCH: integer;
  end;

  TGageArray = class(TObjectArray)
  private
    function GetGage(Index: integer): TGage;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Gages[Index: integer]: TGage read GetGage; default;
  end;

  TGageImporter = class(TPackageImporter)
  private
    FGages: TGageArray;
    FCurrentGage: integer;
    FLakImporter: TLakImporter;
    FSfrImporter: TSfrImporter;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    Constructor Create(Importer: TModflow2005Importer;
      LakImporter: TLakImporter; SfrImporter: TSfrImporter);
    Destructor Destroy; override;
  end;

  TPvalParam = class(TArrayMember)
    PARNAM: string;
    Value: double;
  end;

  TPvalParamArray = class(TObjectArray)
  private
    function GetParam(Index: integer): TPvalParam;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Params[Index: integer]: TPvalParam read GetParam; default;
  end;

  TPvalImporter = class(TPackageImporter)
  private
    FPvalParams: TPvalParamArray;
    FCurrentParam: integer;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TMnwiItem = class(TArrayMember)
    WellID: string;
    QNDflag: double;
    QBHflag: double;
  end;

  TMnwiArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TMnwiItem;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    function GetWellByName(const AWellId: string): TMnwiItem;
    property Items[Index: integer]: TMnwiItem read GetItem; default;
  end;

  TMnw2Importer = class;

  TMnwiImporter = class(TPackageImporter)
  private
    FMnwiArray: TMnwiArray;
    Wel1flag: integer;
    QSUMflag: integer;
    BYNDflag: integer;
    FCurrentWell: integer;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    function GetWellByName(const AWellId: string): TMnwiItem;
    Constructor Create(Importer: TModflow2005Importer;
      MnwImporter: TMnw2Importer);
    Destructor Destroy; override;
  end;

  TMnw2PumpTableItem = class(TArrayMember)
    LIFTn: double;
    Qn: double;
  end;

  TMnw2PumpTableArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TMnw2PumpTableItem;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TMnw2PumpTableItem read GetItem; default;
  end;

  TMnw2WellItem = class(TArrayMember)
  public
    Rw: double;
    Rskin: double;
    Kskin: double;
    B: double;
    C: double;
    P: double;
    CWC: double;
    IR: integer;
    IC: integer;
  end;

  TMnw2WellCell = class(TMnw2WellItem)
  public
    IL: integer;
    PP: double;
  end;

  TMnw2CellArray = class(TObjectArray)
  private
    function GetCell(Index: integer): TMnw2WellCell;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Cells[Index: integer]: TMnw2WellCell read GetCell; default;
  end;

  TMnw2WellScreen = class(TMnw2WellItem)
  public
    Ztop: double;
    Zbotm: double;
  end;

  TMnw2ScreenArray = class(TObjectArray)
  private
    function GetScreen(Index: integer): TMnw2WellScreen;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Screens[Index: integer]: TMnw2WellScreen read GetScreen; default;
  end;

  TWellState = (wsInactive, wsActive, wsReuse);

  TMnw2WellStressPeriod = class(TMnw2WellItem)
  public
    WellState: TWellState;
    Qdes: double;
    CapMult: double;
    Hlim: double;
    QCUT: integer;
    Qfrcmn: double;
    Qfrcmx: double;
  end;

  TMnw2StressPeriodArray = class(TObjectArray)
  private
    function GetStressPeriod(Index: integer): TMnw2WellStressPeriod;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property StressPeriods[Index: integer]: TMnw2WellStressPeriod
      read GetStressPeriod; default;
  end;

  TMnw2Well = class(TArrayMember)
  private
    FNNodes: integer;
    FCells: TMnw2CellArray;
    FScreens: TMnw2ScreenArray;
    FCurrentCell: integer;
    FCurrentScreen: integer;
    FPumpTable : TMnw2PumpTableArray;
    FPUMPCAP: integer;
    FCurrentPumpItem: integer;
    FStressPeriods: TMnw2StressPeriodArray;
    procedure SetNNodes(const Value: integer);
    procedure SetRw(const Value: double);
    procedure SetKskin(const Value: double);
    procedure SetRskin(const Value: double);
    procedure SetB(const Value: double);
    procedure SetC(const Value: double);
    procedure SetP(const Value: double);
    procedure SetCWC(const Value: double);
    procedure SetPUMPCAP(const Value: integer);
  public
    WellId: string;
    LossType: TMnwLossType;
    PUMPLOC: integer;
    Qlimit: integer;
    PPFLAG: integer;
    PUMPLAY: integer;
    PUMPROW: integer;
    PUMPCOL: integer;
    Zpump: double;
    Hlim: double;
    QCUT: integer;
    Qfrcmn: double;
    Qfrcmx: double;
    Hlift: double;
    LIFTq0: double;
    // LIFTqmax
    LIFTqdes: double;
    HWtol: double;
    Constructor Create; override;
    Destructor Destroy; override;
    property PUMPCAP: integer read FPUMPCAP write SetPUMPCAP;
    property NNodes: integer read FNNodes write SetNNodes;
    property Rw: double write SetRw;
    property Rskin: double write SetRskin;
    property Kskin: double write SetKskin;
    property B: double write SetB;
    property C: double write SetC;
    property P: double write SetP;
    property CWC: double write SetCWC;
  end;

  TMnw2WellArray = class(TObjectArray)
  private
    FCurrentWell: TMnw2Well;
    function GetWell(Index: integer): TMnw2Well;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    function GetWellByName(const AWellId: string): TMnw2Well;
    property Wells[Index: integer]: TMnw2Well read GetWell; default;
  end;

  TMnw2Importer = class(TPackageImporter)
  private
    MNWPRNT: integer;
    FWells: TMnw2WellArray;
    FCurrentWell: Integer;
    FCurrentStressPeriod: integer;
    FMnw2Package: TMultinodeWellSelection;
    FMnwiImporter: TMnwiImporter;
    procedure ReadDataSet1;
    procedure ReadAuxiliary;
    procedure ReadWellId;
    procedure ReadNumberOfNodes;
    procedure ReadLossType;
    procedure ReadFlags;
    procedure ReadThiemData;
    procedure ReadSkinData;
    procedure ReadEquationData;
    procedure ReadSpecifyCwcData;
    procedure ReadACell(const ALabel: string);
    procedure ReadAWellScreen(const ALabel: string);
    procedure ReadPumpCell;
    procedure ReadPumpZ;
    procedure ReadFullPumpLimits;
    procedure ReadPartialPumpLimits;
    procedure ReadLiftTableLimits;
    procedure ReadLiftTableItem;
    procedure ReadItmp;
    procedure ReadWellForCurrentStressPeriod;
    procedure AssignCells(AScreenObject: TScreenObject; AWell: TMnw2Well);
    procedure AssignScreens(AScreenObject: TScreenObject; AWell: TMnw2Well);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Procedure AddStressPeriod(ITMP: integer);
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  TMnw1Cell = class(TLocation)
    Qdes: double;
    QWval: double;
    Rw: double;
    Skin: double;
    Hlim: double;
    Href: double;
    DD: boolean;
    Iwgrp: integer;
    Cp_C: double;
    QCUT: boolean;
    QPercentCUT: boolean;
    Qfrcmn: double;
    Qfrcmx: double;
    Site: string;
    Multi: boolean;
    Mn: boolean;
    function SameLocation(OtherCell: TMnw1Cell): boolean;
    function SameValues(OtherCell: TMnw1Cell): boolean;
    procedure Assign(Source: TMnw1Cell);
  end;

  TMnw1Cells = class(TObjectList<TMnw1Cell>)
    StartingStressPeriod: integer;
    EndingStressPeriod: integer;
    function SameLocations(OtherCells: TMnw1Cells): boolean;
    function SameValues(OtherCells: TMnw1Cells): boolean;
  end;

  TMnw1Well = class(TObjectList<TMnw1Cells>)
    UsedInThisStressPeriod: Boolean;
  end;
  
  TMnw1Wells = TList<TMnw1Well>;
  TMnw1WellsObjectList = TObjectList<TMnw1Wells>;

  TMnw1OutputFile = class(TObject)
  private
    FFileName: string;
    procedure SetFileName(const Value: string);
  public
    Flag: string;
    UnitNumber: integer;
    AllTime: boolean;
    property FileName: string read FFileName write SetFileName;
  end;

  TMnw1OutputFiles = TObjectList<TMnw1OutputFile>;

  TMnw1Importer = class(TPackageImporter)
  private
    FWells: TObjectList<TMnw1Well>;
    FWellPriorStressPeriod: TMnw1Wells;
    FWellCurrentStressPeriod: TMnw1Wells;
    FWellLocationsPriorStressPeriod: array of array of array of TMnw1Wells;
//    FWellLocationsCurrentStressPeriod: array of array of array of TMnw1Wells;
    FWellLists: TMnw1WellsObjectList;
    NOMOITER: integer;
    KSPREF: integer;
    FLossType: TMnw1LossType;
    PLossMNW: double;
    FCurrentStressPeriod: integer;
    FMnw1OutputFiles: TMnw1OutputFiles;
    FAdd: Boolean;
    itmp: integer;
    FCellsCurrentStressPeriod: TList<TMnw1Cell>;
    FMnw1Package: TMnw1Package;
    procedure ReadDataSet1;
    procedure ReadDataSet2Version1;
    procedure ReadDataSet2Version2;
    procedure ReadMnwFilePrefix;
    procedure ReadDataSet3;
    procedure AssignAllTimeFlag;
    procedure ReadDataSet4;
    procedure ReadAddNewWells;
    procedure ReadDataSet5_1;
    procedure ReadQCUT;
    procedure ReadQPercentCUT;
    procedure ReadActivationPumpingRate;
    procedure ReadCp_C;
    procedure ReadSiteLabel;
    procedure ReadDataSet5_2;
    procedure ExpandMulti;
    procedure AssignCellToWells;
    procedure HandleCellsFromPriorStressPeriod;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    destructor Destroy; override;
  end;

  TSubLayerAssignment = class(TArrayMember)
    Layer: integer;
  end;

  TSubLayerAssignments = class(TObjectArray)
  private
    function GetLayer(Index: integer): TSubLayerAssignment;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Layers[Index: integer]: TSubLayerAssignment
      read GetLayer; default;
  end;

  TMaterialZone = class(TArrayMember)
    VerticalHydraulicConductivity: double;
    ElasticSpecificStorage: double;
    InelasticSpecificStorage: double;
  end;

  TMaterialZones = class(TObjectArray)
  private
    function GetZone(Index: integer): TMaterialZone;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Zone[Index: integer]: TMaterialZone read GetZone; default;
  end;

  TSubOC = class(TArrayMember)
    ISP1: integer;
    ISP2: integer;
    ITS1: integer;
    ITS2: integer;
    Ifl: array [0..12] of integer;
  end;

  TSubOutputs = class(TObjectArray)
  private
    function GetOC(Index: integer): TSubOC;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property OC[Index: integer]: TSubOC read GetOC; default;
  end;

  TSubImporter = class(TArrayImporter)
  private
    NN: integer;
    ITMIN: integer;
    AC1: double;
    AC2: double;
    IDSAVE: integer;
    IDREST: integer;
    FDelayBeds: TSubLayerAssignments;
    FNoDelayBeds: TSubLayerAssignments;
    FRnbIndex: integer;
    FNoDelayIndex: integer;
    FDelayIndex: integer;
    FConstRNB: TRealConstantRecordArray;
    FRNB: T3DDoubleArray;
    FConstHC: TRealConstantRecordArray;
    FHC: T3DDoubleArray;
    FConstSfe: TRealConstantRecordArray;
    FSfe: T3DDoubleArray;
    FConstSfv: TRealConstantRecordArray;
    FSfv: T3DDoubleArray;
    FConstCom: TRealConstantRecordArray;
    FCom: T3DDoubleArray;
    FConstDstart: TRealConstantRecordArray;
    FDstart: T3DDoubleArray;
    FConstDHC: TRealConstantRecordArray;
    FDHC: T3DDoubleArray;
    FConstDCOM: TRealConstantRecordArray;
    FDCOM: T3DDoubleArray;
    FConstDZ: TRealConstantRecordArray;
    FDZ: T3DDoubleArray;
    FConstNZ: TIntegerConstantArray;
    FNZ: T3DIntArray;
    FMaterialZones: TMaterialZones;
    Ifm1: integer;
    Ifm2: integer;
    Ifm3: integer;
    Ifm4: integer;
    Ifm5: integer;
    Ifm6: integer;
    FSubOutputs: TSubOutputs;
    FNamImporter: TNamImporter;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadDataSet3;
    procedure ReadConstRealArrayForLayer;
    procedure ReadVariableRealArrayForLayer;
    procedure ReadDataSet9;
    procedure ReadConstIntArrayForLayer;
    procedure ReadVariableIntArrayForLayer;
    procedure ReadDataSet15;
    procedure ImportDataSet1(SubPackage: TSubPackageSelection);
    procedure ImportPrintFormat(SubPackage: TSubPackageSelection);
    procedure ImportPrintChoices(SubPackage: TSubPackageSelection);
    procedure ImportPreconsolidatonHead(Index: Integer;
      NoDelayItem: TSubNoDelayBedLayerItem; var ScreenObject: TScreenObject);
    procedure ImportSfe(Index: Integer; NoDelayItem: TSubNoDelayBedLayerItem;
      var ScreenObject: TScreenObject);
    procedure ImportSfv(Index: Integer; NoDelayItem: TSubNoDelayBedLayerItem;
      var ScreenObject: TScreenObject);
    procedure ImportCom(Index: Integer; NoDelayItem: TSubNoDelayBedLayerItem;
      var ScreenObject: TScreenObject);
    procedure ImportRNB(DelayItem: TSubDelayBedLayerItem; Index: Integer;
      var ScreenObject: TScreenObject);
    procedure ImportDStart(DelayItem: TSubDelayBedLayerItem; Index: Integer;
      var ScreenObject: TScreenObject);
    procedure ImportDHC(DelayItem: TSubDelayBedLayerItem; Index: Integer;
      var ScreenObject: TScreenObject);
    procedure ImportDCOM(DelayItem: TSubDelayBedLayerItem; Index: Integer;
      var ScreenObject: TScreenObject);
    procedure ImportDZ(DelayItem: TSubDelayBedLayerItem; Index: Integer;
      var ScreenObject: TScreenObject);
    procedure ImportMaterialZone(DelayItem: TSubDelayBedLayerItem;
      Index: Integer; var ScreenObject: TScreenObject);
  protected
    function ScreenObjectNameRoot: string; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      NamImporter: TNamImporter);
    Destructor Destroy; override;
  end;

  TSwtPrintRecord = record
    ISP1: integer;
    ISP2: integer;
    ITS1: integer;
    ITS2: integer;
    Ifl: array[0..25] of integer;
  end;

  TSwtPrintRecordArray = array of TSwtPrintRecord;

  TSwtImporter = class(TArrayImporter)
  private
    FInterBeds: TSubLayerAssignments;
    ICRCC: Integer;
    ISTPCS: Integer;
    IVOID: Integer;
    ITHK: Integer;
    NSYSTM: Integer;
    ISWTOC: Integer;
    IZCFL: integer;
    IZCFM: integer;
    IGLFL: integer;
    IGLFM: integer;
    IESTFL: integer;
    IESTFM: integer;
    IPCSFL: integer;
    IPCSFM: integer;
    ISTFL: integer;
    ISTFM: integer;
    GL0Const: TRealConstantRecord;
    GL0Variable: T2DDoubleArray;
    SGMConst: TRealConstantRecord;
    SGMVariable: T2DDoubleArray;
    SGSConst: TRealConstantRecord;
    SGSVariable: T2DDoubleArray;
    FThickIndex: Integer;
    FConstTHICK: TRealConstantRecordArray;
    FTHICK: T3DDoubleArray;
    FSseIndex: Integer;
    FConstSse : TRealConstantRecordArray;
    FSse: T3DDoubleArray;
    FCrIndex: Integer;
    FConstCr : TRealConstantRecordArray;
    FCr: T3DDoubleArray;
    FSsvIndex: Integer;
    FConstSsv : TRealConstantRecordArray;
    FSsv: T3DDoubleArray;
    FCcIndex: Integer;
    FConstCc : TRealConstantRecordArray;
    FCc: T3DDoubleArray;
    FVoidIndex: Integer;
    FConstVoid : TRealConstantRecordArray;
    FVoid: T3DDoubleArray;
    FSubIndex: Integer;
    FConstSub : TRealConstantRecordArray;
    FSub: T3DDoubleArray;
    FPcsIndex: Integer;
    FConstPcs : TRealConstantRecordArray;
    FPcs: T3DDoubleArray;
    Ifm: array [0..12] of integer;
    Iun: array [0..12] of integer;
    FSwtPrintRecordArray: TSwtPrintRecordArray;
    FPrintIndex: integer;
    FSwtPackage: TSwtPackageSelection;
    procedure ReadDataSet1;
    procedure ReadDataSet2;
    procedure ReadDataSet3;
    procedure ReadConstRealArrayForLayer;
    procedure ReadVariableRealArrayForLayer;
    procedure Read1LayerConstDataSets(Value: Double; const ID: string);
    procedure Read1LayerVariableDataSets(const ID: string);
    procedure ReadMultilayerConstantArrays(Value: Double; const ID: string);
    procedure ReadMultiLayerVariableArrays(const ID: string);
    procedure ReadDataSet16;
    procedure ReadDataSet17;
    procedure ImportDataSet1;
    procedure ImportTHICK(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportSse(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportLayerGroupData(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject; const Name: string;
      const ConstArray: TRealConstantRecordArray;
      const ImportedData: T3DDoubleArray);
    procedure ImportSsv(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportCr(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportCc(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportVOID(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportSUB(Index: Integer; WtItem: TSwtWaterTableItem;
      var ScreenObject: TScreenObject);
    procedure ImportLayerData;
    procedure ImportDataSet3;
    procedure ImportDataSet16;
    procedure ImportInitialConditions;
    procedure ImportPrintChoices;
  protected
    function ScreenObjectNameRoot: string; override;
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    Destructor Destroy; override;
  end;

  THydModLocation = class(TArrayMember)
    PCKG: string;
    ARR: string;
    INTYP: string;
    KLAY: integer;
    XL: double;
    YL: double;
    HYDLBL: string;
  end;

  THydmodLocationArray = class(TObjectArray)
  private
    function GetLocations(Index: integer): THydModLocation;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Locations[Index: integer]: THydModLocation read GetLocations; default;
  end;

  THydmodImporter = class(TPackageImporter)
  private
    FLocations: THydmodLocationArray;
    FLocationIndex: integer;
    HYDNOH: Double;
    FSfrImporter: TSfrImporter;
    FSubImporter: TSubImporter;
    FHydmodPackage: THydPackageSelection;
    procedure ReadDataSet1;
    function GetObservationLocation(Location: THydModLocation): TPoint2D;
    procedure StoreCommonData(Z: Real; APoint: TPoint2D;
      Location: THydModLocation; Index: Integer; var HydModData: ModflowHydmodUnit.THydmodData);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
  public
    Constructor Create(Importer: TModflow2005Importer;
      SfrImporter: TSfrImporter; SubImporter: TSubImporter);
    Destructor Destroy; override;
  end;

  TFhbCell = class(TLocation)
    Values: array of double;
  end;

  TFhbCellArray = class(TObjectArray)
  private
    function GetCell(Index: Integer): TFhbCell;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Cells[Index: Integer]: TFhbCell read GetCell; default;
  end;

  TFhbImporter = class(TListImporter)
  private
    NBDTIM: Integer;
    BDTIM: array of double;
    FFlowCells: TFhbCellArray;
    FHeadCells: TFhbCellArray;
    FFlowCellIndex: integer;
    FHeadCellIndex: integer;
    FFhbPackage: TFhbPackageSelection;
    procedure ReadDataSet1;
    procedure ReadDataSet2Name;
    procedure ReadDataSet2Weight;
    procedure ReadDataSet3Name;
    procedure ReadDataSet3Weight;
    procedure ReadDataSet4a;
    procedure ReadDataSet4b;
    procedure ReadDataSet5a;
    procedure ReadDataSet5b;
    procedure ReadDataSet7a;
    procedure ReadDataSet7b;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    procedure SetItemValues(Item: TCustomModflowBoundaryItem;
      Boundaries: TList; EndTime: Double; StartTime: Double;
      ScreenObject: TScreenObject; const ParamName: string); override;
    function ScreenObjectNameRoot: string; override;
    function GetBoundary(ScreenObject: TScreenObject): TModflowParamBoundary;
      override;
    function ParameterType: TParameterType; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    destructor Destroy; override;
  end;

  TSwiObs = class(TLocation)
    OBSNAM: string;
  end;

  TSwiObsArray = class(TObjectArray)
  private
    function GetCell(Index: Integer): TSwiObs;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Cells[Index: Integer]: TSwiObs read GetCell; default;
  end;

  TSwiImporter = class(TArrayImporter)
  private
    NSRF, ISTRAT, NOBS, ISWIZT, ISWIBD, ISWIOBS: integer;
    iadptflg: integer;
    NSOLVER, IPRSOL, MUTSOL: integer;
    MXITER, ITER1, NPCOND: integer;
    ZCLOSE, RCLOSE, RELAX: double;
    NBPOL: integer;
    DAMP, DAMPT: double;
    TOESLOPE, TIPSLOPE, ALPHA, BETA: double;
    NADPTMX, NADPTMN: integer;
    ADPTFCT: double;
    NU: TOneDRealArray;
    ZETA_const: array of TRealConstantRecordArray;
    ZETA: array of T3DDoubleArray;
    SSZ_Const: TRealConstantRecordArray;
    SSZ: T3DDoubleArray;
    ISOURCE_Const: TIntegerConstantArray;
    ISOURCE: T3DIntArray;
    FObservations: TSwiObsArray;
    IObs: integer;
    procedure ImportISOURCE;
    procedure ImportPackageData(SwiPackage: TSwiPackage);
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    function ScreenObjectNameRoot: string; override;
  public
    Constructor Create(Importer: TModflow2005Importer);
    destructor Destroy; override;
  end;

  TCustomSwrArrayMember = class(TArrayMember)
  private
    StartingStressPeriodIndex: integer;
  end;

  TSwrISWRBND = class(TCustomSwrArrayMember)
  private
    ISWRBND: integer;
  end;

  TCustomSwrObjectArray = class(TObjectArray)
  private
    function GetAnItem(Index: Integer): TCustomSwrArrayMember;
  public
    property Items[Index: Integer]: TCustomSwrArrayMember read GetAnItem; default;
  end;

  TSwrISWRBND_Array = class(TCustomSwrObjectArray)
  private
    function GetSwrISWRBND(Index: integer): TSwrISWRBND;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property SwrISWRBND[Index: integer]: TSwrISWRBND read GetSwrISWRBND; default;
    function Last: TSwrISWRBND;
  end;

  TSwrRain = class(TCustomSwrArrayMember)
  private
    RAIN: double;
  end;

  TSwrRain_Array = class(TCustomSwrObjectArray)
  private
    function GetRain(Index: integer): TSwrRain;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property SwrRain[Index: integer]: TSwrRain read GetRain; default;
    function Last: TSwrRain;
  end;

  TSwrEvap = class(TCustomSwrArrayMember)
  private
    EVAP: double;
  end;

  TSwrEvap_Array = class(TCustomSwrObjectArray)
  private
    function GetEvap(Index: integer): TSwrEvap;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property SwrEvap[Index: integer]: TSwrEvap read GetEvap; default;
    function Last: TSwrEvap;
  end;

  TSwrLateralFlow = class(TCustomSwrArrayMember)
  private
    QLATFLOW: double;
  end;

  TSwrLateralFlow_Array = class(TCustomSwrObjectArray)
  private
    function GetLateralFlow(Index: integer): TSwrLateralFlow;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property SwrLateralFlow[Index: integer]: TSwrLateralFlow read GetLateralFlow; default;
    function Last: TSwrLateralFlow;
  end;

  TSwrStage = class(TCustomSwrArrayMember)
  private
    STAGE: double;
  end;

  TSwrStage_Array = class(TCustomSwrObjectArray)
  private
    function GetStage(Index: integer): TSwrStage;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property SwrStage[Index: integer]: TSwrStage read GetStage; default;
    function Last: TSwrStage;
  end;

  TSwrReachGeomLink = class(TCustomSwrArrayMember)
  private
    IGEONUMR: integer;
    GZSHIFT: double;
  end;

  TSwrReachGeom_Array = class(TCustomSwrObjectArray)
  private
    function GetReachGeomLink(Index: integer): TSwrReachGeomLink;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property ReachGeomLink[Index: integer]: TSwrReachGeomLink read GetReachGeomLink; default;
    function Last: TSwrReachGeomLink;
  end;

  TSwrReachStructureCount = class(TCustomSwrArrayMember)
  private
    NSTRUCT: integer;
  end;

  TSwrReachStructureCountArray = class(TCustomSwrObjectArray)
  private
    function GetItem(Index: integer): TSwrReachStructureCount;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TSwrReachStructureCount read GetItem; default;
    function Last: TSwrReachStructureCount;
  end;

  TSwrReach = class(TLocation)
  private
    IROUTETYPE: integer;
    IRGNUM: integer;
    RLEN: double;
    // connection numbering starts at zero.
    ICONN: array of integer;
    F_ISWRBND_Array: TSwrISWRBND_Array;
    FRain: TSwrRain_Array;
    FEvap: TSwrEvap_Array;
    FLateralFlow: TSwrLateralFlow_Array;
    FStage: TSwrStage_Array;
    FReachGeom_Array: TSwrReachGeom_Array;
    FReachStructureCounts: TSwrReachStructureCountArray;
    constructor Create; override;
    destructor Destroy; override;
  end;

  TSwrReachArray = class(TObjectArray)
  private
    function GetReaches(Index: integer): TSwrReach;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Reaches[Index: integer]: TSwrReach read GetReaches; default;
  end;

  TSwrTabFile = class(TArrayMember)
  private
    ITAB: integer;
    CTABTYPE: string;
    ITABUNIT: integer;
    CINTP: string;
    CTABRCH: string;
    // @name starts at 0.
    ITABRCH: array of integer;
    TabItem: TTabFileItem;
  end;

  TSwrTabFileArray = class(TObjectArray)
  private
    function GetTabfile(Index: integer): TSwrTabFile;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Tabfiles[Index: integer]: TSwrTabFile read GetTabfile; default;
  end;

  TSwrObs = class(TArrayMember)
  private
    COBSNAME: string;
    COBSTYPE: string;
    IOBSLOC: integer;
    IOBSLOC2: integer;
    IOBSLAY: integer;
  end;

  TSwrObsArray = class(TObjectArray)
  private
    function GetObs(Index: integer): TSwrObs;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Obs[Index: integer]: TSwrObs read GetObs; default;
  end;

  TSwrGeomCrossSectionPoint = class(TArrayMember)
  private
    XB: double;
    ELEVB: double;
  public
    function IsSame(AnItem: TSwrGeomCrossSectionPoint): boolean;
  end;

  TSwrCrossSectionArray = class(TObjectArray)
  private
    function GetPoint(Index: integer): TSwrGeomCrossSectionPoint;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Points[Index: integer]: TSwrGeomCrossSectionPoint read GetPoint; default;
    function IsSame(AnItem: TSwrCrossSectionArray): boolean;
  end;

  TSwrGeomTableItem = class(TArrayMember)
  private
    ELEV: double;
    VOL: double;
    WETPER: double;
    SAREA: double;
    XAREA: double;
  public
    function IsSame(AnItem: TSwrGeomTableItem): boolean;
  end;

  TSwrGeomTableArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TSwrGeomTableItem;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TSwrGeomTableItem read GetItem; default;
    function IsSame(AnItem: TSwrGeomTableArray): boolean;
  end;

  TSwrGeomItem = class(TArrayMember)
  private
    IGEONUM: integer;
    IGEOTYPE: integer;
    IGCNDOP: integer;
    GMANNING: double;
    NGEOPTS: integer;
    GWIDTH: double;
    GBELEV: double;
    GSSLOPE: double;
    GCND: double;
    GLK: double;
    GCNDLN: double;
    GETEXTD: double;
    FCrossSection: TSwrCrossSectionArray;
    FTable: TSwrGeomTableArray;
    FCurrentIndex: integer;
    FGeomItem: TReachGeometryItem;
  public
    constructor Create; override;
    destructor Destroy; override;
  public
    function IsSame(AnItem: TSwrGeomItem): boolean;
  end;

  TSwrGeomStressPeriodArray = class(TObjectArray)
  private
    function GetGeom(Index: integer): TSwrGeomItem;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    FStartingStressPeriod: integer;
    property Geom[Index: integer]: TSwrGeomItem read GetGeom; default;
    function Last: TSwrGeomItem;
  end;

  TSwrGeomArray = class(TObjectArray)
    function GetGeomArray(Index: integer): TSwrGeomStressPeriodArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property GeomArray[Index: integer]: TSwrGeomStressPeriodArray read GetGeomArray; default;
    function Last: TSwrGeomStressPeriodArray;
    function FindByStressPeriod(StressPeriod: Integer): integer;
  end;

  TSwrStructureTableItem = class(TArrayMember)
  private
    STRELEV: double;
    STRQ: double;
  public
    function IsSame(ATableItem: TSwrStructureTableItem): boolean;
  end;

  TSwrStructureTable = class(TObjectArray)
  private
    function GetItem(Index: integer): TSwrStructureTableItem;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    property Items[Index: integer]: TSwrStructureTableItem read GetItem; default;
    function IsSame(AStructureTable: TSwrStructureTable): boolean;
  end;

  TSwrStructure = class(TArrayMember)
  private
    // ISTRRCH is zero based.
    ISTRRCH: Integer;
    ISTRNUM: Integer;
    // ISTRCONN starts at 1.
    ISTRCONN: Integer;
    ISTRTYPE: Integer;
    NSTRPTS: Integer;
    STRCD: double;
    STRCD2: double;
    STRCD3: double;
    STRINV: double;
    STRINV2: double;
    STRWID: double;
    STRWID2: double;
    STRLEN: double;
    STRLEN2: double;
    STRMAN: double;
    STRVAL: double;
    ISTRDIR: Integer;
    ISFRSEG: Integer;
    ISFRRCH: Integer;
    CSTROTYP: string;
    ISTRORCH: Integer;
    ISTROQCON: Integer;
    CSTROLO: string;
    CSTRCRIT: string;
    STRCRIT: double;
    STRCRITC: double;
    STRRT: double;
    STRMAX: double;
    CSTRVAL: string;
    // number of tab file associated with STRVAL in data set 13a.
    ISTRTAB_Discharge: integer;
    // number of tab file in CSTRCRIT in data set 13b.
    ISTRTAB_Control: integer;
    // number of tab file in CSTRVAL in data set 13b.
    ISTRTAB_Gate: integer;
    FTable: TSwrStructureTable;
    FCurrentPointIndex: Integer;
    FStrucItem: TStructure;
  public
    constructor Create; override;
    destructor Destroy; override;
    function IsSame(AStructure: TSwrStructure): boolean;
  end;

  TStructureStressPeriodArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TSwrStructure;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    FStartingStressPeriod: integer;
    property Items[Index: integer]: TSwrStructure read GetItem; default;
    function Last: TSwrStructure;
  end;

  TStructureArray = class(TObjectArray)
  private
    function GetItem(Index: integer): TStructureStressPeriodArray;
  protected
    function ArrayMemberClass: TArrayMemberClass; override;
  public
    FStartingStressPeriod: integer;
    property Items[Index: integer]: TStructureStressPeriodArray read GetItem; default;
    function Last: TStructureStressPeriodArray;
  end;

  TNameFileItem = class(TObject)
    FileName: string;
    UnitNumber: integer;
  end;

  TNameFileItemList = TObjectList<TNameFileItem>;


  TSwrImporter = class(TArrayImporter)
  private
    const
      KRain = '2D RAINFALL DATA';
      KEvap = '2D EVAPORATION DATA';
      KLatFlow = '2D LATERAL INFLOW DATA';
      KStage = '2D STAGE DATA';
      KRunoffMult = 'DIRECT RUNOFF MULTIPLIER';
      KRunoffValue = 'DIRECT RUNOFF VALUE';
      KRunoffMap = 'DIRECT RUNOFF IMAP';
    var
    // data set 1a variables.
    NREACHES: integer;
    ISWRONLY: integer;
    ISWRCBC: integer;
    ISWRPRGF: integer;
    ISWRPSTG: integer;
    ISWRPQAQ: integer;
    ISWRPQM: integer;
    ISWRPSTR: integer;
    ISWRPFRN: integer;
    // Data Set 1b variables;
    PRINT_SWR_TO_SCREEN: boolean;
    SAVE_SWRDT: boolean;
    SWRDT_Unit: Integer;
    SAVE_CONVERGENCE_HISTORY: boolean;
    SAVE_RIVER_PACKAGE: boolean;
    SAVE_RIVER_PACKAGE_ALL: boolean;
    SAVE_AVERAGE_RESULTS: boolean;
    USE_TABFILES: boolean;
    USE_NONCONVERGENCE_CONTINUE: boolean;
    USE_UPSTREAM_WEIGHTING: boolean;
    USE_INEXACT_NEWTON: boolean;
    USE_STEADYSTATE_STORAGE: boolean;
    USE_LAGGED_OPR_DATA: boolean;
    USE_LINEAR_DEPTH_SCALING: boolean;
    USE_DIAGONAL_SCALING: boolean;
    USE_L2NORM_SCALING: boolean;
    USE_RCMREORDERING: boolean;
    USE_RCMREORDERING_IF_IMPROVEMENT: boolean;
//    USE_STAGE_TRANSFORM: boolean;
//    USE_WEIGHTED_HEADS: boolean;
    USE_IMPLICIT_NEWTON_CORRECTION: boolean;
    USE_EXPLICIT_NEWTON_CORRECTION: boolean;
//    USE_ORIGINAL_2D_QM_FORMULATION: boolean;
//    USE_IMPLICIT_INVARIATE_QM: boolean;
//    USE_SOURCECELL_INVARIATE_QM: boolean;
    USE_FRACTIONAL_TOLR: boolean;
    USE_L2NORM_TOLR: boolean;
    SAVE_SWROBSERVATIONS: boolean;
    SAVE_SWROBSERVATIONS_ALL: boolean;
    SWROBSERVATIONS_Unit: Integer;
//    USE_MULTICORE: boolean;
//    USE_MULTICORE_VECTOR: boolean;
    USE_DIRECT_RUNOFF: boolean;
    USE_GLOBAL_TOLA: boolean;
    USE_ABSOLUTE_TOLA: boolean;
    // Data Set 2 variables.
    NTMULT: Integer;
    DLENCONV: Double;
    TIMECONV: double;
    RTINI: double;
    RTMIN: double;
    RTMAX: double;
    RTPRN: double;
    RTMULT: double;
    DMINGRAD: double;
    DMNDEPTH: Double;
    DMAXRAI: double;
    DMAXSTG: double;
    DMAXINF: double;
    // Data Set 3 variables
    ISOLVER: integer;
    NOUTER: integer;
    NINNER: integer;
    IBT: integer;
    TOLS: double;
    TOLR: double;
    TOLA: double;
    DAMPSS: double;
    DAMPTR: double;
    IPRSWR: integer;
    MUTSWR: integer;
    IPC: integer;
    NLEVELS: integer;
    DROPTOL: double;
    IBTPRT: integer;
    PTOLR: double;
    // data Set 4A and 4B
    FReachArray: TSwrReachArray;
    FCurrentReach: TSwrReach;
    FCurrentConnection: integer;
    // Data Set 4C and 4D
    FTabFiles: TSwrTabFileArray;
    FCurrentTabFile: TSwrTabFile;
    FCurrentTabIndex: integer;
    // Data Sets 4E and 4FR
    FObsArray: TSwrObsArray;
    FCurrentObs: TSwrObs;
    FCurrentObsIndex: integer;
    // TransientData
    FCurrentStressPeriod: integer;
    FGeomArray: TSwrGeomArray;
    FCurrentGeomArrays: TSwrGeomStressPeriodArray;
    FCurrentGeom: TSwrGeomItem;
    FStructures: TStructureArray;
    FCurrentStructures: TStructureStressPeriodArray;
    FCurrentStructure: TSwrStructure;
    FStructureChanged: array of boolean;
    FRain: T3DDoubleArray;
    FEvap: T3DDoubleArray;
    FLatFlow: T3DDoubleArray;
    FStage: T3DDoubleArray;
    FRunoffMap: T3DIntArray;
    FRunoffMultiplier: T3DDoubleArray;
    FRunoffValue: T3DDoubleArray;
    FRain_Const : TRealConstantRecordArray;
    FEvap_Const : TRealConstantRecordArray;
    FLatFlow_Const : TRealConstantRecordArray;
    FStage_Const : TRealConstantRecordArray;
    FRunoffMap_Const : TIntegerConstantArray;
    FRunoffMultiplier_Const : TRealConstantRecordArray;
    FRunoffValue_Const : TRealConstantRecordArray;
    FSwrPackage: TSwrPackage;
    FScreenObjectIndex: integer;
    FNameFile: string;
    procedure ReadDataSet1A;
    procedure ReadDataSet1B;
    procedure ReadDataSet1B_UnitNumber;
    procedure ReadDataSet2Required;
    procedure ReadDataSet2Optional;
    procedure ReadDataSet3Required;
    procedure ReadDataSet3IPC;
    procedure ReadDataSet3_NLEVELS;
    procedure ReadDataSet3_IBTPRT;
    procedure ReadDataSet3_PTOLR;
    procedure ReadDataSet4A;
    procedure ReadDataSet4B_NCONN;
    procedure ReadDataSet4B_ICONN;
    procedure ReadDataSet4C;
    procedure ReadDataSet4D_ITAB;
    procedure ReadDataSet4D_CTABTYPE;
    procedure ReadDataSet4D_ITABUNIT;
    procedure ReadDataSet4D_CINTP;
    procedure ReadDataSet4D_CTABRCH;
    procedure ReadDataSet4D_ITABRCH;
    procedure ReadDataSet4E;
    procedure ReadDataSet4F_COBSNAME;
    procedure ReadDataSet4F_COBSTYPE;
    procedure ReadDataSet4F_IOBSLOC;
    procedure ReadDataSet4F_IOBSLOC2_IOBSLAY;
    procedure ReadDataSet5_NoChange;
    procedure ReadDataSet5Changed;
    procedure ReadDataSet6;
    procedure ReadDataSet7A;
    procedure ReadDataSet8A;
    procedure ReadDataSet9A;
    procedure ReadDataSet14A;
    procedure ReadDataSet10;
    procedure ReadDataSet11A_IGEONUM;
    procedure ReadDataSet11A_NGEOPTS;
    procedure ReadDataSet11A_GWIDTH;
    procedure ReadDataSet11A_GSSLOPE;
    procedure ReadDataSet11A_GCND;
    procedure ReadDataSet11A_GLK;
    procedure ReadDataSet11A_GCNDLN;
    procedure ReadDataSet11A_GETEXTD;
    procedure ReadDataSet11B;
    procedure ReadDataSet11C;
    procedure ReadDataSet12;
    procedure ReadDataSet13A_1;
    procedure ReadDataSet13A_2;
    procedure ReadDataSet13A_3;
    procedure ReadDataSet13A_4;
    procedure ReadDataSet13A_5;
    procedure ReadDataSet13A_6;
    procedure ReadDataSet13A_7;
    procedure ReadDataSet13A_8;
    procedure ReadDataSet13A_9;
    procedure ReadDataSet13A_10;
    procedure ReadDataSet13A_11;
    procedure ReadDataSet13A_12;
    procedure ReadDataSet13A_13;
    procedure ReadDataSet13A_14;
    procedure ReadDataSet13A_15;
    procedure ReadDataSet13A_16;
    procedure ReadDataSet13C;
    procedure ReadDataSet13B_1;
    procedure ReadDataSet13B_2;
    procedure ReadDataSet13B_3;
    procedure ReadDataSet13B_4;
    procedure ReadDataSet13B_5;
    procedure ReadDataSet13B_6;
    procedure ReadDataSet13B_7;
    procedure ReadDataSet13B_8;
    procedure ReadDataSet13B_9;
    procedure ReadVariableRealArrays;
    procedure ReadConstantRealArrays;
    procedure ReadRunoffMapConstant;
    procedure ReadRunoffMapVariable;
    procedure SetPackageData;
    procedure ImportReachGeom;
    procedure ImportReaches;
    procedure InitializeReuseArray(var Reuse: TBooleanArray;
      ImportedData: T3DDoubleArray; ImportedConstData: TRealConstantRecordArray);
    procedure ImportSwrTransientArrays(const Root: string; Reuse: TBooleanArray;
      ImportedData: T3DDoubleArray; SwrCollection: TCustomSwrListCollection;
      ImportedConstData: TRealConstantRecordArray);
    procedure ImportRainArray(var AScreenObject: TScreenObject);
    procedure ImportEvapArray(var AScreenObject: TScreenObject);
    procedure ImportLateralFlowArray(var AScreenObject: TScreenObject);
    procedure ImportStageArray(var AScreenObject: TScreenObject);
    procedure ImportDirectRunoffArrays(AScreenObject: TScreenObject);
    procedure ImportTabFiles;
    procedure InitializeStructureChanged;
    procedure ImportStructures;
    procedure ImportObservations;
  protected
    procedure ReadData(const ALabel: string); override;
    procedure HandlePackage; override;
    function ScreenObjectNameRoot: string; override;
  public
    Constructor Create(Importer: TModflow2005Importer; const NameFile: string);
    Destructor Destroy; override;
  end;

var
  GlobalCellCenterScreenObject: TScreenObject = nil;
  GlobalModelType: TModelType;
  LayerString: string;

//procedure ImportModflow2005(const ImportParameters.ListFileName: string;
//  ImportParameters.XOrigin, ImportParameters.YOrigin, ImportParameters.GridAngle: double; ImportParameters.textHandler: TTextHandler;
//  ImportParameters.ProgressHandler: TProgressHandler; ImportParameters.ModelType: TModelType;
//  const ImportParameters.NameFile: string);
procedure ImportModflow2005(ImportParameters: TImportParameters);
var
  Importer: TModflow2005Importer;
begin
  Assert(Assigned(ImportParameters.textHandler));
  NameFile := ImportParameters.NameFile;
  GlobalModelType := ImportParameters.ModelType;
  case ImportParameters.ModelType of
    mtParent:
      begin
        LayerString := StrParentLayer;
      end;
    mtChild:
      begin
        LayerString := 'Layer';
      end;
    else Assert(False);
  end;
  frmGoPhast.CanDraw:= False;
  frmGoPhast.PhastModel.ImportingModel := True;
  Importer := TModflow2005Importer.Create(ImportParameters);
  try
    Importer.textHandler := ImportParameters.textHandler;
    Importer.ProgressHandler := ImportParameters.ProgressHandler;
    Importer.ImportModel;
  finally
    if frmGoPhast.ModelSelection = msUndefined then
    begin
      // import failed.
      frmGoPhast.ModelSelection := msModflow;
    end;
    Importer.Free;
    frmGoPhast.PhastModel.ImportingModel := False;
    frmGoPhast.CanDraw := True;
  end;
  if frmErrorsAndWarnings.HasMessages then
  begin
    frmErrorsAndWarnings.Show;
    frmErrorsAndWarnings.BringToFront;
  end;
end;

{ TModflow2005Importer }

//constructor TModflow2005Importer.Create(const ImportParameters.ListFileName: string;
//  ImportParameters.XOrigin, ImportParameters.YOrigin, ImportParameters.GridAngle: double; const ImportParameters.NameFile: string);
constructor TModflow2005Importer.Create(ImportParameters: TImportParameters);

var
  MZImporter: TMultZoneImporter;
  LakImporter: TLakImporter;
  SfrImporter: TSfrImporter;
  HufImporter: THufImporter;
  Drn: TDrnImporter;
  GHB: TGhbImporter;
  Riv: TRivImporter;
  Bas: TBasImporter;
  Chd: TChdImporter;
  Mnw2: TMnw2Importer;
  Nam: TNamImporter;
  Sub: TSubImporter;
  Str: TStrImporter;
begin
  inherited Create;
  FImportParameters := ImportParameters;
  FPointsComputed := False;
  Assert(FileExists(ImportParameters.ListFileName));
  FListFileName := ImportParameters.ListFileName;

  FPackageIdentifiers:= TStringList.Create;
  Nam := TNamImporter.Create(self);
  FPackageIdentifiers.AddObject('NAM:', Nam);
  Bas := TBasImporter.Create(self);
  FPackageIdentifiers.AddObject('BAS:', Bas);
  FPackageIdentifiers.AddObject('DIS:', TDisImporter.Create(self,
    Bas, ImportParameters.XOrigin, ImportParameters.YOrigin,
    ImportParameters.GridAngle, ImportParameters.GridOrigin));

  MZImporter := TMultZoneImporter.Create(self);

  FPackageIdentifiers.AddObject('ZONE_MULT:', MZImporter);
  FPvalImporter := TPvalImporter.Create(self);
  FPackageIdentifiers.AddObject('PVAL:', FPvalImporter);
  FPackageIdentifiers.AddObject('BCF:', TBcfImporter.Create(self, Bas));
  FPackageIdentifiers.AddObject('LPF:', TLpfImporter.Create(self, Bas));
  HufImporter := THufImporter.Create(self);
  FPackageIdentifiers.AddObject('HUF2:', HufImporter);
  FPackageIdentifiers.AddObject('KDEP:',
    TKdepImporter.Create(self, HufImporter));
  FPackageIdentifiers.AddObject('LVDA:',
    TLvdaImporter.Create(self, HufImporter));
  FPackageIdentifiers.AddObject('HFB:', THfbImporter.Create(self));
  LakImporter:= TLakImporter.Create(self);
  FPackageIdentifiers.AddObject('LAK:', LakImporter);
  SfrImporter := TSfrImporter.Create(self);
  FPackageIdentifiers.AddObject('SFR:', SfrImporter);
  Chd := TChdImporter.Create(self, Bas);
  FPackageIdentifiers.AddObject('CHD:', Chd);
  FPackageIdentifiers.AddObject('FHB:', TFhbImporter.Create(self));
  FPackageIdentifiers.AddObject('RCH:', TRchImporter.Create(self, MZImporter));
  FPackageIdentifiers.AddObject('WEL:', TWelImporter.Create(self));
  Drn := TDrnImporter.Create(self);
  FPackageIdentifiers.AddObject('DRN:', Drn);
  FPackageIdentifiers.AddObject('DRT:', TDrtImporter.Create(self));
  FPackageIdentifiers.AddObject('ETS:', TEtsImporter.Create(self, MZImporter));
  FPackageIdentifiers.AddObject('EVT:', TEvtImporter.Create(self, MZImporter));
  GHB := TGhbImporter.Create(self);
  FPackageIdentifiers.AddObject('GHB:', GHB);
  FPackageIdentifiers.AddObject('MNW1:', TMnw1Importer.Create(self));
  Mnw2 := TMnw2Importer.Create(self);
  FPackageIdentifiers.AddObject('MNW2:', Mnw2);
  FPackageIdentifiers.AddObject('MNWI:', TMnwiImporter.Create(self, Mnw2));
  FPackageIdentifiers.AddObject('RES:', TResImporter.Create(self));
  Riv := TRivImporter.Create(self);
  FPackageIdentifiers.AddObject('RIV:', Riv);
  Str := TStrImporter.Create(self);
  FPackageIdentifiers.AddObject('STR:', Str);
  FPackageIdentifiers.AddObject('DE4:', TDe4Importer.Create(self));
  FPackageIdentifiers.AddObject('GMG:', TGmgImporter.Create(self));
  FPackageIdentifiers.AddObject('SIP:', TSipImporter.Create(self));
  FPackageIdentifiers.AddObject('PCG:', TPcgImporter.Create(self));
  FPackageIdentifiers.AddObject('PCGN:', TPcgnImporter.Create(self));
  FGageImporter := TGageImporter.Create(self, LakImporter, SfrImporter);
  FPackageIdentifiers.AddObject('GAG:', FGageImporter);
  FPackageIdentifiers.AddObject('OC:', nil);
  FPackageIdentifiers.AddObject('IBS:', nil);
  Sub := TSubImporter.Create(self, Nam);
  FPackageIdentifiers.AddObject('SUB:', Sub);
  FPackageIdentifiers.AddObject('SWT:', TSwtImporter.Create(self));
  FPackageIdentifiers.AddObject('HOB:', THobImporter.Create(self));
  FChobImporter := TChdObsImporter.Create(self, Chd, Bas);
  FPackageIdentifiers.AddObject('CHOB:', FChobImporter);
  FPackageIdentifiers.AddObject('DROB:', TDrnObsImporter.Create(self, Drn));
  FPackageIdentifiers.AddObject('GBOB:', TGhbObsImporter.Create(self, GHB));
  FPackageIdentifiers.AddObject('RVOB:', TRivObsImporter.Create(self, Riv));
  FPackageIdentifiers.AddObject('STOB:', TStrObsImporter.Create(self, Str));
  FPackageIdentifiers.AddObject('LMT6:', nil);
  FPackageIdentifiers.AddObject('LMT7:', nil);
  FHydmodImporter := THydmodImporter.Create(self,
    SfrImporter, Sub);
  FPackageIdentifiers.AddObject('HYD:', FHydmodImporter);
  FPackageIdentifiers.AddObject('SWI2:', TSwiImporter.Create(self));
  FPackageIdentifiers.AddObject('NWT:', TNwtImporter.Create(self));
  FPackageIdentifiers.AddObject('UPW:', TUpwImporter.Create(self, Bas));
  FPackageIdentifiers.AddObject('SWR:', TSwrImporter.Create(self, ImportParameters.NameFile));
  // SWR, SFR, and STR must be imported before UZF is imported in order
  // to import IRUNBND correctly.
  FPackageIdentifiers.AddObject('UZF:', TUzfImporter.Create(self, LakImporter, SfrImporter));
end;

destructor TModflow2005Importer.Destroy;
var
  Index: Integer;
begin
  for Index := 0 to FPackageIdentifiers.Count - 1 do
  begin
    FPackageIdentifiers.Objects[Index].Free;
  end;
  FPackageIdentifiers.Free;
  inherited;
end;

function TModflow2005Importer.GetCellAreas: T2DDoubleArray;
var
  Grid: TModflowGrid;
  RowIndex: Integer;
  ColIndex: Integer;
begin
  if FCellAreas = nil then
  begin
    Grid := frmGoPhast.PhastModel.ModflowGrid;
    SetLength(FCellAreas, Grid.RowCount, Grid.ColumnCount);
    for RowIndex := 0 to Grid.RowCount - 1 do
    begin
      for ColIndex := 0 to Grid.ColumnCount - 1 do
      begin
        FCellAreas[RowIndex,ColIndex] :=
          Grid.ColumnWidth[ColIndex] * Grid.RowWidth[RowIndex];
      end;
    end;

  end;
  result := FCellAreas;
end;

function TModflow2005Importer.GetCenterPoints: TSurfacePointArray;
var
  Grid: TModflowGrid;
  RowIndex: Integer;
  ColIndex: Integer;
begin
  if not FPointsComputed then
  begin
    Grid := frmGoPhast.PhastModel.ModflowGrid;
    SetLength(FCenterPoints, Grid.RowCount, Grid.ColumnCount);
    for RowIndex := 0 to Grid.RowCount - 1 do
    begin
      for ColIndex := 0 to Grid.ColumnCount - 1 do
      begin
        FCenterPoints[RowIndex,ColIndex] :=
          Grid.TwoDElementCenter(ColIndex,RowIndex);
      end;
    end;
    FPointsComputed := True;
  end;
  result := FCenterPoints;
end;

function TModflow2005Importer.GetCornerPoints: TSurfacePointArray;
var
  Grid: TModflowGrid;
  RowIndex: Integer;
  ColIndex: Integer;
begin
  if FCornerPoints = nil then
  begin
    Grid := frmGoPhast.PhastModel.ModflowGrid;
    SetLength(FCornerPoints, Grid.RowCount+1, Grid.ColumnCount+1);
    for RowIndex := 0 to Grid.RowCount do
    begin
      for ColIndex := 0 to Grid.ColumnCount do
      begin
        FCornerPoints[RowIndex,ColIndex] :=
          Grid.TwoDElementCorner(ColIndex,RowIndex);
      end;
    end;
  end;
  result := FCornerPoints;
end;

procedure TModflow2005Importer.HandlePackageProgress(Position: integer);
begin
  ProgressHandler(Position, FFileSize);
end;

procedure TModflow2005Importer.IdentifyBoundaryCells(
  var ActiveCells, BoundaryCells: TBool2DArray);
var
  Grid: TCustomModelGrid;
  RowIndex: Integer;
  ColIndex: Integer;
  APoint: TPoint2D;
  FirstRow: Integer;
  LastRow: Integer;
  FirstCol: Integer;
  LastCol: Integer;
//  NewBoundaryCells: TBool2DArray;
begin
  Grid := frmGoPhast.Grid;
  SetLength(ActiveCells, Grid.RowCount, Grid.ColumnCount);
  FirstRow := FImportParameters.FirstRow-1;
  LastRow  := FImportParameters.LastRow-1;
  FirstCol := FImportParameters.FirstCol-1;
  LastCol  := FImportParameters.LastCol-1;
  for RowIndex := FirstRow to LastRow do
  begin
    for ColIndex := FirstCol to LastCol do
    begin
      APoint := Grid.TwoDElementCenter(ColIndex, RowIndex);
      ActiveCells[RowIndex, ColIndex]
        := FImportParameters.Outline.PointInside(APoint);
    end;
  end;
  BoundaryCells := ActiveCells;
  SetLength(BoundaryCells, Grid.RowCount, Grid.ColumnCount);
  for RowIndex := FirstRow+1 to LastRow-1 do
  begin
    for ColIndex := FirstCol+1 to LastCol-1 do
    begin
      if ActiveCells[RowIndex, ColIndex]
        and ActiveCells[RowIndex+1, ColIndex]
        and ActiveCells[RowIndex-1, ColIndex]
        and ActiveCells[RowIndex, ColIndex+1]
        and ActiveCells[RowIndex, ColIndex-1]
        then
      begin
        BoundaryCells[RowIndex, ColIndex] := False;
      end;
    end;
  end;
  if FirstCol = 0 then
  begin
    for RowIndex := FirstRow+1 to LastRow-1 do
    begin
      if ActiveCells[RowIndex-1, FirstCol]
        and ActiveCells[RowIndex+1, FirstCol] then
      begin
        BoundaryCells[RowIndex, FirstCol] := False;
      end; 
    end;
  end;
  if LastCol = Grid.ColumnCount-1 then
  begin
    for RowIndex := FirstRow+1 to LastRow-1 do
    begin
      if ActiveCells[RowIndex-1, LastCol]
        and ActiveCells[RowIndex+1, LastCol] then
      begin
        BoundaryCells[RowIndex, LastCol] := False;
      end; 
    end;
  end;
  if FirstRow = 0 then
  begin
    for ColIndex := FirstCol+1 to LastCol-1 do
    begin
      if ActiveCells[FirstRow, ColIndex-1]
        and ActiveCells[FirstRow, ColIndex+1] then
      begin
        BoundaryCells[FirstRow, ColIndex] := False;
      end; 
    end;
  end;
  if LastRow = Grid.RowCount-1 then
  begin
    for ColIndex := FirstCol+1 to LastCol-1 do
    begin
      if ActiveCells[LastRow, ColIndex-1]
        and ActiveCells[LastRow, ColIndex+1] then
      begin
        BoundaryCells[LastRow, ColIndex] := False;
      end; 
    end;
  end;

  if (FirstCol = 0) and (FirstRow = 0)
    and ActiveCells[FirstRow, FirstCol] then
  begin
    if ((FirstCol = LastCol) or ActiveCells[FirstRow, FirstCol+1])
      and ((FirstRow = LastRow) or ActiveCells[FirstRow+1, FirstCol]) then
    begin
      BoundaryCells[FirstRow, FirstCol] := False;
    end;
  end;
  if (FirstCol = 0) and (LastRow = Grid.RowCount-1)
    and ActiveCells[LastRow, FirstCol] then
  begin
    if ((FirstCol = LastCol) or ActiveCells[LastRow, FirstCol+1])
      and ((FirstRow = LastRow) or ActiveCells[LastRow-1, FirstCol]) then
    begin
      BoundaryCells[LastRow, FirstCol] := False;
    end;
  end;
  if (LastCol = Grid.ColumnCount-1) and (FirstRow = 0)
    and ActiveCells[FirstRow, LastCol] then
  begin
    if ((FirstCol = LastCol) or ActiveCells[FirstRow, LastCol-1])
      and ((FirstRow = LastRow) or ActiveCells[FirstRow+1, LastCol]) then
    begin
      BoundaryCells[FirstRow, LastCol] := False;
    end;
  end;
  if (LastCol = Grid.ColumnCount-1) and (LastRow = Grid.RowCount-1)
    and ActiveCells[LastRow, LastCol] then
  begin
    if ((FirstCol = LastCol) or ActiveCells[LastRow, LastCol-1])
      and ((FirstRow = LastRow) or ActiveCells[LastRow-1, LastCol]) then
    begin
      BoundaryCells[LastRow, LastCol] := False;
    end;
  end;
end;

type
  TFlowDirection = (fdRight, fdLeft, fdFront, fdBack);

procedure TModflow2005Importer.ImportBoundaryFlows;
var
//  FFileVariable: TFileVariable;
  Precision: TModflowPrecision;
  FFileStream: TFileStream;
  KSTP, KPER: Integer;
  PERTIM, TOTIM: TModflowDouble;
  DESC: TModflowDesc;
  NCOL, NROW: Integer;
//  DESC2: TModflowDesc2;
  BoundaryCells: TBool2DArray;
  ActiveDataSet: TDataArray;
  FirstRow: Integer;
  LastRow: Integer;
  FirstCol: Integer;
  LastCol: Integer;
  ScreenObjectIndex: Integer;
//  StressPeriodIndex: Integer;
  ObjectImporter: TSubModelFlowImporter;
  Times: TRealList;
  ScreenObjectList: TScreenObjectList;
  FirstTimeFront: Boolean;
  FirstTimeSide: Boolean;
  ActiveCells: TBool2DArray;
  HufFormat: Boolean;
  NLAY: Integer;
  AnArray: T3DTModflowArray;
  Grid: TCustomModelGrid;
  AuxArray: TAuxArrays;
//  BoundaryScreenObjectList: TScreenObjectList;
//  ObjectIndex: Integer;
//  AScreenObject: TScreenObject;
//  AnItem: TFhbItem;
//  BoundaryTimeIndex: Integer;
//  LastItem: TFhbItem;
  ScreenObjectArray:  array of array[TFlowDirection] of TScreenObject;
  DirIndex: TFlowDirection;
  LayerIndex: Integer;
  ModelName1, ModelName2, PackageName1, PackageName2: string;
  procedure DefineBoundary;
  var
    LocationsToUse: TList;
    RowIndex: Integer;
    ColIndex: Integer;
    Layer: Integer;
    ALocation: TLocation;
    ScreenObject: TScreenObject;
    Values: TList<TModflowDouble>;
    AnItem: TFhbItem;
    ImportedFlows: TValueArrayItem;
    ValueIndex: Integer;
    StartTimePos: Integer;
    LayerIndex: Integer;
    Description: string;
    StartDirection: TFlowDirection;
    EndDirection: TFlowDirection;
    FlowDir: TFlowDirection;
    DeltaCol: integer;
    DeltaRow: Integer;
    InvertValue: Boolean;
    ObjectSuffix: string;
    FirstTime: Boolean;
    IFace: TIface;
    NewName: string;
//    TotTimeIndex: Integer;
    procedure SetDeltas;
    begin
      DeltaCol := 0;
      DeltaRow := 0;
      InvertValue := False;
      case FlowDir of
        fdRight:
          begin
            DeltaCol := -1;
            ObjectSuffix := 'RightFace';
            FirstTime := FirstTimeSide;
            IFace := iRight;
          end;
        fdLeft:
          begin
            InvertValue := True;
            ObjectSuffix := 'LeftFace';
            FirstTime := FirstTimeSide;
            IFace := iLeft;
          end;
        fdFront:
          begin
            InvertValue := True;
            ObjectSuffix := 'FrontFace';
            FirstTime := FirstTimeFront;
            IFace := iFront;
          end;
        fdBack:
          begin
            DeltaRow := -1;
            ObjectSuffix := 'BackFace';
            FirstTime := FirstTimeFront;
            IFace := iBack;
          end;
      end;
    end;
    function CanUseLocation: boolean;
    begin
      result := True;
      case FlowDir of
        fdRight:
          begin
            Result := (ColIndex > 0) and not ActiveCells[RowIndex, ColIndex-1];
          end;
        fdLeft:
          begin
            Result := (ColIndex < Grid.ColumnCount-1) and not ActiveCells[RowIndex, ColIndex+1];
          end;
        fdFront:
          begin
            Result := (RowIndex < Grid.RowCount-1) and not ActiveCells[RowIndex+1, ColIndex]
          end;
        fdBack:
          begin
            Result := (RowIndex > 0) and not ActiveCells[RowIndex-1, ColIndex];
          end;
      end;
    end;
  begin
    Description := Trim(string(DESC));
    if (Description = 'FLOW RIGHT FACE')then
    begin
      StartDirection := fdRight;
      EndDirection := fdLeft;
    end
    else if (Description = 'FLOW FRONT FACE') then
    begin
      StartDirection := fdFront;
      EndDirection := fdBack;
    end
    else
    begin
      Exit;
    end;
    Times.AddUnique(TOTIM);
    NLAY := Abs(NLAY);
    for FlowDir := StartDirection to EndDirection do
    begin
      SetDeltas;
      ObjectImporter.Suffix := ObjectSuffix;
      for LayerIndex := 1 to NLAY do
      begin
        LocationsToUse := TObjectList.Create;
        Values := TList<TModflowDouble>.Create;
        try
          Layer := frmGoPhast.PhastModel.ModflowLayerToDataSetLayer(LayerIndex);
          for RowIndex := FirstRow to LastRow do
          begin
            for ColIndex := FirstCol to LastCol do
            begin
              if BoundaryCells[RowIndex, ColIndex]
                and ActiveDataSet.BooleanData[Layer, RowIndex, ColIndex]
                and CanUseLocation then
              begin
                ALocation := TLocation.Create;
                ALocation.Layer := LayerIndex;
                ALocation.Row := RowIndex+1;
                ALocation.Column := ColIndex+1;
                LocationsToUse.Add(ALocation);
                Values.Add(AnArray[LayerIndex-1, RowIndex+DeltaRow, ColIndex+DeltaCol])
              end;
            end;
          end;
          if LocationsToUse.Count > 0 then
          begin
            if ScreenObjectArray[LayerIndex-1, FlowDir] = nil then
            begin
              ScreenObject := ObjectImporter.CreateScreenObject(LocationsToUse, ScreenObjectIndex,
                LayerIndex, KPER, otPoint);
              ScreenObjectArray[LayerIndex-1, FlowDir] := ScreenObject;
              NewName := StringReplace(ScreenObject.Name, '_Layer',
                '_Time_Step_' + IntToStr(KSTP) + '_Layer', []);
              ScreenObject.Name := NewName;
              ScreenObject.IFACE := iFace;
              ScreenObjectList.Add(ScreenObject);
            end
            else
            begin
              ScreenObject := ScreenObjectArray[LayerIndex-1, FlowDir];
            end;

//            BoundaryScreenObjectList.Add(ScreenObject);
            ImportedFlows := ScreenObject.ImportedValues.Add;
            ImportedFlows.Name := StrParentModelFlows + '_SP_' + KPER.ToString
              + '_TS_' + KSTP.ToString;
            ImportedFlows.Values.DataType := rdtDouble;
            ImportedFlows.Values.Count := LocationsToUse.Count;
            for ValueIndex := 0 to Values.Count - 1 do
            begin
              if InvertValue then
              begin
                ImportedFlows.Values.RealValues[ValueIndex] := -Values[ValueIndex];
              end
              else
              begin
                ImportedFlows.Values.RealValues[ValueIndex] := Values[ValueIndex];
              end;
            end;
            ScreenObject.CreateFhbFlowBoundary;
            if FirstTime then
            begin
              AnItem := ScreenObject.ModflowFhbFlowBoundary.Values.Add as TFhbItem;
              StartTimePos := Times.IndexOf(TOTIM)-1;
              AnItem.StartTime := Times[StartTimePos];
              AnItem.EndTime := TOTIM;
              AnItem.BoundaryValue := rsObjectImportedValuesR + '("' + ImportedFlows.Name + '")';
//            end
//            else
//            begin
//              AnItem := ScreenObject.ModflowFhbFlowBoundary.Values.Add as TFhbItem;
//              AnItem.StartTime := 0;
//              AnItem.EndTime := TOTIM;
//              AnItem.BoundaryValue := '0';
            end;
            AnItem := ScreenObject.ModflowFhbFlowBoundary.Values.Add as TFhbItem;
            AnItem.StartTime := TOTIM;
            AnItem.EndTime := TOTIM;
            AnItem.BoundaryValue := rsObjectImportedValuesR + '("' + ImportedFlows.Name + '")';
//            TotTimeIndex := Times.IndexOf(TOTIM);
          end;
        finally
          LocationsToUse.Free;
          Values.Free;
        end;
      end;
    end;
    if (Description = 'FLOW RIGHT FACE')then
    begin
      FirstTimeSide := False;
    end
    else if (Description = 'FLOW FRONT FACE') then
    begin
      FirstTimeFront := False;
    end
    else
    begin
      Exit;
    end;
  end;
begin
  SetLength(ScreenObjectArray, frmGoPhast.PhastModel.ModflowLayerCount);
  for LayerIndex := 0 to frmGoPhast.PhastModel.ModflowLayerCount-1 do
  begin
    for DirIndex := Low(TFlowDirection) to High(TFlowDirection) do
    begin
      ScreenObjectArray[LayerIndex, DirIndex] := nil;
    end;
  end;
//  BoundaryScreenObjectList := TScreenObjectList.Create;
//  try
  if (FImportParameters.FirstCol > 0)
    and (FImportParameters.FlowFile <> '') then
  begin
    Grid := frmGoPhast.Grid;
    ScreenObjectIndex := 0;
//    StressPeriodIndex := 0;
    FirstRow := FImportParameters.FirstRow-1;
    LastRow  := FImportParameters.LastRow-1;
    FirstCol := FImportParameters.FirstCol-1;
    LastCol  := FImportParameters.LastCol-1;
    IdentifyBoundaryCells(ActiveCells, BoundaryCells);
    ActiveDataSet := frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsActive);
    frmGoPhast.PhastModel.ModflowPackages.FhbPackage.IsSelected := True;
    frmGoPhast.PhastModel.DataArrayManager.CreateInitialDataSets;
    FirstTimeSide := True;
    FirstTimeFront := True;
    ScreenObjectList := TScreenObjectList.Create;
    ObjectImporter := TSubModelFlowImporter.Create(self, 'FHB_Flow');
    Times := TRealList.Create;
    try
      Times.Sorted := True;
      Times.Add(0);
      FFileStream := TFileStream.Create(FImportParameters.FlowFile,
        fmOpenRead or fmShareDenyWrite);
      try
        if FFileStream.Size > 0 then
        begin
          Precision := CheckBudgetPrecision(FFileStream, HufFormat, False);
        end
        else
        begin
  //        result := False;
          Beep;
          MessageDlg(StrTheFlowFileYouSelecte, mtError, [mbOK], 0);
          Exit;
        end;
        while FFileStream.Position < FFileStream.Size do
        begin
          case Precision of
            mpSingle:
              begin
                ReadModflowSinglePrecFluxArray(FFileStream,
                  KSTP, KPER, PERTIM, TOTIM, DESC, NCOL, NROW, NLAY, AnArray,
                  AuxArray, HufFormat);
              end;
            mpDouble:
              begin
                ReadModflowDoublePrecFluxArray(FFileStream,
                  KSTP, KPER, PERTIM, TOTIM, DESC, NCOL, NROW, NLAY, AnArray,
                  AuxArray, -1, -1, -1, HufFormat,
                  ModelName1, ModelName2, PackageName1, PackageName2);
              end;
          end;
          DefineBoundary;
        end;
      finally
        FFileStream.Free;
      end;
    finally
      ObjectImporter.Free;
      Times.Free;
      ScreenObjectList.Free;
    end;
  end;
end;

procedure TModflow2005Importer.ImportBoundaryHeads;
var
  FFileVariable: TFileVariable;
  Precision: TModflowPrecision;
  FFileStream: TFileStream;
  KSTP, KPER: Integer;
  PERTIM, TOTIM: TModflowDouble;
  DESC: TModflowDesc;
  NCOL, NROW, ILAY: Integer;
  AnArray: TModflowDoubleArray;
  DESC2: TModflowDesc2;
  BoundaryCells: TBool2DArray;
  ActiveDataSet: TDataArray;
  FirstRow: Integer;
  LastRow: Integer;
  FirstCol: Integer;
  LastCol: Integer;
  ScreenObjectIndex: Integer;
//  StressPeriodIndex: Integer;
  ObjectImporter: TSubModelHeadImporter;
  Times: TRealList;
  ScreenObjectList: TScreenObjectList;
  FirstTime: Boolean;
  ActiveCells: TBool2DArray;
  ScreenObjectArray:  array of TScreenObject;
  LayerIndex: Integer;
  procedure DefineBoundary;
  var
    LocationsToUse: TList;
    RowIndex: Integer;
    ColIndex: Integer;
    Layer: Integer;
    ALocation: TLocation;
    ScreenObject: TScreenObject;
    Values: TList<TModflowDouble>;
    AnItem: TFhbItem;
    ImportedHeads: TValueArrayItem;
    ValueIndex: Integer;
    StartTimePos: Integer;
    NewName: string;
    LayerIndex: Integer;
  begin
    Times.AddUnique(TOTIM);
    FirstTime := Times.Count <= 2;

    LocationsToUse := TObjectList.Create;
    Values := TList<TModflowDouble>.Create;
    try
      Layer := Abs(ILAY);
      LayerIndex := Layer;
      Layer := frmGoPhast.PhastModel.ModflowLayerToDataSetLayer(Layer);
      for RowIndex := FirstRow to LastRow do
      begin
        for ColIndex := FirstCol to LastCol do
        begin
          if BoundaryCells[RowIndex, ColIndex]
            and ActiveDataSet.BooleanData[Layer, RowIndex, ColIndex] then
          begin
            ALocation := TLocation.Create;
            ALocation.Layer := Abs(ILAY);
            ALocation.Row := RowIndex+1;
            ALocation.Column := ColIndex+1;
            LocationsToUse.Add(ALocation);
            Values.Add(AnArray[RowIndex, ColIndex])
          end;
        end;
      end;
      if LocationsToUse.Count > 0 then
      begin
        if ScreenObjectArray[LayerIndex-1] = nil then
        begin
          ScreenObject := ObjectImporter.CreateScreenObject(LocationsToUse, ScreenObjectIndex,
            Abs(ILAY), KPER, otPoint);
          NewName := StringReplace(ScreenObject.Name, '_Layer',
            '_Time_Step_' + IntToStr(KSTP) + '_Layer', []);
          ScreenObject.Name := NewName;

          ScreenObject.IFACE := iInternal;
          ScreenObjectList.Add(ScreenObject);
          ScreenObjectArray[LayerIndex-1] := ScreenObject;
        end
        else
        begin
          ScreenObject := ScreenObjectArray[LayerIndex-1];
        end;
        ImportedHeads := ScreenObject.ImportedValues.Add;
        ImportedHeads.Name := StrParentModelHeads + '_SP_' + KPER.ToString
          + '_TS_' + KSTP.ToString;
        ImportedHeads.Values.DataType := rdtDouble;
        ImportedHeads.Values.Count := LocationsToUse.Count;
        for ValueIndex := 0 to Values.Count - 1 do
        begin
          ImportedHeads.Values.RealValues[ValueIndex] := Values[ValueIndex];
        end;
        ScreenObject.CreateFhbHeadBoundary;
        if FirstTime then
        begin
          AnItem := ScreenObject.ModflowFhbHeadBoundary.Values.Add as TFhbItem;
          StartTimePos := Times.IndexOf(TOTIM)-1;
          AnItem.StartTime := Times[StartTimePos];
          AnItem.EndTime := TOTIM;
          AnItem.BoundaryValue := rsObjectImportedValuesR + '("' + ImportedHeads.Name + '")';
        end;
        AnItem := ScreenObject.ModflowFhbHeadBoundary.Values.Add as TFhbItem;
        AnItem.StartTime := TOTIM;
        AnItem.EndTime := TOTIM;
        AnItem.BoundaryValue := rsObjectImportedValuesR + '("' + ImportedHeads.Name + '")';
      end;
    finally
      LocationsToUse.Free;
      Values.Free;
    end;
  end;
begin
  SetLength(ScreenObjectArray, frmGoPhast.PhastModel.ModflowLayerCount);
  for LayerIndex := 0 to frmGoPhast.PhastModel.ModflowLayerCount - 1 do
  begin
    ScreenObjectArray[LayerIndex] := nil;
  end;
  if (FImportParameters.FirstCol > 0)
    and (FImportParameters.HeadFile <> '') then
  begin
    ScreenObjectIndex := 0;
//    StressPeriodIndex := 0;
    FirstRow := FImportParameters.FirstRow-1;
    LastRow  := FImportParameters.LastRow-1;
    FirstCol := FImportParameters.FirstCol-1;
    LastCol  := FImportParameters.LastCol-1;
    IdentifyBoundaryCells(ActiveCells, BoundaryCells);
    ActiveDataSet := frmGoPhast.PhastModel.DataArrayManager.GetDataSetByName(rsActive);
    frmGoPhast.PhastModel.ModflowPackages.FhbPackage.IsSelected := True;
    frmGoPhast.PhastModel.DataArrayManager.CreateInitialDataSets;
	  FirstTime := True;
    ScreenObjectList := TScreenObjectList.Create;
    ObjectImporter := TSubModelHeadImporter.Create(self, 'FHB_Head');
    Times := TRealList.Create;
    try
      Times.Sorted := True;
      Times.Add(0);
      if FImportParameters.HeadFileType = hftText then
      begin
        FFileVariable := TFileVariable.Create;
        try
          AssignFile(FFileVariable.AFile, FImportParameters.HeadFile);
          Reset(FFileVariable.AFile);
          if FileSize(FFileVariable.AFile) > 0 then
          begin
//            Precision := mpDouble;
          end
          else
          begin
            Beep;
            MessageDlg(StrTheHeadFileYouSelecte, mtError, [mbOK], 0);
            Exit;
          end;
          while not Eof(FFileVariable.AFile) do
          begin
            ReadModflowAsciiRealArray(FFileVariable, KSTP, KPER, PERTIM, TOTIM,
              DESC2, NCOL, NROW, ILAY, AnArray);
            DefineBoundary;
          end;
        finally
          CloseFile(FFileVariable.AFile);
          FFileVariable.Free;
        end;
      end
      else
      begin
        FFileStream := TFileStream.Create(FImportParameters.HeadFile,
          fmOpenRead or fmShareDenyWrite);
        try
          if FFileStream.Size > 0 then
          begin
            Precision := CheckArrayPrecision(FFileStream);
          end
          else
          begin
    //        result := False;
            Beep;
            MessageDlg(StrTheHeadFileYouSelecte, mtError, [mbOK], 0);
            Exit;
          end;
          while FFileStream.Position < FFileStream.Size do
          begin
            case Precision of
              mpSingle:
                begin
                  ReadSinglePrecisionModflowBinaryRealArray(FFileStream,
                    KSTP, KPER, PERTIM, TOTIM, DESC, NCOL, NROW, ILAY, AnArray);
                end;
              mpDouble:
                begin
                  ReadDoublePrecisionModflowBinaryRealArray(FFileStream,
                    KSTP, KPER, PERTIM, TOTIM, DESC, NCOL, NROW, ILAY, AnArray);
                end;
            end;
            DefineBoundary;
          end;
        finally
          FFileStream.Free;
        end;
      end;
    finally
      ObjectImporter.Free;
      Times.Free;
      ScreenObjectList.Free;
    end;


  end;
end;

procedure TModflow2005Importer.ImportModel;
var
  ALine: string;
  PackageIndex: integer;
  PackageImporter: TPackageImporter;
  KPER: integer;
  Index: Integer;
//  FilePosition: Integer;
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  frmGoPhast.ModelSelection := msModflow;
  frmErrorsAndWarnings.Clear;
  StressPeriodString := '';
  Assert(FileExists(FListFileName));
  AssignFile(FFile,FListFileName);
  try
    Reset(FFile);
    FFileSize := FileSize(FFile);
    While not Eof(FFile) do
    begin
      ReadLn(FFile, ALine);
      UpdateProgress;
      ALine := Trim(ALine);
      if ALine = 'DIS:' then
      begin
        texthandler('Converting DIS input file');
      end
      else if ALine = 'BAS:' then
      begin
        texthandler('Converting BAS input file');
      end
      else if ALine = 'LPF:' then
      begin
        texthandler('Converting LPF input file');
      end
      else if ALine = 'HUF:' then
      begin
        texthandler('Converting HUF2 input file');
      end
      else if ALine = 'BCF:' then
      begin
        texthandler('Converting BCF input file');
      end
      else if ALine = 'OC:' then
      begin
        texthandler('Converting OC input file');
      end;

      if ALine = 'KPER:' then
      begin
        ReadLn(FFile, KPER);
        UpdateProgress;
        texthandler('Converting Stress Period ' + IntToStr(KPER));
        StressPeriodString := ' Stress Period ' + IntToStr(KPER);
      end
      else
      begin
        if (Length(ALine) > 0) and (ALine[Length(ALine)] = ':') then
        begin
          PackageIndex := FPackageIdentifiers.IndexOf(ALine);
          if PackageIndex >= 0 then
          begin
            PackageImporter := FPackageIdentifiers.Objects[PackageIndex]
              as TPackageImporter;
            while PackageImporter <> nil do
            begin
              texthandler('Converting '
                + FPackageIdentifiers[PackageIndex] + StressPeriodString);
              PackageImporter.ImportPackage(PackageIndex);
              if PackageIndex >= 0 then
              begin
                texthandler('Converting '
                  + FPackageIdentifiers[PackageIndex] + StressPeriodString);
                PackageImporter := FPackageIdentifiers.Objects[PackageIndex]
                  as TPackageImporter;
              end
              else
              begin
                PackageImporter := nil;
              end;
            end;
          end;
        end;
      end;
    end;
    FChobImporter.HandlePackage;
    FGageImporter.HandlePackage;
    FPvalImporter.HandlePackage;
    FHydmodImporter.HandlePackage;

  finally
    CloseFile(FFile);
    GlobalCellCenterScreenObject := nil;
  end;
  for Index := 0 to frmGoPhast.PhastModel.ScreenObjectCount - 1 do
  begin
    frmGoPhast.PhastModel.ScreenObjects[Index].CacheValueArrays;
  end;
  frmGoPhast.PhastModel.FormulaManager.Pack;

  InactivateCellsOutsideSubModel;
  ImportBoundaryHeads;
  ImportBoundaryFlows;
  UpdateSubModelGrid;

  frmGoPhast.PhastModel.DataArrayManager.CreateInitialDataSets;
  frmGoPhast.PhastModel.UpdateOnPostInitialize;
  for ChildIndex := 0 to frmGoPhast.PhastModel.ChildModels.Count - 1 do
  begin
    ChildModel := frmGoPhast.PhastModel.ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.DataArrayManager.CreateInitialDataSets;
      ChildModel.UpdateOnPostInitialize;
    end;
  end;
  frmGoPhast.RestoreDefault2DView1Click(nil);
  frmGoPhast.Grid.RowDirection := rdNorthToSouth;
//  frmGoPhast.frameFrontView.ModelCube.YOrigin := yoSouth;

end;

procedure TModflow2005Importer.UpdateProgress;
var
  FilePosition: Integer;
begin
  {$I-}
  FilePosition := FilePos(FFile);
  if IOResult = 0 then
  begin
    ProgressHandler(FilePosition, FFileSize);
  end;
  {$I+}
end;

procedure TModflow2005Importer.InactivateCellsOutsideSubModel;
var
  ExternalScreenObject: TScreenObject;
  ObjectImporter: TSubModelInactiveImporter;
  Grid: TCustomModelGrid;
  APoint: TPoint2D;
  Polygon: TSubPolygon;
  PointIndex: Integer;
  ActiveDataArray: TDataArray;
  DataArrayIndex: Integer;
begin
  if FImportParameters.Outline <> nil then
  begin
    Grid := frmGoPhast.Grid;
    ObjectImporter := TSubModelInactiveImporter.Create(Self, 'BAS');
    try
      ExternalScreenObject := ObjectImporter.CreateScreenObject('Model_Edge');
      ExternalScreenObject.ElevationCount := ecTwo;
      ExternalScreenObject.HigherElevationFormula := kModelTop;
      ExternalScreenObject.LowerElevationFormula
        := frmGoPhast.PhastModel.LayerStructure.Last.DataArrayName;

      APoint := Grid.TwoDElementCorner(0,0);
      ExternalScreenObject.AddPoint(APoint, True);
      APoint := Grid.TwoDElementCorner(Grid.ColumnCount,0);
      ExternalScreenObject.AddPoint(APoint, False);
      APoint := Grid.TwoDElementCorner(Grid.ColumnCount,Grid.RowCount);
      ExternalScreenObject.AddPoint(APoint, False);
      APoint := Grid.TwoDElementCorner(0,Grid.RowCount);
      ExternalScreenObject.AddPoint(APoint, False);
      APoint := ExternalScreenObject.Points[0];
      ExternalScreenObject.AddPoint(APoint, False);

      Polygon := FImportParameters.Outline.Polygons[0];
      APoint := Polygon.Points[0];
      ExternalScreenObject.AddPoint(APoint, True);

      for PointIndex := 1 to Polygon.Count - 1 do
      begin
        APoint := Polygon.Points[PointIndex];
        ExternalScreenObject.AddPoint(APoint, False);
      end;

      ActiveDataArray := frmGoPhast.PhastModel.DataArrayManager.
        GetDataSetByName(rsActive);
      DataArrayIndex := ExternalScreenObject.AddDataSet(ActiveDataArray);
      ExternalScreenObject.DataSetFormulas[DataArrayIndex] := 'False';

    finally
      ObjectImporter.Free;
    end;
  end;
end;

procedure TModflow2005Importer.UpdateSubModelGrid;
var
  Grid: TCustomModelGrid;
  ColumnPositions: TOneDRealArray;
  NewColumnPositions: TOneDRealArray;
  RowPositions: TOneDRealArray;
  NewRowPositions: TOneDRealArray;
  ColIndex: Integer;
  RowIndex: Integer;
begin
  if (FImportParameters.FirstCol > 0)
    and (FImportParameters.LastCol > 0)
    and (FImportParameters.FirstRow > 0)
    and (FImportParameters.LastRow > 0)
    then
  begin
    Grid := frmGoPhast.Grid;
    ColumnPositions := Grid.ColumnPositions;
    SetLength(NewColumnPositions,
      FImportParameters.LastCol - FImportParameters.FirstCol + 2);
    for ColIndex := FImportParameters.FirstCol-1 to FImportParameters.LastCol do
    begin
      NewColumnPositions[ColIndex - (FImportParameters.FirstCol-1)]
        := ColumnPositions[ColIndex];
    end;
    Grid.ColumnPositions := NewColumnPositions;

    RowPositions := Grid.RowPositions;
    SetLength(NewRowPositions,
      FImportParameters.LastRow - FImportParameters.FirstRow + 2);
    for RowIndex := FImportParameters.FirstRow-1 to FImportParameters.LastRow do
    begin
      NewRowPositions[RowIndex - (FImportParameters.FirstRow-1)]
        := RowPositions[RowIndex];
    end;
    Grid.RowPositions := NewRowPositions;
  end;
end;

{ TPackageImporter }

constructor TPackageImporter.Create(Importer: TModflow2005Importer;
  const PackageIdentifier: string);
begin
  FProgressHandler :=  Importer.HandlePackageProgress;
  FImporter := Importer;
  FPackageIdentifier := PackageIdentifier;
  FComments:= TStringList.Create;
  FModel := frmGoPhast.PhastModel;
  FGrid := FModel.ModflowGrid;
end;

procedure TPackageImporter.CreateDataArrayAndAssignValues(
  ScreenObject: TScreenObject; const DataArrayName: string;
  ImportedValues: T2DIntArray);
var
  DataArray: TDataArray;
  Interpolator: TNearestPoint2DInterpolator;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
  if DataArray = nil then
  begin
    DataArray := FModel.DataArrayManager.CreateNewDataArray(TDataArray,
      DataArrayName, '0', DataArrayName,
      [dcType], rdtInteger, eaBlocks, dsoTop, '');
    DataArray.Comment := Format(StrImportedFromExisti, [DateTimeToStr(Now)]);

    DataArray.UpdateDimensions(FGrid.LayerCount, FGrid.RowCount,
      FGrid.ColumnCount);

    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
  AssignIntegerValuesToCellCenters(DataArray, ScreenObject, ImportedValues);
end;

destructor TPackageImporter.Destroy;
begin
  FComments.Free;
  inherited;
end;

function TPackageImporter.FixArrayName(const ArrayName: string): string;
begin
  result := GoPhastTypes.ValidName(ArrayName);
end;

procedure TPackageImporter.HandlePackage;
var
  ID: string;
begin
  ID := FPackageIdentifier;
  Assert(Length(ID) > 0);
  if ID[Length(ID)] = ':' then
  begin
    ID := Copy(ID, 1, Length(ID)-1);
  end;
  FImporter.TextHandler('Importing ' + ID + ' Package');
  FImportedPackage := True;
end;

procedure TPackageImporter.ReadData(const ALabel: string);
begin

end;

procedure TPackageImporter.ImportPackage(out NextPackageIndex: integer);
var
  ALine: string;
  KPER: integer;
  FileName: string;
//  FilePosition: Integer;
begin
  While not Eof(FImporter.FFile) do
  begin
    ReadLn(FImporter.FFile, ALine);
    FImporter.UpdateProgress;

    ALine := Trim(ALine);
    if ALine = FPackageIdentifier then
    begin
      Continue;
    end;
    if (Length(ALine) > 0) and (ALine[Length(ALine)] = ':') then
    begin
      NextPackageIndex := FImporter.FPackageIdentifiers.IndexOf(ALine);
      if NextPackageIndex >= 0 then
      begin
        HandlePackage;
        Exit;
      end;
      if ALine = 'COMMENT:' then
      begin
        ReadLn(FImporter.FFile, ALine);
        FImporter.UpdateProgress;
        ALine := Trim(ALine);
        if (Length(ALine) > 0) and (ALine[1] = '#') then
        begin
          ALine := Trim(Copy(ALine, 2, MAXINT));
        end;
        if (Length(ALine) > 0) then
        begin
          FComments.Add(ALine);
        end;
      end
      else if ALine = 'KPER:' then
      begin
        ReadLn(FImporter.FFile, KPER);
        FImporter.UpdateProgress;
        FImporter.texthandler('Converting Stress Period ' + IntToStr(KPER));
        StressPeriodString := ' Stress Period ' + IntToStr(KPER);
        FImporter.StressPeriodString := StressPeriodString;
      end
      else if Pos('OPENING FILE ON UNIT', ALine) = 1 then
      begin
        ReadLn(FImporter.FFile, FileName);
        FImporter.UpdateProgress;
        FileName := Trim(FileName);
      end
      else
      begin
        ReadData(ALine);
      end;
    end;
  end;
  NextPackageIndex := -1;
  if not ImportedPackage then
  begin
    HandlePackage;
  end;
  Exit;
end;

procedure TPackageImporter.Read1DRealArray(var DoubleArray: TOneDRealArray);
var
  Index: Integer;
begin
  for Index := 0 to Length(DoubleArray) - 1 do
  begin
    Read(FImporter.FFile,DoubleArray[Index]);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

resourcestring
  StrErrorReadingArrayData = 'Error reading array data for the following cells in "%s" (Row, Col)';

procedure TPackageImporter.Read2DRealArray(var DoubleArray: T2DDoubleArray;
  const ArrayName: string);
const
  MaxDouble = 1E308;
var
  RowIndex: Integer;
  ColIndex: Integer;
  ErrorMessage: string;
begin
  ErrorMessage := Format(StrErrorReadingArrayData, [ArrayName]);
//  frmErrorsAndWarnings.RemoveWarningGroup(FModel, ErrorMessage);
  for RowIndex := 0 to Length(DoubleArray) - 1 do
  begin
    for ColIndex := 0 to Length(DoubleArray[RowIndex]) - 1 do
    begin
      try
        Read(FImporter.FFile,DoubleArray[RowIndex, ColIndex]);
      except on EInOutError do
        begin
          DoubleArray[RowIndex, ColIndex] := MaxDouble;
          frmErrorsAndWarnings.AddWarning(FModel, ErrorMessage,
            Format('%0:d, %1:d', [RowIndex+1, ColIndex+1]));
        end;
      end;
    end;
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end;
  FImporter.UpdateProgress;
end;

{ TDisImporter }

constructor TDisImporter.Create(Importer: TModflow2005Importer;
  Bas: TBasImporter;
  XOrigin, YOrigin, GridAngle: double; GridOrigin: TGridOrigin);
begin
  inherited Create(Importer, 'DIS:');
  FBas := Bas;
  Bas.Dis := self;
  FOriginPoint.x := XOrigin;
  FOriginPoint.y := YOrigin;
  FGridAngle := GridAngle;
  FGridOrigin := GridOrigin;
end;

procedure TDisImporter.ImportElevationsAndReleaseMemory;
begin
  if FBas.FHasReadIBound then
  begin
    FixElevations;
    ImportElevations;
    GetLayerThicknesses;
    InitializeView;
    ReleaseMemory;
  end;
end;

procedure TDisImporter.InitializeView;
var
  YWidth: Real;
  MaxZ: Real;
  RowIndex: Integer;
  ColIndex: Integer;
  MaxLayer: Integer;
  MinZ: Real;
  ZHeight: Real;
  XWidth: Real;
begin
  XWidth := FGrid.ColumnPosition[FGrid.ColumnCount] - FGrid.ColumnPosition[0];
  YWidth := FGrid.RowPosition[0] - FGrid.RowPosition[FGrid.RowCount];

  if FConstantElevations[0].IsConstant then
  begin
    MaxZ := FConstantElevations[0].RealValue;
  end
  else
  begin
    MaxZ := FElevations[0, 0, 0];
    for RowIndex := 0 to Length(FElevations[0]) - 1 do
    begin
      for ColIndex := 0 to Length(FElevations[0, 0]) - 1 do
      begin
        if MaxZ < FElevations[0, RowIndex, ColIndex] then
        begin
          MaxZ := FElevations[0, RowIndex, ColIndex];
        end;
      end;
    end;
  end;

  MaxLayer := Length(FElevations) - 1;
  if FConstantElevations[MaxLayer].IsConstant then
  begin
    MinZ := FConstantElevations[MaxLayer].RealValue;
  end
  else
  begin
    MinZ := FElevations[MaxLayer, 0, 0];
    for RowIndex := 0 to Length(FElevations[0]) - 1 do
    begin
      for ColIndex := 0 to Length(FElevations[0, 0]) - 1 do
      begin
        if MinZ > FElevations[MaxLayer, RowIndex, ColIndex] then
        begin
          MinZ := FElevations[MaxLayer, RowIndex, ColIndex];
        end;
      end;
    end;
  end;

  ZHeight := MaxZ - MinZ;
  frmGoPhast.PhastModel.Exaggeration := frmGoPhast.DefaultVE;
  frmGoPhast.InitializeView(XWidth, YWidth, ZHeight);
end;

procedure TDisImporter.ReadStressPeriod;
var
  N: Integer;
begin
  Read(FImporter.FFile, N);
  Read(FImporter.FFile, FStressPeriods[N - 1].PERLEN);
  Read(FImporter.FFile, FStressPeriods[N - 1].NSTP);
  Read(FImporter.FFile, FStressPeriods[N - 1].TSMULT);
  Read(FImporter.FFile, FStressPeriods[N - 1].ISSFLG);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TDisImporter.ImportRowsAndColumns;
var
  RowPositions: TOneDRealArray;
  Index: Integer;
  ColumnPositions: TOneDRealArray;
  Grid: TModflowGrid;
  RotatedOrigin: TPoint2D;
begin
  Grid := frmGoPhast.PhastModel.ModflowGrid;
  RotatedOrigin := Grid.
    RotateFromRealWorldCoordinatesToGridCoordinates(FOriginPoint);

  SetLength(ColumnPositions, NCOL + 1);
  ColumnPositions[0] := RotatedOrigin.x;
  for Index := 0 to NCOL - 1 do
  begin
    ColumnPositions[Index + 1] := ColumnPositions[Index] + DELR[Index];
  end;
  Grid.ColumnPositions := ColumnPositions;
  SetLength(RowPositions, NROW + 1);
  RowPositions[0] := RotatedOrigin.Y;
  for Index := 0 to NROW - 1 do
  begin
    case FGridOrigin of
      goUpperLeft:
        begin
          RowPositions[Index + 1] := RowPositions[Index] - DELC[Index];
        end;
      goLowerLeft:
        begin
          RowPositions[Index + 1] := RowPositions[Index] + DELC[Index];
        end;
      else
        Assert(False);
    end;
  end;
  case FGridOrigin of
    goUpperLeft: Grid.RowDirection := rdNorthToSouth;
    goLowerLeft: Grid.RowDirection := rdSouthToNorth;
  end;
  Grid.RowPositions := RowPositions;
end;

procedure TDisImporter.ImportElevations;
var
  GroupIndex: Integer;
  NewLayerStructure: TLayerStructure;
  ScreenObject: TScreenObject;
  DataArray: TDataArray;
  DataArrayName: string;
  LayerIndex: Integer;
begin
  CheckVariableRealArrays(FConstantElevations, FElevations);
  ScreenObject := nil;
  NewLayerStructure := TLayerStructure.Create(nil);
  try
    NewLayerStructure.Assign(FModel.LayerStructure);
    for GroupIndex := 1 to NewLayerStructure.Count - 1 do
    begin
      NewLayerStructure.LayerGroups[GroupIndex].AquiferName :=
        'Layer ' + IntToStr(GroupIndex);
    end;
    while NewLayerStructure.Count > Length(FElevations) do
    begin
      NewLayerStructure.Delete(NewLayerStructure.Count - 1);
    end;
    while NewLayerStructure.Count < Length(FElevations) do
    begin
      NewLayerStructure.Add;
    end;
    NewLayerStructure.LayerGroups[0].AquiferName := kModelTop;
    GroupIndex := 1;
    for LayerIndex := 0 to Length(LAYCBD) - 1 do
    begin
      NewLayerStructure.LayerGroups[GroupIndex].Simulated := True;
      NewLayerStructure.LayerGroups[GroupIndex].AquiferName :=
        'Layer ' + IntToStr(GroupIndex);
      if LAYCBD[LayerIndex] <> 0 then
      begin
        Inc(GroupIndex);
        NewLayerStructure.LayerGroups[GroupIndex].Simulated := False;
        NewLayerStructure.LayerGroups[GroupIndex].AquiferName :=
          'Confining Bed ' + IntToStr(GroupIndex);
      end;
      Inc(GroupIndex);
    end;
    FModel.LayerStructure.Assign(NewLayerStructure);
  finally
    NewLayerStructure.Free;
  end;
  for GroupIndex := 0 to FModel.LayerStructure.Count - 1 do
  begin
    DataArrayName := FModel.LayerStructure.LayerGroups[GroupIndex].
      DataArrayName;
    DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
    Assert(DataArray <> nil);
    if FConstantElevations[GroupIndex].IsConstant then
    begin
      DataArray.Formula := FortranFloatToStr(FConstantElevations[GroupIndex].
        RealValue);
    end
    else
    begin
      if ScreenObject = nil then
      begin
        CreateOrRetrieveCellCenterScreenObject(ScreenObject);
      end;
      AssignRealValuesToCellCenters(DataArray, ScreenObject,
        FElevations[GroupIndex]);
    end;
  end;
  FGrid.UpdateCellElevations;
end;

procedure TDisImporter.ImportStressPeriods;
var
  Delta: Double;
  NewPeriod: TModflowStressPeriod;
  ImportedSP: TImportedStressPeriod;
  StressPeriodIndex: Integer;
  StartTime: Double;
  Changed: Boolean;
begin
  FModel.ModflowStressPeriods.Clear;
  StartTime := 0;
  for StressPeriodIndex := 0 to Length(FStressPeriods) - 1 do
  begin
    ImportedSP := FStressPeriods[StressPeriodIndex];
    NewPeriod := FModel.ModflowStressPeriods.Add as TModflowStressPeriod;
    NewPeriod.StartTime := StartTime;
    NewPeriod.PeriodLength := ImportedSP.PERLEN;
    if (StressPeriodIndex = 0) and (ImportedSP.PERLEN = 0) then
    begin
      NewPeriod.StartTime := -1;
      NewPeriod.PeriodLength := 1;
    end;
    StartTime := StartTime + ImportedSP.PERLEN;
    NewPeriod.EndTime := StartTime;
    NewPeriod.TimeStepMultiplier := ImportedSP.TSMULT;
    if ImportedSP.ISSFLG = 0 then
    begin
      NewPeriod.StressPeriodType := sptTransient;
    end
    else
    begin
      NewPeriod.StressPeriodType := sptSteadyState;
    end;
    if ImportedSP.NSTP > 1 then
    begin
      if ImportedSP.TSMULT = 1 then
      begin
        NewPeriod.MaxLengthOfFirstTimeStep :=
          ImportedSP.PERLEN / ImportedSP.NSTP;
      end
      else
      begin
        NewPeriod.MaxLengthOfFirstTimeStep :=
          ImportedSP.PERLEN * (ImportedSP.TSMULT - 1)
          / (IntPower(ImportedSP.TSMULT, ImportedSP.NSTP) - 1);
      end;
    end
    else
    begin
      NewPeriod.MaxLengthOfFirstTimeStep := NewPeriod.PeriodLength;
    end;
    Changed := True;
    Delta := 0.01;
    while Changed do
    begin
      Changed := False;
      Delta := Delta / 10;
      while (NewPeriod.NumberOfSteps > ImportedSP.NSTP) do
      begin
        NewPeriod.MaxLengthOfFirstTimeStep :=
          NewPeriod.MaxLengthOfFirstTimeStep * (1 + Delta);
        Changed := True;
      end;
      while (NewPeriod.NumberOfSteps < ImportedSP.NSTP) do
      begin
        NewPeriod.MaxLengthOfFirstTimeStep :=
          NewPeriod.MaxLengthOfFirstTimeStep * (1 - Delta);
        Changed := True;
      end;
    end;
  end;
end;

procedure TDisImporter.ReadVariableBottomElev;
var
  LayerIndex: Integer;
  ALine: string;
  Layer: Integer;
  ArrayName: string;
begin
  ReadLn(FImporter.FFile, ALine);
  FImporter.UpdateProgress;
  ALine := Trim(ALine);
  ReadLn(FImporter.FFile, Layer);
  if ALine = 'MODEL LAYER BOTTOM EL.' then
  begin
    LayerIndex := GetLayerBottomIndex(Layer);
    ArrayName := Format('Bottom of layer %d', [LayerIndex]);
  end
  else if ALine = 'BOT. EL. OF QUASI-3D BED' then
  begin
    LayerIndex := GetConfiningBedBottomIndex(Layer);
    ArrayName := Format('Bottom of confining bed layer %d', [LayerIndex]);
  end
  else
  begin
    LayerIndex := -1;
    Assert(False);
  end;
  Read2DRealArray(FElevations[LayerIndex], ArrayName);
end;

procedure TDisImporter.ReadVariableTopElev;
var
  ALine: string;
begin
  ReadLn(FImporter.FFile, ALine);
  FImporter.UpdateProgress;
  ALine := Trim(ALine);
  if ALine = 'TOP ELEVATION OF LAYER 1' then
  begin
    Read2DRealArray(FElevations[0], kModelTop);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TDisImporter.ReleaseMemory;
begin
  SetLength(DELR, 0);
  SetLength(DELC, 0);
  SetLength(FElevations, 0, 0, 0);
  SetLength(FConstantElevations, 0);
  SetLength(FStressPeriods, 0);
end;

procedure TDisImporter.SetGridLimitsFromOutline;
var
  ImportParam: TImportParameters;
  RowIndex: Integer;
  Grid: TCustomModelGrid;
  ColIndex: Integer;
  APoint: TPoint2D;
  FoundFirst: Boolean;
begin
  ImportParam := FImporter.FImportParameters;
  if (ImportParam.Outline <> nil) then
  begin
    Grid := frmGoPhast.Grid;
    FoundFirst := False;
    for RowIndex := 1 to Grid.RowCount do
    begin
      for ColIndex := 1 to Grid.ColumnCount do
      begin
        APoint := Grid.TwoDElementCenter(ColIndex-1, RowIndex-1);
        if ImportParam.Outline.PointInside(APoint) then
        begin
          if not FoundFirst then
          begin
            FoundFirst:= True;
            ImportParam.FirstCol := ColIndex;
            ImportParam.LastCol := ColIndex;
            ImportParam.FirstRow := RowIndex;
            ImportParam.LastRow := RowIndex;
          end
          else
          begin
            if ColIndex < ImportParam.FirstCol then
            begin
              ImportParam.FirstCol := ColIndex
            end;
            if ColIndex > ImportParam.LastCol then
            begin
              ImportParam.LastCol := ColIndex
            end;
            if RowIndex < ImportParam.FirstRow then
            begin
              ImportParam.FirstRow := RowIndex
            end;
            if RowIndex > ImportParam.LastRow then
            begin
              ImportParam.LastRow := RowIndex
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TDisImporter.ReadConstantBottomElev;
var
  LayerIndex: Integer;
  ALine: string;
  Value: Double;
  Layer: Integer;
begin
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  ReadLn(FImporter.FFile, Layer);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  if ALine = 'MODEL LAYER BOTTOM EL.' then
  begin
    LayerIndex := GetLayerBottomIndex(Layer);
  end
  else if ALine = 'BOT. EL. OF QUASI-3D BED' then
  begin
    LayerIndex := GetConfiningBedBottomIndex(Layer);
  end
  else
  begin
    LayerIndex := -1;
    Assert(False);
  end;
  FConstantElevations[LayerIndex].IsConstant := True;
  FConstantElevations[LayerIndex].RealValue := Value;
end;

procedure TDisImporter.ReadConstantTopElev;
var
  Value: Double;
  ALine: string;
begin
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  if ALine = 'TOP ELEVATION OF LAYER 1' then
  begin
    FConstantElevations[0].IsConstant := True;
    FConstantElevations[0].RealValue := Value;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TDisImporter.CreateImportOutline;
var
  ImportParam: TImportParameters;
  Grid: TCustomModelGrid;
  Points: TRealPointArray;
  GridOutline: TGridOutline;
begin
  ImportParam := FImporter.FImportParameters;
  if (ImportParam.Outline = nil)
    and (ImportParam.FirstCol > 0)
    and (ImportParam.FirstRow > 0)
    and (ImportParam.LastCol > 0)
    and (ImportParam.LastRow > 0)
    then
  begin
    Assert(ImportParam.LastCol >= ImportParam.FirstCol);
    Assert(ImportParam.LastRow >= ImportParam.FirstRow);
    Grid := FModel.Grid;
    Assert(Grid <> nil);
    Assert(ImportParam.LastCol <= Grid.ColumnCount);
    Assert(ImportParam.LastRow <= Grid.RowCount);
    GridOutline := TGridOutline.Create;
    ImportParam.Outline := GridOutline;
    SetLength(Points, 5);
    Points[0] := Grid.TwoDElementCorner(ImportParam.FirstCol-1, ImportParam.FirstRow-1);
    Points[1] := Grid.TwoDElementCorner(ImportParam.FirstCol-1, ImportParam.LastRow);
    Points[2] := Grid.TwoDElementCorner(ImportParam.LastCol, ImportParam.LastRow);
    Points[3] := Grid.TwoDElementCorner(ImportParam.LastCol, ImportParam.FirstRow-1);
    Points[4] := Points[0];
    GridOutline.FPolygons.Add(TSubPolygon.Create(Points, 5, 0, 0));
  end;
end;

procedure TDisImporter.FixElevations;
const
  MaxCount = 10;
var
  LayerIndex: Integer;
  ModelMuseLayIndex: Integer;
  Changed: boolean;
  RowIndex: Integer;
  ColIndex: Integer;
  MinThickness: double;
  TopElev: Double;
  BotElev: Double;
  Thickness: Double;
  Count: Integer;
  procedure ConvertElevToVariable(ModelMuseLayIndex: integer);
  var
    RowIndex: integer;
    ColIndex: Integer;
  begin
    SetLength(FElevations[ModelMuseLayIndex], NROW, NCOL);
    for RowIndex := 0 to NROW - 1 do
    begin
      for ColIndex := 0 to NCOL - 1 do
      begin
        FElevations[ModelMuseLayIndex, RowIndex, ColIndex]
          := FConstantElevations[ModelMuseLayIndex].RealValue;
      end;
    end;
    FConstantElevations[ModelMuseLayIndex].IsConstant := False;
  end;
  procedure HandleLayerGoingUp(SimulatedLayer: boolean);
  var
    RowIndex: integer;
    ColIndex: Integer;
    TopElevation: Double;
    Active: Boolean;
    BottomElevation: Double;
    AboveActive: Boolean;
    AltLayerIndex: Integer;
    AltModelMuseLayIndex: Integer;
//    LIndex: integer;
  begin
    for RowIndex := 0 to NROW - 1 do
    begin
      for ColIndex := 0 to NCOL - 1 do
      begin
        if SimulatedLayer then
        begin
          if FBas.FConstantIbound[LayerIndex].IsConstant then
          begin
            Active := FBas.FConstantIbound[LayerIndex].IntegerValue <> 0;
          end
          else
          begin
            Active := FBas.FIbound[LayerIndex, RowIndex, ColIndex] <> 0;
          end;
        end
        else
        begin
          Active := False;
        end;
        if SimulatedLayer and ((LayerIndex = 0) or (LAYCBD[LayerIndex-1] <> 0)) then
        begin
          AboveActive := False;
        end
        else
        begin
          if SimulatedLayer then
          begin
            AltLayerIndex := LayerIndex-1;
          end
          else
          begin
            AltLayerIndex := LayerIndex;
          end;
          if FBas.FConstantIbound[AltLayerIndex].IsConstant then
          begin
            AboveActive := FBas.FConstantIbound[AltLayerIndex].IntegerValue <> 0;
          end
          else
          begin
            AboveActive := FBas.FIbound[AltLayerIndex, RowIndex, ColIndex] <> 0;
          end;
        end;

        if not Active and not AboveActive then
        begin
          if FConstantElevations[ModelMuseLayIndex].IsConstant then
          begin
            TopElevation := FConstantElevations[ModelMuseLayIndex].RealValue;
          end
          else
          begin
            TopElevation := FElevations[ModelMuseLayIndex, RowIndex, ColIndex];
          end;
          AltModelMuseLayIndex := ModelMuseLayIndex + 1;
          if FConstantElevations[AltModelMuseLayIndex].IsConstant then
          begin
            BottomElevation := FConstantElevations[AltModelMuseLayIndex].RealValue;
          end
          else
          begin
            BottomElevation := FElevations[AltModelMuseLayIndex, RowIndex, ColIndex];
          end;
          if TopElevation <= BottomElevation then
          begin
            Changed := True;
            TopElevation := BottomElevation + MinThickness;
            if FConstantElevations[ModelMuseLayIndex].IsConstant then
            begin
              ConvertElevToVariable(ModelMuseLayIndex);
            end;
            FElevations[ModelMuseLayIndex, RowIndex, ColIndex] := TopElevation;
//            for LIndex := ModelMuseLayIndex-1 downto 0 do
//            begin
//              TopElevation := FElevations[LIndex, RowIndex, ColIndex];
//              BottomElevation := FElevations[LIndex+1, RowIndex, ColIndex];
//              if TopElevation <= BottomElevation then
//              begin
//                TopElevation := BottomElevation + MinThickness;
//                if FConstantElevations[LIndex].IsConstant then
//                begin
//                  ConvertElevToVariable(LIndex);
//                end;
//                FElevations[LIndex, RowIndex, ColIndex] := TopElevation;
//              end
//              else
//              begin
//                break;
//              end;
//            end;
          end;
        end;
      end;
    end;
  end;
  procedure HandleLayerGoingDown(SimulatedLayer: boolean);
  var
    RowIndex: integer;
    ColIndex: Integer;
    TopElevation: Double;
    Active: Boolean;
    BottomElevation: Double;
    BelowActive: Boolean;
    AltModelMuseLayIndex: Integer;
//    LIndex: integer;
  begin
    for RowIndex := 0 to NROW - 1 do
    begin
      for ColIndex := 0 to NCOL - 1 do
      begin
        if SimulatedLayer then
        begin
          if FBas.FConstantIbound[LayerIndex].IsConstant then
          begin
            Active := FBas.FConstantIbound[LayerIndex].IntegerValue <> 0;
          end
          else
          begin
            Active := FBas.FIbound[LayerIndex, RowIndex, ColIndex] <> 0;
          end;
        end
        else
        begin
          Active := False;
        end;
        if SimulatedLayer and ((LayerIndex = NLAY-1) or (LAYCBD[LayerIndex] <> 0)) then
        begin
          BelowActive := False;
        end
        else
        begin
          if FBas.FConstantIbound[LayerIndex+1].IsConstant then
          begin
            BelowActive := FBas.FConstantIbound[LayerIndex+1].IntegerValue <> 0;
          end
          else
          begin
            BelowActive := FBas.FIbound[LayerIndex+1, RowIndex, ColIndex] <> 0;
          end;
        end;

        if not Active and not BelowActive then
        begin
          if FConstantElevations[ModelMuseLayIndex].IsConstant then
          begin
            BottomElevation := FConstantElevations[ModelMuseLayIndex].RealValue;
          end
          else
          begin
            BottomElevation := FElevations[ModelMuseLayIndex, RowIndex, ColIndex];
          end;
          AltModelMuseLayIndex := ModelMuseLayIndex - 1;
          if FConstantElevations[AltModelMuseLayIndex].IsConstant then
          begin
            TopElevation := FConstantElevations[AltModelMuseLayIndex].RealValue;
          end
          else
          begin
            TopElevation := FElevations[AltModelMuseLayIndex, RowIndex, ColIndex];
          end;
          if TopElevation <= BottomElevation then
          begin
            Changed := True;
            BottomElevation := TopElevation - MinThickness;
            if FConstantElevations[ModelMuseLayIndex].IsConstant then
            begin
              ConvertElevToVariable(ModelMuseLayIndex);
            end;
            FElevations[ModelMuseLayIndex, RowIndex, ColIndex] := BottomElevation;
          end;
        end;
      end;
    end;
  end;
begin
  Assert(FBas.FHasReadIBound);

  MinThickness := 0.0;
  for LayerIndex := 0 to Length(FConstantElevations) - 2 do
  begin
    for RowIndex := 0 to NROW - 1 do
    begin
      for ColIndex := 0 to NCOL - 1 do
      begin
        if FConstantElevations[LayerIndex].IsConstant then
        begin
          TopElev := FConstantElevations[LayerIndex].RealValue;
        end
        else
        begin
          TopElev := FElevations[LayerIndex, RowIndex, ColIndex];
        end;
        if FConstantElevations[LayerIndex+1].IsConstant then
        begin
          BotElev := FConstantElevations[LayerIndex+1].RealValue;
        end
        else
        begin
          BotElev := FElevations[LayerIndex+1, RowIndex, ColIndex];
        end;
        Thickness := TopElev - BotElev;
        if Thickness > 0 then
        begin
          if (MinThickness = 0) or (MinThickness > Thickness)  then
          begin
            MinThickness := Thickness
          end;
        end;
      end;
    end;
  end;
  MinThickness := MinThickness /Sqr(NLAY + 1);
  if MinThickness = 0 then
  begin
    MinThickness := 1;
  end;

  Count := 0;
  repeat
    Inc(Count);
    Changed := False;
    for LayerIndex := NLAY - 1 downto 0 do
    begin
      if LAYCBD[LayerIndex] <> 0 then
      begin
        ModelMuseLayIndex := GetConfiningBedBottomIndex(LayerIndex+1)-1;
        HandleLayerGoingUp(False);
      end;
      ModelMuseLayIndex := GetLayerBottomIndex(LayerIndex+1)-1;
      HandleLayerGoingUp(True);
    end;
    for LayerIndex := 0 to NLAY - 1 do
    begin
      ModelMuseLayIndex := GetLayerBottomIndex(LayerIndex+1);
      HandleLayerGoingDown(True);
      if LAYCBD[LayerIndex] <> 0 then
      begin
        ModelMuseLayIndex := GetConfiningBedBottomIndex(LayerIndex+1);
        HandleLayerGoingDown(False);
      end;
    end;
  until (not Changed) or (Count >= MaxCount);
  FHasFixedElevations := True;
end;

function TDisImporter.GetConfiningBedBottomIndex(Layer: Integer): integer;
var
  Index: Integer;
begin
  Assert((Layer >= 1) and (Layer <= NLAY));
  result := Layer;
  for Index := 0 to Layer - 1 do
  begin
    if LAYCBD[Index] <> 0 then
    begin
      Inc(result);
    end;
  end;
end;

function TDisImporter.GetConstLayerThickness(LayIndex: Integer): double;
begin
  result := FConstantLayerThicknesses[LayIndex].RealValue;
end;

function TDisImporter.GetIsConstLayerThickness(LayIndex: Integer): Boolean;
begin
  result := FConstantLayerThicknesses[LayIndex].IsConstant;
end;

function TDisImporter.GetLayerBottomIndex(Layer: Integer): integer;
var
  Index: Integer;
begin
  Assert((Layer >= 1) and (Layer <= NLAY));
  result := Layer;
  for Index := 0 to Layer - 2 do
  begin
    if LAYCBD[Index] <> 0 then
    begin
      Inc(result);
    end;
  end;
end;

procedure TDisImporter.GetLayerThicknesses;
var
  LayerIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  TopElevation: Double;
  BottomElevation: Double;
  ConstantThicknesses: Double;
  IsConstant: Boolean;
begin
  SetLength(FLayerThicknesses, NBOTM-1);
  SetLength(FConstantLayerThicknesses, NBOTM-1);
  for LayerIndex  := 0 to NBOTM - 2 do
  begin
    if (FConstantElevations[LayerIndex].IsConstant)
      and (FConstantElevations[LayerIndex+1].IsConstant) then
    begin
      FConstantLayerThicknesses[LayerIndex].IsConstant := True;
      FConstantLayerThicknesses[LayerIndex].RealValue :=
        FConstantElevations[LayerIndex].RealValue -
        FConstantElevations[LayerIndex+1].RealValue;
    end
    else
    begin
      FConstantLayerThicknesses[LayerIndex].IsConstant := False;
      SetLength(FLayerThicknesses[LayerIndex], NROW, NCOL);
      for RowIndex := 0 to NROW - 1 do
      begin
        for ColIndex := 0 to NCOL - 1 do
        begin
          if FConstantElevations[LayerIndex].IsConstant then
          begin
            TopElevation := FConstantElevations[LayerIndex].RealValue
          end
          else
          begin
            TopElevation := FElevations[LayerIndex, RowIndex, ColIndex];
          end;
          if FConstantElevations[LayerIndex+1].IsConstant then
          begin
            BottomElevation := FConstantElevations[LayerIndex+1].RealValue
          end
          else
          begin
            BottomElevation := FElevations[LayerIndex+1, RowIndex, ColIndex];
          end;
          FLayerThicknesses[LayerIndex, RowIndex, ColIndex] :=
            TopElevation - BottomElevation;
        end;
      end;
      ConstantThicknesses := FLayerThicknesses[LayerIndex, 0, 0];
      IsConstant := True;
      for RowIndex := 0 to NROW - 1 do
      begin
        for ColIndex := 0 to NCOL - 1 do
        begin
          if ConstantThicknesses <> FLayerThicknesses[LayerIndex, RowIndex, ColIndex] then
          begin
            IsConstant := False;
            break;
          end;
        end;
        if not IsConstant then
        begin
          break;
        end;
      end;
      if IsConstant then
      begin
        FConstantLayerThicknesses[LayerIndex].IsConstant := True;
        FConstantLayerThicknesses[LayerIndex].RealValue := ConstantThicknesses;
      end;
    end;
  end;
end;

function TDisImporter.GetVariableLayerThickness(LayIndex, RowIndex,
  ColIndex: Integer): double;
begin
  result := FLayerThicknesses[LayIndex, RowIndex, ColIndex];
end;

procedure TDisImporter.HandlePackage;
begin
  inherited;
  FModel.ModelSelection := msModflow;
  FModel.DataArrayManager.CreateInitialDataSets;

  FModel.ModflowOptions.Description.AddStrings(FComments);

  FGrid.GridAngle := FGridAngle;

  FModel.ModflowOptions.LengthUnit := LENUNI;
  FModel.ModflowOptions.TimeUnit := ITMUNI;

  ImportRowsAndColumns;
  SetGridLimitsFromOutline;
  ImportStressPeriods;
  ImportElevationsAndReleaseMemory;
  CreateImportOutline;
end;

procedure TDisImporter.ReadVariableDelrDelc;
var
  ALine: string;
begin
  ReadLn(FImporter.FFile, ALine);
  FImporter.UpdateProgress;
  ALine := Trim(ALine);
  if ALine = 'DELR' then
  begin
    Read1DRealArray(DELR);
  end
  else if ALine = 'DELC' then
  begin
    Read1DRealArray(DELC);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TDisImporter.ReadConstantDelrDelc;
var
  Value: Double;
  ALine: string;
begin
  ReadLn(FImporter.FFile, ALine);
  Read(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  if Trim(ALine) = 'DELR' then
  begin
    AssignConstant1DArray(DELR, Value);
  end
  else if Trim(ALine) = 'DELC' then
  begin
    AssignConstant1DArray(DELC, Value);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TDisImporter.ReadDataSet2;
var
  Index: Integer;
begin
  Assert(Length(LAYCBD) = NLAY);
  for Index := 0 to NLAY - 1 do
  begin
    Read(FImporter.FFile, LAYCBD[Index]);
  end;
  NBOTM := NLAY + 1;
  for Index := 0 to NLAY - 1 do
  begin
    if LAYCBD[Index] <> 0 then
    begin
      Inc(NBOTM);
    end;
  end;
  SetLength(FElevations, NBOTM, NROW, NCOL);
  SetLength(FConstantElevations, NBOTM);
  for Index := 0 to NBOTM - 1 do
  begin
    FConstantElevations[Index].IsConstant := False;
  end;
end;

procedure TDisImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, NLAY);
  Read(FImporter.FFile, NROW);
  Read(FImporter.FFile, NCOL);
  Read(FImporter.FFile, NPER);
  Read(FImporter.FFile, ITMUNI);
  Read(FImporter.FFile, LENUNI);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(LAYCBD, NLAY);
  SetLength(DELR, NCOL);
  SetLength(DELC, NROW);
  SetLength(FStressPeriods, NPER);
end;

procedure TDisImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'NLAY, NROW, NCOL, NPER, ITMUNI, LENUNI:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'LAYCBD(K):' then
  begin
    ReadDataSet2;
  end
  else if ALabel = StrConstant1DRealArray then
  begin
    ReadConstantDelrDelc;
  end
  else if ALabel = StrVariable1DRealArray then
  begin
    ReadVariableDelrDelc;
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadConstantTopElev;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstantBottomElev;
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    ReadVariableTopElev;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableBottomElev;
  end
  else if ALabel = StrVariable2DRealArrayForCrossSection then
  begin
    Assert(False);
  end
  else if ALabel = 'N,PERLEN(N),NSTP(N),TSMULT(N),ISSFLG(N):' then
  begin
    ReadStressPeriod;
  end
  else
  begin
    Assert(False);
  end
end;

procedure TPackageImporter.AssignConstant2DArray(Value: Double;
  Array2D: T2DDoubleArray);
var
  RowIndex: Integer;
  ColIndex: Integer;
begin
  for RowIndex := 0 to Length(Array2D)-1 do
  begin
    for ColIndex := 0 to Length(Array2D[RowIndex]) - 1 do
    begin
      Array2D[RowIndex, ColIndex] := Value;
    end;
  end;
end;

procedure TPackageImporter.AssignConstant2DIntArray(Value: integer;
  Array2D: T2DIntArray);
var
  RowIndex: Integer;
  ColIndex: Integer;
begin
  for RowIndex := 0 to Length(Array2D)-1 do
  begin
    for ColIndex := 0 to Length(Array2D[RowIndex]) - 1 do
    begin
      Array2D[RowIndex, ColIndex] := Value;
    end;
  end;
end;

procedure TPackageImporter.AssignImportedValues(ImportedValues: TValueArrayItem;
  ImportedData: TDoubleArray);
var
  Index: Integer;
begin
  ImportedValues.Values.DataType := rdtDouble;
  ImportedValues.Values.Count := Length(ImportedData);
  for Index := 0 to Length(ImportedData) - 1 do
  begin
    ImportedValues.Values.RealValues[Index] :=
      ImportedData[Index];
  end;
  ImportedValues.Values.CacheData;
end;

procedure TPackageImporter.AssignIntegerValuesToCellCenters(
  DataArray: TDataArray; ScreenObject: TScreenObject;
  ImportedData: T2DIntArray);
var
  PointIndex: Integer;
  ImportedValues: TValueArrayItem;
  DataSetIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Interpolator: TNearestPoint2DInterpolator;
  APoint: TPoint2D;
begin
  Assert(DataArray.Orientation = dsoTop);
  if DataArray.TwoDInterpolator = nil then
  begin
    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
  DataSetIndex := ScreenObject.AddDataSet(DataArray);
  ScreenObject.DataSetFormulas[DataSetIndex] := rsObjectImportedValuesI;
  ScreenObject.ImportedValues.Add;
  ImportedValues := ScreenObject.ImportedValues.Items[
    ScreenObject.ImportedValues.Count-1];
  ImportedValues.Values.DataType := rdtInteger;
  ImportedValues.Values.Count := FGrid.RowCount * FGrid.ColumnCount;
  ImportedValues.Name := DataArray.Name;
  PointIndex := 0;
  for RowIndex := 0 to FGrid.RowCount - 1 do
  begin
    for ColIndex := 0 to FGrid.ColumnCount - 1 do
    begin
      APoint := FImporter.CenterPoints[RowIndex, ColIndex];
      if (FImporter.FImportParameters.Outline = nil)
        or FImporter.FImportParameters.Outline.PointInside(APoint) then
      begin
        ImportedValues.Values.IntValues[PointIndex] :=
          ImportedData[RowIndex, ColIndex];
        Inc(PointIndex);
      end;
    end;
  end;
  ImportedValues.Values.Count := PointIndex;
  ImportedValues.Values.CacheData;
end;

procedure TPackageImporter.AssignBooleanValuesToCellCenters(
  DataArray: TDataArray; ScreenObject: TScreenObject;
  ImportedData: T2DIntArray);
var
  PointIndex: Integer;
  ImportedValues: TValueArrayItem;
  DataSetIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Interpolator: TNearestPoint2DInterpolator;
  APoint: TPoint2D;
begin
  Assert(DataArray.Orientation = dsoTop);
  if DataArray.TwoDInterpolator = nil then
  begin
    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
  DataSetIndex := ScreenObject.AddDataSet(DataArray);
  ScreenObject.DataSetFormulas[DataSetIndex] := rsObjectImportedValuesB
    + '("' + DataArray.Name + '")';
  ScreenObject.ImportedValues.Add;
  ImportedValues := ScreenObject.ImportedValues.Items[
    ScreenObject.ImportedValues.Count-1];
  ImportedValues.Values.DataType := rdtBoolean;
  ImportedValues.Values.Count := FGrid.RowCount * FGrid.ColumnCount;
  ImportedValues.Name := DataArray.Name;
  PointIndex := 0;
  for RowIndex := 0 to FGrid.RowCount - 1 do
  begin
    for ColIndex := 0 to FGrid.ColumnCount - 1 do
    begin
      APoint := FImporter.CenterPoints[RowIndex, ColIndex];
      if (FImporter.FImportParameters.Outline = nil)
        or FImporter.FImportParameters.Outline.PointInside(APoint) then
      begin
        ImportedValues.Values.BooleanValues[PointIndex] :=
          ImportedData[RowIndex, ColIndex] <> 0;
        Inc(PointIndex);
      end;
    end;
  end;
  ImportedValues.Values.Count := PointIndex;
  ImportedValues.Values.CacheData;
end;

procedure TPackageImporter.AssignConstant1DArray(AnArray: TOneDRealArray;
  Value: Double);
var
  Index: Integer;
begin
  for Index := 0 to Length(AnArray) - 1 do
  begin
    AnArray[Index] := Value;
  end;
end;

{ TBasImporter }

constructor TBasImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'BAS:');
  SetLength(FInitialCHDLocations, 0, 0, 0);
  FSpecifiedHeadsList := TObjectList.Create;
end;

procedure TBasImporter.ReadConstantIboundForLayer;
var
  ColIndex: Integer;
  RowIndex: Integer;
  IntegerConstant: Integer;
  Layer: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = BoundaryArray);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  ReadLn(FImporter.FFile, IntegerConstant);
  for RowIndex := 0 to Length(FIbound[Layer]) - 1 do
  begin
    for ColIndex := 0 to Length(FIbound[Layer, RowIndex]) - 1 do
    begin
      FIbound[Layer, RowIndex, ColIndex] := IntegerConstant;
    end;
  end;
  FConstantIbound[Layer].IsConstant := True;
  FConstantIbound[Layer].IntegerValue := IntegerConstant;
  FImporter.UpdateProgress;
  FHasReadIBound := True;
end;

procedure TBasImporter.ReadConstantIboundForCrossSection;
var
  ColIndex: Integer;
  LayerIndex: Integer;
  IntegerConstant: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = BoundaryArray);
  ReadLn(FImporter.FFile, IntegerConstant);
  Assert(FCrossSection);
  for LayerIndex := 0 to Length(FIbound) - 1 do
  begin
    Assert(Length(FIbound[LayerIndex]) = 1);
    for ColIndex := 0 to Length(FIbound[LayerIndex, 0]) - 1 do
    begin
      FIbound[LayerIndex, 0, ColIndex] := IntegerConstant;
      FConstantIbound[LayerIndex].IsConstant := True;
      FConstantIbound[LayerIndex].IntegerValue := IntegerConstant;
    end;
  end;
  FImporter.UpdateProgress;
  FHasReadIBound := True;
end;

procedure TBasImporter.ReadVariableIboundForLayer;
var
  Layer: Integer;
  ID: string;
  IntArray: T2DIntArray;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = BoundaryArray);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  IntArray := FIbound[Layer];
  ReadVariable2DIntArray(IntArray);
  FHasReadIBound := True;
end;

procedure TBasImporter.ReadVariableIboundForCrossSection;
var
  ColIndex: Integer;
  LayerIndex: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = BoundaryArray);
  Assert(FCrossSection);
  for LayerIndex := 0 to Length(FIbound) - 1 do
  begin
    Assert(Length(FIbound[LayerIndex]) = 1);
    for ColIndex := 0 to Length(FIbound[LayerIndex, 0]) - 1 do
    begin
      Read(FImporter.FFile, FIbound[LayerIndex, 0, ColIndex]);
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
  FHasReadIBound := True;
end;

procedure TBasImporter.ReadConstantInitialHeadForCrossSection;
var
  ID: string;
  Value: Double;
  LayerIndex: Integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  Assert(ID = StrInitialHead);
  Assert(FCrossSection);
  for LayerIndex := 0 to Length(FStrt) - 1 do
  begin
    Assert(Length(FStrt[0]) = 1);
    AssignConstant2DArray(Value, FStrt[LayerIndex]);
    FConstantStrt[LayerIndex].IsConstant := True;
    FConstantStrt[LayerIndex].RealValue := Value;
  end;
end;

procedure TBasImporter.ReadConstantInitialHeadForLayer;
var
  Value: Double;
  LayerIndex: Integer;
  ID: string;
  Layer: Integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Readln(FImporter.FFile, Value);
  Assert(ID = StrInitialHead);
  LayerIndex := Layer - 1;
  AssignConstant2DArray(Value, FStrt[LayerIndex]);
  FConstantStrt[LayerIndex].IsConstant := True;
  FConstantStrt[LayerIndex].RealValue := Value;
  FImporter.UpdateProgress;
end;

procedure TBasImporter.ReadVariableInitialHeadForCrossSection;
var
  ID: string;
  LayerIndex: Integer;
  ColIndex: Integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Assert(ID = StrInitialHead);
  Assert(FCrossSection);
  for LayerIndex := 0 to Length(FStrt) - 1 do
  begin
    Assert(Length(FStrt[LayerIndex]) = 1);
    for ColIndex := 0 to Length(FStrt[LayerIndex, 0]) - 1 do
    begin
      Read(FImporter.FFile, FStrt[LayerIndex, 0, ColIndex]);
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
end;

procedure TBasImporter.ReadVariableInitialHeadForLayer;
var
  ID: string;
  Layer: Integer;
  LayerIndex: Integer;
  ArrayName: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Assert(ID = StrInitialHead);
  LayerIndex := Layer - 1;
  ArrayName := Format('Initial Head for layer %d', [Layer]);
  Read2DRealArray(FStrt[LayerIndex], ArrayName);
end;

procedure TBasImporter.ReleaseMemory;
begin
  inherited;
  SetLength(FIbound, 0, 0, 0);
  SetLength(FConstantIbound, 0);
  SetLength(FStrt, 0, 0, 0);
  SetLength(FConstantStrt, 0);
end;

function TBasImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Specified_Head_';
end;

procedure TBasImporter.ReadDataSet1;
var
  IPRTIM: Integer;
//  IFREFM: Integer;
  ICHFLG: Integer;
  IXSEC: Integer;
begin
  Read(FImporter.FFile, IXSEC);
  Read(FImporter.FFile, ICHFLG);
  // IFREFM is not used but you need to read it to get to IPRTIM.
  Read(FImporter.FFile, DummyInteger); // IFREFM
  Read(FImporter.FFile, IPRTIM);
  Read(FImporter.FFile, STOPER);

  FChtoch := (ICHFLG <> 0);
  FPrintTime := (IPRTIM <> 0);
  FCrossSection := (IXSEC <> 0);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TBasImporter.ReadHeading(var AHeading: string);
begin
  ReadLn(FImporter.FFile, AHeading);
  FImporter.UpdateProgress;
  AHeading := Trim(AHeading);
  if Length(AHeading) > 0 then
  begin
    Assert(AHeading[1] = '#');
    AHeading := Trim(Copy(AHeading, 2, MAXINT));
  end;
end;

procedure TBasImporter.ImportActiveCells;
var
  LayerIndex: Integer;
  Interpolator: TNearestPoint2DInterpolator;
  DataArray: TDataArray;
  DataArrayName: string;
  ScreenObject: TScreenObject;
  Group: TLayerGroup;
  GroupIndex: Integer;
  ActiveFormula: string;
  IsConstant: Boolean;
  ConstantValue: Integer;
  Index: Integer;

begin
  CheckVariableIntegerArrays(FConstantIbound, FIbound);
  ScreenObject := nil;
  IsConstant := True;
  ConstantValue := FConstantIbound[0].IntegerValue;
  for Index := 0 to Length(FConstantIbound) - 1 do
  begin
    IsConstant := FConstantIbound[Index].IsConstant
      and (FConstantIbound[Index].IntegerValue = ConstantValue);
    if not IsConstant then
    begin
      break;
    end;
  end;

  if IsConstant then
  begin
    DataArray := FModel.DataArrayManager.GetDataSetByName(rsActive);
    if ConstantValue = 0 then
    begin
      DataArray.Formula := 'False';
    end
    else
    begin
      DataArray.Formula := 'True';
    end;
  end
  else
  begin
    LayerIndex := -1;
    if FModel.LayerStructure.Count > 2 then
    begin
      ActiveFormula := 'CaseB(' + LayerString + ', ';
    end
    else
    begin
      ActiveFormula := '';
    end;
    for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
    begin
      Group := FModel.LayerStructure.LayerGroups[GroupIndex];
      if Group.RunTimeSimulated then
      begin
        Inc(LayerIndex);
        if FConstantIbound[LayerIndex].IsConstant then
        begin
          if FConstantIbound[LayerIndex].IntegerValue = 0 then
          begin
            ActiveFormula := ActiveFormula + 'False';
          end
          else
          begin
            ActiveFormula := ActiveFormula + 'True';
          end;
        end
        else
        begin
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          end;
          DataArrayName := 'Imported_Active_Layer_' + IntToStr(GroupIndex);
          DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
          if DataArray = nil then
          begin
            DataArray := FModel.DataArrayManager.CreateNewDataArray(TDataArray,
              DataArrayName, 'True', DataArrayName, [], rdtBoolean, eaBlocks, dsoTop, '');
            DataArray.Comment := Format(StrImportedFromExisti, [DateTimeToStr(Now)]);

            DataArray.UpdateDimensions(FGrid.LayerCount,
              FGrid.RowCount,FGrid.ColumnCount);

            Interpolator := TNearestPoint2DInterpolator.Create(nil);
            try
              DataArray.TwoDInterpolator := Interpolator;
            finally
              Interpolator.Free;
            end;
          end;
          AssignBooleanValuesToCellCenters(
            DataArray, ScreenObject, FIbound[LayerIndex]);
          ActiveFormula := ActiveFormula + DataArrayName;
        end;
      end
      else
      begin
        ActiveFormula := ActiveFormula + 'True';
      end;
      if GroupIndex < FModel.LayerStructure.Count - 1 then
      begin
        ActiveFormula := ActiveFormula + ', ';
      end;
    end;
    if FModel.LayerStructure.Count > 2 then
    begin
      ActiveFormula := ActiveFormula + ')';
    end;
    DataArray := FModel.DataArrayManager.GetDataSetByName(rsActive);
    DataArray.Formula := ActiveFormula;
  end;
end;

procedure TBasImporter.ImportSpecifiedHeads;
var
  Item: TChdItem;
  GroupIndex: Integer;
  ModelStartTime: Double;
  FirstPeriodlEndTime: Double;
  RowIndex: Integer;
  ColIndex: Integer;
  LayerIndex: Integer;
  Group: TLayerGroup;
  ScreenObject: TScreenObject;
  ObjectIndex: integer;
  Boundary: TChdLocationObject;
  InstanceCount: integer;
  SpecifiedHeadLocations: TDataArray;
  Position: Integer;
  List: TList;
  Storage: TBasChdObjects;
  ListIndex: Integer;
  InnerListIndex: Integer;
  AnotherBoundary: TChdLocationObject;
begin
  InstanceCount := 0;
//  SpecifiedHeadLocations := nil;

  // Only define CHD objects in first stress period.  The constant
  // head boundary will persist into later stress periods where it
  // may be overridden by objects in the CHD package.
  // If the CHD objects based on negative IBOUND are defined for
  // all stress periods, the specified heads might incorrectly include
  // the sum of specified heads initially defined in the CHD pacakge and
  // those defined in the BAS package.
  ModelStartTime := FModel.ModflowStressPeriods[0].StartTime;
  FirstPeriodlEndTime := FModel.ModflowStressPeriods[0].EndTime;
  LayerIndex := -1;
  ObjectIndex := 0;

  List := TList.Create;
  try
    for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
    begin
      Group := FModel.LayerStructure.LayerGroups[GroupIndex];
      if Group.RunTimeSimulated then
      begin
        List.Clear;
        Inc(LayerIndex);
        for RowIndex := 0 to FGrid.RowCount - 1 do
        begin
          for ColIndex := 0 to FGrid.ColumnCount - 1 do
          begin
            if (FIbound[LayerIndex, RowIndex, ColIndex] < 0)
              and ((FInitialCHDLocations = nil) or
              not FInitialCHDLocations[LayerIndex, RowIndex, ColIndex]) then
            begin
              Boundary:= TChdLocationObject.Create;
              List.Add(Boundary);
              Boundary.Layer := LayerIndex+1;
              Boundary.Row := RowIndex+1;
              Boundary.Column := ColIndex+1;
              Boundary.StartFactor := FStrt[LayerIndex, RowIndex, ColIndex];
              Boundary.EndFactor := Boundary.StartFactor;
            end;
          end;
        end;
        if List.Count > 0 then
        begin
          AssignObsGroupsToCells(List);

          if not FModel.ModflowPackages.ChdBoundary.IsSelected then
          begin
            FModel.ModflowPackages.ChdBoundary.IsSelected := True;
            FModel.DataArrayManager.CreateInitialDataSets;
          end;
          SpecifiedHeadLocations := FModel.DataArrayManager.GetDataSetByName(
            rsModflowSpecifiedHead);
          Assert(SpecifiedHeadLocations <> nil);

          for ListIndex := 0 to List.Count - 1 do
          begin
            Boundary := List[ListIndex];
            if Boundary.Used then
            begin
              Continue;
            end;
            Storage:= TBasChdObjects.Create;
            FSpecifiedHeadsList.Add(Storage);
            Storage.FList.Add(Boundary);
            Boundary.Used := True;
            for InnerListIndex := ListIndex + 1 to List.Count - 1 do
            begin
              AnotherBoundary := List[InnerListIndex];
              if Boundary.SameObservations(AnotherBoundary) then
              begin
                AnotherBoundary.Used := True;
                Storage.FList.Add(AnotherBoundary);
              end;
            end;

            ScreenObject := CreateScreenObject(Storage.FList, ObjectIndex,
              LayerIndex+1, -1, otPolygon);
            if ScreenObject <> nil then
            begin
              ScreenObject.CreateChdBoundary;
              Item := ScreenObject.ModflowChdBoundary.Values.Add as TChdItem;

              Inc(InstanceCount);
              SetItemValues(Item, Storage.FList, FirstPeriodlEndTime,
                ModelStartTime, ScreenObject, IntToStr(InstanceCount));

              Assert(SpecifiedHeadLocations <> nil);
              Position := ScreenObject.AddDataSet(SpecifiedHeadLocations);
              ScreenObject.DataSetFormulas[Position] := 'True';
              Storage.FScreenObject := ScreenObject;
            end;
          end;
        end;
      end;
    end;
  finally
    List.Free;
  end;
  ReleaseMemory;
end;

procedure TBasImporter.ImportInitialHead;
var
  DataArray: TDataArray;
  DataArrayName: string;
  Group: TLayerGroup;
  GroupIndex: Integer;
  InitialHeadFormula: string;
  LayerIndex: Integer;
  ScreenObject: TScreenObject;
  IsConstant: Boolean;
  ConstantValue: Double;
begin
  CheckVariableRealArrays(FConstantStrt, FStrt);
  ScreenObject := nil;
  CheckRealConstArray(ConstantValue, IsConstant, FConstantStrt);
  if IsConstant then
  begin
    DataArray := FModel.DataArrayManager.GetDataSetByName(rsModflow_Initial_Head);
    DataArray.Formula := FortranFloatToStr(ConstantValue);
  end
  else
  begin
    LayerIndex := -1;
    if FModel.LayerStructure.Count > 2 then
    begin
      InitialHeadFormula := 'CaseR(' + LayerString + ', ';
    end
    else
    begin
      InitialHeadFormula := '';
    end;
    for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
    begin
      Group := FModel.LayerStructure.LayerGroups[GroupIndex];
      if Group.RunTimeSimulated then
      begin
        Inc(LayerIndex);
        if FConstantStrt[LayerIndex].IsConstant then
        begin
          InitialHeadFormula := InitialHeadFormula
            + FortranFloatToStr(FConstantStrt[LayerIndex].RealValue);
        end
        else
        begin
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
//            ScreenObject.Name := 'Imported_Initial_Head_Object_'
//              + IntToStr(GroupIndex);
          end;
          DataArrayName := 'Imported_Initial_Head_Layer_'
            + IntToStr(GroupIndex);

          CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
            FStrt[LayerIndex]);

          InitialHeadFormula := InitialHeadFormula + DataArrayName;
        end;
      end
      else
      begin
        InitialHeadFormula := InitialHeadFormula + '0';
      end;
      if GroupIndex < FModel.LayerStructure.Count - 1 then
      begin
        InitialHeadFormula := InitialHeadFormula + ', ';
      end;
    end;
    if FModel.LayerStructure.Count > 2 then
    begin
      InitialHeadFormula := InitialHeadFormula + ')';
    end;
    DataArray := FModel.DataArrayManager.GetDataSetByName(rsModflow_Initial_Head);
    DataArray.Formula := InitialHeadFormula;
  end;
end;

destructor TBasImporter.Destroy;
begin
  FSpecifiedHeadsList.Free;
  inherited;
end;

procedure TBasImporter.HandlePackage;
begin
  inherited;
  if not FDis.FHasFixedElevations then
  begin
    FDis.ImportElevationsAndReleaseMemory;
  end;
  if FHeading2 <> '' then
  begin
    FModel.ModflowOptions.Description.Insert(0, FHeading2);
  end;
  if FHeading1 <> '' then
  begin
    FModel.ModflowOptions.Description.Insert(0, FHeading1);
  end;
  FModel.ModflowOptions.ComputeFluxesBetweenConstantHeadCells := FChtoch;
  FModel.ModflowOptions.PrintTime := FPrintTime;
  FModel.ModflowOptions.HNoFlow := FHNoFlo;
  FModel.ModflowOptions.StopError := (STOPER <> 0);
  FModel.ModflowOptions.StopErrorCriterion := STOPER;

  ImportInitialHead;
  ImportActiveCells;

  // Specified heads are imported by TChdObsImporter (even if the
  // the CHOB package is not used.
//  ImportSpecifiedHeads;

  FModel.DataArrayManager.CreateInitialDataSets;
end;

procedure TBasImporter.ReadData(const ALabel: string);
var
  NLAY: integer;
  NROW: Integer;
  NCOL: Integer;
  Index: Integer;
begin
  inherited;

  if (FIbound = nil) or (FStrt = nil) then
  begin
    NLAY := FDis.NLAY;
    NROW := FDis.NROW;
    NCOL := FDis.NCOL;
    if FIbound = nil then
    begin
      SetLength(FIbound, NLAY, NROW, NCOL);
      SetLength(FConstantIbound, NLAY);
      for Index := 0 to NLAY - 1 do
      begin
        FConstantIbound[Index].IsConstant := False;
      end;
    end;
    if FStrt = nil then
    begin
      SetLength(FStrt, NLAY, NROW, NCOL);
      SetLength(FConstantStrt, NLAY);
      for Index := 0 to NLAY - 1 do
      begin
        FConstantStrt[Index].IsConstant := False;
      end;
    end;
  end;

  if ALabel = StrHEADNG1 then
  begin
    ReadHeading(FHeading1);
  end
  else if ALabel = StrHEADNG2 then
  begin
    ReadHeading(FHeading2);
  end
  else if ALabel = StrIXSECICHFLGIFREF then
  begin
    ReadDataSet1;
  end
  else if ALabel = StrConstant2DIntegerArrayForLayer then
  begin
    ReadConstantIboundForLayer;
  end
  else if ALabel = StrConstant2DIntegerArray then
  begin
    ReadConstantIboundForCrossSection;
  end
  else if ALabel = StrVariable2DIntegerArrayForLayer then
  begin
    ReadVariableIboundForLayer;
  end
  else if ALabel = StrVariable2DIntegerArrayForCrossSection then
  begin
    ReadVariableIboundForCrossSection;
  end
  else if ALabel = StrHNOFLO then
  begin
    ReadLn(FImporter.FFile, FHNoFlo);
    FImporter.UpdateProgress;
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadConstantInitialHeadForCrossSection;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstantInitialHeadForLayer;
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    Assert(False);
//    ReadVariableInitialHeadForCrossSection;
 end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableInitialHeadForLayer;
  end
  else if ALabel = StrVariable2DRealArrayForCrossSection then
  begin
    ReadVariableInitialHeadForCrossSection;
//    Assert(False);
  end
  else
  begin
    Assert(False,
      'The following text was found when importing the Basic package: "'
      + ALabel + '".'
      + sLineBreak
      + 'One of the following was expected: '
      + '"' + StrHEADNG1 + '", '
      + '"' + StrHEADNG2 + '", '
      + '"' + StrIXSECICHFLGIFREF + '", '
      + '"' + StrConstant2DIntegerArrayForLayer + '", '
      + '"' + StrConstant2DIntegerArray + '", '
      + '"' + StrVariable2DIntegerArrayForLayer + '", '
      + '"' + StrVariable2DIntegerArrayForCrossSection + '", '
      + '"' + StrHNOFLO + '", '
      + '"' + StrConstant2DRealArray + '", '
      + '"' + StrConstant2DRealArrayForLayer + '", '
      + '"' + StrVariable2DRealArray + '", '
      + '"' + StrVariable2DRealArrayForLayer + '", '
      + '"' + StrVariable2DRealArrayForCrossSection + '".');
  end;
end;

procedure TPackageImporter.CreateOrRetrieveCellCenterScreenObject(
  var ScreenObject: TScreenObject);
var
  UndoCreateScreenObject: TCustomUndo;
  RowIndex: Integer;
  ColIndex: Integer;
  APoint: TPoint2D;
  UpdateOutline: Boolean;
  FoundFirst: Boolean;
begin
  if GlobalCellCenterScreenObject = nil then
  begin
    GlobalCellCenterScreenObject := TScreenObject.CreateWithViewDirection(
      FModel, vdTop, UndoCreateScreenObject, False);
    GlobalCellCenterScreenObject.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);

    FModel.AddScreenObject(GlobalCellCenterScreenObject);
    GlobalCellCenterScreenObject.ElevationCount := ecZero;
    if FImporter.FImportParameters.AssignmentMethod = camInterpolate then
    begin
      GlobalCellCenterScreenObject.SetValuesByInterpolation := True;
    end
    else
    begin
      GlobalCellCenterScreenObject.SetValuesOfIntersectedCells := True;
    end;
    GlobalCellCenterScreenObject.EvaluatedAt := eaBlocks;
    GlobalCellCenterScreenObject.Visible := False;
    GlobalCellCenterScreenObject.Capacity := FGrid.RowCount * FGrid.ColumnCount;
    UpdateOutline := (FImporter.FImportParameters.Outline <> nil)
      and (FImporter.FImportParameters.FirstCol = 0)
      and (FImporter.FImportParameters.LastCol = 0)
      and (FImporter.FImportParameters.FirstRow = 0)
      and (FImporter.FImportParameters.LastRow = 0);
    FoundFirst := False;
    for RowIndex := 0 to FGrid.RowCount - 1 do
    begin
      for ColIndex := 0 to FGrid.ColumnCount - 1 do
      begin
        APoint := FImporter.CenterPoints[RowIndex, ColIndex];

        if (FImporter.FImportParameters.Outline = nil)
          or FImporter.FImportParameters.Outline.PointInside(APoint) then
        begin
          GlobalCellCenterScreenObject.AddPoint(APoint, True);
          if UpdateOutline then
          begin
            if FoundFirst then
            begin
              if FImporter.FImportParameters.FirstCol > ColIndex + 1 then
              begin
                FImporter.FImportParameters.FirstCol := ColIndex + 1;
              end;
              if FImporter.FImportParameters.LastCol < ColIndex + 1 then
              begin
                FImporter.FImportParameters.LastCol := ColIndex + 1;
              end;
              if FImporter.FImportParameters.FirstRow > RowIndex + 1 then
              begin
                FImporter.FImportParameters.FirstRow := RowIndex + 1;
              end;
              if FImporter.FImportParameters.LastRow < RowIndex + 1 then
              begin
                FImporter.FImportParameters.LastRow := RowIndex + 1;
              end;
            end
            else
            begin
              FoundFirst := True;
              FImporter.FImportParameters.FirstCol := ColIndex + 1;
              FImporter.FImportParameters.LastCol := ColIndex + 1;
              FImporter.FImportParameters.FirstRow := RowIndex + 1;
              FImporter.FImportParameters.LastRow := RowIndex + 1;
            end;
          end;
        end;
      end;
    end;
    GlobalCellCenterScreenObject.Name := 'Imported_Arrays';
    GlobalCellCenterScreenObject.SectionStarts.CacheData;
  end;
  ScreenObject := GlobalCellCenterScreenObject;
end;

procedure TPackageImporter.AssignRealValuesToCellCenters(DataArray: TDataArray;
  ScreenObject: TScreenObject; ImportedData: T2DDoubleArray);
var
  PointIndex: Integer;
  ImportedValues: TValueArrayItem;
  DataSetIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Interpolator: TNearestPoint2DInterpolator;
  APoint: TPoint2D;
begin
  Assert(DataArray.Orientation = dsoTop);
  if DataArray.TwoDInterpolator = nil then
  begin
    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
  DataSetIndex := ScreenObject.AddDataSet(DataArray);
  ScreenObject.DataSetFormulas[DataSetIndex] := rsObjectImportedValuesR
    + '("' + DataArray.Name + '")';
  ScreenObject.ImportedValues.Add;
  ImportedValues := ScreenObject.ImportedValues.Items[
    ScreenObject.ImportedValues.Count-1];
  ImportedValues.Values.DataType := rdtDouble;
  ImportedValues.Values.Count := FGrid.RowCount * FGrid.ColumnCount;
  ImportedValues.Name := DataArray.Name;
  PointIndex := 0;
  for RowIndex := 0 to FGrid.RowCount - 1 do
  begin
    for ColIndex := 0 to FGrid.ColumnCount - 1 do
    begin
      APoint := FImporter.CenterPoints[RowIndex, ColIndex];
      if (FImporter.FImportParameters.Outline = nil)
        or FImporter.FImportParameters.Outline.PointInside(APoint) then
      begin
        ImportedValues.Values.RealValues[PointIndex] :=
          ImportedData[RowIndex, ColIndex];
        Inc(PointIndex);
      end;
    end;
  end;
  ImportedValues.Values.Count := PointIndex;
  ImportedValues.Values.CacheData;
end;

{ TMultZoneImporter }

function TMultZoneImporter.ConstantZone(Index: integer;
  out ZoneValue: integer): boolean;
begin
  ZoneValue := 0;
  result := Length(FConstantZoneArrays) > 0;
  if result then
  begin
    result := FConstantZoneArrays[Index].IsConstant;
    ZoneValue := FConstantZoneArrays[Index].IntegerValue;
  end;
end;

constructor TMultZoneImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'ZONE_MULT:');
  FModel := frmGoPhast.PhastModel;
  FGrid := FModel.ModflowGrid;
  FZoneNames := TStringList.Create;
  FMultNames := TStringList.Create;
  FZoneNames.CaseSensitive := False;
end;

destructor TMultZoneImporter.Destroy;
begin
  FMultNames.Free;
  FZoneNames.Free;
  inherited;
end;

procedure TMultZoneImporter.ImportZones;
var
  ZoneIndex: Integer;
  DataArrayName: string;
  DataArray: TDataArray;
  ScreenObject: TScreenObject;
begin
  ScreenObject := nil;
  Assert(FZoneNames.Count = Length(FZoneArrays));
  Assert(FZoneNames.Count = Length(FConstantZoneArrays));
  for ZoneIndex := 0 to FZoneNames.Count - 1 do
  begin
    DataArrayName := FixArrayName(FZoneNames[ZoneIndex]);
    DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
    if DataArray = nil then
    begin
      DataArray := FModel.DataArrayManager.CreateNewDataArray(TDataArray,
        DataArrayName, '0', DataArrayName, [dcType], rdtInteger, eaBlocks, dsoTop, '');
      DataArray.Comment := Format(StrImportedFromExisti, [DateTimeToStr(Now)]);

      DataArray.UpdateDimensions(FGrid.LayerCount,
        FGrid.RowCount, FGrid.ColumnCount);
    end;
    if FConstantZoneArrays[ZoneIndex].IsConstant then
    begin
      DataArray.Formula := IntToStr(
        FConstantZoneArrays[ZoneIndex].IntegerValue);
    end
    else
    begin
      DataArray.Formula := '0';
      if ScreenObject = nil then
      begin
        CreateOrRetrieveCellCenterScreenObject(ScreenObject);
      end;
      AssignIntegerValuesToCellCenters(DataArray, ScreenObject,
        FZoneArrays[ZoneIndex]);
      // zone arrays are used when importing parameters.
//      FZoneArrays[ZoneIndex] := nil;
    end;
  end;
end;

function TMultZoneImporter.IndexOfZone(Name: string): integer;
begin
  result := FZoneNames.IndexOf(Name);
end;

procedure TMultZoneImporter.ImportMultipliers;
var
  MultIndex: Integer;
  DataArrayName: string;
  DataArray: TDataArray;
  ScreenObject: TScreenObject;
begin
  ScreenObject := nil;
  Assert(FMultNames.Count = Length(FMultArrays));
  Assert(FMultNames.Count = Length(FConstantMultArrays));
  for MultIndex := 0 to FMultNames.Count - 1 do
  begin
    DataArrayName := FixArrayName(FMultNames[MultIndex]);
    DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
    if DataArray = nil then
    begin
      DataArray := FModel.DataArrayManager.CreateNewDataArray(TDataArray,
        DataArrayName, '0', DataArrayName,
        [dcType], rdtDouble, eaBlocks, dsoTop, '');
      DataArray.Comment := Format(StrImportedFromExisti, [DateTimeToStr(Now)]);

      DataArray.UpdateDimensions(FGrid.LayerCount,
        FGrid.RowCount, FGrid.ColumnCount);
    end;
    if FConstantMultArrays[MultIndex].IsConstant then
    begin
      DataArray.Formula := FortranFloatToStr(FConstantMultArrays[MultIndex].RealValue);
    end
    else
    begin
      DataArray.Formula := '0';
      if ScreenObject = nil then
      begin
        CreateOrRetrieveCellCenterScreenObject(ScreenObject);
      end;
      AssignRealValuesToCellCenters(DataArray, ScreenObject,
        FMultArrays[MultIndex]);
      FMultArrays[MultIndex] := nil;
    end;
  end;
end;

procedure TMultZoneImporter.HandlePackage;
begin
  inherited;
  ImportZones;
  ImportMultipliers;
//  ReleaseMemory;
end;

procedure TMultZoneImporter.ReadVariableZoneArray;
var
  IntArray: T2DIntArray;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  if (Pos(FCurrentZoneName, ID) > 0) and (Pos('ZONE ARRAY:', ID) > 0) then
  begin
    IntArray := FZoneArrays[FZoneNames.Count - 1];
    ReadVariable2DIntArray(IntArray);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TMultZoneImporter.ReadConstantZoneArray;
var
  Value: Integer;
  ALine: string;
begin
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  if (Pos(FCurrentZoneName, ALine) > 0)
    and (Pos('ZONE ARRAY:', ALine) > 0) then
  begin
    FConstantZoneArrays[FZoneNames.Count - 1].IsConstant := True;
    FConstantZoneArrays[FZoneNames.Count - 1].IntegerValue := Value;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TMultZoneImporter.ReadZoneName;
var
  NZ: Integer;
  ZONNAM: string;
begin
  Readln(FImporter.FFile, NZ);
  Readln(FImporter.FFile, ZONNAM);
  Dec(NZ);
  Assert(NZ = FZoneNames.Count);
  ZONNAM := Trim(ZONNAM);
  FCurrentZoneName := ZONNAM;
  ZONNAM := FixArrayName(ZONNAM);
  FZoneNames.Add(ZONNAM);
  FImporter.UpdateProgress;
end;

//procedure TMultZoneImporter.ReleaseMemory;
//begin
//  SetLength(FZoneArrays, 0, 0, 0);
//  SetLength(FConstantZoneArrays, 0);
//  SetLength(FMultArrays, 0, 0, 0);
//  SetLength(FConstantMultArrays, 0);
//end;

function TMultZoneImporter.ZoneArray(Index: integer): T2DIntArray;
begin
  result := FZoneArrays[Index];
end;

procedure TMultZoneImporter.ReadMultiplierDefinedByFunction;
begin
  Read2DRealArray(FMultArrays[FMultNames.Count - 1],
    'Multiplier array ' + FCurrentMultName);
end;

procedure TMultZoneImporter.ReadVariableMultiplier;
var
  ALine: string;
begin
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  if (Pos(FCurrentMultName, ALine) > 0)
    and (Pos('MULT. ARRAY:', ALine) > 0) then
  begin
    Read2DRealArray(FMultArrays[FMultNames.Count - 1],
      'Multiplier array ' + FCurrentMultName);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TMultZoneImporter.ReadConstantMultiplier;
var
  ALine: string;
  Value: Double;
begin
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  if (Pos(FCurrentMultName, ALine) > 0)
    and (Pos('MULT. ARRAY:', ALine) > 0) then
  begin
    FConstantMultArrays[FMultNames.Count - 1].IsConstant := True;
    FConstantMultArrays[FMultNames.Count - 1].RealValue := Value;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TMultZoneImporter.ReadMultiplierName;
var
  M: Integer;
  MLTNAM: string;
begin
  Readln(FImporter.FFile, M);
  Readln(FImporter.FFile, MLTNAM);
  FImporter.UpdateProgress;
  Dec(M);
  Assert(M = FMultNames.Count);
  MLTNAM := Trim(MLTNAM);
  FCurrentMultName := MLTNAM;
  MLTNAM := FixArrayName(MLTNAM);
  FMultNames.Add(MLTNAM);
end;

procedure TMultZoneImporter.ReadNumberOfMultipliers;
var
  NMLTAR: Integer;
begin
  ReadLn(FImporter.FFile, NMLTAR);
  FImporter.UpdateProgress;
  SetLength(FMultArrays, NMLTAR, FGrid.RowCount, FGrid.ColumnCount);
  SetLength(FConstantMultArrays, NMLTAR);
  FMultNames.Capacity := NMLTAR;
end;

procedure TMultZoneImporter.ReadNumberOfZones;
var
  NZONAR: Integer;
begin
  ReadLn(FImporter.FFile, NZONAR);
  FImporter.UpdateProgress;
  SetLength(FZoneArrays, NZONAR, FGrid.RowCount, FGrid.ColumnCount);
  SetLength(FConstantZoneArrays, NZONAR);
  FZoneNames.Capacity := NZONAR;
end;

procedure TMultZoneImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'NZONAR:' then
  begin
    ReadNumberOfZones;
  end
  else if ALabel = 'NMLTAR:' then
  begin
    ReadNumberOfMultipliers;
  end
  else if ALabel = 'M, MLTNAM(M):' then
  begin
    ReadMultiplierName;
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadConstantMultiplier;
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    ReadVariableMultiplier;
  end
  else if ALabel = 'DEFINED BY FUNCTION:' then
  begin
    ReadMultiplierDefinedByFunction;
  end
  else if ALabel = 'NZ, ZONNAM(NZ):' then
  begin
    ReadZoneName;
  end
  else if ALabel = StrConstant2DIntegerArray then
  begin
    ReadConstantZoneArray;
  end
  else if ALabel = StrVariable2DIntegerArray then
  begin
    ReadVariableZoneArray;
  end
  else
  begin
//    raise Exception.Create(ALabel);
    Assert(False);
  end;
end;

procedure TPackageImporter.ReadVariable2DIntArray(IntArray: T2DIntArray);
var
  ColIndex: Integer;
  RowIndex: Integer;
begin
  for RowIndex := 0 to Length(IntArray) - 1 do
  begin
    for ColIndex := 0 to Length(IntArray[RowIndex]) - 1 do
    begin
      Read(FImporter.FFile, IntArray[RowIndex, ColIndex]);
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
end;

function TPackageImporter.UniformArray(ImportedData: TDoubleArray): boolean;
var
  AValue: Double;
  Index: Integer;
begin
  result := True;
  AValue := ImportedData[0];
  for Index := 1 to Length(ImportedData) - 1 do
  begin
    if AValue <> ImportedData[Index] then
    begin
      result := False;
      Exit;
    end;
  end;
end;

{ TLpfImporter }

constructor TCustomFlowPackageImporter.Create(Importer: TModflow2005Importer;
  Bas: TBasImporter);
begin
  inherited Create(Importer, PackageLabel);
  FBas := Bas;
  FIsSelected := False;
  FNextParameterIndex := -1;
end;

procedure TArrayImporter.Import2DDataSet(const ImportName,
  ImportArrayName: string; const TwoDConstRecord: TRealConstantRecord;
  const TwoDRealArray: T2DDoubleArray; const LayerFormulaSuffix: string = '');
var
  DataArrayName: string;
  ScreenObject: TScreenObject;
  DataSetFormula: string;
  DataArray: TDataArray;
begin
  ScreenObject := nil;
  DataArray := FModel.DataArrayManager.GetDataSetByName(ImportArrayName);
  if TwoDConstRecord.IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(TwoDConstRecord.RealValue);
  end
  else
  begin
    Assert(TwoDRealArray <> nil);
    CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    DataArrayName := 'Imported_' + ImportName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
      TwoDRealArray);
    if LayerFormulaSuffix <> '' then
    begin
      DataSetFormula := DataSetFormula + '(';
    end;
    DataSetFormula := DataSetFormula + DataArrayName;
    if LayerFormulaSuffix <> '' then
    begin
      DataSetFormula := DataSetFormula + LayerFormulaSuffix + ')';
    end;
    DataArray.Formula := DataSetFormula;
  end;
end;

procedure TArrayImporter.ImportDataSet(ImportName: string;
  ImportArrayName: string; var ThreeDConstRealArray: TRealConstantRecordArray;
  const ThreeDRealArray: T3DDoubleArray; const LayerFormulaSuffix: string = '');
var
  DataArrayName: string;
  ScreenObject: TScreenObject;
  Group: TLayerGroup;
  GroupIndex: Integer;
  DataSetFormula: string;
  LayerIndex: Integer;
  DataArray: TDataArray;
  IsConstant: Boolean;
  ConstantValue: Double;
begin
  CheckVariableRealArrays(ThreeDConstRealArray, ThreeDRealArray);
  ScreenObject := nil;
  if (ThreeDRealArray <> nil) or (ThreeDConstRealArray <> nil) then
  begin
    CheckRealConstArray(ConstantValue, IsConstant, ThreeDConstRealArray);
    if IsConstant then
    begin
      DataArray := FModel.DataArrayManager.GetDataSetByName(ImportArrayName);
      Assert(DataArray <> nil);
      DataArray.Formula := FortranFloatToStr(ConstantValue);
    end
    else
    begin
      LayerIndex := -1;
      if FModel.LayerStructure.Count > 2 then
      begin
        DataSetFormula := 'CaseR(' + LayerString + ', ';
      end
      else
      begin
        DataSetFormula := '';
      end;
      for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
      begin
        Group := FModel.LayerStructure.LayerGroups[GroupIndex];
        if Group.RunTimeSimulated then
        begin
          Inc(LayerIndex);
        end;
        Assert(LayerIndex >= 0);
        if (ThreeDConstRealArray <> nil)
          and ThreeDConstRealArray[LayerIndex].IsConstant then
        begin
          DataSetFormula := DataSetFormula
            + FortranFloatToStr(ThreeDConstRealArray[LayerIndex].RealValue);
        end
        else
        begin
          if Group.RunTimeSimulated and (LayerIndex < Length(ThreeDRealArray)) then
          begin
            if ThreeDRealArray[LayerIndex] = nil then
            begin
              DataArrayName := '0.';
            end
            else
            begin
              if ScreenObject = nil then
              begin
                CreateOrRetrieveCellCenterScreenObject(ScreenObject);
              end;
              DataArrayName := 'Imported_' + ImportName
                + '_Layer_' + IntToStr(GroupIndex);
              CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
                ThreeDRealArray[LayerIndex]);
            end;
            if LayerFormulaSuffix <> '' then
            begin
              DataSetFormula := DataSetFormula + '(';
            end;
            DataSetFormula := DataSetFormula + DataArrayName;
            if LayerFormulaSuffix <> '' then
            begin
              DataSetFormula := DataSetFormula + LayerFormulaSuffix + ')';
            end;
          end
          else
          begin
            DataSetFormula := DataSetFormula + '0';
          end;
        end;
        if GroupIndex < FModel.LayerStructure.Count - 1 then
        begin
          DataSetFormula := DataSetFormula + ', ';
        end;
      end;
      if FModel.LayerStructure.Count > 2 then
      begin
        DataSetFormula := DataSetFormula + ')';
      end;
      DataArray := FModel.DataArrayManager.GetDataSetByName(ImportArrayName);
      Assert(DataArray <> nil);
      DataArray.Formula := DataSetFormula;
    end;
  end;
end;

procedure TLpfImporter.ImportWetDry;
begin
  ImportDataSet('WetDry', rsWetDry, FWetDryConst, FWetDry);
end;

function TLpfImporter.PackageLabel: string;
begin
  Result := 'LPF:';
end;

procedure TLpfImporter.ImportDataSet7;
begin
  if FModel.ModflowWettingOptions.WettingActive then
  begin
    FModel.ModflowWettingOptions.WettingFactor := WETFCT;
    FModel.ModflowWettingOptions.WettingIterations := IWETIT;
    FModel.ModflowWettingOptions.WettingEquation := IHDWET;
  end;
end;

procedure TLpfImporter.ImportDataSet6;
var
  LayerGroup: TLayerGroup;
  Index: Integer;
  LayerIndex: Integer;
begin
  // Data set 6.
  LayerIndex := -1;
  for Index := 1 to FModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FModel.LayerStructure.LayerGroups[Index];
    if LayerGroup.RunTimeSimulated then
    begin
      Inc(LayerIndex);
      if LAYWET[LayerIndex] <> 0 then
      begin
        FModel.ModflowWettingOptions.WettingActive := True;
        break;
      end;
    end;
  end;
end;

procedure TLpfImporter.ImportDataSet1(LpfPackage: TLpfSelection);
begin
  // Data set 1
  FModel.ModflowOptions.HDry := HDRY;
  LpfPackage.UseConstantCV := FComputeVkUsingCellThickness;
  LpfPackage.UseSaturatedThickness := FComputeThicknessUsingStartingHead;
  LpfPackage.UseCvCorrection := not FNoCvCorrection;
  LpfPackage.UseVerticalFlowCorrection := not FNoVerticalFlowCorrection;
  LpfPackage.UseStorageCoefficient := FStorageCoefficientChoice;
  LpfPackage.NoParCheck := FNoParameterCheck;
{
    FStorageCoefficientChoice: Boolean;
    FComputeVkUsingCellThickness: Boolean;
    FComputeThicknessUsingStartingHead: Boolean;
    FNoVerticalFlowCorrection: Boolean;
    FNoParameterCheck: boolean;

}

end;

procedure TArrayImporter.InitializeConstArray(
  ConstArray: TRealConstantRecordArray);
var
  Index: Integer;
begin
  for Index := 0 to Length(ConstArray) - 1 do
  begin
    ConstArray[Index].IsConstant := False;
    ConstArray[Index].RealValue := 0;
  end;
end;

procedure TArrayImporter.InitializeConstIntArray(
  ConstArray: TIntegerConstantArray);
var
  Index: Integer;
begin
  for Index := 0 to Length(ConstArray) - 1 do
  begin
    ConstArray[Index].IsConstant := False;
    ConstArray[Index].IntegerValue := 0;
  end;
end;

procedure TLpfImporter.ReadDataSet7;
begin
  Read(FImporter.FFile, WETFCT);
  Read(FImporter.FFile, IWETIT);
  Read(FImporter.FFile, IHDWET);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

function TLpfImporter.ScreenObjectNameRoot: string;
begin
  result := '';
  Assert(False);
end;

procedure TCustomFlowPackageImporter.ReadDataSet1Options;
var
  ITHFLG: Integer;
  ICONCV: Integer;
  ISFAC: Integer;
  NOCVCO: Integer;
  NOPCHK: integer;
  NOVFC: integer;
begin
  Read(FImporter.FFile, ISFAC);
  Read(FImporter.FFile, ICONCV);
  Read(FImporter.FFile, ITHFLG);
  Read(FImporter.FFile, NOCVCO);
  Read(FImporter.FFile, NOVFC);
  Read(FImporter.FFile, NOPCHK);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FStorageCoefficientChoice := ISFAC <> 0;
  FComputeVkUsingCellThickness := ICONCV <> 0;
  FComputeThicknessUsingStartingHead := ITHFLG <> 0;
  FNoCvCorrection := (NOCVCO <> 0);
  FNoVerticalFlowCorrection := NOVFC <> 0;
  FNoParameterCheck := (NOPCHK <> 0);
end;

procedure TLpfImporter.ReadDataSet1;
var
  NPLPF: Integer;
begin
  FIsSelected := True;
  Read(FImporter.FFile, ILPFCB);
  Read(FImporter.FFile, HDRY);
  Read(FImporter.FFile, NPLPF);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(FParameters, NPLPF);
  FNextParameterIndex := 0;
end;

procedure TLpfImporter.HandlePackage;
var
  LpfPackage: TLpfSelection;
begin
  inherited;

  LpfPackage := FModel.ModflowPackages.LpfPackage;
  LpfPackage.IsSelected := FIsSelected;
  if FIsSelected then
  begin
    FModel.ModflowPackages.HufPackage.IsSelected := False;
    FModel.ModflowPackages.BcfPackage.IsSelected := False;
    FModel.ModflowPackages.UpwPackage.IsSelected := False;
    LpfPackage.Comments := FComments;
    ImportDataSet1(LpfPackage);
    ImportDataSet2;
    ImportDataSet3;
    ImportHorizontalAnisotropy;
    ImportDataSet5;
    ImportDataSet6;
    ImportDataSet7;
    ImportLpfParameters;
    FModel.DataArrayManager.CreateInitialDataSets;

    ImportHorizontalHydraulicConductivity;
    ImportVerticalHydraulicConductivity;
    ImportSpecificStorage;
    ImportSpecificYield;
    ImportWetDry;

    FModel.UpdateDataArrayParameterUsed;

  end;
end;

procedure TLpfImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'ILPFCB, HDRY, NPLPF:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'ISFAC, ICONCV, ITHFLG, NOCVCO, NOVFC, NOPCHK:' then
  begin
    ReadDataSet1Options;
  end
  else if ALabel = 'K,LAYTYP(K),LAYAVG(K),CHANI(K),LAYVKA(K),LAYWET(K):' then
  begin
    ReadDataSets2to6;
  end
  else if ALabel = 'WETFCT,IWETIT,IHDWET:' then
  begin
    ReadDataSet7;
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadArrayParameter;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadDataSets10to16Variable;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadDataSets10to16Constant;
  end
  else
  begin
    Assert(False);
  end
end;


procedure TArrayParameterImporter.ReadArrayParameter;
var
  Index: Integer;
  NumberOfZones: Integer;
  ZoneName: string;
  MultiplierName: string;
  Layer: Integer;
  InstanceIndex: Integer;
  Limit: Integer;
  NUMINST: Integer;
  NCLU: Integer;
  PARTYP: string;
  ID: string;
  ClusterIndex: Integer;
  PARNAM: string;
begin
  Readln(FImporter.FFile, PARNAM);
  FParameters[FNextParameterIndex].PARNAM := Trim(PARNAM);

  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Assert((ID = 'PTYP:') or (ID = 'PARTYP:'));
  ReadLn(FImporter.FFile, PARTYP);
  FParameters[FNextParameterIndex].PARTYP := Trim(UpperCase(PARTYP));

  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Assert(ID = 'Parval:');
  ReadLn(FImporter.FFile, FParameters[FNextParameterIndex].Parval);

  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Assert(ID = 'NCLU:');
  ReadLn(FImporter.FFile, NCLU);

  if ReadInstance then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    Assert(ID = 'NUMINST:');
    ReadLn(FImporter.FFile, NUMINST);
  end
  else
  begin
    NUMINST := 0;
  end;

  if NUMINST > 0 then
  begin
    Limit := NUMINST;
  end
  else
  begin
    Limit := 1;
  end;
  SetLength(FParameters[FNextParameterIndex].Instances,Limit);

  for InstanceIndex := 0 to Limit-1 do
  begin
    SetLength(FParameters[FNextParameterIndex].
      Instances[InstanceIndex].Clusters, NCLU);
    if NUMINST > 0 then
    begin
      ReadLn(FImporter.FFile, ID);
      ID := Trim(ID);
      Assert(ID = 'INAME(ILOC):');
      ReadLn(FImporter.FFile, FParameters[FNextParameterIndex].
        Instances[InstanceIndex].InstanceName);
    end
    else
    begin
      FParameters[FNextParameterIndex].
        Instances[InstanceIndex].InstanceName := '';
    end;
    for ClusterIndex := 0 to NCLU - 1 do
    begin
      if FParameters[FNextParameterIndex].PARTYP = 'SYTP' then
      begin
        Layer := 0;
      end
      else
      begin
        ReadLn(FImporter.FFile, ID);
        ID := Trim(ID);
        Layer := -1;
        if ID = 'MULTIPLIER ARRAY AND ZONE ARRAY FOR A LAYER:' then
        begin
          ReadLn(FImporter.FFile, Layer);
        end
        else if ID = 'MULTIPLIER ARRAY AND ZONE ARRAY:' then
        begin
          Layer := 0;
        end
        else if ID = 'HGUNAM:' then
        begin
          ReadLn(FImporter.FFile, Layer);
        end
        else if ID = 'LAYER:' then
        begin
          ReadLn(FImporter.FFile, Layer);
        end
        else
        begin
          Assert(False);
        end;
      end;
      FParameters[FNextParameterIndex].
        Instances[InstanceIndex].Clusters[ClusterIndex].Layer := Layer;

      ReadLn(FImporter.FFile, MultiplierName);
      MultiplierName := FixArrayName(Trim(MultiplierName));
      FParameters[FNextParameterIndex].Instances[InstanceIndex].
        Clusters[ClusterIndex].MultiplierName := MultiplierName;

      ReadLn(FImporter.FFile, ZoneName);
      ZoneName := FixArrayName(Trim(ZoneName));
      FParameters[FNextParameterIndex].Instances[InstanceIndex].
        Clusters[ClusterIndex].ZoneName := ZoneName;

      if UpperCase(ZoneName) <> 'ALL' then
      begin
        ReadLn(FImporter.FFile, ID);
        ID := Trim(ID);
        Assert(ID = 'NUMBER OF ZONES:');
        ReadLn(FImporter.FFile, NumberOfZones);
        SetLength(FParameters[FNextParameterIndex].Instances[InstanceIndex].
          Clusters[ClusterIndex].ZoneValues, NumberOfZones);

        ReadLn(FImporter.FFile, ID);
        ID := Trim(ID);
        Assert(ID = 'ZONE VALUES:');
        for Index := 0 to NumberOfZones - 1 do
        begin
          Read(FImporter.FFile, FParameters[FNextParameterIndex].
            Instances[InstanceIndex].Clusters[ClusterIndex].ZoneValues[Index]);
        end;
        Readln(FImporter.FFile);
      end;
    end;
  end;
  Inc(FNextParameterIndex);
  FImporter.UpdateProgress;
end;

function TArrayParameterImporter.ReadInstance: boolean;
begin
  result := True;
end;

procedure TPackageImporter.CreateDataArrayAndAssignValues(
  ScreenObject: TScreenObject; const DataArrayName: string;
  ImportedValues: T2DDoubleArray);
var
  DataArray: TDataArray;
  Interpolator: TNearestPoint2DInterpolator;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
  if DataArray = nil then
  begin
    DataArray := FModel.DataArrayManager.CreateNewDataArray(TDataArray,
      DataArrayName, '0', DataArrayName,
      [dcType], rdtDouble, eaBlocks, dsoTop, '');

    DataArray.UpdateDimensions(FGrid.LayerCount, FGrid.RowCount,
      FGrid.ColumnCount);

    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
  AssignRealValuesToCellCenters(DataArray, ScreenObject, ImportedValues);
end;

procedure TPackageImporter.CheckRealConstArray(out ConstantValue: Double;
      out IsConstant: Boolean; const ArrayToCheck: TRealConstantRecordArray);
var
  Index: Integer;
begin
  IsConstant := ArrayToCheck <> nil;
  if IsConstant then
  begin
    ConstantValue := ArrayToCheck[0].RealValue;
    for Index := 0 to Length(ArrayToCheck) - 1 do
    begin
      IsConstant := ArrayToCheck[Index].IsConstant
        and (ArrayToCheck[Index].RealValue = ConstantValue);
      if not IsConstant then
      begin
        break;
      end;
    end;
  end
  else
  begin
    ConstantValue := 0;
  end;
end;

procedure TPackageImporter.CheckVariableIntegerArrays(
  var ConstArray: TIntegerConstantArray; VarArray: T3DIntArray);
var
  Index: Integer;
  LayerIndex: Integer;
//  AnArray: T2DDoubleArray;
//  AValue: Double;
  RowIndex: Integer;
  ColIndex: Integer;
  IsConstant: Boolean;
  AnArray: T2DIntArray;
  AValue: Integer;
begin
  if Length(VarArray) = 0 then
  begin
    Exit;
  end;
  if (Length(ConstArray) = 0) then
  begin
    SetLength(ConstArray, Length(VarArray));
    for Index := 0 to Length(ConstArray) - 1 do
    begin
      ConstArray[Index].IsConstant := False;
    end;
  end;
  Assert(Length(ConstArray) = Length(VarArray));
  for LayerIndex := 0 to Length(ConstArray) - 1 do
  begin
    if not ConstArray[LayerIndex].IsConstant then
    begin
      AnArray := VarArray[LayerIndex];
      if Length(AnArray) = 0 then
      begin
        Continue;
      end;
      AValue := AnArray[0,0];
      IsConstant := True;
      for RowIndex := 0 to Length(AnArray) - 1 do
      begin
        for ColIndex := 0 to Length(AnArray[0]) - 1 do
        begin
          IsConstant := AnArray[RowIndex,ColIndex] = AValue;
          if not IsConstant then
          begin
            break;
          end;
        end;
        if not IsConstant then
        begin
          break;
        end;
      end;
      if IsConstant then
      begin
        ConstArray[LayerIndex].IsConstant := True;
        ConstArray[LayerIndex].IntegerValue := AValue;
      end;
    end;
  end;
end;

procedure TPackageImporter.CheckVariableRealArrays(
  var ConstArray: TRealConstantRecordArray; VarArray: T3DDoubleArray);
var
  Index: Integer;
  LayerIndex: Integer;
  AnArray: T2DDoubleArray;
  AValue: Double;
  RowIndex: Integer;
  ColIndex: Integer;
  IsConstant: Boolean;
begin
  if Length(VarArray) = 0 then
  begin
    Exit;
  end;
  if (Length(ConstArray) = 0) then
  begin
    SetLength(ConstArray, Length(VarArray));
    for Index := 0 to Length(ConstArray) - 1 do
    begin
      ConstArray[Index].IsConstant := False;
    end;
  end;
  Assert(Length(ConstArray) = Length(VarArray));
  for LayerIndex := 0 to Length(ConstArray) - 1 do
  begin
    if not ConstArray[LayerIndex].IsConstant then
    begin
      AnArray := VarArray[LayerIndex];
      if Length(AnArray) = 0 then
      begin
        Continue;
      end;
      AValue := AnArray[0,0];
      IsConstant := True;
      for RowIndex := 0 to Length(AnArray) - 1 do
      begin
        for ColIndex := 0 to Length(AnArray[0]) - 1 do
        begin
          IsConstant := AnArray[RowIndex,ColIndex] = AValue;
          if not IsConstant then
          begin
            break;
          end;
        end;
        if not IsConstant then
        begin
          break;
        end;
      end;
      if IsConstant then
      begin
        ConstArray[LayerIndex].IsConstant := True;
        ConstArray[LayerIndex].RealValue := AValue;
      end;
    end;
  end;
end;

{ TPcgImporter }

constructor TPcgImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'PCG:');
end;

procedure TPcgImporter.HandlePackage;
var
  PcgPackage: TPcgSelection;
begin
  inherited;

  PcgPackage := FModel.ModflowPackages.PcgPackage;
  PcgPackage.IsSelected := True;
  PcgPackage.Comments := FComments;

  PcgPackage.MXITER := MXITER;
  PcgPackage.ITER1 := ITER1;
  PcgPackage.MXITER := MXITER;

  PcgPackage.HCLOSE.Value := HCLOSEPCG;
  PcgPackage.RCLOSE.Value := RCLOSEPCG;
  PcgPackage.RELAX.Value := RELAXPCG;
  if NBPOL = 2 then
  begin
    PcgPackage.NBPOL := peeDontEstimate;
  end
  else
  begin
    PcgPackage.NBPOL := peeEstimate;
  end;
  PcgPackage.IPRPCG := IPRPCG;
  case MUTPCG of
    0:PcgPackage.MUTPCG := ppsAll;
    1:PcgPackage.MUTPCG := ppsIterations;
    2:PcgPackage.MUTPCG := ppsNone;
    3:PcgPackage.MUTPCG := ppsFail;
    else PcgPackage.MUTPCG := ppsAll;
  end;
  PcgPackage.DAMPPCG.Value := DAMPPCG;
  PcgPackage.DAMPPCGT.Value := DAMPPCGT;
  if IHCOFADD <> 0 then
  begin
    IHCOFADD := 1;
  end;
  PcgPackage.IHCOFADD := TPcgDryConvertOption(IHCOFADD);
end;

procedure TPcgImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, HCLOSEPCG);
  Read(FImporter.FFile, RCLOSEPCG);
  Read(FImporter.FFile, RELAXPCG);
  Read(FImporter.FFile, NBPOL);
  Read(FImporter.FFile, IPRPCG);
  Read(FImporter.FFile, MUTPCG);
  Read(FImporter.FFile, DAMPPCG);
  Read(FImporter.FFile, DAMPPCGT);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TPcgImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, MXITER);
  Read(FImporter.FFile, ITER1);
  Read(FImporter.FFile, NPCOND);
  Read(FImporter.FFile, IHCOFADD);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TPcgImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'MXITER, ITER1, NPCOND, IHCOFADD:' then
  begin
    ReadDataSet1;
  end
  else if ALabel =
    'HCLOSEPCG,RCLOSEPCG,RELAXPCG,NBPOL,IPRPCG,MUTPCG,DAMPPCG:' then
  begin
      ReadDataSet2;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TGmgImporter }

constructor TGmgImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'GMG:');
end;

procedure TGmgImporter.HandlePackage;
begin
  inherited;
  FGmgPackage := FModel.ModflowPackages.GmgPackage;
  FGmgPackage.IsSelected := True;
  FGmgPackage.Comments := FComments;
  ImportDataSet1;
  ImportDataset2;
  ImportDataSet3;
  ImportDataSet4;
end;

procedure TGmgImporter.ImportDataSet4;
begin
  // Data set 4
  if ISC = 4 then
  begin
    FGmgPackage.RELAX.Value := RELAX;
  end;
end;

procedure TGmgImporter.ImportDataSet3;
begin
  // Data set 3
  FGmgPackage.ISM := ISM;
  FGmgPackage.ISC := ISC;
  if IADAMP = 2 then
  begin
    FGmgPackage.DUP.Value := DUP;
    FGmgPackage.DLOW.Value := DLOW;
    FGmgPackage.CHGLIMIT.Value := CHGLIMIT;
  end;
end;

procedure TGmgImporter.ImportDataset2;
begin
  // Data set 2
  FGmgPackage.DAMP.Value := DAMP;
  FGmgPackage.IADAMP := IADAMP;
  FGmgPackage.IOUTGMG := IOUTGMG;
  FGmgPackage.IUNITMHC := IUNITMHC > 0;
end;

procedure TGmgImporter.ImportDataSet1;
begin
  // Data set 1
  FGmgPackage.RCLOSE.Value := RCLOSE;
  FGmgPackage.IITER := IITER;
  FGmgPackage.HCLOSE.Value := HCLOSE;
  FGmgPackage.MXITER := MXITER;
end;

procedure TGmgImporter.ReadDataSet4;
begin
  Read(FImporter.FFile, RELAX);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TGmgImporter.ReadFullDataSet3;
begin
  Read(FImporter.FFile, ISM);
  Read(FImporter.FFile, ISC);
  Read(FImporter.FFile, DUP);
  Read(FImporter.FFile, DLOW);
  Read(FImporter.FFile, CHGLIMIT);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TGmgImporter.ReadPartialDataSet3;
begin
  Read(FImporter.FFile, ISM);
  Read(FImporter.FFile, ISC);
  ReadLn(FImporter.FFile);
end;

procedure TGmgImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, DAMP);
  Read(FImporter.FFile, IADAMP);
  Read(FImporter.FFile, IOUTGMG);
  Read(FImporter.FFile, IUNITMHC);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TGmgImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, RCLOSE);
  Read(FImporter.FFile, IITER);
  Read(FImporter.FFile, HCLOSE);
  Read(FImporter.FFile, MXITER);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TGmgImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'RCLOSEGMG,IITER,HCLOSEGMG,MXITER:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'DAMP, IADAMP, IOUTGMG, IUNITMHC:' then
  begin
    ReadDataSet2;
  end
  else if ALabel = 'ISM,ISC:' then
  begin
    ReadPartialDataSet3;
  end
  else if ALabel = 'ISM,ISC,DUP,DLOW,CHGLIMIT:' then
  begin
    ReadFullDataSet3;
  end
  else if ALabel = 'RELAX:' then
  begin
    ReadDataSet4;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TSipImporter }

constructor TSipImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'SIP:');
end;

procedure TSipImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, ACCL);
  Read(FImporter.FFile, HCLOSE);
  Read(FImporter.FFile, IPCALC);
  Read(FImporter.FFile, WSEED);
  Read(FImporter.FFile, IPRSIP);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSipImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, MXITER);
  Read(FImporter.FFile, NPARM);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSipImporter.HandlePackage;
begin
  inherited;
  FSipPackage := FModel.ModflowPackages.SipPackage;
  FSipPackage.IsSelected := True;
  FSipPackage.Comments := FComments;

  // data set 1
  FSipPackage.MXITER := MXITER;
  FSipPackage.NPARM := NPARM;

  // data set 2
  FSipPackage.ACCL.Value := ACCL;
  FSipPackage.HCLOSE.Value := HCLOSE;
  FSipPackage.IPCALC := IPCALC;
  FSipPackage.WSEED.Value := WSEED;
  FSipPackage.IPRSIP := IPRSIP;
end;

procedure TSipImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'MXITER,NPARM:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'ACCL,HCLOSE,IPCALC,WSEED,IPRSIP:' then
  begin
    ReadDataSet2;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TDe4Importer }

constructor TDe4Importer.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'DE4:');
end;

procedure TDe4Importer.ReadDataSet2;
begin
  Read(FImporter.FFile, IFREQ);
  Read(FImporter.FFile, MUTD4);
  Read(FImporter.FFile, ACCL);
  Read(FImporter.FFile, HCLOSE);
  Read(FImporter.FFile, IPRD4);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  if IFREQ < 1 then
  begin
    IFREQ := 1;
  end
  else if IFREQ > 3 then
  begin
    IFREQ := 3;
  end;
  if MUTD4 < 0 then
  begin
    MUTD4 := 0;
  end
  else if MUTD4 > 2 then
  begin
    MUTD4 := 2;
  end;
end;

procedure TDe4Importer.ReadDataSet1;
begin
  Read(FImporter.FFile, ITMX);
  Read(FImporter.FFile, MXUP);
  Read(FImporter.FFile, MXLOW);
  Read(FImporter.FFile, MXBW);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TDe4Importer.HandlePackage;
begin
  inherited;
  FDe4Package := FModel.ModflowPackages.De4Package;
  FDe4Package.IsSelected := True;
  FDe4Package.Comments := FComments;

  // data set 1.
  FDe4Package.ITMX := ITMX;
  FDe4Package.MXUP := MXUP;
  FDe4Package.MXLOW := MXLOW;
  FDe4Package.MXBW := MXBW;

  // data set 2.
  FDe4Package.IFREQ := IFREQ;
  FDe4Package.MUTD4 := MUTD4;
  FDe4Package.ACCL.Value := ACCL;
  FDe4Package.HCLOSE.Value := HCLOSE;
  FDe4Package.IPRD4 := IPRD4;
end;

procedure TDe4Importer.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'ITMX, MXUP, MXLOW, MXBW:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'IFREQ,MUTD4,ACCLDE4,HCLOSEDE4,IPRD4:' then
  begin
    ReadDataSet2;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TChdImporter }

constructor TChdImporter.Create(Importer: TModflow2005Importer;
  BasImporter: TBasImporter);
begin
  inherited Create(Importer, 'CHD:');
  FBasImporter := BasImporter;
  FStressPeriods:= TChdStressPeriodArray.Create;
  FParameters:= TChdParamArray.Create;
  FReadData := False;
end;

function TChdImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: Integer; LayerIndex,
  StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject;
var
  SpecifiedHeadLocations: TDataArray;
  Position: Integer;
begin
  result := inherited CreateScreenObject(List,
    ScreenObjectIndex, LayerIndex, StressPeriodIndex, otPolygon);
  if result <> nil then
  begin
    result.CreateChdBoundary;
    SpecifiedHeadLocations := FModel.DataArrayManager.GetDataSetByName(rsModflowSpecifiedHead);
    Assert(SpecifiedHeadLocations <> nil);
    Position := result.AddDataSet(SpecifiedHeadLocations);
    result.DataSetFormulas[Position] := 'True';
  end;
end;

destructor TChdImporter.Destroy;
begin
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

function TCustomChdImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  // Assign values to the TScreenObject
  // for the current stress period(s).
  result := ScreenObject.ModflowChdBoundary;
end;

procedure TChdImporter.ReadNonParameterLocations;
var
  BoundaryIndex: Integer;
  Index: Integer;
  LAYER: integer;
  Row: integer;
  Column: integer;
  StartFactor: double;
  EndFactor: double;
  AuxVar: double;
  ChdBoundary: TChdLocationObject;
begin
  for BoundaryIndex := 0 to ITMP - 1 do
  begin
    ChdBoundary := FStressPeriods[FCurrentStressPeriod].
      Boundaries[CurrentInstance] as TChdLocationObject;
    Read(FImporter.FFile, LAYER);
    ChdBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    ChdBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    ChdBoundary.Column := Column;
    Read(FImporter.FFile, StartFactor);
    ChdBoundary.StartFactor := StartFactor;
    Read(FImporter.FFile, EndFactor);
    ChdBoundary.EndFactor := EndFactor;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      ChdBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    Inc(CurrentInstance);
  end;
end;

procedure TChdImporter.ReadParameterLocations;
var
  Index: Integer;
  BoundaryIndex: Integer;
  LAYER: integer;
  Row: integer;
  Column: integer;
  StartFactor: double;
  EndFactor: double;
  AuxVar: double;
  ChdLocation: TChdLocationObject;
begin
  for BoundaryIndex := 0 to NLST - 1 do
  begin
    ChdLocation := FParameters[CurrentParameter].Instances[CurrentInstance].
      Locations[BoundaryIndex] as TChdLocationObject;
    Read(FImporter.FFile, LAYER);
    ChdLocation.Layer := LAYER;
    Read(FImporter.FFile, Row);
    ChdLocation.Row := Row;
    Read(FImporter.FFile, Column);
    ChdLocation.Column := Column;
    Read(FImporter.FFile, StartFactor);
    ChdLocation.StartFactor := StartFactor;
    Read(FImporter.FFile, EndFactor);
    ChdLocation.EndFactor := EndFactor;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      ChdLocation.AuxilliaryVariables[Index] := AuxVar;
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TChdImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'CHD');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

procedure TChdImporter.ReadDataSet2;
begin
  FReadData := True;
  Readln(FImporter.FFile, MXACTC);
  FImporter.UpdateProgress;
end;

function TChdImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_CHD_';
end;

procedure TChdImporter.HandlePackage;
var
  ScreenObjectIndex: integer;
  LayerIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength-1) then
  begin
    Exit;
  end;
  inherited;
  SetLength(FBasImporter.FInitialCHDLocations,
    FModel.ModflowLayerCount, FModel.Grid.RowCount,
    FModel.Grid.ColumnCount);
  for LayerIndex := 0 to FModel.ModflowLayerCount - 1 do
  begin
    for RowIndex := 0 to FModel.Grid.RowCount - 1 do
    begin
      for ColIndex := 0 to FModel.Grid.ColumnCount - 1 do
      begin
        FBasImporter.FInitialCHDLocations[LayerIndex, RowIndex, ColIndex]
          := false;
      end;
    end;
  end;
  FChdPackage := FModel.ModflowPackages.ChdBoundary;
  FChdPackage.IsSelected := True;
  FChdPackage.Comments := FComments;
  FModel.DataArrayManager.CreateInitialDataSets;
  AssignObservations;

  ScreenObjectIndex := 0;
  ImportNonParameterBoundaries(ScreenObjectIndex);
  ImportParameterBoundaries(ScreenObjectIndex);
  if FObsImporter <> nil then
  begin
    FObsImporter.HandlePackage;
  end;
  ReleaseMemory;
end;

procedure TChdImporter.HandleParamLocation(UsedStressPeriods: TIntegerList;
  Boundary: TLocation);
begin
  if UsedStressPeriods[0] = 0 then
  begin
    FBasImporter.FInitialCHDLocations[Boundary.Layer-1, Boundary.Row-1,
      Boundary.Column-1] := True;
  end;
end;

procedure TChdImporter.HandleNonParamLocation(StressPeriodIndex: Integer;
  Boundary: TLocation);
begin
  if StressPeriodIndex = 0 then
  begin
    FBasImporter.FInitialCHDLocations[Boundary.Layer-1, Boundary.Row-1,
      Boundary.Column-1] := True;
  end;
end;

procedure TChdImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'MXACTC:' then
    begin
      ReadDataSet2;
    end
    else if ALabel = 'NP,MXL:' then
    begin
      ReadDataSet1;
    end
    else if ALabel = 'CHDAUX(NAUX):' then
    begin
      ReadAuxilliaryVariableName;
    end
    else if ALabel = 'NOPRINT:' then
    begin
      FNoPrint := True;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
      // do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
    end
    else if ALabel = 'LAYER,ROW,COL,START_FACTOR,END_FACTOR,CHDAUX:' then
    begin
      ReadParameterLocations;
    end
    else if ALabel = 'ITMP,NP:' then
    begin
      ReadFirstStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadFirstStressPeriodDataSet5WithoutParameters;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,NP:' then
    begin
      ReadNewStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadNewStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'LAYER,ROW,COL,START_FACTOR,END_FACTOR,CHDAUX:' then
    begin
      ReadNonParameterLocations;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadParamNameForStressPeriod;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

function TCustomChdImporter.ParameterType: TParameterType;
begin
  result := ptCHD;
end;

{ TWelImporter }

constructor TWelImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'WEL:');
  FParameters := TWelParamArray.Create;
  FStressPeriods := TWelStressPeriodArray.Create;
  PSIRAMP := 1e-6;
  FWellTabFiles := TWellTabFiles.Create;
end;

function TWelImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: Integer; LayerIndex, StressPeriodIndex: integer;
  ObjectType: TObjectType): TScreenObject;
begin
  result := inherited CreateScreenObject(List, ScreenObjectIndex, LayerIndex,
    StressPeriodIndex, ObjectType);
  if result <> nil then
  begin
    result.CreateWelBoundary;
    result.ModflowWellBoundary.FormulaInterpretation := fiDirect;
  end;
end;

destructor TWelImporter.Destroy;
begin
  FWellTabFiles.Free;
  FParameters.Free;
  FStressPeriods.Free;
  inherited;
end;

procedure TWelImporter.ReadPhiRamp;
begin
  Read(FImporter.FFile, PSIRAMP);
  Read(FImporter.FFile, IUNITRAMP);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TWelImporter.ReadMaxTab;
var
  NUMTAB: integer;
begin
  Read(FImporter.FFile, NUMTAB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FWellTabFiles.ArrayLength := NUMTAB;
  FTabCell := -1;
  FModel.ModelSelection := msModflowNWT;
end;

function TWelImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowWellBoundary;
end;

procedure TWelImporter.ImportTabFileWells(var ScreenObjectIndex: Integer);
var
  LocationsToUse: TList;
  ALocation: TLocation;
  WellIndex: Integer;
  AWellCell: TWellTabValues;
  StartTime: Double;
  EndTime: Double;
  ScreenObject: TScreenObject;
  FirstTabItem: TWellTabValue;
  WellBoundary: TMfWellBoundary;
  WellItem: TWellItem;
  TabItem: TWellTabValue;
  NextTabItem: TWellTabValue;
  TimeIndex: Integer;
//  WellBoundary: TWellBoundary;
begin
  StartTime := FModel.ModflowStressPeriods.First.StartTime;
  EndTime := FModel.ModflowStressPeriods.Last.EndTime;
  LocationsToUse := TList.Create;
  try
    ALocation := TLocation.Create;
    try
      LocationsToUse.Add(ALocation);
      ALocation.Used := True;

      for WellIndex := 0 to FWellTabFiles.ArrayLength - 1 do
      begin
        AWellCell := FWellTabFiles[WellIndex];

        if AWellCell.ArrayLength > 0 then
        begin
          ALocation.Layer := AWellCell.Layer;
          ALocation.Row := AWellCell.Row;
          ALocation.Column := AWellCell.Column;

          ScreenObject := CreateScreenObject(LocationsToUse, ScreenObjectIndex,
            ALocation.Layer, 0, otPoint);

          if ScreenObject <> nil then
          begin
            ScreenObject.CreateWelBoundary;
            WellBoundary := ScreenObject.ModflowWellBoundary;

            FirstTabItem := AWellCell[0];
            if FirstTabItem.Time > StartTime then
            begin
              WellItem := WellBoundary.Values.Add as TWellItem;
              WellItem.StartTime := StartTime;
              WellItem.EndTime := FirstTabItem.Time;
              WellItem.PumpingRate := '0.';
            end;
            for TimeIndex := 0 to AWellCell.ArrayLength - 1 do
            begin
              TabItem := AWellCell[TimeIndex];
              WellItem := WellBoundary.Values.Add as TWellItem;
              WellItem.StartTime := TabItem.Time;
              WellItem.PumpingRate := FortranFloatToStr(TabItem.Rate);
              if TimeIndex < AWellCell.ArrayLength - 1 then
              begin
                NextTabItem := AWellCell[TimeIndex+1];
                WellItem.EndTime := NextTabItem.Time;
              end
              else
              begin
                if EndTime > TabItem.Time then
                begin
                  WellItem.EndTime := EndTime;
                end
                else
                begin
                  WellItem.EndTime := TabItem.Time;
                end;
              end;
            end;
          end;
        end;
      end;
    finally
      ALocation.Free;
    end;
  finally
    LocationsToUse.Free;
  end;
end;

procedure TWelImporter.HandlePackage;
var
  ScreenObjectIndex: integer;
  WelPackage: TWellPackage;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  inherited;
  WelPackage := FModel.ModflowPackages.WelPackage as TWellPackage;
  WelPackage.IsSelected := True;
  WelPackage.Comments := FComments;
  WelPackage.PhiRamp := PsiRamp;
  if FWellTabFiles.ArrayLength > 0 then
  begin
    WelPackage.UseTabFiles := True;
  end;

  ScreenObjectIndex := 0;
  if WelPackage.UseTabFiles then
  begin
    ImportTabFileWells(ScreenObjectIndex);
  end
  else
  begin
    ImportNonParameterBoundaries(ScreenObjectIndex);
  end;
  ImportParameterBoundaries(ScreenObjectIndex);
  ReleaseMemory;
end;

function TWelImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Wel_';
end;

procedure TWelImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
var
  WelBoundary: TWelLocationObject;
  WelItem: TWellItem;
  ValueItem: TValueArrayItem;
  Index: Integer;
  PumpingValues: TValueArrayStorage;
  PumpName: string;
  APoint: TPoint2D;
begin
  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  PumpName := 'WelPump' + ParamName;
  ValueItem.Name := PumpName;
  PumpingValues := ValueItem.Values;
  PumpingValues.DataType := rdtDouble;
  PumpingValues.Count := Boundaries.Count;

  WelItem := Item as TWellItem;
  WelItem.StartTime := StartTime;
  WelItem.EndTime := EndTime;
  for Index := 0 to Boundaries.Count - 1 do
  begin
    WelBoundary := Boundaries[Index];
    APoint := FImporter.CenterPoints[WelBoundary.Row-1, WelBoundary.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
      PumpingValues.RealValues[Index] := WelBoundary.PumpingRate;
    end;
  end;
  WelItem.PumpingRate := rsObjectImportedValuesR + '("' + PumpName + '")';
  PumpingValues.CacheData;
end;

procedure TWelImporter.ReadNonParameterLocations;
var
  Index: Integer;
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  PumpingRate: Double;
  WelBoundary: TWelLocationObject;
begin
  for BoundaryIndex := 0 to ITMP - 1 do
  begin
    WelBoundary := FStressPeriods[FCurrentStressPeriod].
      Boundaries[CurrentInstance] as TWelLocationObject;
    Read(FImporter.FFile, LAYER);
    WelBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    WelBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    WelBoundary.Column := Column;
    Read(FImporter.FFile, PumpingRate);
    WelBoundary.PumpingRate := PumpingRate;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      WelBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    Inc(CurrentInstance);
  end;
end;

procedure TWelImporter.ReadParameterLocations;
var
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  PumpingRate: Double;
  Index: Integer;
  WellBoundary : TWelLocationObject;
begin
  for BoundaryIndex := 0 to NLST - 1 do
  begin
    WellBoundary := FParameters[CurrentParameter].Instances[CurrentInstance].
      Locations[BoundaryIndex] as TWelLocationObject;
    Read(FImporter.FFile, LAYER);
    WellBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    WellBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    WellBoundary.Column := Column;
    Read(FImporter.FFile, PumpingRate);
    WellBoundary.PumpingRate := PumpingRate;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      WellBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TWelImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'Q');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

procedure TWelImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, MXACTW);
  Read(FImporter.FFile, IWELCB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

{$HINTS OFF}
procedure TWelImporter.ReadTabFile;
var
  TabFileData: TWellTabValues;
  TABUNIT: integer;
  TABVAL: Integer;
  ALabel: string;
  TabData: TWellTabValue;
  TimeIndex: Integer;
begin
  FModel.ModelSelection := msModflowNWT;
  Inc(FTabCell);
  TabFileData := FWellTabFiles[FTabCell];
  Read(FImporter.FFile, TABUNIT);
  Read(FImporter.FFile, TABVAL);
  Read(FImporter.FFile, TabFileData.Layer);
  Read(FImporter.FFile, TabFileData.Row);
  Read(FImporter.FFile, TabFileData.Column);
  Readln(FImporter.FFile);
  TabFileData.ArrayLength := TABVAL;

  Readln(FImporter.FFile, ALabel);
  Assert(Trim(ALabel) = 'TTIME,TRATE:');
  for TimeIndex := 0 to TABVAL - 1 do
  begin
    TabData := TabFileData[TimeIndex];
    Read(FImporter.FFile, TabData.Time);
    Read(FImporter.FFile, TabData.Rate);
    Readln(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
end;
{$HINTS ON}

procedure TWelImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'NP,MXL:' then
    begin
      ReadDataSet1;
    end
    else if ALabel = 'MXACTW, IWELCB:' then
    begin
      ReadDataSet2;
    end
    else if ALabel = 'WELAUX(NAUX):' then
    begin
      ReadAuxilliaryVariableName;
    end
    else if ALabel = 'NOPRINT:' then
    begin
      FNoPrint := True;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
      // do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
    end
    else if ALabel = 'Layer Row Column Qfact [xyz]:' then
    begin
      ReadParameterLocations;
    end
    else if ALabel = 'ITMP,NP:' then
    begin
      ReadFirstStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadFirstStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'PSIRAMP,IUNITRAMP:' then
    begin
      ReadPhiRamp;
    end
    else if ALabel = 'NUMTAB,MAXVAL:' then
    begin
      ReadMaxTab;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,NP:' then
    begin
      ReadNewStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadNewStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'Layer Row Column Q [xyz]:' then
    begin
      ReadNonParameterLocations;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadParamNameForStressPeriod;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else if ALabel = 'TABUNIT,TABVAL(J),TABLAY(J),TABROW(J),TABCOL(J):' then
    begin
      ReadTabFile;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

function TWelImporter.ParameterType: TParameterType;
begin
  result := ptQ;
end;

{ TWelInstanceRecord }

function TWelInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWelLocationObject;
end;

{ TWelParameterRecord }

function TWelParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWelInstanceObject;
end;

{ TWelStressPeriod }

function TWelStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWelLocationObject;
end;

{ TWellParamArray }

function TWelParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWelParameterObject;
end;

{ TWelStressPeriodArray }

function TWelStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWelStressPeriod;
end;

{ TArrayMember }

constructor TArrayMember.Create;
begin
  inherited;
end;

{ TObjectArray }

destructor TObjectArray.Destroy;
begin
  ArrayLength := 0;
  inherited;
end;

function TObjectArray.GetArrayLength: integer;
begin
  result := Length(FObjects);
end;

function TObjectArray.GetObject(Index: integer): TArrayMember;
begin
  result := FObjects[Index];
end;

procedure TObjectArray.SetArrayLength(const Value: integer);
var
  OldLength: integer;
  Index: Integer;
begin
  OldLength := ArrayLength;
  if Value <> OldLength then
  begin
    if Value > OldLength then
    begin
      SetLength(FObjects, Value);
      for Index := OldLength to Value - 1 do
      begin
        FObjects[Index] := ArrayMemberClass.Create;
      end;
    end
    else
    begin
      for Index := OldLength -1 downto Value do
      begin
        FObjects[Index].Free;
      end;
      SetLength(FObjects, Value);
    end;
  end;
end;

{ TChdInstanceObject }

function TChdInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChdLocationObject;
end;

{ TChdParameterObject }

function TChdParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChdInstanceObject;
end;

{ TChdParamArray }

function TChdParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChdParameterObject;
end;

{ TChdStressPeriod }

function TChdStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChdLocationObject;
end;

{ TChdStressPeriodArray }

function TChdStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChdStressPeriod;
end;

destructor TListImporter.Destroy;
begin
  FAuxillaryVariables.Free;
  inherited;
end;

procedure TListImporter.CreateParameters;
var
  Parameter: TListParameterObject;
  ParameterIndex: Integer;
  Parameters: TModflowTransientListParameters;
  NewParameter: TModflowTransientListParameter;
begin
  // Create parameters in the model.
  Parameters := TModflowTransientListParameters.Create(nil);
  try
    Parameters.Assign(FModel.ModflowTransientParameters);
    for ParameterIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      Parameter := FParameters[ParameterIndex];
      NewParameter := Parameters.Add as TModflowTransientListParameter;
      NewParameter.ParameterName := Parameter.PARNAM;
      Parameter.ModifiedParamName := NewParameter.ParameterName;
      NewParameter.ParameterType := ParameterType;
      NewParameter.Value := Parameter.Parval;
    end;
    FModel.ModflowTransientParameters := Parameters;
  finally
    Parameters.Free;
  end;
end;

procedure TListImporter.HandleParamLocation(UsedStressPeriods: TIntegerList;
  Boundary: TLocation);
begin
  // do nothing.
end;

procedure TListImporter.HandleNonParamLocation(StressPeriodIndex: Integer;
  Boundary: TLocation);
begin
  // do nothing
end;

procedure TListImporter.AssignObsGroupsToCells(CellList: TList);
var
  CellIndex: Integer;
  Cell: TLocation;
  StartPosition: Integer;
  ObsGroupIndex: Integer;
  ObsGroup: TObservationGroup;
  ObsCellIndex: Integer;
  ObsCell: TFlowObservationLocation;
  Found: Boolean;
begin
  StartPosition := 0;
  for ObsGroupIndex := 0 to FObsImporter.FObservations.ArrayLength - 1 do
  begin
    ObsGroup := FObsImporter.FObservations[ObsGroupIndex];
    for ObsCellIndex := 0 to ObsGroup.FCells.ArrayLength - 1 do
    begin
      ObsCell := ObsGroup.FCells[ObsCellIndex];
      Found := False;
      for CellIndex := StartPosition to CellList.Count - 1 do
      begin
        Cell := CellList[CellIndex];
        if (Cell.Layer = ObsCell.LAYER)
          and (Cell.Row = ObsCell.ROW)
          and (Cell.Column = ObsCell.COLUMN) then
        begin
          Found := True;
          StartPosition := CellIndex + 1;
          Cell.FObservationGroups.Add(ObsGroup);
          Cell.FObservationCells.Add(ObsCell);
          break;
        end;
      end;
      if not Found then
      begin
        for CellIndex := 0 to StartPosition - 1 do
        begin
          Cell := CellList[CellIndex];
          if (Cell.Layer = ObsCell.LAYER)
            and (Cell.Row = ObsCell.ROW)
            and (Cell.Column = ObsCell.COLUMN) then
          begin
//            Found := True;
            StartPosition := CellIndex + 1;
            Cell.FObservationGroups.Add(ObsGroup);
            Cell.FObservationCells.Add(ObsCell);
            break;
          end;
        end;
      end;
    end;
  end;
end;

constructor TListImporter.Create(Importer: TModflow2005Importer;
  const PackageIdentifier: string);
begin
  inherited Create(Importer, PackageIdentifier);
  CurrentParameter := -1;
  FCurrentStressPeriod := -1;
  FAuxillaryVariables := TStringList.Create;
end;

{ TInstanceObject }

function TListInstanceObject.GetLocations(Index: integer): TLocation;
begin
  result := TLocation(Objects[Index]);
end;

{ TParameterObject }

function TListParameterObject.GetInstance(Index: integer): TListInstanceObject;
begin
  result := TListInstanceObject(Objects[Index]);
end;

{ TParamArray }

function TListParamArray.GetParamByName(
  const ParamName: string): TListParameterObject;
var
  Index: Integer;
  Param: TListParameterObject;
begin
  result := nil;
  for Index := 0 to ArrayLength - 1 do
  begin
    Param := Params[Index];
    if AnsiCompareText(Param.PARNAM, ParamName) = 0 then
    begin
      result := Param;
      Exit;
    end;
  end;
end;

function TListParamArray.GetParams(Index: integer): TListParameterObject;
begin
  result := TListParameterObject(Objects[Index]);
end;

{ TStressPeriod }

function TListStressPeriod.GetBoundary(Index: integer): TLocation;
begin
  result := TLocation(Objects[Index]);
end;

{ TStressPeriodArray }

function TListStressPeriodArray.GetStressPeriod(Index: integer): TListStressPeriod;
begin
  result := (Objects[Index]) as TListStressPeriod;
end;

procedure TListImporter.ImportNonParameterBoundaries(
  var ScreenObjectIndex: Integer);
var
  Item: TCustomModflowBoundaryItem;
  SO_Boundary: TModflowParamBoundary;
  ScreenObject: TScreenObject;
  Boundary, AnotherBoundary: TLocation;
  BoundaryIndex: Integer;
  SP: TListStressPeriod;
  InnerIndex: Integer;
  StressPeriod: TListStressPeriod;
  EndTime: Double;
  StartTime: Double;
  StressPeriodIndex: Integer;
  UsedLocations: array of TBooleanDynArray;
  LocationsToUse: TList;
  InnerBoundaryIndex: Integer;
  InstanceCount: integer;
  APoint: TPoint2D;
  procedure InitializeTestArray;
  var
    RowIndex: Integer;
    ColIndex: Integer;
  begin
    for RowIndex := 0 to FGrid.RowCount - 1 do
    begin
      for ColIndex := 0 to FGrid.ColumnCount - 1 do
      begin
        UsedLocations[RowIndex,ColIndex] := false;
      end;
    end;
  end;
begin
  InstanceCount := 0;
  SetLength(UsedLocations, FGrid.RowCount, FGrid.ColumnCount);
  LocationsToUse := TList.Create;
  try
    for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
    begin
      // initialize the start and end times for when the boundary will be
      // applied.
      StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
      StressPeriod := FStressPeriods[StressPeriodIndex];
      if StressPeriod.Reuse then
      begin
        Continue;
      end
      else
      begin
        // Update the endtime if the boundaries from the current
        // stress period will be reused in subsequent stress periods.
        for InnerIndex := StressPeriodIndex + 1 to
          FStressPeriods.ArrayLength - 1 do
        begin
          SP := FStressPeriods[InnerIndex];
          if SP.Reuse then
          begin
            EndTime := FModel.ModflowStressPeriods[InnerIndex].EndTime;
          end
          else
          begin
            break;
          end;
        end;

        for BoundaryIndex := 0 to StressPeriod.ArrayLength - 1 do
        begin
          Boundary := StressPeriod.Boundaries[BoundaryIndex];
          APoint := FImporter.CenterPoints[Boundary.Row-1, Boundary.Column-1];
          if (FImporter.FImportParameters.Outline = nil)
            or FImporter.FImportParameters.Outline.PointInside(APoint) then
          begin
            if Boundary.Used then
            begin
              HandleNonParamLocation(StressPeriodIndex, Boundary);
              Continue;
            end;
            InitializeTestArray;
            LocationsToUse.Clear;
            LocationsToUse.Add(Boundary);
            UsedLocations[Boundary.Row-1, Boundary.Column-1] := True;
            Boundary.Used := True;
            for InnerBoundaryIndex := BoundaryIndex+1
              to StressPeriod.ArrayLength - 1 do
            begin
              AnotherBoundary := StressPeriod.Boundaries[InnerBoundaryIndex];
              if not AnotherBoundary.Used
                and (Boundary.Layer = AnotherBoundary.Layer)
                and not UsedLocations[AnotherBoundary.Row-1,
                AnotherBoundary.Column-1]
                and Boundary.SameObservations(AnotherBoundary) then
              begin
                APoint := FImporter.CenterPoints[AnotherBoundary.Row-1, AnotherBoundary.Column-1];
                if (FImporter.FImportParameters.Outline = nil)
                  or FImporter.FImportParameters.Outline.PointInside(APoint) then
                begin
                  LocationsToUse.Add(AnotherBoundary);
                  UsedLocations[AnotherBoundary.Row-1,
                    AnotherBoundary.Column-1] := True;
                  AnotherBoundary.Used := True;
                end;
              end;
            end;
            ScreenObject := CreateScreenObject(LocationsToUse, ScreenObjectIndex,
              Boundary.Layer, StressPeriodIndex, otPoint);
            if ScreenObject <> nil then
            begin
              HandleNonParamLocation(StressPeriodIndex, Boundary);
              // Assign values to the TScreenObject
              // for the current stress period(s).
              SO_Boundary := GetBoundary(ScreenObject);
              Item := SO_Boundary.Values.Add as TCustomModflowBoundaryItem;
              Inc(InstanceCount);
              SetItemValues(Item, LocationsToUse, EndTime, StartTime, ScreenObject,
                IntToStr(InstanceCount));
            end;
          end;
        end;
      end;
    end;
  finally
    LocationsToUse.Free;
  end;
end;

procedure TListImporter.ImportParameterBoundaries(ScreenObjectIndex: Integer);
var
  Item: TCustomModflowBoundaryItem;
  EndTime: Double;
  LocationIndex: Integer;
  InnerParamIndex: Integer;
  StressPeriod: TListStressPeriod;
  StressPeriodIndex: Integer;
  Instance: TListInstanceObject;
  InstanceIndex: Integer;
  InstanceCount: Integer;
  Instances: TIntegerList;
  UsedStressPeriods: TIntegerList;
//  NewParameter: TModflowTransientListParameter;
  Parameter: TListParameterObject;
  ParameterIndex: Integer;
//  Parameters: TModflowTransientListParameters;
  StartTime: Double;
  StressPeriodI: Integer;
  Param: TCustomMF_BoundColl;
  ParamItem: TModflowParamItem;
  SO_Boundary: TModflowParamBoundary;
  ScreenObject: TScreenObject;
  Boundary: TLocation;
  UsedLocations: array of TBooleanDynArray;
  LocationsToUse: TList;
  InnerBoundaryIndex: Integer;
  AnotherBoundary: TLocation;
  ACount: integer;
  APoint: TPoint2D;
//  RowIndex: Integer;
//  ColIndex: Integer;
  procedure InitializeTestArray;
  var
    RowIndex: Integer;
    ColIndex: Integer;
  begin
    for RowIndex := 0 to FGrid.RowCount - 1 do
    begin
      for ColIndex := 0 to FGrid.ColumnCount - 1 do
      begin
        UsedLocations[RowIndex,ColIndex] := false;
      end;
    end;
  end;
begin
  CreateParameters;

  ACount := 0;
  // If multiple boundaries are in the same cell, they must
  // be separate objects.
  SetLength(UsedLocations, FGrid.RowCount, FGrid.ColumnCount);

  LocationsToUse := TList.Create;
  // Create TScreenObjects to represent the boundaries.
  // UsedStressPeriods will list the stress periods
  // in which a parameter is used.
  UsedStressPeriods := TIntegerList.Create;
  // Instances will indicate which instance of a parameter will be used
  // in any particular stress period.
  Instances := TIntegerList.Create;
  try
    for ParameterIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      Parameter := FParameters[ParameterIndex];
      InstanceCount := Parameter.ArrayLength;
      UsedStressPeriods.Clear;
      Instances.Clear;
      if InstanceCount > 1 then
      begin
        for InstanceIndex := 0 to InstanceCount - 1 do
        begin
          Instance := Parameter.Instances[InstanceIndex];
          Assert(Instance.Name <> '');
        end;
      end;
      // Identify the stress periods in which the parameter is used
      // and the instance used in each stress period.
      for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
      begin
        StressPeriod := FStressPeriods[StressPeriodIndex];
        for InnerParamIndex := 0 to Length(StressPeriod.Parameters) - 1 do
        begin
          if SameText(Parameter.PARNAM,
            StressPeriod.Parameters[InnerParamIndex]) then
          begin
            if InstanceCount = 1 then
            begin
              UsedStressPeriods.Add(StressPeriodIndex);
              Instances.Add(0);
            end
            else
            begin
              for InstanceIndex := 0 to InstanceCount - 1 do
              begin
                Instance := Parameter.Instances[InstanceIndex];
                if SameText(Instance.Name,
                  StressPeriod.Instances[InnerParamIndex]) then
                begin
                  UsedStressPeriods.Add(StressPeriodIndex);
                  Instances.Add(InstanceIndex);
                end;
              end;
            end;
          end;
        end;
      end;
      // Create the TScreenObjects to represent the boundaries.
      for InstanceIndex := 0 to InstanceCount - 1 do
      begin
        Instance := Parameter.Instances[InstanceIndex];
        for LocationIndex := 0 to Instance.ArrayLength - 1 do
        begin
          Boundary := Instance.Locations[LocationIndex];
          if Boundary.Used then
          begin
            HandleParamLocation(UsedStressPeriods, Boundary);
            Continue;
          end;
          APoint := FImporter.CenterPoints[Boundary.Row-1, Boundary.Column-1];
          if (FImporter.FImportParameters.Outline = nil)
            or FImporter.FImportParameters.Outline.PointInside(APoint) then
          begin
            InitializeTestArray;
            LocationsToUse.Clear;
            LocationsToUse.Add(Boundary);
            UsedLocations[Boundary.Row-1, Boundary.Column-1] := True;
            Boundary.Used := True;
            for InnerBoundaryIndex := LocationIndex+1
              to Instance.ArrayLength - 1 do
            begin
              AnotherBoundary := Instance.Locations[InnerBoundaryIndex];
              if not AnotherBoundary.Used
                and (Boundary.Layer = AnotherBoundary.Layer)
                and not UsedLocations[AnotherBoundary.Row-1,AnotherBoundary.Column-1]
                and Boundary.SameObservations(AnotherBoundary)
                then
              begin
                APoint := FImporter.CenterPoints[AnotherBoundary.Row-1, AnotherBoundary.Column-1];
                if (FImporter.FImportParameters.Outline = nil)
                  or FImporter.FImportParameters.Outline.PointInside(APoint) then
                begin
                  LocationsToUse.Add(AnotherBoundary);
                  UsedLocations[AnotherBoundary.Row-1,
                    AnotherBoundary.Column-1] := True;
                  AnotherBoundary.Used := True;
                end;
              end;
            end;
            HandleParamLocation(UsedStressPeriods, Boundary);

            ScreenObject := CreateScreenObject(LocationsToUse, ScreenObjectIndex,
              Boundary.Layer, InstanceIndex, otPoint);
            if ScreenObject <> nil then
            begin
              SO_Boundary := GetBoundary(ScreenObject);
              ParamItem := SO_Boundary.Parameters.Add;
              Param := ParamItem.Param;
              Param.ParamName := Parameter.ModifiedParamName;
              // Loop over the stress periods in which this parameter
              // is used.
              for StressPeriodI := 0 to UsedStressPeriods.Count - 1 do
              begin
                // If this instance is used in the current stress period,
                // assign new values.
                if Instances[StressPeriodI] = InstanceIndex then
                begin
                  StressPeriodIndex := UsedStressPeriods[StressPeriodI];
                  StartTime := FModel.ModflowStressPeriods[
                    StressPeriodIndex].StartTime;
                  EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
                  Item := Param.Add as TCustomModflowBoundaryItem;
                  Inc(ACount);
                  SetItemValues(Item, LocationsToUse, EndTime, StartTime,
                    ScreenObject, IntToStr(ACount));
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  finally
    UsedStressPeriods.Free;
    Instances.Free;
    LocationsToUse.Free;
  end;
end;

procedure TListImporter.InitializeCurrentStressPeriod;
var
  Index: Integer;
begin
  if ITMP < 0 then
  begin
    FStressPeriods[FCurrentStressPeriod].Reuse := True;
    FStressPeriods[FCurrentStressPeriod].ArrayLength := 0;
  end
  else
  begin
    FStressPeriods[FCurrentStressPeriod].Reuse := False;
    FStressPeriods[FCurrentStressPeriod].ArrayLength := ITMP;
    for Index := 0 to ITMP - 1 do
    begin
      SetLength(FStressPeriods[FCurrentStressPeriod].Boundaries[Index].
        AuxilliaryVariables, FAuxillaryVariables.Count);
    end;
  end;
  SetLength(FStressPeriods[FCurrentStressPeriod].Parameters, NP);
  SetLength(FStressPeriods[FCurrentStressPeriod].Instances, NP);
  CurrentInstance := 0;
  CurrentParameter := 0;
end;

procedure TListImporter.InitializeStressPeriods;
begin
  FStressPeriods.ArrayLength :=
    FModel.ModflowStressPeriods.Count;
end;

procedure TListImporter.ReadAuxilliaryVariableName;
var
  AuxName: string;
begin
  Readln(FImporter.FFile, AuxName);
  FImporter.UpdateProgress;
  AuxName := Trim(AuxName);
  FAuxillaryVariables.Add(AuxName);
end;

procedure TListImporter.ReadParameterName;
var
  PNAME: string;
begin
  Readln(FImporter.FFile, PNAME);
  FImporter.UpdateProgress;
  PNAME := UpperCase(Trim(PNAME));
  Inc(CurrentParameter);
  FParameters[CurrentParameter].PARNAM := PNAME;
  FParameters[CurrentParameter].ArrayLength := 1;
  FParameters[CurrentParameter].Instances[0].ArrayLength := 1;
  SetLength(FParameters[CurrentParameter].Instances[0].Locations[0].
    AuxilliaryVariables, FAuxillaryVariables.Count);
  CurrentInstance := 0;
end;

procedure TListImporter.ReadParameterValueAndLocationCount;
var
  InnerIndex: Integer;
  Index: Integer;
  Parval: Double;
begin
  Read(FImporter.FFile, Parval);
  Read(FImporter.FFile, NLST);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FParameters[CurrentParameter].Parval := Parval;
  for Index := 0 to FParameters[CurrentParameter].ArrayLength - 1 do
  begin
    FParameters[CurrentParameter].Instances[Index].ArrayLength := NLST;
    for InnerIndex := 0 to NLST - 1 do
    begin
      SetLength(FParameters[CurrentParameter].Instances[Index].
        Locations[InnerIndex].AuxilliaryVariables, FAuxillaryVariables.Count);
    end;
  end;
  FBoundaryIndex := -1;
end;

procedure TListImporter.ReadNumberOfInstances;
var
  NUMINST: Integer;
  Index: Integer;
  InnerIndex: Integer;
  Param: TListParameterObject;
  Instance: TListInstanceObject;
begin
  Read(FImporter.FFile, NUMINST);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  Param := FParameters[CurrentParameter];
  Param.ArrayLength := NUMINST;
  for Index := 0 to NUMINST - 1 do
  begin
    Instance := Param.Instances[Index];
    Instance.ArrayLength := NLST;
    for InnerIndex := 0 to NLST - 1 do
    begin
      SetLength(Instance.Locations[InnerIndex].AuxilliaryVariables,
        FAuxillaryVariables.Count);
    end;
  end;
end;

procedure TListImporter.ReadInstanceName;
var
  InstanceName: string;
begin
  Readln(FImporter.FFile, InstanceName);
  FImporter.UpdateProgress;
  InstanceName := UpperCase(Trim(InstanceName));
  FParameters[CurrentParameter].Instances[CurrentInstance].Name := InstanceName;
end;

procedure TListImporter.ReadFirstStressPeriodDataSet5WithParameters;
begin
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, NP);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(FCurrentStressPeriod);
  InitializeStressPeriods;
  InitializeCurrentStressPeriod;
end;

procedure TListImporter.ReadFirstStressPeriodDataSet5WithoutParameters;
begin
  ReadLn(FImporter.FFile, ITMP);
  FImporter.UpdateProgress;
  NP := 0;
  Inc(FCurrentStressPeriod);
  InitializeStressPeriods;
  InitializeCurrentStressPeriod;
end;

procedure TListImporter.ReadNewStressPeriodDataSet5WithParameters;
begin
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, NP);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(FCurrentStressPeriod);
  InitializeCurrentStressPeriod;
end;

procedure TListImporter.ReadNewStressPeriodDataSet5WithoutParameters;
begin
  ReadLn(FImporter.FFile, ITMP);
  FImporter.UpdateProgress;
  NP := 0;
  Inc(FCurrentStressPeriod);
  InitializeCurrentStressPeriod;
end;

procedure TListImporter.ReadParamNameForStressPeriod;
var
  ParameterName: string;
begin
  Readln(FImporter.FFile, ParameterName);
  FImporter.UpdateProgress;
  ParameterName := UpperCase(Trim(ParameterName));
  if Length(ParameterName) > 10 then
  begin
    SetLength(ParameterName, 10);
  end;
  FStressPeriods[FCurrentStressPeriod].Parameters[CurrentParameter] :=
    ParameterName;
  Inc(CurrentParameter);
end;

procedure TListImporter.ReleaseMemory;
begin
  if FParameters <> nil then
  begin
    FParameters.ArrayLength := 0;
  end;
  if FStressPeriods <> nil then
  begin
    FStressPeriods.ArrayLength := 0;
  end;
end;

procedure TListImporter.ReadInstanceNameForStressPeriod;
var
  InstanceName: string;
begin
  Readln(FImporter.FFile, InstanceName);
  FImporter.UpdateProgress;
  InstanceName := UpperCase(Trim(InstanceName));
  FStressPeriods[FCurrentStressPeriod].Instances[CurrentParameter - 1] :=
    InstanceName;
end;

{ TGhbInstanceObject }

function TGhbInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TGhbLocationObject;
end;

{ TGhbParameterObject }

function TGhbParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TGhbInstanceObject;
end;

{ TGhbParamArray }

function TGhbParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TGhbParameterObject;
end;

{ TGhbStressPeriod }

function TGhbStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TGhbLocationObject;
end;

{ TGhbStressPeriodArray }

function TGhbStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TGhbStressPeriod;
end;

procedure TListImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, NP);
  Read(FImporter.FFile, DummyInteger); // MXL
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FParameters.ArrayLength := NP;
end;

{ TGhbImporter }

constructor TGhbImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'GHB:');
  FStressPeriods:= TGhbStressPeriodArray.Create;
  FParameters:= TGhbParamArray.Create;
end;

function TGhbImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: Integer; LayerIndex,
  StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject;
begin
  result := inherited CreateScreenObject(List, ScreenObjectIndex, LayerIndex,
    StressPeriodIndex, otPolygon);
  if result <> nil then
  begin
    result.CreateGhbBoundary;
    result.ModflowGhbBoundary.FormulaInterpretation := fiSpecific;
  end;
end;

destructor TGhbImporter.Destroy;
begin
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

function TGhbImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowGhbBoundary;
end;

procedure TGhbImporter.HandlePackage;
var
  ScreenObjectIndex: integer;
  GhbPackage: TModflowPackageSelection;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  inherited;
  GhbPackage := FModel.ModflowPackages.GhbBoundary;
  GhbPackage.IsSelected := True;
  GhbPackage.Comments := FComments;
  AssignObservations;

  ScreenObjectIndex := 0;
  ImportNonParameterBoundaries(ScreenObjectIndex);
  ImportParameterBoundaries(ScreenObjectIndex);
  if FObsImporter <> nil then
  begin
    FObsImporter.HandlePackage;
  end;
  ReleaseMemory;
end;

procedure TGhbImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'NP,MXL:' then
    begin
      ReadDataSet1;
    end
    else if ALabel = 'MXACTB,IGHBCB:' then
    begin
      ReadDataSet2;
    end
    else if ALabel = 'GHBAUX(NAUX):' then
    begin
      ReadAuxilliaryVariableName;
    end
    else if ALabel = 'NOPRINT:' then
    begin
      FNoPrint := True;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
      // do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
    end
    else if ALabel = 'Layer Row Column Bhead  Cond [xyz]:' then
    begin
      ReadParameterLocations;
    end
    else if ALabel = 'ITMP,NP:' then
    begin
      ReadFirstStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadFirstStressPeriodDataSet5WithoutParameters;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,NP:' then
    begin
      ReadNewStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadNewStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'Layer Row Column Bhead  Cond [xyz]:' then
    begin
      ReadNonParameterLocations;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadParamNameForStressPeriod;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

function TGhbImporter.ParameterType: TParameterType;
begin
  result := ptGHB;
end;

procedure TGhbImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, MXACTB);
  Read(FImporter.FFile, IGHBCB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TGhbImporter.ReadNonParameterLocations;
var
  Index: Integer;
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  BHead: Double;
  GhbBoundary: TGhbLocationObject;
  Conductance: double;
begin
  for BoundaryIndex := 0 to ITMP - 1 do
  begin
    GhbBoundary := FStressPeriods[FCurrentStressPeriod].
      Boundaries[CurrentInstance] as TGhbLocationObject;
    Read(FImporter.FFile, LAYER);
    GhbBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    GhbBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    GhbBoundary.Column := Column;
    Read(FImporter.FFile, BHead);
    GhbBoundary.BHead := BHead;
    Read(FImporter.FFile, Conductance);
    GhbBoundary.Conductance := Conductance;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      GhbBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    Inc(CurrentInstance);
  end;
end;

procedure TGhbImporter.ReadParameterLocations;
var
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  BHead: Double;
  Index: Integer;
  GhbBoundary : TGhbLocationObject;
  Conductance: double;
begin
  for BoundaryIndex := 0 to NLST - 1 do
  begin
    GhbBoundary := FParameters[CurrentParameter].Instances[CurrentInstance].
      Locations[BoundaryIndex] as TGhbLocationObject;
    Read(FImporter.FFile, LAYER);
    GhbBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    GhbBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    GhbBoundary.Column := Column;
    Read(FImporter.FFile, BHead);
    GhbBoundary.BHead := BHead;
    Read(FImporter.FFile, Conductance);
    GhbBoundary.Conductance := Conductance;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      GhbBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TGhbImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'GHB');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

function TGhbImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_GHB_'
end;

procedure TGhbImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
var
  GhbBoundary: TGhbLocationObject;
  GhbItem: TGhbItem;
  ValueItem: TValueArrayItem;
  Index: Integer;
  GhbHeadValues: TValueArrayStorage;
  GhbConductanceValues: TValueArrayStorage;
  HeadName: string;
  ConductanceName: string;
  APoint: TPoint2D;
begin
  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  HeadName := 'GhbHead' + ParamName;
  ValueItem.Name := HeadName;
  GhbHeadValues := ValueItem.Values;
  GhbHeadValues.DataType := rdtDouble;
  GhbHeadValues.Count := Boundaries.Count;

  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  ConductanceName := 'GhbConductance' + ParamName;
  ValueItem.Name := ConductanceName;
  GhbConductanceValues := ValueItem.Values;
  GhbConductanceValues.DataType := rdtDouble;
  GhbConductanceValues.Count := Boundaries.Count;

  GhbItem := Item as TGhbItem;
  GhbItem.StartTime := StartTime;
  GhbItem.EndTime := EndTime;
  for Index := 0 to Boundaries.Count - 1 do
  begin
    GhbBoundary := Boundaries[Index];
    APoint := FImporter.CenterPoints[GhbBoundary.Row-1, GhbBoundary.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
      GhbHeadValues.RealValues[Index] := GhbBoundary.BHead;
      GhbConductanceValues.RealValues[Index] := GhbBoundary.Conductance
        / FImporter.CellAreas[GhbBoundary.Row-1, GhbBoundary.Column-1];
    end;
  end;
  GhbItem.BoundaryHead := rsObjectImportedValuesR + '("' + HeadName + '")';
  GhbItem.Conductance := rsObjectImportedValuesR + '("' + ConductanceName
    + '")';
  AssignObservationFactors(ScreenObject, ParamName, Boundaries);
  GhbHeadValues.CacheData;
  GhbConductanceValues.CacheData;
end;

{ TDrnInstanceObject }

function TDrnInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrnLocationObject;
end;

{ TDrnParameterObject }

function TDrnParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrnInstanceObject;
end;

{ TDrnParamArray }

function TDrnParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrnParameterObject;
end;

{ TDrnStressPeriod }

function TDrnStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrnLocationObject;
end;

{ TDrnStressPeriodArray }

function TDrnStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrnStressPeriod;
end;

{ TDrnImporter }

procedure TListImporter.AssignObservations;
var
  StressPeriodIndex: Integer;
  CellList: TList;
begin
  // If observations are used, add the observation group
  // and observation location to each cell that
  // is part of the observation.
  if FObsImporter <> nil then
  begin
    FObsImporter.CreateObservationGroups;
    CellList := TList.Create;
    try
      for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
      begin
        FillListOfCellsForStressPeriod(StressPeriodIndex, CellList);
        AssignObsGroupsToCells(CellList);
      end;
    finally
      CellList.Free;
    end;
  end;
end;

constructor TDrnImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'DRN:');
  FObsImporter := nil;
  FStressPeriods:= TDrnStressPeriodArray.Create;
  FParameters:= TDrnParamArray.Create;
end;

function TDrnImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: Integer; LayerIndex,
  StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject;
begin
  result := inherited CreateScreenObject(List,
    ScreenObjectIndex, LayerIndex, StressPeriodIndex, otPolygon);
  if result <> nil then
  begin
    result.CreateDrnBoundary;
    result.ModflowDrnBoundary.FormulaInterpretation := fiSpecific;
  end;
end;

destructor TDrnImporter.Destroy;
begin
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

procedure TListImporter.AssignObservationFactors(ScreenObject: TScreenObject;
  const ParamName: string; Boundaries: TList);
var
  Location: TLocation;
  ObservationFactors: TList;
  ObservationNames: TStringList;
  ObservationIndex: Integer;
  Values: TValueArrayStorage;
  FactorIndex: Integer;
  ObsCell: TFlowObservationLocation;
  ObsGroup: TObservationGroup;
  Group: TFluxObservationGroup;
  Position: Integer;
  Factor: TObservationFactor;
  Index: Integer;
  ValueItem: TValueArrayItem;
begin
  Assert(Boundaries.Count > 0);
  Location := Boundaries[0];
  if Location.FObservationGroups.Count = 0 then
  begin
    Exit;
  end;
  ObservationFactors := TList.Create;
  ObservationNames := TStringList.Create;
  try
    for ObservationIndex := 0 to Location.FObservationGroups.Count - 1 do
    begin
      ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueItem.Name := 'ObservationFactor_' + ParamName
        + '_' + IntToStr(ObservationIndex + 1);
      ObservationNames.Add(ValueItem.Name);
      Values := ValueItem.Values;
      Values.DataType := rdtDouble;
      Values.Count := Boundaries.Count;
      ObservationFactors.Add(Values);
    end;
    for Index := 0 to Boundaries.Count - 1 do
    begin
      Location := Boundaries[Index];
      for FactorIndex := 0 to ObservationFactors.Count - 1 do
      begin
        Values := ObservationFactors[FactorIndex];
        ObsCell := Location.FObservationCells[FactorIndex];
        Values.RealValues[Index] := ObsCell.FACTOR;
      end;
    end;
    Location := Boundaries[0];
    for ObservationIndex := 0 to Location.FObservationGroups.Count - 1 do
    begin
      ObsGroup := Location.FObservationGroups[ObservationIndex];
      Group := ObsGroup.FGroup;
      Position := Group.AddObject(ScreenObject);
      Factor := Group.ObservationFactors[Position];
      Factor.Factor := rsObjectImportedValuesR + '("'
        + ObservationNames[ObservationIndex] + '")';
    end;
    ScreenObject.ImportedValues.CacheData;
  finally
    ObservationNames.Free;
    ObservationFactors.Free;
  end;
end;

procedure TListImporter.FillListOfCellsForStressPeriod(
  StressPeriodIndex: Integer; CellList: TList);
var
  Instance: TListInstanceObject;
  InstanceCount: Integer;
  ParPosition: Integer;
  Param: TListParameterObject;
  ParamIndex: Integer;
  BoundaryCell: TLocation;
  CellIndex: Integer;
  StressPeriodData: TListStressPeriod;
  APoint: TPoint2D;
begin
  CellList.Clear;
  StressPeriodData := FStressPeriods[StressPeriodIndex];
  for CellIndex := 0 to StressPeriodData.ArrayLength - 1 do
  begin
    BoundaryCell := StressPeriodData[CellIndex];
    APoint := FImporter.CenterPoints[BoundaryCell.Row-1, BoundaryCell.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
      CellList.Add(BoundaryCell);
    end;
  end;
  for ParamIndex := 0 to FParameters.ArrayLength - 1 do
  begin
    Param := FParameters[ParamIndex];
    ParPosition := StressPeriodData.IndexOfParameter(Param.PARNAM);
    if ParPosition >= 0 then
    begin
      InstanceCount := Param.ArrayLength;
      if InstanceCount > 1 then
      begin
        Instance := Param.GetInstanceByName(
          StressPeriodData.Instances[ParPosition]);
      end
      else
      begin
        Instance := Param[0];
      end;
      for CellIndex := 0 to Instance.ArrayLength - 1 do
      begin
        BoundaryCell := Instance[CellIndex];
        APoint := FImporter.CenterPoints[BoundaryCell.Row-1, BoundaryCell.Column-1];
        if (FImporter.FImportParameters.Outline = nil)
          or FImporter.FImportParameters.Outline.PointInside(APoint) then
        begin
          CellList.Add(BoundaryCell);
        end;
      end;
    end;
  end;
end;

function TDrnImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowDrnBoundary;
end;

procedure TDrnImporter.HandlePackage;
var
  ScreenObjectIndex: integer;
  DrnPackage: TModflowPackageSelection;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  inherited;
  DrnPackage := FModel.ModflowPackages.DrnPackage;
  DrnPackage.IsSelected := True;
  DrnPackage.Comments := FComments;
  AssignObservations;

  ScreenObjectIndex := 0;
  ImportNonParameterBoundaries(ScreenObjectIndex);
  ImportParameterBoundaries(ScreenObjectIndex);
  if FObsImporter <> nil then
  begin
    FObsImporter.HandlePackage;
  end;
  ReleaseMemory;
end;

procedure TDrnImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'NP,MXL:' then
    begin
      ReadDataSet1;
    end
    else if ALabel = 'MXACTD,IDRNCB:' then
    begin
      ReadDataSet2;
    end
    else if ALabel = 'DRNAUX(NAUX):' then
    begin
      ReadAuxilliaryVariableName;
    end
    else if ALabel = 'NOPRINT:' then
    begin
      FNoPrint := True;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
      // do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
    end
    else if ALabel = 'Layer Row Column Elevation  Cond [xyz]:' then
    begin
      ReadParameterLocations;
    end
    else if ALabel = 'ITMP,NP:' then
    begin
      ReadFirstStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadFirstStressPeriodDataSet5WithoutParameters;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,NP:' then
    begin
      ReadNewStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadNewStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'Layer Row Column Elevation  Cond [xyz]:' then
    begin
      ReadNonParameterLocations;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadParamNameForStressPeriod;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

function TDrnImporter.ParameterType: TParameterType;
begin
  result := ptDRN;
end;

procedure TDrnImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, MXACTD);
  Read(FImporter.FFile, IDRNCB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TDrnImporter.ReadNonParameterLocations;
var
  Index: Integer;
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  DrnBoundary: TDrnLocationObject;
  Conductance: double;
  Elevation: double;
begin
  for BoundaryIndex := 0 to ITMP - 1 do
  begin
    DrnBoundary := FStressPeriods[FCurrentStressPeriod].
      Boundaries[CurrentInstance] as TDrnLocationObject;
    Read(FImporter.FFile, LAYER);
    DrnBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    DrnBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    DrnBoundary.Column := Column;
    Read(FImporter.FFile, Elevation);
    DrnBoundary.Elevation := Elevation;
    Read(FImporter.FFile, Conductance);
    DrnBoundary.Conductance := Conductance;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      DrnBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    Inc(CurrentInstance);
  end;
end;

procedure TDrnImporter.ReadParameterLocations;
var
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  Index: Integer;
  DrnBoundary : TDrnLocationObject;
  Conductance: double;
  Elevation: double;
begin
  for BoundaryIndex := 0 to NLST - 1 do
  begin
    DrnBoundary := FParameters[CurrentParameter].Instances[CurrentInstance].
      Locations[BoundaryIndex] as TDrnLocationObject;
    Read(FImporter.FFile, LAYER);
    DrnBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    DrnBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    DrnBoundary.Column := Column;
    Read(FImporter.FFile, Elevation);
    DrnBoundary.Elevation := Elevation;
    Read(FImporter.FFile, Conductance);
    DrnBoundary.Conductance := Conductance;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      DrnBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TDrnImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'DRN');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

function TDrnImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_DRN_'
end;

procedure TDrnImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
var
  DrnBoundary: TDrnLocationObject;
  DrnItem: TDrnItem;
  ValueItem: TValueArrayItem;
  Index: Integer;
  DrnHeadValues: TValueArrayStorage;
  DrnConductanceValues: TValueArrayStorage;
  DrnElevName: string;
  ConductanceName: string;
  APoint: TPoint2D;
begin
  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  DrnElevName := 'DrnElevation' + ParamName;
  ValueItem.Name := DrnElevName;
  DrnHeadValues := ValueItem.Values;
  DrnHeadValues.DataType := rdtDouble;
  DrnHeadValues.Count := Boundaries.Count;

  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  ConductanceName := 'DrnConductance' + ParamName;
  ValueItem.Name := ConductanceName;
  DrnConductanceValues := ValueItem.Values;
  DrnConductanceValues.DataType := rdtDouble;
  DrnConductanceValues.Count := Boundaries.Count;

  DrnItem := Item as TDrnItem;
  DrnItem.StartTime := StartTime;
  DrnItem.EndTime := EndTime;
  for Index := 0 to Boundaries.Count - 1 do
  begin
    DrnBoundary := Boundaries[Index];
    APoint := FImporter.CenterPoints[DrnBoundary.Row-1, DrnBoundary.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
      DrnHeadValues.RealValues[Index] := DrnBoundary.Elevation;
      DrnConductanceValues.RealValues[Index] := DrnBoundary.Conductance
        / FImporter.CellAreas[DrnBoundary.Row-1, DrnBoundary.Column-1];
    end;
  end;
  DrnItem.Elevation := rsObjectImportedValuesR + '("' + DrnElevName + '")';
  DrnItem.Conductance := rsObjectImportedValuesR
    + '("' + ConductanceName + '")';

  AssignObservationFactors(ScreenObject, ParamName, Boundaries);
  DrnHeadValues.CacheData;
  DrnConductanceValues.CacheData;
end;

{ TRivInstanceObject }

function TRivInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TRivLocationObject;
end;

{ TRivParameterObject }

function TRivParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TRivInstanceObject;
end;

{ TRivParamArray }

function TRivParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TRivParameterObject;
end;

{ TRivStressPeriod }

function TRivStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TRivLocationObject;
end;

{ TRivStressPeriodArray }

function TRivStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TRivStressPeriod;
end;

{ TRivImporter }

constructor TRivImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'RIV:');
  FStressPeriods:= TRivStressPeriodArray.Create;
  FParameters:= TRivParamArray.Create;
end;

function TRivImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: Integer; LayerIndex,
  StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject;
begin
  result := inherited CreateScreenObject(List,
    ScreenObjectIndex, LayerIndex, StressPeriodIndex, otPolygon);
  if result <> nil then
  begin
    result.CreateRivBoundary;
    result.ModflowRivBoundary.FormulaInterpretation := fiSpecific;
  end;
end;

destructor TRivImporter.Destroy;
begin
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

function TRivImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowRivBoundary
end;

procedure TRivImporter.HandlePackage;
var
  ScreenObjectIndex: integer;
  RivPackage: TModflowPackageSelection;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  inherited;
  RivPackage := FModel.ModflowPackages.RivPackage;
  RivPackage.IsSelected := True;
  RivPackage.Comments := FComments;
  AssignObservations;

  ScreenObjectIndex := 0;
  ImportNonParameterBoundaries(ScreenObjectIndex);
  ImportParameterBoundaries(ScreenObjectIndex);
  if FObsImporter <> nil then
  begin
    FObsImporter.HandlePackage;
  end;
  ReleaseMemory;
end;

procedure TRivImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'NP,MXL:' then
    begin
      ReadDataSet1;
    end
    else if ALabel = 'MXACTR,IRIVCB:' then
    begin
      ReadDataSet2;
    end
    else if ALabel = 'RIVAUX(NAUX):' then
    begin
      ReadAuxilliaryVariableName;
    end
    else if ALabel = 'NOPRINT:' then
    begin
      FNoPrint := True;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
      // do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
    end
    else if ALabel = 'Layer Row Column Stage  Cond Rbot [xyz]:' then
    begin
      ReadParameterLocations;
    end
    else if ALabel = 'ITMP,NP:' then
    begin
      ReadFirstStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadFirstStressPeriodDataSet5WithoutParameters;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,NP:' then
    begin
      ReadNewStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadNewStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'Layer Row Column Stage  Cond Rbot [xyz]:' then
    begin
      ReadNonParameterLocations;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadParamNameForStressPeriod;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

function TRivImporter.ParameterType: TParameterType;
begin
  result := ptRIV;
end;

procedure TRivImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, MXACTR);
  Read(FImporter.FFile, IRIVCB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TRivImporter.ReadNonParameterLocations;
var
  Index: Integer;
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  RivBoundary: TRivLocationObject;
  Conductance: double;
  Stage: double;
  Bottom: double;
begin
  for BoundaryIndex := 0 to ITMP - 1 do
  begin
    RivBoundary := FStressPeriods[FCurrentStressPeriod].
      Boundaries[CurrentInstance] as TRivLocationObject;
    Read(FImporter.FFile, LAYER);
    RivBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    RivBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    RivBoundary.Column := Column;
    Read(FImporter.FFile, Stage);
    RivBoundary.Stage := Stage;
    Read(FImporter.FFile, Conductance);
    RivBoundary.Conductance := Conductance;
    Read(FImporter.FFile, Bottom);
    RivBoundary.Bottom := Bottom;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      RivBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    Inc(CurrentInstance);
  end;
end;

procedure TRivImporter.ReadParameterLocations;
var
  AuxVar: Double;
  BoundaryIndex: Integer;
  LAYER: Integer;
  Row: Integer;
  Column: Integer;
  Index: Integer;
  RivBoundary : TRivLocationObject;
  Conductance: double;
  Stage: double;
  Bottom: double;
begin
  for BoundaryIndex := 0 to NLST - 1 do
  begin
    RivBoundary := FParameters[CurrentParameter].Instances[CurrentInstance].
      Locations[BoundaryIndex] as TRivLocationObject;
    Read(FImporter.FFile, LAYER);
    RivBoundary.Layer := LAYER;
    Read(FImporter.FFile, Row);
    RivBoundary.Row := Row;
    Read(FImporter.FFile, Column);
    RivBoundary.Column := Column;
    Read(FImporter.FFile, Stage);
    RivBoundary.Stage := Stage;
    Read(FImporter.FFile, Conductance);
    RivBoundary.Conductance := Conductance;
    Read(FImporter.FFile, Bottom);
    RivBoundary.Bottom := Bottom;
    for Index := 0 to FAuxillaryVariables.Count - 1 do
    begin
      Read(FImporter.FFile, AuxVar);
      RivBoundary.AuxilliaryVariables[Index] := AuxVar;
    end;
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TRivImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'RIV');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

function TRivImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Riv_'
end;

procedure TRivImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
var
  RivBoundary: TRivLocationObject;
  RivItem: TRivItem;
  ValueItem: TValueArrayItem;
  Index: Integer;
  RivBottomValues: TValueArrayStorage;
  RivStageValues: TValueArrayStorage;
  RivConductanceValues: TValueArrayStorage;
  StageName: string;
  ConductanceName: string;
  BottomName: string;
  APoint: TPoint2D;
begin
  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  StageName := 'RivStage' + ParamName;
  ValueItem.Name := StageName;
  RivStageValues := ValueItem.Values;
  RivStageValues.DataType := rdtDouble;
  RivStageValues.Count := Boundaries.Count;

  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  ConductanceName := 'RivConductance' + ParamName;
  ValueItem.Name := ConductanceName;
  RivConductanceValues := ValueItem.Values;
  RivConductanceValues.DataType := rdtDouble;
  RivConductanceValues.Count := Boundaries.Count;

  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  BottomName := 'RivBottom' + ParamName;
  ValueItem.Name := BottomName;
  RivBottomValues := ValueItem.Values;
  RivBottomValues.DataType := rdtDouble;
  RivBottomValues.Count := Boundaries.Count;

  RivItem := Item as TRivItem;
  RivItem.StartTime := StartTime;
  RivItem.EndTime := EndTime;
  for Index := 0 to Boundaries.Count - 1 do
  begin
    RivBoundary := Boundaries[Index];
    APoint := FImporter.CenterPoints[RivBoundary.Row-1, RivBoundary.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
    RivStageValues.RealValues[Index] := RivBoundary.Stage;
    RivConductanceValues.RealValues[Index] := RivBoundary.Conductance
      / FImporter.CellAreas[RivBoundary.Row-1, RivBoundary.Column-1];
    RivBottomValues.RealValues[Index] := RivBoundary.Bottom;
    end;
  end;
  RivItem.RiverStage := rsObjectImportedValuesR + '("' + StageName + '")';
  RivItem.Conductance := rsObjectImportedValuesR + '("'
    + ConductanceName + '")';
  RivItem.RiverBottom := rsObjectImportedValuesR + '("' + BottomName + '")';
  AssignObservationFactors(ScreenObject, ParamName, Boundaries);
  RivStageValues.CacheData;
  RivConductanceValues.CacheData;
  RivBottomValues.CacheData;
end;

{ TRchImporter }

constructor TRchImporter.Create(Importer: TModflow2005Importer;
  ZoneImporter: TMultZoneImporter);
begin
  inherited Create(Importer, 'RCH:', ZoneImporter);
end;

procedure TRchImporter.CreateBoundary(ScreenObject: TScreenObject);
begin
  ScreenObject.CreateRchBoundary;
end;

procedure TTransientArrayImporter.CreateAssignedLayerDataSet(
  Package: TCustomTransientLayerPackageSelection; DataSetRoot: string;
  ScreenObjectName: string; var AssignedLayerDataSet: TDataArray);
var
  ColumnIndex: Integer;
  Layer: Integer;
  DSAbove: string;
  DSBelow: string;
  ScreenObject: TScreenObject;
  ImportedData: T2DDoubleArray;
  RowIndex: Integer;
begin
  AssignedLayerDataSet := nil;
  ScreenObject := nil;
  if (Package.LayerOption = loSpecified)
    and not Package.TimeVaryingLayers then
  begin
    CheckVariableIntegerArrays(FConstantLayerIndicators,
      FVariableLayerIndicators);
    Assert(not FReuseLayerIndicator[0]);
    CreateTransientDataSet(-1, DataSetRoot, rdtDouble, AssignedLayerDataSet);
    if (FConstantLayerIndicators <> nil)
      and FConstantLayerIndicators[0].IsConstant then
    begin
      Layer := FConstantLayerIndicators[0].IntegerValue;
      Layer := FModel.ModflowLayerToDataSetLayer(Layer);
      DSAbove := FModel.LayerStructure.LayerGroups[Layer].DataArrayName;
      DSBelow := FModel.LayerStructure.LayerGroups[Layer + 1].DataArrayName;
      AssignedLayerDataSet.Formula := '(' + DSAbove + ' + ' + DSBelow + ')/2';
    end
    else
    begin
      AssignedLayerDataSet.Formula := '0';
      Assert(FVariableLayerIndicators <> nil);
      Assert(FVariableLayerIndicators[0] <> nil);
      if ScreenObject = nil then
      begin
        CreateOrRetrieveCellCenterScreenObject(ScreenObject);
//        ScreenObject.Name := ScreenObjectName;
      end;
      SetLength(ImportedData, FGrid.RowCount, FGrid.ColumnCount);
      for RowIndex := 0 to FGrid.RowCount - 1 do
      begin
        for ColumnIndex := 0 to FGrid.ColumnCount - 1 do
        begin
          Layer := FVariableLayerIndicators[0, RowIndex, ColumnIndex];
          Layer := FModel.ModflowLayerToDataSetLayer(Layer);
          ImportedData[RowIndex, ColumnIndex] :=
            FGrid.LayerCenter(ColumnIndex, RowIndex, Layer);
        end;
      end;
      AssignRealValuesToCellCenters(AssignedLayerDataSet,
        ScreenObject, ImportedData);
    end;
  end;
end;

procedure TTransientArrayImporter.ReadVariableIntArray(
  var VariableIntArray: T3DIntArray);
begin
  if VariableIntArray = nil then
  begin
    SetLength(VariableIntArray, FModel.ModflowStressPeriods.Count);
  end;
  SetLength(VariableIntArray[FCurrentStressPeriod],
    FGrid.RowCount, FGrid.ColumnCount);
  ReadVariable2DIntArray(VariableIntArray[FCurrentStressPeriod]);
end;

procedure TTransientArrayImporter.ReadConstantIntArray(IntValue: Integer;
  var ConstantIntArray: TIntegerConstantArray);
var
  Index: Integer;
begin
  if ConstantIntArray = nil then
  begin
    SetLength(ConstantIntArray, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(ConstantIntArray) - 1 do
    begin
      ConstantIntArray[Index].IsConstant := False;
      ConstantIntArray[Index].IntegerValue := 0;
    end;
  end;
  ConstantIntArray[FCurrentStressPeriod].IsConstant := True;
  ConstantIntArray[FCurrentStressPeriod].IntegerValue := IntValue;
  FImporter.UpdateProgress;
end;

procedure TTransientArrayImporter.ReadRealVariableArray(
  var VariableArray: T3DDoubleArray; const ArrayName: string);
begin
  if VariableArray = nil then
  begin
    SetLength(VariableArray, FModel.ModflowStressPeriods.Count);
  end;
  SetLength(VariableArray[FCurrentStressPeriod],
    FGrid.RowCount, FGrid.ColumnCount);
  Read2DRealArray(VariableArray[FCurrentStressPeriod], ArrayName);
end;

procedure TTransientArrayImporter.ReadRealConstantArrayItem(Value: Double;
  var RealConstantArray: TRealConstantRecordArray);
var
  Index: Integer;
begin
  if RealConstantArray = nil then
  begin
    SetLength(RealConstantArray, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(RealConstantArray) - 1 do
    begin
      RealConstantArray[Index].IsConstant := False;
      RealConstantArray[Index].RealValue := 0;
    end;
  end;
  RealConstantArray[FCurrentStressPeriod].IsConstant := True;
  RealConstantArray[FCurrentStressPeriod].RealValue := Value;
  FImporter.UpdateProgress;
end;

constructor TTransientArrayImporter.Create(Importer: TModflow2005Importer;
  const PackageIdentifier: string; ZoneImporter: TMultZoneImporter);
begin
  inherited Create(Importer, PackageIdentifier);
  FZoneImporter := ZoneImporter;
  CurrentParameter := -1;
  FCurrentStressPeriod := -1;
  FParams:= TArrayParamArray.Create;
  FStressPeriods:= TArrayStressPeriodArray.Create;
end;

destructor TTransientArrayImporter.Destroy;
begin
  FStressPeriods.Free;
  FParams.Free;
  FQuadTree.Free;
  inherited;
end;

procedure TTransientArrayImporter.InitializeEpsilon;
begin
  GlobalInitializeEpsilon(FEpsilon, FGrid);
end;

procedure TTransientArrayImporter.ImportSharedData(const ALabel: string;
  out Handled: boolean);
begin
  Handled := True;
  if ALabel = 'NP:' then
  begin
    ReadNumberOfParameters;
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadParameterName;
  end
  else if ALabel = 'PARTYP:' then
  begin
    ReadParameterType(FRequiredType);
  end
  else if ALabel = 'Parval:' then
  begin
    ReadParameterValue;
  end
  else if ALabel = 'NCLU:' then
  begin
    ReadNumberOfClusters;
  end
  else if ALabel = 'NUMINST:' then
  begin
    ReadNumberOfInstances;
  end
  else if ALabel = 'INAME(ILOC):' then
  begin
    ReadInstanceName;
  end
  else if ALabel = 'MULTIPLIER ARRAY AND ZONE ARRAY:' then
  begin
    ReadMultiplierAndZoneArrayNames;
  end
  else if ALabel = 'NUMBER OF ZONES:' then
  begin
    ReadNumberOfZones;
  end
  else if ALabel = 'ZONE VALUES:' then
  begin
    ReadZoneValues;
  end
  else if ALabel = 'Pname:' then
  begin
    ReadParameterForStressPeriod;
  end
  else if ALabel = 'Iname:' then
  begin
    ReadInstanceForStressPeriod;
  end
  else
  begin
    Handled := False;
  end;
end;

procedure TTransientArrayImporter.ReadInstanceForStressPeriod;
var
  Iname: string;
begin
  ReadLn(FImporter.FFile, Iname);
  FImporter.UpdateProgress;
  Iname := Trim(Iname);
  FStressPeriods[FCurrentStressPeriod].Instances[CurrentParameter - 1] := Iname;
end;

procedure TTransientArrayImporter.ReadParameterForStressPeriod;
var
  PNAME: string;
begin
  ReadLn(FImporter.FFile, Pname);
  FImporter.UpdateProgress;
  Pname := Trim(Pname);
  FStressPeriods[FCurrentStressPeriod].Parameters[CurrentParameter] := Pname;
  Inc(CurrentParameter);
end;

procedure TTransientArrayImporter.ReadZoneValues;
var
  Zone: Integer;
  Index: Integer;
begin
  for Index := 0 to ZoneCount - 1 do
  begin
    Read(FImporter.FFile, Zone);
    FParams[CurrentParameter].Instances[CurrentInstance].
      Clusters[CurrentCluster].Zones[Index] := Zone;
  end;
  Inc(CurrentCluster);
  if CurrentCluster = NCLU then
  begin
    Inc(CurrentInstance);
  end;
end;

procedure TTransientArrayImporter.ReadNumberOfZones;
begin
  Readln(FImporter.FFile, ZoneCount);
  FImporter.UpdateProgress;
  SetLength(FParams[CurrentParameter].Instances[CurrentInstance].
    Clusters[CurrentCluster].Zones, ZoneCount);
end;

procedure TTransientArrayImporter.ReadMultiplierAndZoneArrayNames;
var
  ZoneName: string;
  MultiplierName: string;
begin
  Readln(FImporter.FFile, MultiplierName);
  MultiplierName := Copy(Trim(MultiplierName), 1, 10);
  Readln(FImporter.FFile, ZoneName);
  ZoneName := Copy(Trim(ZoneName), 1, 10);
  FImporter.UpdateProgress;
  MultiplierName := Trim(MultiplierName);
  ZoneName := Trim(ZoneName);
  FParams[CurrentParameter].Instances[CurrentInstance].
    Clusters[CurrentCluster].MultiplierArray := MultiplierName;
  FParams[CurrentParameter].Instances[CurrentInstance].
    Clusters[CurrentCluster].ZoneArray := ZoneName;
  if UpperCase(ZoneName) = 'ALL' then
  begin
    Inc(CurrentCluster);
    if CurrentCluster = NCLU then
    begin
      Inc(CurrentInstance);
    end;
  end;
end;

procedure TTransientArrayImporter.ReadInstanceName;
var
  InstanceName: string;
begin
  Readln(FImporter.FFile, InstanceName);
  FImporter.UpdateProgress;
  InstanceName := Trim(InstanceName);
  FParams[CurrentParameter].Instances[CurrentInstance].Name := InstanceName;
  CurrentCluster := 0;
end;

procedure TTransientArrayImporter.ReadNumberOfInstances;
var
  Index: Integer;
  NUMINST: Integer;
begin
  Readln(FImporter.FFile, NUMINST);
  FImporter.UpdateProgress;
  if NUMINST = 0 then
  begin
    NUMINST := 1;
  end;
  FParams[CurrentParameter].ArrayLength := NUMINST;
  for Index := 0 to NUMINST - 1 do
  begin
    FParams[CurrentParameter].Instances[Index].ArrayLength := NCLU;
  end;
end;

procedure TTransientArrayImporter.ReadNumberOfClusters;
begin
  Readln(FImporter.FFile, NCLU);
  FImporter.UpdateProgress;
  FParams[CurrentParameter].ArrayLength := 1;
  FParams[CurrentParameter].Instances[0].ArrayLength := NCLU;
end;

procedure TTransientArrayImporter.ReadParameterValue;
var
  Parval: Double;
begin
  Readln(FImporter.FFile, Parval);
  FImporter.UpdateProgress;
  FParams[CurrentParameter].Parval := Parval;
end;

procedure TTransientArrayImporter.ReadParameterType(RequiredType: string);
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  Assert(PARTYP = RequiredType);
  FParams[CurrentParameter].PARTYP := PARTYP;
end;

procedure TTransientArrayImporter.ReadParameterName;
var
  PNAME: string;
begin
  Readln(FImporter.FFile, PNAME);
  FImporter.UpdateProgress;
  PNAME := Trim(PNAME);
  Inc(CurrentParameter);
  FParams[CurrentParameter].PARNAM := PNAME;
  CurrentInstance := 0;
  CurrentCluster := 0;
  FParams[CurrentParameter].ArrayLength := 1;
end;

procedure TTransientArrayImporter.ReadNumberOfParameters;
begin
  ReadLn(FImporter.FFile, NP);
  FImporter.UpdateProgress;
  FParams.ArrayLength := NP;
end;

procedure TTransientArrayImporter.CreateScreenObjectsFromClusters(
  Param: TArrayParameterObject; var ObjectIndex: Integer;
  ScreenObjectList, ClusterList: TList;
  const ScreenObjectRoot, ImportedElevFormula: string;
  Package: TCustomTransientLayerPackageSelection);
var
  Cluster: TClusterObject;
  ClusterIndex: Integer;
  InstanceIndex: Integer;
  Instance: TArrayInstanceObject;
begin
  for InstanceIndex := 0 to Param.ArrayLength - 1 do
  begin
    Instance := Param[InstanceIndex];
    for ClusterIndex := 0 to Instance.ArrayLength - 1 do
    begin
      Cluster := Instance[ClusterIndex];
      CreateScreenObjectFromCluster(ClusterList, ScreenObjectList,
        ObjectIndex, Cluster, ScreenObjectRoot, ImportedElevFormula,
        Package);
    end;
  end;
end;

procedure TTransientArrayImporter.CreateTransientParam(
  Param: TArrayParameterObject);
var
  ArrayParam: TModflowTransientListParameter;
begin
  ArrayParam := FModel.ModflowTransientParameters.Add
    as TModflowTransientListParameter;
  ArrayParam.ParameterName := Param.PARNAM;
  Param.ModifiedParamName := ArrayParam.ParameterName;
  if AnsiCompareText(Param.PARTYP, 'RCH') = 0 then
  begin
    ArrayParam.ParameterType := ptRCH;
  end
  else if AnsiCompareText(Param.PARTYP, 'EVT') = 0 then
  begin
    ArrayParam.ParameterType := ptEVT;
  end
  else if AnsiCompareText(Param.PARTYP, 'ETS') = 0 then
  begin
    ArrayParam.ParameterType := ptETS;
  end
  else
  begin
    Assert(False);
  end;
  ArrayParam.Value := Param.Parval;
end;

procedure TRchImporter.AssignRechRateNonParam(RechargeName: string;
  NewItemNeeded: Boolean; var RchItem: TRchItem; RchBoundary: TRchBoundary;
  StressPeriodIndex: Integer);
begin
  if NewItemNeeded then
  begin
    RchItem := RchBoundary.Values.Add as TRchItem;
    RchItem.RechargeRate := RechargeName;
    RchItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    RchItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end
  else
  begin
    RchItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end;
end;

procedure TRchImporter.AssignRchLayerNonParam(NewItemNeeded: Boolean;
  var LayerItem: TRchLayerItem; RchBoundary: TRchBoundary;
  RechargeLayerName: string; StressPeriodIndex: Integer);
begin
  if FRchPackage.TimeVaryingLayers then
  begin
    if NewItemNeeded then
    begin
      LayerItem := RchBoundary.RechargeLayers.Add as TRchLayerItem;
      LayerItem.RechargeLayer := RechargeLayerName;
      LayerItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

procedure TRchImporter.CreateRechargeRateDataSet(StressPeriodIndex: Integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseRecharge,
    StrImportedRechargeSt, FConstantRecharge, FVariableRecharge,
    'Imported_RCH_Values_SP_');
end;

procedure TRchImporter.AssignParamRechargeRate(ScreenObject: TScreenObject;
  StressPeriodIndex: Integer; Cluster: TClusterObject;
  Param: TArrayParameterObject);
var
  RchItem: TRchItem;
  ParamItem: TRchParamItem;
begin
  ParamItem := ScreenObject.ModflowRchBoundary.Parameters.
    GetParamByName(Param.ModifiedParamName) as TRchParamItem;
  if ParamItem = nil then
  begin
    ParamItem := ScreenObject.ModflowRchBoundary.
      Parameters.Add as TRchParamItem;
    ParamItem.Param.ParamName := Param.ModifiedParamName;
  end;
  RchItem := ParamItem.Param.Add as TRchItem;
  RchItem.StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
  RchItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  if AnsiCompareText(Cluster.MultiplierArray, 'NONE') = 0 then
  begin
    RchItem.RechargeRate := '1';
  end
  else
  begin
    RchItem.RechargeRate := FixArrayName(Cluster.MultiplierArray);
  end;
end;

procedure TRchImporter.AssignTimeVaryingLayer(ScreenObject: TScreenObject;
  RechargeLayerName: string; StressPeriodIndex: Integer);
var
  LayerItem: TRchLayerItem;
  RchBoundary: TRchBoundary;
begin
  if FRchPackage.TimeVaryingLayers then
  begin
    RchBoundary := ScreenObject.ModflowRchBoundary;
    if not FReuseLayerIndicator[StressPeriodIndex] then
    begin
      LayerItem := RchBoundary.RechargeLayers.Add as TRchLayerItem;
      LayerItem.RechargeLayer := RechargeLayerName;
      LayerItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      LayerItem := RchBoundary.RechargeLayers.
        Items[RchBoundary.RechargeLayers.Count - 1] as TRchLayerItem;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

procedure TTransientArrayImporter.GetParamInstanceForCurrentStressPeriod(
  var Instance: TArrayInstanceObject;
  Param: TArrayParameterObject; StressPeriod: TArrayStressPeriod);
var
  PNameIndex: Integer;
  InstanceName: string;
  ParamUsed: Boolean;
  InstanceIndex: Integer;
begin
  // In each stress period, identify whether the parameter was used.
  // If it was used, identify the intance used.
  ParamUsed := False;
  InstanceName := '';
  for PNameIndex := 0 to Length(StressPeriod.Parameters) - 1 do
  begin
    if AnsiCompareText(StressPeriod.Parameters[PNameIndex],
      Param.PARNAM) = 0 then
    begin
      ParamUsed := True;
      InstanceName := '';
      if PNameIndex < Length(StressPeriod.Instances) then
      begin
        InstanceName := StressPeriod.Instances[PNameIndex];
      end;
      break;
    end;
  end;
  Instance := nil;
  if ParamUsed then
  begin
    for InstanceIndex := 0 to Param.GetArrayLength - 1 do
    begin
      Instance := Param.Instances[InstanceIndex];
      if AnsiCompareText(InstanceName, Instance.Name) = 0 then
      begin
        break;
      end;
      Instance := nil;
    end;
  end;
end;

procedure TRchImporter.ReuseRchStressPeriodWithParameters(
  StressPeriodIndex: Integer; Param: TArrayParameterObject;
  ScreenObjectList: TList; const RechargeLayerName: string);
var
  RchItem, NewRchItem: TRchItem;
  ParamItem: TRchParamItem;
  ScreenObject: TScreenObject;
  SO_Index: Integer;
begin
  for SO_Index := 0 to ScreenObjectList.Count - 1 do
  begin
    ScreenObject := ScreenObjectList[SO_Index];
    ParamItem := ScreenObject.ModflowRchBoundary.Parameters.
      GetParamByName(Param.ModifiedParamName) as TRchParamItem;
    if ParamItem <> nil then
    begin
      if ParamItem.Param.Count > 0 then
      begin
        RchItem := ParamItem.Param.Items[ParamItem.Param.Count - 1] as TRchItem;
        if RchItem.EndTime =
          FModel.ModflowStressPeriods[StressPeriodIndex].StartTime then
        begin
          if FRchPackage.TimeVaryingLayers then
          begin
            NewRchItem := ParamItem.Param.Add as TRchItem;
            NewRchItem.Assign(RchItem);
            NewRchItem.StartTime :=
              FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
            NewRchItem.EndTime :=
              FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
          end
          else
          begin
            RchItem.EndTime :=
              FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
          end;
          AssignTimeVaryingLayer(ScreenObject,
            RechargeLayerName, StressPeriodIndex);
        end;
      end;
    end;
  end;
end;

procedure TTransientArrayImporter.EvaluateTimeVaryingLayers(
  Package: TCustomTransientLayerPackageSelection);
var
  Index: Integer;
  TimeVaryingLayers: Boolean;
begin
  TimeVaryingLayers := False;
  if Package.LayerOption = loSpecified then
  begin
    for Index := 1 to Length(FReuseLayerIndicator) - 1 do
    begin
      if not FReuseLayerIndicator[Index] then
      begin
        TimeVaryingLayers := True;
        break;
      end;
    end;
  end;
  Package.TimeVaryingLayers := TimeVaryingLayers;
end;

procedure TRchImporter.SetRechargeOption;
var
  Option: Integer;
begin
  Option := NRCHOP - 1;
  if Option < 0 then
  begin
    Option := 0;
  end;
  if Option > 2 then
  begin
    Option := 2;
  end;
  FRchPackage.LayerOption := TLayerOption(Option);
end;

procedure TTransientArrayImporter.CreateTimeVaryingAssignedLayerDataSet(
  StressPeriodIndex: Integer; const DataSetRoot, ScreenObjectRoot: string;
  Package: TCustomTransientLayerPackageSelection);
var
  AssignedLayerDataSet: TDataArray;
  ScreenObject: TScreenObject;
  ValueList: TIntegerList;
  Values: T2DIntArray;
  MaxCount: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Value: Integer;
  Root: string;
begin
  ScreenObject := nil;
  if Package.TimeVaryingLayers then
  begin
    if not FReuseLayerIndicator[StressPeriodIndex] then
    begin
      CreateTransientDataSet(StressPeriodIndex, DataSetRoot, rdtInteger,
        AssignedLayerDataSet);
      AssignedLayerDataSet.Comment := AssignedLayerDataSet.Comment
        + sLineBreak + Format('Stress Period: %d', [StressPeriodIndex+1]);
      if (FConstantLayerIndicators <> nil)
        and FConstantLayerIndicators[StressPeriodIndex].IsConstant then
      begin
        AssignedLayerDataSet.Formula :=
          IntToStr(FConstantLayerIndicators[StressPeriodIndex].IntegerValue);
      end
      else
      begin
        AssignedLayerDataSet.Formula := '0';
        Assert(FVariableLayerIndicators <> nil);
        Assert(FVariableLayerIndicators[StressPeriodIndex] <> nil);

        ValueList := TIntegerList.Create;
        try
          ValueList.Sorted := True;
          Values := FVariableLayerIndicators[StressPeriodIndex];
//          MaxCount := Min((Length(Values) * Length(Values[0])) div 10, 100);
          MaxCount := 2;
          for RowIndex := 0 to Length(Values) - 1 do
          begin
            for ColIndex := 0 to Length(Values[0]) - 1 do
            begin
              Value := Values[RowIndex,ColIndex];
              ValueList.AddUnique(Value);
              if ValueList.Count >= MaxCount then
              begin
                break;
              end;
            end;
            if ValueList.Count >= MaxCount then
            begin
              break;
            end;
          end;
          if ValueList.Count >= MaxCount then
          begin
            if ScreenObject = nil then
            begin
              CreateOrRetrieveCellCenterScreenObject(ScreenObject);
//              ScreenObject.Name := ScreenObjectRoot
//                + GetStressPeriodString(StressPeriodIndex);
            end;
            AssignIntegerValuesToCellCenters(AssignedLayerDataSet, ScreenObject,
              FVariableLayerIndicators[StressPeriodIndex]);
          end
          else if ValueList.Count = 1 then
          begin
            AssignedLayerDataSet.Formula :=
              IntToStr(ValueList[0]);
          end
          else
          begin
            Root := ScreenObjectRoot
              + GetStressPeriodString(StressPeriodIndex) + '_Obj_';
            CreateScreenObjectsAroundValues(Values, Root,
              AssignedLayerDataSet, ValueList);
          end;
        finally
          ValueList.Free;
          FVariableLayerIndicators[StressPeriodIndex] := nil;
        end
      end;
    end;
  end;
end;

procedure TTransientArrayImporter.CreateScreenObjectFromCluster(ClusterList,
  ScreenObjectList: TList; var ObjectIndex: Integer; Cluster: TClusterObject;
  const ScreenObjectRoot, ImportedElevFormula: string;
  Package: TCustomTransientLayerPackageSelection);
var
  ScreenObject: TScreenObject;
  ZoneIndex: Integer;
  ZoneValue: Integer;
  InnerZoneIndex: Integer;
  ZoneArray: T2DIntArray;
  ZoneName: string;
begin
  if not FindSimilarClusterAndAddScreenObject(Cluster,
    ClusterList, ScreenObjectList) then
  begin
    Inc(ObjectIndex);
    if UpperCase(Cluster.ZoneArray) = 'ALL' then
    begin
      ScreenObject := CreateScreenObjectAroundGrid(ScreenObjectRoot
        + IntToStr(ObjectIndex));
      ScreenObject.ElevationFormula := kModelTop;
    end
    else
    begin
      ScreenObject := nil;
      ZoneName := FixArrayName(Cluster.ZoneArray);
      if Length(ZoneName) > 10 then
      begin
        SetLength(ZoneName, 10);
      end;
      ZoneIndex := FZoneImporter.IndexOfZone(ZoneName);
      Assert(ZoneIndex >= 0);
      if FZoneImporter.ConstantZone(ZoneIndex, ZoneValue) then
      begin
        if ZoneValue <> 0 then
        begin
          for InnerZoneIndex := 0 to Length(Cluster.Zones) - 1 do
          begin
            if ZoneValue = Cluster.Zones[InnerZoneIndex] then
            begin
              ScreenObject := CreateScreenObjectAroundGrid(ScreenObjectRoot
                + IntToStr(ObjectIndex));
              ScreenObject.ElevationFormula := kModelTop;
              break;
            end;
          end;
        end;
      end
      else
      begin
        ZoneArray := FZoneImporter.ZoneArray(ZoneIndex);
        ScreenObject := CreateScreenObjectAroundZones(ZoneArray, Cluster,
          ScreenObjectRoot + IntToStr(ObjectIndex));
        ScreenObject.ElevationFormula := kModelTop;
      end;
    end;
    if ScreenObject <> nil then
    begin
      ClusterList.Add(Cluster);
      ScreenObjectList.Add(ScreenObject);
      CreateBoundary(ScreenObject);
      if (Package.LayerOption = loSpecified)
        and not Package.TimeVaryingLayers then
      begin
        ScreenObject.ElevationFormula := ImportedElevFormula;
      end
      else
      begin
        ScreenObject.ElevationFormula := '('
          + FModel.LayerStructure.LayerGroups[0].DataArrayName
          + ' + '
          + FModel.LayerStructure.LayerGroups[1].DataArrayName
          + ') / 2'
      end;
    end;
  end;
end;

procedure TTransientArrayImporter.InitializeQuadTree;
begin
  GlobalInitializeQuadTree(FQuadTree, FGrid);
end;

procedure TTransientArrayImporter.ImportSegments(Sender: TObject;
  const Segments: TLine2DArray);
begin
  GlobalImportSegments(Sender, Segments, FEpsilon, FQuadTree, FPointLists);
end;

procedure TTransientArrayImporter.CreateScreenObjectsAroundValues(
  Values: T2DDoubleArray; const Root: string; DataArray: TDataArray;
  ValueList: TRealList);
var
  RowIndex: Integer;
  ColIndex: Integer;

  Value: Double;
  ContourGrid: T2DGrid;
  MaxRow: Integer;
  MaxCol: Integer;
  ContourCreator: TContourCreator;
  Capacity: Integer;
  PointListIndex: Integer;
  PointList: TPointList;
  ScreenObject: TScreenObject;
  PointIndex: Integer;
  ValueIndex: Integer;
  DSIndex: Integer;
begin
  ContourGrid := FGrid.ContourGrid(eaBlocks, msModflow, vdTop, 0);
  Assert(ContourGrid <> nil);
  MaxRow := Length(ContourGrid[0]) - 1;
  MaxCol := Length(ContourGrid) - 1;
  Assert(ValueList.Count > 1);

  for RowIndex := 0 to MaxRow do
  begin
    for ColIndex := 0 to MaxCol do
    begin
      ContourGrid[ColIndex,RowIndex].Value := 0;
      ContourGrid[ColIndex,RowIndex].Active := True;
    end;
  end;

  FPointLists:= TObjectList<TPointList>.Create;
  ContourCreator:= TContourCreator.Create(100);
  try
    InitializeEpsilon;

    ContourCreator.EvaluatedAt := eaBlocks;
    ContourCreator.Grid := ContourGrid;
    ContourCreator.OnExtractSegments := ImportSegments;
    ContourCreator.Value := 1;

    for ValueIndex := 0 to ValueList.Count - 1 do
    begin
      ScreenObject := CreateScreenObject(Root + IntToStr(ValueIndex+1));
      ScreenObject.ElevationCount := ecZero;
      Value := ValueList[ValueIndex];
      DSIndex := ScreenObject.AddDataSet(DataArray);
      ScreenObject.DataSetFormulas[DSIndex] :=
        FortranFloatToStr(Value);

      for RowIndex := 0 to Length(Values) - 1 do
      begin
        for ColIndex := 0 to Length(Values[0]) - 1 do
        begin

          if Value = Values[RowIndex,ColIndex] then
          begin
            ContourGrid[ColIndex+1,RowIndex+1].Value := 2;
          end
          else
          begin
            ContourGrid[ColIndex+1,RowIndex+1].Value := 0;
          end;
        end;
      end;
      InitializeQuadTree;
      FPointLists.Clear;

      ContourCreator.ExtractContour;

      Assert(FPointLists.Count> 0);
      Capacity := 0;
      for PointListIndex := 0 to FPointLists.Count - 1 do
      begin
        PointList := FPointLists[PointListIndex];
        Capacity := Capacity + PointList.Count;
      end;
      ScreenObject.Capacity := ScreenObject.Capacity + Capacity;
      for PointListIndex := 0 to FPointLists.Count - 1 do
      begin
        PointList := FPointLists[PointListIndex];
        for PointIndex := 0 to PointList.Count - 1 do
        begin
          if (PointIndex > 0) and (PointIndex < PointList.Count - 1) then
          begin
            if not Collinear(PointList.Points[PointIndex-1],
              PointList.Points[PointIndex],
              PointList.Points[PointIndex+1]) then
            begin
              ScreenObject.AddPoint(PointList.Points[PointIndex], False);
            end;
          end
          else
          begin
            ScreenObject.AddPoint(PointList.Points[PointIndex], PointIndex=0);
          end;
        end;
      end
    end;
  finally
    ContourCreator.Free;
    FPointLists.Free;
  end;
end;

procedure TTransientArrayImporter.CreateScreenObjectsAroundValues(
  Values: T2DIntArray; const Root: string; DataArray: TDataArray;
  ValueList: TIntegerList);
var
  RowIndex: Integer;
  ColIndex: Integer;

  Value: integer;
  ContourGrid: T2DGrid;
  MaxRow: Integer;
  MaxCol: Integer;
  ContourCreator: TContourCreator;
  Capacity: Integer;
  PointListIndex: Integer;
  PointList: TPointList;
  ScreenObject: TScreenObject;
  PointIndex: Integer;
  ValueIndex: Integer;
  DSIndex: Integer;
begin
  ContourGrid := FGrid.ContourGrid(eaBlocks, msModflow, vdTop, 0);
  Assert(ContourGrid <> nil);
  MaxRow := Length(ContourGrid[0]) - 1;
  MaxCol := Length(ContourGrid) - 1;
  Assert(ValueList.Count > 1);

  for RowIndex := 0 to MaxRow do
  begin
    for ColIndex := 0 to MaxCol do
    begin
      ContourGrid[ColIndex,RowIndex].Value := 0;
      ContourGrid[ColIndex,RowIndex].Active := True;
    end;
  end;

  FPointLists:= TObjectList<TPointList>.Create;

  ContourCreator:= TContourCreator.Create(100);
  try
    InitializeEpsilon;

    ContourCreator.EvaluatedAt := eaBlocks;
    ContourCreator.Grid := ContourGrid;
    ContourCreator.OnExtractSegments := ImportSegments;
    ContourCreator.Value := 1;

    for ValueIndex := 0 to ValueList.Count - 1 do
    begin
      ScreenObject := CreateScreenObject(Root + IntToStr(ValueIndex+1));
      ScreenObject.ElevationCount := ecZero;
      Value := ValueList[ValueIndex];
      DSIndex := ScreenObject.AddDataSet(DataArray);
      ScreenObject.DataSetFormulas[DSIndex] :=
        FortranFloatToStr(Value);

      for RowIndex := 0 to Length(Values) - 1 do
      begin
        for ColIndex := 0 to Length(Values[0]) - 1 do
        begin

          if Value = Values[RowIndex,ColIndex] then
          begin
            ContourGrid[ColIndex+1,RowIndex+1].Value := 2;
          end
          else
          begin
            ContourGrid[ColIndex+1,RowIndex+1].Value := 0;
          end;
        end;
      end;
      InitializeQuadTree;
      FPointLists.Clear;

      ContourCreator.ExtractContour;

      Assert(FPointLists.Count> 0);
      Capacity := 0;
      for PointListIndex := 0 to FPointLists.Count - 1 do
      begin
        PointList := FPointLists[PointListIndex];
        Capacity := Capacity + PointList.Count;
      end;
      ScreenObject.Capacity := ScreenObject.Capacity + Capacity;
      for PointListIndex := 0 to FPointLists.Count - 1 do
      begin
        PointList := FPointLists[PointListIndex];
        for PointIndex := 0 to PointList.Count - 1 do
        begin
          if (PointIndex > 0) and (PointIndex < PointList.Count - 1) then
          begin
            if not Collinear(PointList.Points[PointIndex-1],
              PointList.Points[PointIndex],
              PointList.Points[PointIndex+1]) then
            begin
              ScreenObject.AddPoint(PointList.Points[PointIndex], False);
            end;
          end
          else
          begin
            ScreenObject.AddPoint(PointList.Points[PointIndex], PointIndex=0);
          end;
        end;
      end
    end;
  finally
    ContourCreator.Free;
    FPointLists.Free;
  end;
end;

function TTransientArrayImporter.CreateScreenObjectAroundZones(
  ZoneArray: T2DIntArray; Cluster: TClusterObject;
  const Name: string): TScreenObject;
var
  ContourGrid: T2DGrid;
  ColIndex: Integer;
  MaxRow: Integer;
  MaxCol: Integer;
  RowIndex: Integer;
  ZoneIndex: Integer;
  ContourCreator: TContourCreator;
  PointListIndex: Integer;
  Capacity: Integer;
  PointList: TPointList;
  PointIndex: Integer;
  ZoneExists: boolean;
  QPoint: TQuadPoint;
  AnObject: TObject;
begin
  InitializeQuadTree;
  Result := CreateScreenObject(Name);
  Result.ElevationCount := ecOne;
  ContourGrid := FGrid.ContourGrid(eaBlocks, msModflow, vdTop, 0);
  Assert(ContourGrid <> nil);
  MaxRow := Length(ContourGrid[0]) - 1;
  MaxCol := Length(ContourGrid) - 1;
  for ColIndex := 0 to MaxCol do
  begin
    for RowIndex := 0 to MaxRow do
    begin
      ContourGrid[ColIndex,RowIndex].Value := 0;
      ContourGrid[ColIndex,RowIndex].Active := True;
    end;
  end;

  ZoneExists := False;
  for RowIndex := 0 to Length(ZoneArray) - 1 do
  begin
    for ColIndex := 0 to Length(ZoneArray[0]) - 1 do
    begin
      for ZoneIndex := 0 to Length(Cluster.Zones) - 1 do
      begin
        if ZoneArray[RowIndex,ColIndex] = Cluster.Zones[ZoneIndex] then
        begin
          ContourGrid[ColIndex+1,RowIndex+1].Value := 2;
          ZoneExists := True;
          break;
        end;
      end;
    end;
  end;

  if not ZoneExists then
  begin
    result.Deleted := True;
    Exit;
  end;

  FPointLists:= TObjectList<TPointList>.Create;
  ContourCreator:= TContourCreator.Create(100);
  try
    ContourCreator.EvaluatedAt := eaBlocks;
    InitializeEpsilon;

    ContourCreator.Grid := ContourGrid;
    ContourCreator.Value := 1;
    ContourCreator.OnExtractSegments := ImportSegments;
    ContourCreator.ExtractContour;

    Assert(FPointLists.Count> 0);
    Capacity := 0;
    for PointListIndex := 0 to FPointLists.Count - 1 do
    begin
      PointList := FPointLists[PointListIndex];
      Capacity := Capacity + PointList.Count;
    end;
    Result.Capacity := Capacity;
    for PointListIndex := 0 to FPointLists.Count - 1 do
    begin
      PointList := FPointLists[PointListIndex];
      for PointIndex := 0 to PointList.Count - 1 do
      begin
        if (PointIndex > 0) and (PointIndex < PointList.Count - 1) then
        begin
          if not Collinear(PointList.Points[PointIndex-1],
            PointList.Points[PointIndex],
            PointList.Points[PointIndex+1]) then
          begin
            result.AddPoint(PointList.Points[PointIndex], False);
          end;
        end
        else
        begin
          result.AddPoint(PointList.Points[PointIndex], PointIndex=0);
        end;
      end;
    end;
  finally
    for var QPointIndex := FQuadTree.Count - 1 downto 0 do
    begin
      QPoint := FQuadTree.Points[QPointIndex];
      for var QDataIndex := 0 to Length(QPoint.Data) - 1 do
      begin
        AnObject := QPoint.Data[QDataIndex];
        AnObject.Free;
      end;
    end;

    ContourCreator.Free;
    FPointLists.Free;
  end;
end;

procedure TTransientArrayImporter.InitializeCurrentStressPeriod(
  ReadParamArray: Integer);
begin
  if FParams.ArrayLength > 0 then
  begin
    FStressPeriods[FCurrentStressPeriod].Reuse := ReadParamArray < 0;
    if (ReadParamArray > 0) then
    begin
      SetLength(FStressPeriods[FCurrentStressPeriod].Parameters,
        ReadParamArray);
      SetLength(FStressPeriods[FCurrentStressPeriod].Instances,
        ReadParamArray);
    end;
  end;
end;

procedure TTransientArrayImporter.InitializeReuseLayerIndicator;
var
  Index: Integer;
begin
  if FReuseLayerIndicator = nil then
  begin
    SetLength(FReuseLayerIndicator, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(FReuseLayerIndicator) - 1 do
    begin
      FReuseLayerIndicator[Index] := False;
    end;
  end;
end;

procedure TRchImporter.InitializeReuseRecharge;
var
  Index: Integer;
begin
  if FReuseRecharge = nil then
  begin
    SetLength(FReuseRecharge, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(FReuseRecharge) - 1 do
    begin
      FReuseRecharge[Index] := False;
    end;
  end;
end;

procedure TTransientArrayImporter.InitializeStressPeriods;
begin
  FStressPeriods.ArrayLength :=
    FModel.ModflowStressPeriods.Count;
end;

function TTransientArrayImporter.FindSimilarClusterAndAddScreenObject(
  ACluster: TClusterObject;
  ClusterList, ScreenObjectList: TList): boolean;
var
  Index: integer;
  Cluster: TClusterObject;
begin
  result := False;
  for Index := 0 to ClusterList.Count - 1 do
  begin
    Cluster := ClusterList[Index];
    result := ACluster.SimilarMultAndZone(Cluster);
    if result then
    begin
      ClusterList.Add(ACluster);
      ScreenObjectList.Add(ScreenObjectList[Index]);
      break;
    end;
  end;
end;

procedure TRchImporter.HandlePackage;
var
  StressPeriodIndex: Integer;
  ScreenObject: TScreenObject;
  RechargeLayerDataSet: TDataArray;
  NewItemNeeded: Boolean;
  RchBoundary: TRchBoundary;
  RchItem: TRchItem;
  LayerItem: TRchLayerItem;
  RechargeName: string;
  RechargeLayerName: string;
  ParamIndex: Integer;
  Param: TArrayParameterObject;
  Instance: TArrayInstanceObject;
  ClusterIndex: Integer;
  Cluster: TClusterObject;
  ObjectIndex: integer;
  ClusterList: TList;
  ScreenObjectList: TList;
  StressPeriod: TArrayStressPeriod;
  ScreenObIndex: Integer;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  FRchPackage := FModel.ModflowPackages.RchPackage;
  FRchPackage.IsSelected := True;
  FRchPackage.Comments := FComments;
  FRchPackage.AssignmentMethod := umAdd;
  SetRechargeOption;
  EvaluateTimeVaryingLayers(FRchPackage);

  CreateAssignedLayerDataSet(FRchPackage, StrImportedRechargeEl,
    'Imported_RCH_Elevation', RechargeLayerDataSet);

  if RechargeLayerDataSet <> nil then
  begin
    RechargeLayerDataSet.Comment := RechargeLayerDataSet.Comment
      + sLineBreak + 'Stress Period: 1';
  end;
//  AssignSteadyRechargeLayerDataSet(RechargeLayerDataSet);

  if NP > 0 then
  begin
    ClusterList := TList.Create;
    ScreenObjectList := TList.Create;
    try
      ObjectIndex := 0;
      for ParamIndex := 0 to FParams.ArrayLength - 1 do
      begin
        Param := FParams[ParamIndex];
        CreateTransientParam(Param);

        ScreenObjectList.Clear;
        ClusterList.Clear;
        CreateScreenObjectsFromClusters(Param, ObjectIndex,
          ScreenObjectList, ClusterList, 'ImportedRchParam_',
          StrImportedRechargeEl, FRchPackage);
        // At this point, ScreenObjectList contains each TScreenObject
        // that has been created for a particular parameter
        // and Cluster list contains a TClusterObject that has the
        // zone array and zones used to define the geometry of the
        // TScreenObject but not necessarily the corresponding Multiplier
        // array.

        // What need's to be done is to identify the stress periods in which
        // each parameter instance was used and find the corresponding
        // TScreenObjects and assign the formulas for those
        // stress periods using the appropriate multiplier arrays.

        // Loop over stress periods
        for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
        begin
          if ParamIndex = 0 then
          begin
            CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex,
              StrImportedRechargeLa, 'Imported_RCH_Layers_SP_', FRchPackage);
          end;
          if FRchPackage.TimeVaryingLayers and
            (not FReuseLayerIndicator[StressPeriodIndex]) then
          begin
            RechargeLayerName := StrImportedRechargeLa +
              GetStressPeriodString(StressPeriodIndex);
          end;
          StressPeriod := FStressPeriods[StressPeriodIndex];
          if StressPeriod.Reuse then
          begin
            ReuseRchStressPeriodWithParameters(StressPeriodIndex,
              Param, ScreenObjectList, RechargeLayerName);
          end
          else
          begin
            // In each stress period, identify whether the parameter was used.
            // If it was used, identify the intance used.
            GetParamInstanceForCurrentStressPeriod(Instance, Param,
              StressPeriod);
            if Instance <> nil then
            begin
              // Identify the cluster associated with the instance.
              for ClusterIndex := 0 to Instance.ArrayLength - 1 do
              begin
                Cluster := Instance.Clusters[ClusterIndex];
                ScreenObIndex := ClusterList.IndexOf(Cluster);
                Assert(ScreenObIndex >= 0);
                // Identify the cluster in ClusterList with the same geometry
                // as the cluster used.
                // Retrieve the corresponding TScreenObject from
                // ScreenObjectList.
                // Assign a formula for this parameter in this
                // stress period.
                // The formula should be either the
                // name of the multiplier array,
                // if one is used, or 1 if a multiplier array is not used.
                ScreenObject := ScreenObjectList[ScreenObIndex];
                if FRchPackage.TimeVaryingLayers then
                begin
                  ScreenObject.ElevationCount := ecZero;
                end;
                AssignParamRechargeRate(ScreenObject, StressPeriodIndex,
                  Cluster, Param);
                AssignTimeVaryingLayer(ScreenObject,
                  RechargeLayerName, StressPeriodIndex);
              end;
            end;
          end;
        end;
      end;
    finally
      ScreenObjectList.Free;
      ClusterList.Free;
    end;
  end
  else
  begin
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      CreateRechargeRateDataSet(StressPeriodIndex);
      CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex,
        StrImportedRechargeLa, 'Imported_RCH_Layers_SP_', FRchPackage);
    end;

    ScreenObject := CreateScreenObjectAroundGrid('ImportedRecharge');
    if (FRchPackage.LayerOption = loSpecified)
      and not FRchPackage.TimeVaryingLayers then
    begin
      ScreenObject.ElevationFormula := StrImportedRechargeEl;
    end
    else
    begin
      ScreenObject.ElevationFormula := kModelTop;
//      ScreenObject.ElevationCount := ecZero;
    end;

    ScreenObject.CreateRchBoundary;
    RchBoundary := ScreenObject.ModflowRchBoundary;
    RchItem := nil;
    LayerItem := nil;
    if FReuseRecharge[0] then
    begin
      Beep;
      MessageDlg(Format(StrErrorInSPackage, [StrRecharge]), mtError, [mbOK], 0);
      Exit;
    end;
    if FRchPackage.TimeVaryingLayers and FReuseLayerIndicator[0] then
    begin
      Beep;
      MessageDlg(Format(StrErrorInSPackage, [StrRecharge]), mtError, [mbOK], 0);
      Exit;
    end;
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      NewItemNeeded := not FReuseRecharge[StressPeriodIndex];
      if FRchPackage.TimeVaryingLayers then
      begin
        if not FReuseLayerIndicator[StressPeriodIndex] then
        begin
          NewItemNeeded := True;
        end;
      end;
      if not FReuseRecharge[StressPeriodIndex] then
      begin
        RechargeName := StrImportedRechargeSt
          + GetStressPeriodString(StressPeriodIndex);
      end;
      if FRchPackage.TimeVaryingLayers and
        (not FReuseLayerIndicator[StressPeriodIndex]) then
      begin
        RechargeLayerName := StrImportedRechargeLa +
          GetStressPeriodString(StressPeriodIndex);
      end;
      AssignRechRateNonParam(RechargeName, NewItemNeeded, RchItem,
        RchBoundary, StressPeriodIndex);
      AssignRchLayerNonParam(NewItemNeeded, LayerItem,
        RchBoundary, RechargeLayerName, StressPeriodIndex);
    end;
  end;
end;

procedure TRchImporter.ReadData(const ALabel: string);
var
//  IRCHCB: integer;
  INRECH: integer;
  INIRCH: integer;
  ALine: string;
  Value: double;
  ID: string;
  IntValue: integer;
  Handled: Boolean;
begin
  inherited;
  FRequiredType := 'RCH';
  ImportSharedData(ALabel, Handled);
  if not Handled then
  begin
    if ALabel = 'NRCHOP,IRCHCB:' then
    begin
      Read(FImporter.FFile, NRCHOP);
      Read(FImporter.FFile, DummyInteger); // IRCHCB
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'INRECH,INIRCH:' then
    begin
      Read(FImporter.FFile, INRECH);
      Read(FImporter.FFile, INIRCH);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INRECH);
      InitializeReuseRecharge;
      FReuseRecharge[FCurrentStressPeriod] := INRECH < 0;
      InitializeReuseLayerIndicator;
      FReuseLayerIndicator[FCurrentStressPeriod] := INIRCH < 0;
      CurrentParameter := 0;
    end
    else if ALabel = 'INRECH:' then
    begin
      Read(FImporter.FFile, INRECH);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INRECH);
      InitializeReuseRecharge;
      FReuseRecharge[FCurrentStressPeriod] := INRECH < 0;
      CurrentParameter := 0;
    end
    else if ALabel = StrConstant2DRealArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      Readln(FImporter.FFile, Value);
      if ALine = 'RECHARGE' then
      begin
        ReadRealConstantArrayItem(Value, FConstantRecharge);
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrVariable2DRealArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      if ALine = 'RECHARGE' then
      begin
        ReadRealVariableArray(FVariableRecharge, Format('Recharge rate %d', [FCurrentStressPeriod]));
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrConstant2DIntegerArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      Readln(FImporter.FFile, IntValue);
      if ALine = 'RECHARGE LAYER INDEX' then
      begin
        ReadConstantIntArray(IntValue, FConstantLayerIndicators);
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrVariable2DIntegerArray then
    begin
      ReadLn(FImporter.FFile, ID);
      ID := Trim(ID);
      if ID = 'RECHARGE LAYER INDEX' then
      begin
        ReadVariableIntArray(FVariableLayerIndicators);
      end
      else
      begin
        Assert(False);
      end;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

{ TArrayParameterObject }

function TArrayParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TArrayInstanceObject;
end;

function TArrayParameterObject.GetInstance(
  Index: integer): TArrayInstanceObject;
begin
  result := TArrayInstanceObject(Objects[Index]);
end;

function TArrayParameterObject.GetInstanceByName(
  const InstanceName: string): TArrayInstanceObject;
var
  Index: Integer;
  Instance: TArrayInstanceObject;
begin
  result := nil;
  for Index := 0 to ArrayLength - 1 do
  begin
    Instance := Instances[Index];
    if AnsiCompareText(Instance.Name, InstanceName) = 0 then
    begin
      result := Instance;
      Exit;
    end;
  end;
end;

{ TArrayParamArray }

function TArrayParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TArrayParameterObject;
end;

function TArrayParamArray.GetParams(Index: integer): TArrayParameterObject;
begin
  result := TArrayParameterObject(Objects[Index]);
end;

{ TArrayInstanceObject }

function TArrayInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TClusterObject;
end;

function TArrayInstanceObject.GetCluster(Index: integer): TClusterObject;
begin
  result := TClusterObject(Objects[Index]);
end;

{ TArrayStressPeriodArray }

function TArrayStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TArrayStressPeriod;
end;

function TArrayStressPeriodArray.GetStressPeriod(
  Index: integer): TArrayStressPeriod;
begin
  result := TArrayStressPeriod(Objects[Index]);
end;

{ TClusterObject }

function TClusterObject.SimilarMultAndZone(Cluster: TClusterObject): boolean;
var
  Index: Integer;
begin
  result := (AnsiCompareText(Cluster.ZoneArray, ZoneArray) = 0)
    and (AnsiCompareText(Cluster.MultiplierArray, MultiplierArray) = 0);
  if result then
  begin
    result := Length(Zones) = Length(Cluster.Zones);
    if result then
    begin
      for Index := 0 to Length(Zones) - 1 do
      begin
        result := Zones[Index] = Cluster.Zones[Index];
        if not result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

{ TEvtImporter }

procedure TCustomETImporter.ReuseEtStressPeriodWithParameters(
  StressPeriodIndex: Integer; Param: TArrayParameterObject;
  ScreenObjectList: TList;
  const EvtLayerName, EvtSurfaceName, EvtDepthName: string);
var
  EvtItem, NewEvtItem: TEvtItem;
  ParamItem: TEvtParamItem;
  ScreenObject: TScreenObject;
  SO_Index: Integer;
  Boundary: TModflowParamBoundary;
begin
  for SO_Index := 0 to ScreenObjectList.Count - 1 do
  begin
    ScreenObject := ScreenObjectList[SO_Index];
    Boundary := GetBoundary(ScreenObject);
    ParamItem := Boundary.Parameters.
      GetParamByName(Param.ModifiedParamName) as TEvtParamItem;
    if ParamItem <> nil then
    begin
      if ParamItem.Param.Count > 0 then
      begin
        EvtItem := ParamItem.Param.Items[ParamItem.Param.Count - 1]
          as TEvtItem;
        if EvtItem.EndTime =
          FModel.ModflowStressPeriods[StressPeriodIndex].StartTime then
        begin
          if Package.TimeVaryingLayers then
          begin
            NewEvtItem := ParamItem.Param.Add as TEvtItem;
            NewEvtItem.Assign(EvtItem);
            NewEvtItem.StartTime :=
              FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
            NewEvtItem.EndTime :=
              FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
          end
          else
          begin
            EvtItem.EndTime :=
              FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
          end;
          AssignTimeVaryingLayer(ScreenObject,
            EvtLayerName, StressPeriodIndex);
          AssignSurfaceAndDepth(ScreenObject, EvtSurfaceName, EvtDepthName,
            StressPeriodIndex);
        end;
      end;
    end;
  end;
end;

procedure TEvtImporter.SetEvtOption;
var
  Option: Integer;
begin
  Option := NEVTOP - 1;
  if Option < 0 then
  begin
    Option := 0;
  end;
  if Option > 2 then
  begin
    Option := 2;
  end;
  FEvtPackage.LayerOption := TLayerOption(Option);
end;

procedure TEvtImporter.AssignEvtLayerNonParam(NewItemNeeded: Boolean;
  var LayerItem: TEvtLayerItem; EvtBoundary: TEvtBoundary; EvtLayerName: string;
  StressPeriodIndex: Integer);
begin
  if FEvtPackage.TimeVaryingLayers then
  begin
    if NewItemNeeded then
    begin
      LayerItem := EvtBoundary.EvapotranspirationLayers.Add as TEvtLayerItem;
      LayerItem.EvapotranspirationLayer := EvtLayerName;
      LayerItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

procedure TCustomETImporter.AssignEtRateNonParam(EvtName: string;
  NewItemNeeded: Boolean; var EvtItem: TEvtItem;
  EvtBoundary: TModflowParamBoundary; StressPeriodIndex: Integer);
begin
  if NewItemNeeded then
  begin
    EvtItem := EvtBoundary.Values.Add as TEvtItem;
    EvtItem.EvapotranspirationRate := EvtName;
    EvtItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end
  else
  begin
    EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end;
end;

procedure TTransientArrayImporter.CreateTransientRealDataArray(
  StressPeriodIndex: Integer; Reuse: TBooleanDynArray; DataArrayRoot: string;
  ConstantValues: TRealConstantRecordArray; VariableValues: T3DDoubleArray;
  ImportedValueName: string);
var
  ScreenObject: TScreenObject;
  ADataArray: TDataArray;
  ValueList: TRealList;
  Values: T2DDoubleArray;
  MaxCount: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Value: Double;
  Root: string;
begin
  ScreenObject := nil;
  if not Reuse[StressPeriodIndex] then
  begin
    CreateTransientDataSet(StressPeriodIndex, DataArrayRoot,
      rdtDouble, ADataArray);

    if (ConstantValues <> nil) and ConstantValues[StressPeriodIndex].IsConstant then
    begin
      ADataArray.Formula := FortranFloatToStr(ConstantValues[StressPeriodIndex].RealValue);
    end
    else
    begin
      ADataArray.Formula := '0';
      Assert(VariableValues <> nil);
      Assert(VariableValues[StressPeriodIndex] <> nil);
      ValueList := TRealList.Create;
      try
        ValueList.Sorted := True;
        Values := VariableValues[StressPeriodIndex];
//        MaxCount := Min((Length(Values) * Length(Values[0])) div 10, 100);
        MaxCount := 2;
        for RowIndex := 0 to Length(Values) - 1 do
        begin
          for ColIndex := 0 to Length(Values[0]) - 1 do
          begin
            Value := Values[RowIndex, ColIndex];
            ValueList.AddUnique(Value);
            if ValueList.Count >= MaxCount then
            begin
              break;
            end;
          end;
          if ValueList.Count >= MaxCount then
          begin
            break;
          end;
        end;
        if ValueList.Count >= MaxCount then
        begin
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          end;
          AssignRealValuesToCellCenters(ADataArray, ScreenObject, VariableValues[StressPeriodIndex]);
        end
        else if ValueList.Count = 1 then
        begin
          ADataArray.Formula := FortranFloatToStr(ValueList[0]);
        end
        else
        begin
          Root := ImportedValueName + GetStressPeriodString(StressPeriodIndex) + '_Obj_';
          CreateScreenObjectsAroundValues(Values, Root, ADataArray, ValueList);
        end;
      finally
        ValueList.Free;
        VariableValues[StressPeriodIndex] := nil;
      end;
    end;
  end;
end;

procedure TEvtImporter.AssignEvtSurfaceNonParam(
  EvtSurfaceName, EvtExtinctName: string;
  NewItemNeeded: Boolean; var EvtItem: TEvtSurfDepthItem;
  EvtBoundary: TEvtBoundary; StressPeriodIndex: Integer);
begin
  if NewItemNeeded then
  begin
    EvtItem := EvtBoundary.EvtSurfDepthCollection.Add as TEvtSurfDepthItem;
    EvtItem.EvapotranspirationSurface := EvtSurfaceName;
    EvtItem.EvapotranspirationDepth := EvtExtinctName;
    EvtItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end
  else
  begin
    EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end;
end;

procedure TCustomETImporter.AssignParamEvtRate(ScreenObject: TScreenObject;
  StressPeriodIndex: Integer; Cluster: TClusterObject;
  Param: TArrayParameterObject);
var
  EvtItem: TEvtItem;
  ParamItem: TEvtParamItem;
  Boundary: TModflowParamBoundary;
begin
  Boundary := GetBoundary(ScreenObject);
  ParamItem := Boundary.Parameters.
    GetParamByName(Param.ModifiedParamName) as TEvtParamItem;
  if ParamItem = nil then
  begin
    if Param.PARTYP = 'ETS' then
    begin
      ParamItem := Boundary.
        Parameters.Add as TEtsParamItem;
      ParamItem.Param.ParamName := Param.ModifiedParamName;
    end
    else
    begin
      ParamItem := Boundary.
        Parameters.Add as TEvtParamItem;
      ParamItem.Param.ParamName := Param.ModifiedParamName;
    end;
  end;
  EvtItem := ParamItem.Param.Add as TEvtItem;
  EvtItem.StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
  EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  if AnsiCompareText(Cluster.MultiplierArray, 'NONE') = 0 then
  begin
    EvtItem.EvapotranspirationRate := '1';
  end
  else
  begin
    EvtItem.EvapotranspirationRate := FixArrayName(Cluster.MultiplierArray);
  end;
end;

procedure TEvtImporter.AssignSurfaceAndDepth(ScreenObject: TScreenObject;
  EvtSurfaceName, EvtDepthName: string; StressPeriodIndex: Integer);
var
  EvtBoundary: TEvtBoundary;
  LayerItem: TEvtSurfDepthItem;
begin
  EvtBoundary := ScreenObject.ModflowEvtBoundary;
  if (EvtBoundary.EvtSurfDepthCollection.Count > 0)
    and FReuseEtSurface[StressPeriodIndex]
    and FReuseEtExtinctionDepth[StressPeriodIndex] then
  begin
    LayerItem := EvtBoundary.EvtSurfDepthCollection.
      Items[EvtBoundary.EvtSurfDepthCollection.Count - 1] as TEvtSurfDepthItem;
    LayerItem.EndTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end
  else
  begin
    LayerItem := EvtBoundary.EvtSurfDepthCollection.Add as TEvtSurfDepthItem;
    LayerItem.EvapotranspirationSurface := EvtSurfaceName;
    LayerItem.EvapotranspirationDepth := EvtDepthName;
    LayerItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    LayerItem.EndTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end;
end;

procedure TEvtImporter.AssignTimeVaryingLayer(ScreenObject: TScreenObject;
  EvtLayerName: string; StressPeriodIndex: Integer);
var
  LayerItem: TEvtLayerItem;
  EvtBoundary: TEvtBoundary;
begin
  if Package.TimeVaryingLayers then
  begin
    EvtBoundary := ScreenObject.ModflowEvtBoundary;
    if not FReuseLayerIndicator[StressPeriodIndex] then
    begin
      LayerItem := EvtBoundary.EvapotranspirationLayers.Add as TEvtLayerItem;
      LayerItem.EvapotranspirationLayer := EvtLayerName;
      LayerItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      LayerItem := EvtBoundary.EvapotranspirationLayers.
        Items[EvtBoundary.EvapotranspirationLayers.Count - 1] as TEvtLayerItem;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

constructor TEvtImporter.Create(Importer: TModflow2005Importer;
  ZoneImporter: TMultZoneImporter);
begin
  inherited Create(Importer, 'EVT:', ZoneImporter);
end;

procedure TEvtImporter.CreateBoundary(ScreenObject: TScreenObject);
begin
  ScreenObject.CreateEvtBoundary;
end;

class function TEvtImporter.ImportedEtSurfaceName: string;
begin
  result := StrImportedEvtSurfSt;
end;

class function TEvtImporter.ImportedEtSurfaceSP: string;
begin
  result := 'Imported_EVT_Surface_SP_';
end;

procedure TCustomETImporter.CreateEtSurfaceDataSet(StressPeriodIndex: Integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseEtSurface,
    ImportedEtSurfaceName, FConstantEtSurface, FVariableEtSurface,
    ImportedEtSurfaceSP);

end;

class function TEvtImporter.EtExtinctionDepth_Name: string;
begin
  result := StrImportedEvtExtinctDepthSt;
end;

class function TEvtImporter.EtExtinctionDepth_SP: string;
begin
  result := 'Imported_EVT_ExtinctionDepth_SP_';
end;

function TEvtImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowEvtBoundary;
end;

procedure TCustomETImporter.CreateEtExtinctionDepthDataSet(
  StressPeriodIndex: Integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseEtExtinctionDepth,
    EtExtinctionDepth_Name, FConstantExtinctionDepth, FVariableExtinctionDepth,
    EtExtinctionDepth_SP);

end;

class function TEvtImporter.ImportedEtRateName: string;
begin
  result := StrImportedEvtSt;
end;

class function TEvtImporter.ImportedEtValuesName: string;
begin
  result := 'Imported_EVT_Values_SP_';
end;

procedure TCustomETImporter.CreateEvtRateDataSet(StressPeriodIndex: Integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseEtRate,
    ImportedEtRateName, FConstantEtRate, FVariableEtRate, ImportedEtValuesName);
end;

procedure TEvtImporter.HandlePackage;
var
  StressPeriodIndex: Integer;
  ScreenObject: TScreenObject;
  EtLayerDataSet: TDataArray;
  NewItemNeeded: Boolean;
  EvtBoundary: TEvtBoundary;
  EvtItem: TEvtItem;
  LayerItem: TEvtLayerItem;
  EvtName: string;
  EvtLayerName: string;
  EvtSurfaceName: string;
  ParamIndex: Integer;
  Param: TArrayParameterObject;
  Instance: TArrayInstanceObject;
  ClusterIndex: Integer;
  Cluster: TClusterObject;
  ObjectIndex: integer;
  ClusterList: TList;
  ScreenObjectList: TList;
  StressPeriod: TArrayStressPeriod;
  ScreenObIndex: Integer;
  EvtExtinctName: string;
  EvtSurf: TEvtSurfDepthItem;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  FEvtPackage := FModel.ModflowPackages.EvtPackage;
  Package := FEvtPackage;
  FEvtPackage.IsSelected := True;
  FEvtPackage.Comments := FComments;
  SetEvtOption;
  EvaluateTimeVaryingLayers(FEvtPackage);

  CreateAssignedLayerDataSet(FEvtPackage, StrImportedEvtEl,
    'Imported_Evt_Elevation', EtLayerDataSet);

  if NP > 0 then
  begin
    ClusterList := TList.Create;
    ScreenObjectList := TList.Create;
    try
      ObjectIndex := 0;
      for ParamIndex := 0 to FParams.ArrayLength - 1 do
      begin
        Param := FParams[ParamIndex];
        CreateTransientParam(Param);

        ScreenObjectList.Clear;
        ClusterList.Clear;
        CreateScreenObjectsFromClusters(Param, ObjectIndex,
          ScreenObjectList, ClusterList, 'ImportedEvtParam_', StrImportedEvtEl,
          FEvtPackage);
        // At this point, ScreenObjectList contains each TScreenObject
        // that has been created for a particular parameter
        // and Cluster list contains a TClusterObject that has the
        // zone array and zones used to define the geometry of the
        // TScreenObject but not necessarily the corresponding Multiplier
        // array.

        // What need's to be done is to identify the stress periods in which
        // each parameter instance was used and find the corresponding
        // TScreenObjects and assign the formulas for those
        // stress periods using the appropriate multiplier arrays.

        // Loop over stress periods
        for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
        begin
          if ParamIndex = 0 then
          begin
            CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex,
              StrImportedEvtLa, 'Imported_EVT_Layers_SP_', FEvtPackage);
            CreateEtSurfaceDataSet(StressPeriodIndex);
            CreateEtExtinctionDepthDataSet(StressPeriodIndex);
          end;
          if FEvtPackage.TimeVaryingLayers and
            (not FReuseLayerIndicator[StressPeriodIndex]) then
          begin
            EvtLayerName := StrImportedEvtLa +
              GetStressPeriodString(StressPeriodIndex);
          end;
          if not FReuseEtSurface[StressPeriodIndex] then
          begin
            EvtSurfaceName := ImportedEtSurfaceName
              + GetStressPeriodString(StressPeriodIndex);
          end;
          if not FReuseEtExtinctionDepth[StressPeriodIndex] then
          begin
            EvtExtinctName := EtExtinctionDepth_Name
              + GetStressPeriodString(StressPeriodIndex);
          end;
          StressPeriod := FStressPeriods[StressPeriodIndex];
          if StressPeriod.Reuse then
          begin
            ReuseEtStressPeriodWithParameters(StressPeriodIndex,
              Param, ScreenObjectList, EvtLayerName, EvtSurfaceName,
              EvtExtinctName);
          end
          else
          begin
            // In each stress period, identify whether the parameter was used.
            // If it was used, identify the intance used.
            GetParamInstanceForCurrentStressPeriod(Instance, Param,
              StressPeriod);
            if Instance <> nil then
            begin
              // Identify the cluster associated with the instance.
              for ClusterIndex := 0 to Instance.ArrayLength - 1 do
              begin
                Cluster := Instance.Clusters[ClusterIndex];
                ScreenObIndex := ClusterList.IndexOf(Cluster);
                Assert(ScreenObIndex >= 0);
                // Identify the cluster in ClusterList with the same geometry
                // as the cluster used.
                // Retrieve the corresponding TScreenObject from
                // ScreenObjectList.
                // Assign a formula for this parameter in this
                // stress period.
                // The formula should be either the
                // name of the multiplier array,
                // if one is used, or 1 if a multiplier array is not used.
                ScreenObject := ScreenObjectList[ScreenObIndex];
                AssignParamEvtRate(ScreenObject, StressPeriodIndex,
                  Cluster, Param);
                AssignTimeVaryingLayer(ScreenObject,
                  EvtLayerName, StressPeriodIndex);
                AssignSurfaceAndDepth(ScreenObject, EvtSurfaceName,
                  EvtExtinctName, StressPeriodIndex);
              end;
            end;
          end;
        end;
      end;
    finally
      ScreenObjectList.Free;
      ClusterList.Free;
    end;
  end
  else
  begin
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      CreateEvtRateDataSet(StressPeriodIndex);
      CreateEtSurfaceDataSet(StressPeriodIndex);
      CreateEtExtinctionDepthDataSet(StressPeriodIndex);
      CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex,
        StrImportedEvtLa, 'Imported_EVT_Layers_SP_', FEvtPackage);
    end;

    ScreenObject := CreateScreenObjectAroundGrid('ImportedEvt');
    if (FEvtPackage.LayerOption = loSpecified)
      and not FEvtPackage.TimeVaryingLayers then
    begin
      ScreenObject.ElevationFormula := StrImportedEvtEl;
    end
    else
    begin
      ScreenObject.ElevationFormula := kModelTop;
//      ScreenObject.ElevationCount := ecZero;
    end;

    ScreenObject.CreateEVTBoundary;
    EvtBoundary := ScreenObject.ModflowEvtBoundary;
    EvtItem := nil;
    LayerItem := nil;
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      NewItemNeeded := not FReuseEtRate[StressPeriodIndex];
      if FEvtPackage.TimeVaryingLayers then
      begin
        if not FReuseLayerIndicator[StressPeriodIndex] then
        begin
          NewItemNeeded := True;
        end;
      end;
      if not FReuseEtSurface[StressPeriodIndex] then
      begin
        NewItemNeeded := True;
      end;
      if not FReuseEtExtinctionDepth[StressPeriodIndex] then
      begin
        NewItemNeeded := True;
      end;

      if not FReuseEtRate[StressPeriodIndex] then
      begin
        EvtName := ImportedEtRateName
          + GetStressPeriodString(StressPeriodIndex);
      end;
      if FEvtPackage.TimeVaryingLayers and
        (not FReuseLayerIndicator[StressPeriodIndex]) then
      begin
        EvtLayerName := StrImportedEvtLa +
          GetStressPeriodString(StressPeriodIndex);
      end;
      if not FReuseEtSurface[StressPeriodIndex] then
      begin
        EvtSurfaceName := ImportedEtSurfaceName
          + GetStressPeriodString(StressPeriodIndex);
      end;
      if not FReuseEtExtinctionDepth[StressPeriodIndex] then
      begin
        EvtExtinctName := EtExtinctionDepth_Name
          + GetStressPeriodString(StressPeriodIndex);
      end;

      AssignEtRateNonParam(EvtName, NewItemNeeded, EvtItem,
        EvtBoundary, StressPeriodIndex);
      AssignEvtLayerNonParam(NewItemNeeded, LayerItem,
        EvtBoundary, EvtLayerName, StressPeriodIndex);
      AssignEvtSurfaceNonParam(EvtSurfaceName,EvtExtinctName, NewItemNeeded,
        EvtSurf, EvtBoundary, StressPeriodIndex);
    end;
  end;
end;

procedure TEvtImporter.ReadData(const ALabel: string);
var
  Handled: Boolean;
//  IEVTCB: integer;
  INSURF: integer;
  INEVTR: integer;
  INEXDP: integer;
  INIEVT: integer;
  ALine: string;
  Value: double;
  IntValue: integer;
  ID: string;
begin
  inherited;
  FRequiredType := 'EVT';
  ImportSharedData(ALabel, Handled);
  if not Handled then
  begin
    if ALabel = 'NEVTOP,IEVTCB:' then
    begin
      Read(FImporter.FFile, NEVTOP);
      Read(FImporter.FFile, DummyInteger); // IEVTCB
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'INSURF,INEVTR,INEXDP,INIEVT:' then
    begin
      Read(FImporter.FFile, INSURF);
      Read(FImporter.FFile, INEVTR);
      Read(FImporter.FFile, INEXDP);
      Read(FImporter.FFile, INIEVT);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INEVTR);
      InitializeReuseEtSurface;
      FReuseEtSurface[FCurrentStressPeriod] := INSURF < 0;
      InitializeReuseEtRate;
      FReuseEtRate[FCurrentStressPeriod] := INEVTR < 0;
      InitializeReuseExtinctionDepth;
      FReuseEtExtinctionDepth[FCurrentStressPeriod] := INEXDP < 0;
      InitializeReuseLayerIndicator;
      FReuseLayerIndicator[FCurrentStressPeriod] := INIEVT < 0;
      CurrentParameter := 0;
    end
    else if ALabel = 'INSURF,INEVTR,INEXDP:' then
    begin
      Read(FImporter.FFile, INSURF);
      Read(FImporter.FFile, INEVTR);
      Read(FImporter.FFile, INEXDP);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INEVTR);
      InitializeReuseEtSurface;
      FReuseEtSurface[FCurrentStressPeriod] := INSURF < 0;
      InitializeReuseEtRate;
      FReuseEtRate[FCurrentStressPeriod] := INEVTR < 0;
      InitializeReuseExtinctionDepth;
      FReuseEtExtinctionDepth[FCurrentStressPeriod] := INEXDP < 0;
      CurrentParameter := 0;
    end
    else if ALabel = StrConstant2DRealArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      Readln(FImporter.FFile, Value);
      if ALine = 'ET SURFACE' then
      begin
        ReadRealConstantArrayItem(Value, FConstantEtSurface);
      end
      else if ALine = 'EVAPOTRANSPIRATION RATE' then
      begin
        ReadRealConstantArrayItem(Value, FConstantEtRate);
      end
      else if ALine = 'EXTINCTION DEPTH' then
      begin
        ReadRealConstantArrayItem(Value, FConstantExtinctionDepth);
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrVariable2DRealArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      if ALine = 'ET SURFACE' then
      begin
        ReadRealVariableArray(FVariableEtSurface, Format('ET Surface %d', [FCurrentStressPeriod]));
      end
      else if ALine = 'EVAPOTRANSPIRATION RATE' then
      begin
        ReadRealVariableArray(FVariableEtRate, Format('ET Evapotranspiration Rate depth %d', [FCurrentStressPeriod]));
      end
      else if ALine = 'EXTINCTION DEPTH' then
      begin
        ReadRealVariableArray(FVariableExtinctionDepth, Format('ET Extinction depth %d', [FCurrentStressPeriod]));
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrConstant2DIntegerArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      Readln(FImporter.FFile, IntValue);
      if ALine = 'ET LAYER INDEX' then
      begin
        ReadConstantIntArray(IntValue, FConstantLayerIndicators);
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrVariable2DIntegerArray then
    begin
      ReadLn(FImporter.FFile, ID);
      ID := Trim(ID);
      if ID = 'ET LAYER INDEX' then
      begin
        ReadVariableIntArray(FVariableLayerIndicators);
      end
      else
      begin
        Assert(False);
      end;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

procedure TCustomChdImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime: Double; StartTime: Double;
  ScreenObject: TScreenObject; const ParamName: string);
var
  ChdBoundary: TChdLocationObject;
  ChdItem: TChdItem;
  ValueItem: TValueArrayItem;
  Index: Integer;
  StartValues: TValueArrayStorage;
  EndValues: TValueArrayStorage;
  StartName: string;
  EndName: string;
  APoint: TPoint2D;
begin
  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  StartName := 'ChdStart' + ParamName;
  ValueItem.Name := StartName;
  StartValues := ValueItem.Values;
  StartValues.DataType := rdtDouble;
  StartValues.Count := Boundaries.Count;

  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  EndName := 'ChdEnd' + ParamName;
  ValueItem.Name := EndName;
  EndValues := ValueItem.Values;
  EndValues.DataType := rdtDouble;
  EndValues.Count := Boundaries.Count;

  ChdItem := Item as TChdItem;
  ChdItem.StartTime := StartTime;
  ChdItem.EndTime := EndTime;
  for Index := 0 to Boundaries.Count - 1 do
  begin
    ChdBoundary := Boundaries[Index];
    APoint := FImporter.CenterPoints[ChdBoundary.Row-1, ChdBoundary.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
      StartValues.RealValues[Index] := ChdBoundary.StartFactor;
      EndValues.RealValues[Index] := ChdBoundary.EndFactor;
    end;
  end;
  ChdItem.StartHead := rsObjectImportedValuesR + '("' + StartName + '")';
  ChdItem.EndHead := rsObjectImportedValuesR + '("' + EndName + '")';
  AssignObservationFactors(ScreenObject, ParamName, Boundaries);
  StartValues.CacheData;
  EndValues.CacheData;
end;

{ TSfrImporter }

constructor TSfrImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'SFR');
  FSegmentStorage:= TList.Create;
  FItemStorage:= TList.Create;
  FStressPeriods:= TSfrStressPeriodArray.Create;
  FParameters:= TSfrParamArray.Create;
  DLEAK := 0.0001;
  ISFROPT := 0;
  Nstrail := 10;
  ISUZN := 10;
  NSFRSETS := 30;
  FCurrentReachIndex := -1;
  FCurrentSegmentIndex := -1;
  FReaches := TSfrReaches.Create;
  FStressPeriodSegments := TStressPeriodSegments.Create;
end;

procedure TSfrImporter.ReadUnsatParameters;
begin
  Read(FImporter.FFile, NSTRAIL);
  Read(FImporter.FFile, ISUZN);
  Read(FImporter.FFile, NSFRSETS);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

function TSfrImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Sfr_'
end;

procedure TSfrImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
begin
  Assert(False);
end;

procedure TSfrImporter.ReadIsfropt;
begin
  Read(FImporter.FFile, ISFROPT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSfrImporter.ReadNumberOfInstances;
var
  NUMINST: Integer;
  Index: Integer;
  Instance: TSfrInstanceObject;
begin
  Read(FImporter.FFile, NUMINST);
  Readln(FImporter.FFile);
  FParameters[CurrentParameter].ArrayLength := NUMINST;
  for Index := 0 to NUMINST - 1 do
  begin
    Instance := FParameters[CurrentParameter].Instances[Index]
      as TSfrInstanceObject;
    Instance.Segments.ArrayLength := NLST;
  end;
  FImporter.UpdateProgress;
end;

procedure TSfrImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'SFR');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

procedure TSfrImporter.ReadParameterValueAndLocationCount;
var
  Index: Integer;
  Parval: Double;
  Instance: TSfrInstanceObject;
begin
  Read(FImporter.FFile, Parval);
  Read(FImporter.FFile, NLST);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FParameters[CurrentParameter].Parval := Parval;
  for Index := 0 to FParameters[CurrentParameter].ArrayLength - 1 do
  begin
    Instance := FParameters[CurrentParameter].Instances[Index]
      as TSfrInstanceObject;
    Instance.Segments.ArrayLength := NLST;
  end;
  SegCount := 0;
end;

procedure TSfrImporter.ReadBasicData;
begin
  FIsSelected := True;
  Read(FImporter.FFile, NSTRM);
  Read(FImporter.FFile, NSS);
  Read(FImporter.FFile, NP);
  Read(FImporter.FFile, NPARSEG);
  Read(FImporter.FFile, SfrCONST);
  Read(FImporter.FFile, DLEAK);
  Read(FImporter.FFile, ISTCB1);
  Read(FImporter.FFile, ISTCB2);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FParameters.ArrayLength := NP;
  if NSTRM < 0 then
  begin
    NSTRM := -NSTRM;
  end;
  FReaches.ArrayLength := NSTRM;
end;

procedure TSfrImporter.ReadDataSet5WithoutParameters;
//var
//  IPTFLG: Integer;
//  IRDFLG: Integer;
begin
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, DummyInteger); // IRDFLG
  Read(FImporter.FFile, DummyInteger); // IPTFLG
  NP := 0;
  Inc(FCurrentStressPeriod);
  InitializeCurrentStressPeriod;
end;

procedure TSfrImporter.ReadDataSet5WithParameters;
//var
//  IRDFLG: Integer;
//  IPTFLG: Integer;
begin
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, DummyInteger); // IRDFLG
  Read(FImporter.FFile, DummyInteger); // IPTFLG
  Read(FImporter.FFile, NP);
  Inc(FCurrentStressPeriod);
  InitializeCurrentStressPeriod;
end;

function TSfrImporter.CreateStream(List: TList;
  var ScreenObjectIndex: integer): TScreenObject;
var
  UndoCreateScreenObject: TCustomUndo;
  Index: Integer;
  Reach: TSfrLocationObject;
  PriorReach: TSfrLocationObject;
  ImportedElevations: TValueArrayStorage;
  Grid: TModflowGrid;
  APoint: TPoint2D;
begin
  result := TScreenObject.CreateWithViewDirection(FModel, vdTop,
    UndoCreateScreenObject, False);
  result.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);
  Inc(ScreenObjectIndex);
  result.Name := ScreenObjectNameRoot + '_'
    + IntToStr(ScreenObjectIndex);
  FModel.AddScreenObject(result);
  result.ElevationCount := ecOne;
  result.SetValuesOfIntersectedCells := True;
  result.EvaluatedAt := eaBlocks;
  result.Visible := False;
  result.Capacity := List.Count;
  ImportedElevations := result.ImportedSectionElevations;
  ImportedElevations.DataType := rdtDouble;
  ImportedElevations.Count := List.Count;
  PriorReach := nil;
  Grid := frmGoPhast.PhastModel.ModflowGrid;
  for Index := 0 to List.Count - 1 do
  begin
    Reach := List[Index];
    if (PriorReach = nil) or (Abs(Reach.Row-PriorReach.Row) > 1)
      or (Abs(Reach.Column-PriorReach.Column) > 1)
      or ((Reach.Row = PriorReach.Row) and (Reach.Column = PriorReach.Column)) then
    begin
      result.AddPoint(FImporter.CenterPoints[Reach.Row - 1,
        Reach.Column - 1], True);
    end
    else
    begin
      if (Reach.Row <> PriorReach.Row) then
      begin
        if (Reach.Column <> PriorReach.Column) then
        begin
          APoint := FImporter.CornerPoints[Min(Reach.Row, PriorReach.Row),
            Min(Reach.Column, PriorReach.Column)]
        end
        else
        begin
          APoint := Grid.TwoDRowEdgeCenter(Reach.Column-1,
            Min(Reach.Row, PriorReach.Row));
        end;
      end
      else
      begin
        Assert((Reach.Column <> PriorReach.Column));
        APoint := Grid.TwoDColumnEdgeCenter(Min(Reach.Column, PriorReach.Column),
          Reach.Row-1);
      end;
      result.AddPoint(APoint, False);
      result.AddPoint(APoint, True);
      result.AddPoint(FImporter.CenterPoints[Reach.Row - 1,
        Reach.Column - 1], False);
    end;

    ImportedElevations.RealValues[Index] :=
      FGrid.LayerCenter(Reach.Column - 1, Reach.Row - 1,
      FModel.ModflowLayerToDataSetLayer(Reach.Layer));
    PriorReach := Reach;
  end;
  result.ElevationFormula := rsObjectImportedValuesR
    + '("' + StrImportedElevations + '")';
  result.SectionStarts.CacheData;

  result.CreateSfrBoundary;
  FSfrBoundary := result.ModflowSfrBoundary;
  Reach := List[0];
  FSfrBoundary.SegmentNumber := Reach.SegmentNumber;
  AssignStartAndEndTimes;
  AssignReachValues(List, Result);
  ImportedElevations.CacheData;
end;

destructor TSfrImporter.Destroy;
begin
  FStressPeriodSegments.Free;
  FReaches.Free;
  FParameters.Free;
  FStressPeriods.Free;
  FSegmentStorage.Free;
  FItemStorage.Free;
  inherited;
end;

procedure TSfrImporter.AssignExternalFlows(Segment: TSegment);
var
  ExternalFlow: TExternalFlowProperties;
  FlowIndex: Integer;
  FlowFileData: TFlowFileCollection;
  FlowItem: TFlowFileItem;
begin
  ExternalFlow := FSfrBoundary.ExternalFlow;
  FlowFileData := ExternalFlow.FlowFileData;
  if Length(Segment.InflowValues) > 0 then
  begin
    ExternalFlow.FlowFileChoice := ffcSpecify;
    ExternalFlow.ReferenceTimeChoice := ffrtStartOfModel;
    if FlowFileData.Count = 0 then
    begin
      FlowFileData.Capacity := Length(Segment.InflowValues);
      for FlowIndex := 0 to Length(Segment.InflowValues) - 1 do
      begin
        FlowItem := FlowFileData.Add;
        FlowItem.Time := Segment.InflowValues[FlowIndex].Time;
        FlowItem.Inflow := Segment.InflowValues[FlowIndex].Inflow;
      end;
    end;
  end
  else
  begin
    if FlowFileData.Count = 0 then
    begin
      ExternalFlow.FlowFileChoice := ffcNone;
    end;
  end;
end;

{$HINTS OFF}
procedure TSfrImporter.ReadExternalFlows;
var
  SEGNUM: Integer;
  NUMVAL: Integer;
  ValIndex: Integer;
  IUNIT: Integer;
  ParamIndex: Integer;
  Param: TListParameterObject;
  InstIndex: Integer;
  Instance: TSfrInstanceObject;
  SegIndex: Integer;
  ASeg: TSegment;
begin
  Read(FImporter.FFile, SEGNUM);
  if NP > 0 then
  begin
    FCurrentSegment := nil;
    for ParamIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      Param := FParameters[ParamIndex];
      for InstIndex := 0 to Param.ArrayLength - 1 do
      begin
        Instance := Param.Instances[InstIndex] as TSfrInstanceObject;
        for SegIndex := 0 to Instance.Segments.ArrayLength - 1 do
        begin
          ASeg := Instance.Segments[SegIndex];
          if ASeg.NSEG = SEGNUM then
          begin
            FCurrentSegment := ASeg;
            break;
          end;
        end;
        if FCurrentSegment <> nil then
        begin
          break;
        end;
      end;
      if FCurrentSegment <> nil then
      begin
        break;
      end;
    end;
    if FCurrentSegment = nil then
    begin
      FCurrentSegment := FCurrentSegments[SEGNUM-1];
      Assert(FCurrentSegment.NSEG = SEGNUM);
    end;
    Assert(FCurrentSegment <> nil);
  end
  else
  begin
    FCurrentSegment := FCurrentSegments[SEGNUM-1];
    Assert(FCurrentSegment.NSEG = SEGNUM);
  end;
  Read(FImporter.FFile, NUMVAL);
  SetLength(FCurrentSegment.InflowValues, NUMVAL);
  // reading IUNIT here isn't required. In the future, if another variable
  // follows IUNIT, reading IUNIT would be required.
  Read(FImporter.FFile, IUNIT);
  readln(FImporter.FFile);
  for ValIndex := 0 to NUMVAL - 1 do
  begin
    Read(FImporter.FFile, FCurrentSegment.InflowValues[ValIndex].Time);
    Read(FImporter.FFile, FCurrentSegment.InflowValues[ValIndex].Inflow);
    readln(FImporter.FFile);
  end;
end;
{$HINTS ON}

procedure TSfrImporter.AssignParameterSegmentProperties(PriorSegNumber: Integer);
var
  ICalcItem: TSfrParamIcalcItem;
  Segment: TSegment;
  Instance: TSfrInstanceObject;
  InstanceName: string;
  ParamPosition: Integer;
  StressPeriod: TSegmentArray;
  StressPeriodIndex: Integer;
  IcalcIndex: Integer;
  Param: TSfrParameterObject;
  PIndex: Integer;
begin
  for PIndex := 0 to FParameters.ArrayLength - 1 do
  begin
    Param := FParameters[PIndex] as TSfrParameterObject;
    IcalcIndex := -1;
    for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
    begin
      Inc(IcalcIndex);
      StressPeriod := FStressPeriods[StressPeriodIndex] as TSegmentArray;
      ParamPosition := StressPeriod.IndexOfParameter(Param.PARNAM);
      if ParamPosition >= 0 then
      begin
        InstanceName := StressPeriod.Instances[ParamPosition];
        if InstanceName = '' then
        begin
          Instance := Param.Instances[0] as TSfrInstanceObject;
        end
        else
        begin
          Instance := Param.GetInstanceByName(InstanceName)
            as TSfrInstanceObject;
          if Instance = nil then
          begin
            frmErrorsAndWarnings.AddError(frmGoPhast.PhastModel,
              StrIncorrectParameter,
              Format(StrTheParameterInstan, [InstanceName, Param.PARNAM]));

          end;
        end;
        if Instance <> nil then
        begin
          Segment := Instance.GetSegByNumber(PriorSegNumber);
          if (Segment <> nil) then
          begin
            AssignParamIcalcValues(IcalcIndex, Segment);
            ICalcItem := FSfrBoundary.ParamIcalc.Items[IcalcIndex];
            ICalcItem.Param := Param.PARNAM;
            ICalcItem.ParamInstance := DefaultInstanceName(StressPeriodIndex);
            AssignFlowTableValues(IcalcIndex, Segment);
            AssignSegmentFlowValues(IcalcIndex, Segment);
            AssignChannelValues(IcalcIndex, StressPeriodIndex, Segment);
            AssignEquationValues(IcalcIndex, Segment);
            AssignUpstreamValues(IcalcIndex, StressPeriodIndex, Segment);
            AssignDownstreamValues(Segment, StressPeriodIndex, IcalcIndex);
            AssignUnsatValues(Segment, StressPeriodIndex, IcalcIndex);
            AssignExternalFlows(Segment);
          end;
        end;
      end;
    end;
  end;
end;

procedure TSfrImporter.CreateParamInstances(ParameterSegments: TIntegerList);
var
  Segment: TSegment;
  Instance: TSfrInstanceObject;
  InstanceItem: TSfrParamInstance;
  ParamPosition: Integer;
  StressPeriod: TSegmentArray;
  StressPeriodIndex: Integer;
  ParamIndex: Integer;
  InstanceIndex: Integer;
  SegIndex: Integer;
  ParamObject: TSfrParameterObject;
  Parameter: TModflowTransientListParameter;
begin
  for ParamIndex := 0 to FParameters.ArrayLength - 1 do
  begin
    ParamObject := FParameters[ParamIndex] as TSfrParameterObject;
    Parameter := FModel.ModflowTransientParameters.Add
      as TModflowTransientListParameter;
    Parameter.ParameterName := ParamObject.PARNAM;
    Parameter.ParameterType := ptSFR;
    Parameter.Value := ParamObject.Parval;
    for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
    begin
      StressPeriod := FStressPeriods[StressPeriodIndex] as TSegmentArray;
      ParamPosition := StressPeriod.IndexOfParameter(Parameter.ParameterName);
      if ParamPosition >= 0 then
      begin
        InstanceItem := FSfrPackage.ParameterInstances.Add as TSfrParamInstance;
        InstanceItem.ParameterName := ParamObject.PARNAM;
        InstanceItem.ParameterInstance :=
          DefaultInstanceName(StressPeriodIndex);
        InstanceItem.StartTime :=
          FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
        InstanceItem.EndTime :=
          FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
      end;
    end;
    for InstanceIndex := 0 to ParamObject.ArrayLength - 1 do
    begin
      Instance := ParamObject.Instances[InstanceIndex] as TSfrInstanceObject;
      for SegIndex := 0 to Instance.Segments.ArrayLength - 1 do
      begin
        Segment := Instance.Segments[SegIndex] as TSegment;
        if Segment.NSEG > 0 then
        begin
          ParameterSegments.AddUnique(Segment.NSEG);
        end;
      end;
    end;
  end;
end;

procedure TSfrImporter.AssignSegmentProperties;
var
  Segment: TSegment;
  SegmentArray: TSegmentArray;
  StressPeriod: TListStressPeriod;
  StressPeriodIndex: Integer;
  IcalcIndex: Integer;
begin
  IcalcIndex := -1;
  for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
  begin
    // initialize the start and end times for when the boundary will be
    // applied.
    StressPeriod := FStressPeriods[StressPeriodIndex];
    if not StressPeriod.Reuse then
    begin
      Inc(IcalcIndex);
      SegmentArray := FStressPeriodSegments[StressPeriodIndex];
      Segment := SegmentArray[FSfrBoundary.SegmentNumber - 1];
      AssignParamIcalcValues(IcalcIndex, Segment);
      AssignFlowTableValues(IcalcIndex, Segment);
      AssignSegmentFlowValues(IcalcIndex, Segment);
      AssignChannelValues(IcalcIndex, StressPeriodIndex, Segment);
      AssignEquationValues(IcalcIndex, Segment);
      AssignUpstreamValues(IcalcIndex, StressPeriodIndex, Segment);
      AssignDownstreamValues(Segment, StressPeriodIndex, IcalcIndex);
      AssignUnsatValues(Segment, StressPeriodIndex, IcalcIndex);
      AssignExternalFlows(Segment);
    end;
  end;
end;

procedure TSfrImporter.AssignUnsatValues(Segment: TSegment;
  StressPeriodIndex: Integer; IcalcIndex: Integer);
var
  DownstreamUnsatItem: TSfrUnsatSegmentItem;
  UpstreamUnsatItem: TSfrUnsatSegmentItem;
begin
  if StressPeriodIndex = 0 then
  begin
    if (Segment.ICalc in [1, 2]) and (FSfrPackage.Isfropt in [4, 5]) then
    begin
      UpstreamUnsatItem := FSfrBoundary.
        UpstreamUnsatSegmentValues[IcalcIndex] as TSfrUnsatSegmentItem;
      UpstreamUnsatItem.BrooksCoreyExponent := FortranFloatToStr(Segment.EPS1);
      UpstreamUnsatItem.InitialWaterContent := FortranFloatToStr(Segment.THTI1);
      UpstreamUnsatItem.SaturatedWaterContent := FortranFloatToStr(Segment.THTS1);
      UpstreamUnsatItem.VerticalSaturatedK := FortranFloatToStr(Segment.UHC1);

      DownstreamUnsatItem := FSfrBoundary.
        DownstreamUnsatSegmentValues[IcalcIndex] as TSfrUnsatSegmentItem;
      DownstreamUnsatItem.BrooksCoreyExponent := FortranFloatToStr(Segment.EPS2);
      DownstreamUnsatItem.InitialWaterContent := FortranFloatToStr(Segment.THTI2);
      DownstreamUnsatItem.SaturatedWaterContent := FortranFloatToStr(Segment.THTS2);
      DownstreamUnsatItem.VerticalSaturatedK := FortranFloatToStr(Segment.UHC2);
    end;
  end;
end;

procedure TSfrImporter.AssignDownstreamValues(Segment: TSegment;
  StressPeriodIndex: Integer; IcalcIndex: Integer);
var
  DownstreamItem: TSfrSegmentItem;
begin
  DownstreamItem := FSfrBoundary.
    DownstreamSegmentValues[IcalcIndex] as TSfrSegmentItem;
  if FSfrPackage.Isfropt in [0, 4, 5] then
  begin
    DownstreamItem.HydraulicConductivity := FortranFloatToStr(Segment.HCOND2);
    if FSfrPackage.Isfropt = 0 then
    begin
      DownstreamItem.StreamBedThickness := FortranFloatToStr(Segment.THICKM2);
      DownstreamItem.StreambedElevation := FortranFloatToStr(Segment.ELEVDN);
      DownstreamItem.StreamWidth := FortranFloatToStr(Segment.WIDTH2);
      DownstreamItem.StreamDepth := FortranFloatToStr(Segment.DEPTH2);
    end;
  end;
  if FSfrPackage.Isfropt in [4, 5] then
  begin
    if (Segment.ICalc in [1, 2]) and (StressPeriodIndex = 0) then
    begin
      DownstreamItem.StreamBedThickness := FortranFloatToStr(Segment.THICKM2);
      DownstreamItem.StreambedElevation := FortranFloatToStr(Segment.ELEVDN);
    end;
  end;
  if FSfrPackage.Isfropt <= 1 then
  begin
    DownstreamItem.StreamWidth := FortranFloatToStr(Segment.WIDTH2);
  end
  else
  begin
    if StressPeriodIndex = 0 then
    begin
      DownstreamItem.StreamWidth := FortranFloatToStr(Segment.WIDTH2);
    end;
  end;
end;

procedure TSfrImporter.AssignUpstreamValues(IcalcIndex: Integer;
  StressPeriodIndex: Integer; Segment: TSegment);
var
  UpstreamItem: TSfrSegmentItem;
begin
  UpstreamItem := FSfrBoundary.
    UpstreamSegmentValues[IcalcIndex] as TSfrSegmentItem;
  if FSfrPackage.Isfropt in [0, 4, 5] then
  begin
    UpstreamItem.HydraulicConductivity := FortranFloatToStr(Segment.HCOND1);
    if FSfrPackage.Isfropt = 0 then
    begin
      UpstreamItem.StreamBedThickness := FortranFloatToStr(Segment.THICKM1);
      UpstreamItem.StreambedElevation := FortranFloatToStr(Segment.ELEVUP);
      UpstreamItem.StreamWidth := FortranFloatToStr(Segment.WIDTH1);
      UpstreamItem.StreamDepth := FortranFloatToStr(Segment.DEPTH1);
    end;
  end;
  if FSfrPackage.Isfropt in [4, 5] then
  begin
    if (Segment.ICalc in [1, 2]) and (StressPeriodIndex = 0) then
    begin
      UpstreamItem.StreamBedThickness := FortranFloatToStr(Segment.THICKM1);
      UpstreamItem.StreambedElevation := FortranFloatToStr(Segment.ELEVUP);
    end;
  end;
  if FSfrPackage.Isfropt <= 1 then
  begin
    UpstreamItem.StreamWidth := FortranFloatToStr(Segment.WIDTH1);
  end
  else
  begin
    if StressPeriodIndex = 0 then
    begin
      UpstreamItem.StreamWidth := FortranFloatToStr(Segment.WIDTH1);
    end;
  end;
end;

procedure TSfrImporter.AssignEquationValues(IcalcIndex: Integer;
  Segment: TSegment);
var
  EqItem: TSfrEquationItem;
begin
  if Segment.ICalc = 3 then
  begin
    EqItem := FSfrBoundary.EquationValues[IcalcIndex] as TSfrEquationItem;
    EqItem.DepthCoefficient := FortranFloatToStr(Segment.CDPTH);
    EqItem.DepthExponent := FortranFloatToStr(Segment.FDPTH);
    EqItem.WidthCoefficient := FortranFloatToStr(Segment.AWDTH);
    EqItem.WidthExponent := FortranFloatToStr(Segment.BWDTH);
  end;
end;

procedure TSfrImporter.AssignChannelValues(IcalcIndex: Integer;
  StressPeriodIndex: Integer; Segment: TSegment);
var
  CrossSectionIndex: Integer;
  ChannelItem: TSfrChannelItem;
begin
  if Segment.ICalc in [1, 2] then
  begin
    ChannelItem := FSfrBoundary.ChannelValues[IcalcIndex] as TSfrChannelItem;
    ChannelItem.ChannelRoughness := FortranFloatToStr(Segment.ROUGHCH);
    if Segment.ICalc = 2 then
    begin
      ChannelItem.BankRoughness := FortranFloatToStr(Segment.ROUGHBK);
    end;
    if Segment.ICalc = 2 then
    begin
      if (StressPeriodIndex = 0) or (FSfrPackage.Isfropt <= 1) then
      begin
        for CrossSectionIndex := 0 to 7 do
        begin
          ChannelItem.X[CrossSectionIndex] :=
            FortranFloatToStr(Segment.TableX[CrossSectionIndex]);
          ChannelItem.Z[CrossSectionIndex] :=
            FortranFloatToStr(Segment.TableZ[CrossSectionIndex]);
        end;
      end;
    end;
  end;
end;

procedure TSfrImporter.AssignSegmentFlowValues(IcalcIndex: Integer;
  Segment: TSegment);
var
  FlowItem: TSfrSegmentFlowItem;
begin
  FlowItem := FSfrBoundary.SegmentFlows[IcalcIndex] as TSfrSegmentFlowItem;
  FlowItem.Flow := FortranFloatToStr(Segment.FLOW);
  FlowItem.Precipitation := FortranFloatToStr(Segment.PPTSW);
  FlowItem.Evapotranspiration := FortranFloatToStr(Segment.ETSW);
  FlowItem.Runnoff := FortranFloatToStr(Segment.RUNOFF);
end;

procedure TSfrImporter.AssignFlowTableValues(IcalcIndex: Integer;
  Segment: TSegment);
var
  Table: TSfrTablelItem;
  TableIndex: Integer;
  TableRow: TSfrTableRowItem;
  TableItem: TFlowTableItem;
begin
  if Segment.ICalc = 4 then
  begin
    Table := FSfrBoundary.TableCollection[IcalcIndex] as TSfrTablelItem;
    for TableIndex := 0 to Segment.NSTRPTS - 1 do
    begin
      TableRow := Table.SfrTable.Add as TSfrTableRowItem;
      TableItem := Segment.FFlowTable[TableIndex];
      TableRow.Flow := FortranFloatToStr(TableItem.FLOWTAB);
      TableRow.Depth := FortranFloatToStr(TableItem.DPTHTAB);
      TableRow.Width := FortranFloatToStr(TableItem.WDTHTAB);
    end;
  end;
end;

procedure TSfrImporter.AssignParamIcalcValues(IcalcIndex: Integer;
  Segment: TSegment);
var
  Item: TSfrParamIcalcItem;
begin
  Item := FSfrBoundary.ParamIcalc.Items[IcalcIndex];
  Item.ICalc := Segment.ICALC;
//  FSegmentStorage.Add(Segment);
//  FItemStorage.Add(Item);
  Item.OutflowSegment := Segment.OUTSEG;
  Item.DiversionSegment := Segment.IUPSEG;
  if Item.DiversionSegment > 0 then
  begin
    Item.IPRIOR := Segment.IPRIOR;
  end;
end;

procedure TSfrImporter.AssignStartAndEndTimes;
var
  StressPeriod: TListStressPeriod;
  EndTime: Double;
  StartTime: Double;
  StressPeriodIndex: Integer;
  Item: TSfrItem;
  SP: TListStressPeriod;
  InnerIndex: Integer;
  ParamIcalcItem: TSfrParamIcalcItem;
  TableItem: TSfrTablelItem;
  FlowItem: TSfrSegmentFlowItem;
  ChannelItem: TSfrChannelItem;
  EqItem: TSfrEquationItem;
  UpstreamItem: TSfrSegmentItem;
  DownstreamItem: TSfrSegmentItem;
  UpUnsatItem: TSfrUnsatSegmentItem;
  DownUnsatItem: TSfrUnsatSegmentItem;
begin
  for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
  begin
    // initialize the start and end times for when the boundary will be
    // applied.
    StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    StressPeriod := FStressPeriods[StressPeriodIndex];
    if StressPeriod.Reuse and not FParamUsed then
    begin
      Continue;
    end
    else
    begin
      // Update the endtime if the boundaries from the current
      // stress period will be reused in subsequent stress periods.
      for InnerIndex := StressPeriodIndex + 1 to FStressPeriods.ArrayLength - 1 do
      begin
        SP := FStressPeriods[InnerIndex];
        if SP.Reuse and not FParamUsed then
        begin
          EndTime := FModel.ModflowStressPeriods[InnerIndex].EndTime;
        end
        else
        begin
          break;
        end;
      end;
    end;
    if StressPeriodIndex = 0 then
    begin
      Item := FSfrBoundary.Values.Add as TSfrItem;
      Item.StartTime := StartTime;
      Item.EndTime := EndTime;
    end;

    ParamIcalcItem := FSfrBoundary.ParamIcalc.Add as TSfrParamIcalcItem;
    ParamIcalcItem.StartTime := StartTime;
    ParamIcalcItem.EndTime := EndTime;

    TableItem := FSfrBoundary.TableCollection.Add as TSfrTablelItem;
    TableItem.StartTime := StartTime;
    TableItem.EndTime := EndTime;

    FlowItem := FSfrBoundary.SegmentFlows.Add as TSfrSegmentFlowItem;
    FlowItem.StartTime := StartTime;
    FlowItem.EndTime := EndTime;

    ChannelItem := FSfrBoundary.ChannelValues.Add as TSfrChannelItem;
    ChannelItem.StartTime := StartTime;
    ChannelItem.EndTime := EndTime;

    EqItem := FSfrBoundary.EquationValues.Add as TSfrEquationItem;
    EqItem.StartTime := StartTime;
    EqItem.EndTime := EndTime;

    UpstreamItem := FSfrBoundary.UpstreamSegmentValues.Add as TSfrSegmentItem;
    UpstreamItem.StartTime := StartTime;
    UpstreamItem.EndTime := EndTime;

    DownstreamItem := FSfrBoundary.DownstreamSegmentValues.Add
      as TSfrSegmentItem;
    DownstreamItem.StartTime := StartTime;
    DownstreamItem.EndTime := EndTime;

    if StressPeriodIndex = 0 then
    begin
      UpUnsatItem := FSfrBoundary.UpstreamUnsatSegmentValues.Add
        as TSfrUnsatSegmentItem;
      UpUnsatItem.StartTime := StartTime;
      UpUnsatItem.EndTime := EndTime;

      DownUnsatItem := FSfrBoundary.DownstreamUnsatSegmentValues.Add
        as TSfrUnsatSegmentItem;
      DownUnsatItem.StartTime := StartTime;
      DownUnsatItem.EndTime := EndTime;
    end;
  end;
end;

procedure TSfrImporter.AssignReachValues(List: TList;
  ScreenObject: TScreenObject);
var
  Values: TValueArrayStorage;
  ValueArray: TValueArrayItem;
  Item: TSfrItem;
  Index: Integer;
  Reach: TSfrLocationObject;
  PriorPoint: TPoint2D;
  SectionLength: double;
  PointIndex: Integer;
  APoint: TPoint2D;
begin
//  FSfrBoundary.FormulaInterpretation := fiSpecific;

  Item := FSfrBoundary.Values[0] as TSfrItem;
  if List.Count > 1 then
  begin
    ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
    ValueArray.Name := 'RCHLEN';
    Values := ValueArray.Values;
    Values.DataType := rdtDouble;
    Values.Count := List.Count;
    for Index := 0 to List.Count - 1 do
    begin
      Reach := List[Index];
      if ScreenObject.SectionLength[Index] = 1 then
      begin
        Values.RealValues[Index] := Reach.RCHLEN;
      end
      else
      begin
        SectionLength := 0;
        PriorPoint := ScreenObject.Points[ScreenObject.SectionStart[Index]];
        for PointIndex := ScreenObject.SectionStart[Index]+1
          to ScreenObject.SectionEnd[Index] do
        begin
          APoint := ScreenObject.Points[PointIndex];
          SectionLength := SectionLength + Distance(PriorPoint,APoint);
          PriorPoint := APoint;
        end;
        Values.RealValues[Index] := Reach.RCHLEN / SectionLength;
      end;

    end;
    Item.ReachLength := 'If(' + StrObjectIntersectLength + ' > 0., ('
      + rsObjectImportedValuesR + '("RCHLEN") * ' + StrObjectIntersectLength
      + '), ' + rsObjectImportedValuesR + '("RCHLEN"))';
  end
  else
  begin
    Reach := List[0];
    Item.ReachLength := FortranFloatToStr(Reach.RCHLEN);
  end;
  if FSfrPackage.Isfropt in [1, 2, 3] then
  begin
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'STRTOP';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.STRTOP;
      end;
      Item.StreambedElevation := rsObjectImportedValuesR + '("STRTOP")';
    end
    else
    begin
      Reach := List[0];
      Item.StreambedElevation := FortranFloatToStr(Reach.STRTOP);
    end;
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'SLOPE';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.SLOPE;
      end;
      Item.StreamSlope := rsObjectImportedValuesR + '("SLOPE")';
    end
    else
    begin
      Reach := List[0];
      Item.StreamSlope := FortranFloatToStr(Reach.SLOPE);
    end;
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'STRTHICK';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.STRTHICK;
      end;
      Item.StreamBedThickness := rsObjectImportedValuesR + '("STRTHICK")';
    end
    else
    begin
      Reach := List[0];
      Item.StreamBedThickness := FortranFloatToStr(Reach.STRTHICK);
    end;
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'STRHC1';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.STRHC1;
      end;
      Item.HydraulicConductivity := rsObjectImportedValuesR + '("STRHC1")';
    end
    else
    begin
      Reach := List[0];
      Item.HydraulicConductivity := FortranFloatToStr(Reach.STRHC1);
    end;
  end;
  if FSfrPackage.Isfropt in [2, 3] then
  begin
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'THTS';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.THTS;
      end;
      Item.SaturatedWaterContent := rsObjectImportedValuesR + '("THTS")';
    end
    else
    begin
      Reach := List[0];
      Item.SaturatedWaterContent := FortranFloatToStr(Reach.THTS);
    end;
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'THTI';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.THTI;
      end;
      Item.InitialWaterContent := rsObjectImportedValuesR + '("THTI")';
    end
    else
    begin
      Reach := List[0];
      Item.InitialWaterContent := FortranFloatToStr(Reach.THTI);
    end;
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'EPS';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.EPS;
      end;
      Item.BrooksCoreyExponent := rsObjectImportedValuesR + '("EPS")';
    end
    else
    begin
      Reach := List[0];
      Item.BrooksCoreyExponent := FortranFloatToStr(Reach.EPS);
    end;
  end;
  if FSfrPackage.Isfropt in [2, 3] then
  begin
    if List.Count > 1 then
    begin
      ValueArray := ScreenObject.ImportedValues.Add as TValueArrayItem;
      ValueArray.Name := 'UHC';
      Values := ValueArray.Values;
      Values.DataType := rdtDouble;
      Values.Count := List.Count;
      for Index := 0 to List.Count - 1 do
      begin
        Reach := List[Index];
        Values.RealValues[Index] := Reach.UHC;
      end;
      Item.VerticalK := rsObjectImportedValuesR + '("UHC")';
    end
    else
    begin
      Reach := List[0];
      Item.VerticalK := FortranFloatToStr(Reach.UHC);
    end;
  end;
  ScreenObject.ImportedValues.CacheData;
end;

procedure TSfrImporter.ReadFirstDataSet5WithParameters;
//var
//  IRDFLG: Integer;
//  IPTFLG: Integer;
begin
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, DummyInteger); // IRDFLG
  Read(FImporter.FFile, DummyInteger); // IPTFLG
  Read(FImporter.FFile, NP);
  Inc(FCurrentStressPeriod);
  InitializeStressPeriods;
  FStressPeriodSegments.ArrayLength :=
    FModel.ModflowStressPeriods.Count;
  InitializeCurrentStressPeriod;
end;

procedure TSfrImporter.ReadFirstDataSet5WithoutParameters;
//var
//  IPTFLG: Integer;
//  IRDFLG: Integer;
begin
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, DummyInteger); // IRDFLG
  Read(FImporter.FFile, DummyInteger); // IPTFLG
  NP := 0;
  Inc(FCurrentStressPeriod);
  InitializeStressPeriods;
  FStressPeriodSegments.ArrayLength :=
    FModel.ModflowStressPeriods.Count;
  InitializeCurrentStressPeriod;
end;

procedure TSfrImporter.ReadFlowTableWidths;
var
  Index: Integer;
begin
  for Index := 0 to FCurrentSegment.NSTRPTS - 1 do
  begin
    Read(FImporter.FFile, FCurrentSegment.FFlowTable[Index].WDTHTAB);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  if SegCount = NLST then
  begin
    Inc(CurrentInstance);
  end;
end;

procedure TSfrImporter.ReadFlowTableDepths;
var
  Index: Integer;
begin
  for Index := 0 to FCurrentSegment.NSTRPTS - 1 do
  begin
    Read(FImporter.FFile, FCurrentSegment.FFlowTable[Index].DPTHTAB);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSfrImporter.ReadFlowTableFlows;
var
  Index: Integer;
begin
  for Index := 0 to FCurrentSegment.NSTRPTS - 1 do
  begin
    Read(FImporter.FFile, FCurrentSegment.FFlowTable[Index].FLOWTAB);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSfrImporter.ReadTableZValues;
var
  Index: Integer;
begin
  for Index := 0 to Length(FCurrentSegment.TableZ) - 1 do
  begin
    Read(FImporter.FFile, FCurrentSegment.TableZ[Index]);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  if SegCount = NLST then
  begin
    Inc(CurrentInstance);
  end;
end;

procedure TSfrImporter.ReadTableXValues;
var
  Index: Integer;
begin
  for Index := 0 to Length(FCurrentSegment.TableX) - 1 do
  begin
    Read(FImporter.FFile, FCurrentSegment.TableX[Index]);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSfrImporter.ReadSegment4b6a(const ALabel: string;
  IsParameter: boolean);
var
  LabelList: TStringList;
  Index: Integer;
  DataLabel: string;
  Instance: TSfrInstanceObject;
  NSEG: integer;
begin
  Inc(SegCount);

  LabelList := TStringList.Create;
  try
    LabelList.Delimiter := ',';
    LabelList.DelimitedText := ALabel;
    Assert(LabelList.Count > 0);
    Assert(LabelList[0] = 'NSEG');
    Read(FImporter.FFile, NSEG);
    if IsParameter then
    begin
      Instance := FParameters[CurrentParameter].
        Instances[CurrentInstance] as TSfrInstanceObject;
      FCurrentSegment := Instance.Segments[FCurrentSegmentIndex];
    end
    else
    begin
      FCurrentSegment := FCurrentSegments[NSEG - 1];
    end;
    FCurrentSegment.NSEG := NSEG;
    for Index := 1 to LabelList.Count - 1 do
    begin
      DataLabel := LabelList[Index];
      if Index = LabelList.Count - 1 then
      begin
        // Remove colon at end.
        SetLength(DataLabel, Length(DataLabel)-1);
      end;
      if DataLabel = 'ICALC' then
      begin
        Read(FImporter.FFile, FCurrentSegment.ICALC);
      end
      else if DataLabel = 'OUTSEG' then
      begin
        Read(FImporter.FFile, FCurrentSegment.OUTSEG);
      end
      else if DataLabel = 'IUPSEG' then
      begin
        Read(FImporter.FFile, FCurrentSegment.IUPSEG);
      end
      else if DataLabel = 'IPRIOR' then
      begin
        Read(FImporter.FFile, FCurrentSegment.IPRIOR);
      end
      else if DataLabel = 'NSTRPTS' then
      begin
        Read(FImporter.FFile, FCurrentSegment.NSTRPTS);
        FCurrentSegment.FFlowTable.ArrayLength := FCurrentSegment.NSTRPTS;
      end
      else if DataLabel = 'FLOW' then
      begin
        Read(FImporter.FFile, FCurrentSegment.FLOW);
      end
      else if DataLabel = 'RUNOFF' then
      begin
        Read(FImporter.FFile, FCurrentSegment.RUNOFF);
      end
      else if DataLabel = 'ETSW' then
      begin
        Read(FImporter.FFile, FCurrentSegment.ETSW);
      end
      else if DataLabel = 'PPTSW' then
      begin
        Read(FImporter.FFile, FCurrentSegment.PPTSW);
      end
      else if DataLabel = 'ROUGHCH' then
      begin
        Read(FImporter.FFile, FCurrentSegment.ROUGHCH);
      end
      else if DataLabel = 'ROUGHBK' then
      begin
        Read(FImporter.FFile, FCurrentSegment.ROUGHBK);
      end
      else if DataLabel = 'CDPTH' then
      begin
        Read(FImporter.FFile, FCurrentSegment.CDPTH);
      end
      else if DataLabel = 'FDPTH' then
      begin
        Read(FImporter.FFile, FCurrentSegment.FDPTH);
      end
      else if DataLabel = 'AWDTH' then
      begin
        Read(FImporter.FFile, FCurrentSegment.AWDTH);
      end
      else if DataLabel = 'BWDTH' then
      begin
        Read(FImporter.FFile, FCurrentSegment.BWDTH);
      end
      else
      begin
        Assert(False);
      end;
    end;
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  finally
    LabelList.Free;
  end;
end;

procedure TSfrImporter.ReadSegment4c6b(const ALabel: string);
var
  LabelList: TStringList;
  Index: Integer;
  DataLabel: string;
begin
  LabelList := TStringList.Create;
  try
    LabelList.Delimiter := ',';
    LabelList.DelimitedText := ALabel;
    Assert(LabelList.Count > 0);
    for Index := 0 to LabelList.Count - 1 do
    begin
      DataLabel := LabelList[Index];
      if Index = LabelList.Count - 1 then
      begin
        // Remove colon at end.
        SetLength(DataLabel, Length(DataLabel)-1);
      end;
      if DataLabel = 'HCOND1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.HCOND1);
      end
      else if DataLabel = 'THICKM1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.THICKM1);
      end
      else if DataLabel = 'ELEVUP' then
      begin
        Read(FImporter.FFile, FCurrentSegment.ELEVUP);
      end
      else if DataLabel = 'WIDTH1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.WIDTH1);
      end
      else if DataLabel = 'DEPTH1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.DEPTH1);
      end
      else if DataLabel = 'THTS1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.THTS1);
      end
      else if DataLabel = 'THTI1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.THTI1);
      end
      else if DataLabel = 'EPS1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.EPS1);
      end
      else if DataLabel = 'UHC1' then
      begin
        Read(FImporter.FFile, FCurrentSegment.UHC1);
      end
      else
      begin
        Assert(False);
      end;
    end;
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  finally
    LabelList.Free;
  end;
end;

procedure TSfrImporter.ReadSegment4d6c(const ALabel: string);
var
  LabelList: TStringList;
  Index: Integer;
  DataLabel: string;
begin
  LabelList := TStringList.Create;
  try
    LabelList.Delimiter := ',';
    LabelList.DelimitedText := ALabel;
    Assert(LabelList.Count > 0);
    for Index := 0 to LabelList.Count - 1 do
    begin
      DataLabel := LabelList[Index];
      if Index = LabelList.Count - 1 then
      begin
        // Remove colon at end.
        SetLength(DataLabel, Length(DataLabel)-1);
      end;
      if DataLabel = 'HCOND2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.HCOND2);
      end
      else if DataLabel = 'THICKM2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.THICKM2);
      end
      else if DataLabel = 'ELEVDN' then
      begin
        Read(FImporter.FFile, FCurrentSegment.ELEVDN);
      end
      else if DataLabel = 'WIDTH2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.WIDTH2);
      end
      else if DataLabel = 'DEPTH2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.DEPTH2);
      end
      else if DataLabel = 'THTS2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.THTS2);
      end
      else if DataLabel = 'THTI2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.THTI2);
      end
      else if DataLabel = 'EPS2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.EPS2);
      end
      else if DataLabel = 'UHC2' then
      begin
        Read(FImporter.FFile, FCurrentSegment.UHC2);
      end
      else
      begin
        Assert(False);
      end;
    end;
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  finally
    LabelList.Free;
  end;
  if not (FCurrentSegment.ICALC in [2,4]) then
  begin
    if SegCount = NLST then
    begin
      Inc(CurrentInstance);
    end;
  end;
end;

procedure TSfrImporter.ReadSegmentStart(IsParameter: boolean);
var
  NSEG: Integer;
  Instance: TSfrInstanceObject;

begin
  SegCount := 0;
  Read(FImporter.FFile, NSEG);
  if IsParameter then
  begin
    Inc(FCurrentSegmentIndex);
    Instance := FParameters[CurrentParameter].
      Instances[CurrentInstance] as TSfrInstanceObject;
    FCurrentSegment := Instance.Segments[FCurrentSegmentIndex];
  end
  else
  begin
    FCurrentSegment := FCurrentSegments[NSEG - 1];
  end;
  FCurrentSegment.NSEG := NSEG;
  Read(FImporter.FFile, FCurrentSegment.ICALC);
  Read(FImporter.FFile, FCurrentSegment.OUTSEG);
  Read(FImporter.FFile, FCurrentSegment.IUPSEG);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

function TSfrImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  Assert(False);
  result := nil;
end;

function TSfrImporter.DefaultInstanceName(StressPeriodIndex: integer): string;
begin
  result := 'I_' + IntToStr(StressPeriodIndex+1);
end;

procedure TSfrImporter.HandlePackage;
var
  LocationList: TList;
  Index: Integer;
  PriorSegNumber: Integer;
  Location: TSfrLocationObject;
  ScreenObjectIndex: integer;
  ParameterSegments: TIntegerList;
//  Segment: TSegment;
//  Item: TSfrParamIcalcItem;
begin
  if FImportedPackage or (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  inherited;
  FSfrPackage := FModel.ModflowPackages.SfrPackage;
  FSfrPackage.IsSelected := True;
  FSfrPackage.Comments := FComments;
  FSfrPackage.Dleak := self.DLEAK;
  FSfrPackage.Isfropt := self.ISFROPT;
  FSfrPackage.Nstrail := self.NSTRAIL;
  FSfrPackage.Isuzn := self.ISUZN;
  FSfrPackage.Nsfrsets := self.NSFRSETS;
  FSfrPackage.KinematicRouting := self.IRTFLG > 0;
  if FSfrPackage.KinematicRouting then
  begin
    FSfrPackage.TimeStepsForKinematicRouting := NUMTIM;
    FSfrPackage.KinematicRoutingTolerance := FLWTOL;
    FSfrPackage.KinematicRoutingWeight := WEIGHT;
  end;

  FSfrPackage.LossFactorOption := Self.FLossFactorUsed;
  if FSfrPackage.LossFactorOption then
  begin
    FSfrPackage.LossFactor := Self.FLossFactor;
    FModel.ModelSelection := msModflowNWT;
  end;

  ParameterSegments := TIntegerList.Create;
  try
    ParameterSegments.Sorted := True;
    CreateParamInstances(ParameterSegments);

    ScreenObjectIndex := 0;
    LocationList := TList.Create;
    try
      LocationList.Capacity := FReaches.ArrayLength;
      PriorSegNumber := -1;
      for Index := 0 to FReaches.ArrayLength - 1 do
      begin
        Location := FReaches.Reaches[Index];
        if (Index = 0) then
        begin
          PriorSegNumber := Location.SegmentNumber;
        end;
        if (Location.SegmentNumber = PriorSegNumber) then
        begin
          LocationList.Add(Location);
        end;
        if (Location.SegmentNumber <> PriorSegNumber) then
        begin
          if LocationList.Count > 0 then
          begin
            FParamUsed := ParameterSegments.IndexOf(PriorSegNumber) >= 0;
            CreateStream(LocationList, ScreenObjectIndex);
            if FParamUsed then
            begin
              AssignParameterSegmentProperties(PriorSegNumber);
            end
            else
            begin
              AssignSegmentProperties;
            end;
            LocationList.Clear;
            LocationList.Capacity := FReaches.ArrayLength;
          end;
          LocationList.Add(Location);
          PriorSegNumber := Location.SegmentNumber;
        end;
        if (Index = FReaches.ArrayLength - 1) then
        begin
          if (LocationList.Count = 0)
            or (LocationList[LocationList.Count-1] <> Location) then
          begin
            LocationList.Add(Location);
            PriorSegNumber := Location.SegmentNumber;
          end;
          FParamUsed := ParameterSegments.IndexOf(PriorSegNumber) >= 0;
          CreateStream(LocationList, ScreenObjectIndex);
          if FParamUsed then
          begin
            AssignParameterSegmentProperties(PriorSegNumber);
          end
          else
          begin
            AssignSegmentProperties;
          end;
          LocationList.Clear;
        end;
      end;
//      for Index := 0 to FSegmentStorage.Count - 1 do
//      begin
//        Segment := FSegmentStorage[Index];
//        Item := FItemStorage[Index];
//        Item.OutflowSegment := Segment.OUTSEG;
//        Item.DiversionSegment := Segment.IUPSEG;
//        if Item.DiversionSegment > 0 then
//        begin
//          Item.IPRIOR := Segment.IPRIOR;
//        end;
//      end;
    finally
      LocationList.Free;
    end;
  finally
    ParameterSegments.Free;
  end;
  ReleaseMemory;
  frmGoPhast.EnableLinkStreams;
end;

procedure TSfrImporter.ReadLossFactor;
begin
  Readln(FImporter.FFile, FLossFactor);
  FLossFactorUsed := True;
end;

procedure TSfrImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel =
      'NSTRM, NSS, NSFRPAR, NPARSEG, CONST, DLEAK, ISTCB1, ISTCB2:' then
    begin
      ReadBasicData;
    end
    else if ALabel = 'FACTOR:' then
    begin
      ReadLossFactor;
    end
    else if ALabel = 'ISFROPT:' then
    begin
      ReadIsfropt;
    end
    else if ALabel = 'NSTRAIL, ISUZN, NSFRSETS:' then
    begin
      ReadUnsatParameters;
    end
    else if ALabel = 'IRTFLG, NUMTIM, WEIGHT, FLWTOL:' then
    begin
      Read(FImporter.FFile, IRTFLG);
      Read(FImporter.FFile, NUMTIM);
      Read(FImporter.FFile, WEIGHT);
      Read(FImporter.FFile, FLWTOL);
      Readln(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'NUMTAB,MAXVAL:' then
    begin
      Read(FImporter.FFile, NUMTAB);
      Read(FImporter.FFile, MAXVAL);
      Readln(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'KRCH IRCH JRCH ISEG IREACH:' then
    begin
      Inc(FCurrentReachIndex);
      FCurrentReach := FReaches[FCurrentReachIndex] as TSfrLocationObject;
      Read(FImporter.FFile, FCurrentReach.Layer);
      Read(FImporter.FFile, FCurrentReach.Row);
      Read(FImporter.FFile, FCurrentReach.Column);
      Read(FImporter.FFile, FCurrentReach.SegmentNumber);
      Read(FImporter.FFile, FCurrentReach.ReachNumber);
      Readln(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'RCHLEN, STRTOP, SLOPE, STRTHICK, STRHC1:' then
    begin
      Read(FImporter.FFile, FCurrentReach.RCHLEN);
      Read(FImporter.FFile, FCurrentReach.STRTOP);
      Read(FImporter.FFile, FCurrentReach.SLOPE);
      Read(FImporter.FFile, FCurrentReach.STRTHICK);
      Read(FImporter.FFile, FCurrentReach.STRHC1);
      Readln(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'THTS,THTI,EPS:' then
    begin
      Read(FImporter.FFile, FCurrentReach.THTS);
      Read(FImporter.FFile, FCurrentReach.THTI);
      Read(FImporter.FFile, FCurrentReach.EPS);
      Readln(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'UHC:' then
    begin
      Read(FImporter.FFile, FCurrentReach.UHC);
      Readln(FImporter.FFile);
      FImporter.UpdateProgress;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
      FCurrentSegmentIndex := -1;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
      // do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
      FCurrentSegmentIndex := -1;
      SegCount := 0;
    end
    else if ALabel = 'n, icalc, noutseg, iupseg:' then
    begin
      ReadSegmentStart(True);
    end
    else if Copy(ALabel, 1,5) = 'NSEG,' then
    begin
      ReadSegment4b6a(ALabel, True);
    end
    else if (Copy(ALabel, 1,7) = 'HCOND1,')
      or (Copy(ALabel, 1,7) = 'WIDTH1,') then
    begin
      ReadSegment4c6b(ALabel);
    end
    else if (Copy(ALabel, 1,7) = 'HCOND2,')
      or (Copy(ALabel, 1,7) = 'WIDTH2,') then
    begin
      ReadSegment4d6c(ALabel);
    end
    else if (ALabel = 'XCPT1 XCPT2 ... XCPT8:') then
    begin
      ReadTableXValues;
    end
    else if (ALabel = 'ZCPT1 ZCPT2 ... ZCPT8:') then
    begin
      ReadTableZValues;
    end
    else if (ALabel = 'FLOWTAB(1) FLOWTAB(2) ... FLOWTAB(NSTRPTS):') then
    begin
      ReadFlowTableFlows;
    end
    else if (ALabel = 'DPTHTAB(1) DPTHTAB(2) ... DPTHTAB(NSTRPTS):') then
    begin
      ReadFlowTableDepths;
    end
    else if (ALabel = 'WDTHTAB(1) WDTHTAB(2) ... WDTHTAB(NSTRPTS):') then
    begin
      ReadFlowTableWidths;
    end
    else if ALabel = 'ITMP, IRDFLG, IPTFLG:' then
    begin
      ReadFirstDataSet5WithoutParameters;
    end
    else if ALabel = 'ITMP, IRDFLG, IPTFLG, NP:' then
    begin
      ReadFirstDataSet5WithParameters;
    end
    else
    begin
      Assert(False, Format('Unrecognized label %s', [ALabel]));
    end;
  end
  else
  begin
    if ALabel = 'ITMP, IRDFLG, IPTFLG:' then
    begin
      ReadDataSet5WithoutParameters;
    end
    else if ALabel = 'ITMP, IRDFLG, IPTFLG, NP:' then
    begin
      ReadDataSet5WithParameters;
    end
    else if ALabel = 'n, icalc, noutseg, iupseg:' then
    begin
      ReadSegmentStart(False);
    end
    else if Copy(ALabel, 1,5) = 'NSEG,' then
    begin
      ReadSegment4b6a(ALabel, False);
    end
    else if (Copy(ALabel, 1,6) = 'HCOND1')
      or (Copy(ALabel, 1,6) = 'WIDTH1') then
    begin
      ReadSegment4c6b(ALabel);
    end
    else if (Copy(ALabel, 1,6) = 'HCOND2')
      or (Copy(ALabel, 1,6) = 'WIDTH2') then
    begin
      ReadSegment4d6c(ALabel);
    end
    else if (ALabel = 'XCPT1 XCPT2 ... XCPT8:') then
    begin
      ReadTableXValues;
    end
    else if (ALabel = 'ZCPT1 ZCPT2 ... ZCPT8:') then
    begin
      ReadTableZValues;
    end
    else if (ALabel = 'FLOWTAB(1) FLOWTAB(2) ... FLOWTAB(NSTRPTS):') then
    begin
      ReadFlowTableFlows;
    end
    else if (ALabel = 'DPTHTAB(1) DPTHTAB(2) ... DPTHTAB(NSTRPTS):') then
    begin
      ReadFlowTableDepths;
    end
    else if (ALabel = 'WDTHTAB(1) WDTHTAB(2) ... WDTHTAB(NSTRPTS):') then
    begin
      ReadFlowTableWidths;
    end
    else if (ALabel = 'Pname:') then
    begin
      ReadParamNameForStressPeriod
    end
    else if (ALabel = 'Iname:') then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else if (ALabel = 'SEGNUM NUMVAL IUNIT:') then
    begin
      ReadExternalFlows;
    end
    else
    begin
//      ShowMessage(ALabel);
      Assert(False, Format('Unrecognized label %s', [ALabel]));
    end;
  end;
end;

procedure TSfrImporter.InitializeCurrentStressPeriod;
begin
  inherited;
  FCurrentSegments := FStressPeriodSegments[FCurrentStressPeriod];
  FCurrentSegments.ArrayLength := NSS;
end;

function TSfrImporter.ParameterType: TParameterType;
begin
  result := ptSFR;
end;

{ TSfrInstanceObject }

function TSfrInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSfrLocationObject;
end;

constructor TSfrInstanceObject.Create;
begin
  inherited;
  FSegments:= TSegmentArray.Create;
end;

destructor TSfrInstanceObject.Destroy;
begin
  FSegments.Free;
  inherited;
end;

function TSfrInstanceObject.GetSegByNumber(NSEG: integer): TSegment;
var
  Index: Integer;
  Segment: TSegment;
begin
  result := nil;
  for Index := 0 to Segments.ArrayLength - 1 do
  begin
    Segment := Segments[Index];
    if Segment.NSEG = NSEG then
    begin
      result := Segment;
      Exit;
    end;
  end;
end;

{ TSfrParameterObject }

function TSfrParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSfrInstanceObject;
end;

{ TSfrParamArray }

function TSfrParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSfrParameterObject;
end;

{ TSfrStressPeriod }

function TSfrReaches.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSfrLocationObject;
end;

{ TSfrStressPeriodArray }

function TSfrStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSegmentArray;
end;

{ TSegmentArray }

function TSegmentArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSegment;
end;

function TSegmentArray.GetSegments(Index: integer): TSegment;
begin
  result := Objects[Index] as TSegment;
end;

{ TFlowTableArray }

function TFlowTableArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TFlowTableItem;
end;

function TFlowTableArray.GetItem(Index: integer): TFlowTableItem;
begin
  result := Objects[Index] as TFlowTableItem;
end;

{ TSegment }

constructor TSegment.Create;
begin
  inherited;
  FFlowTable := TFlowTableArray.Create;
end;

destructor TSegment.Destroy;
begin
  FFlowTable.Free;
  inherited;
end;

function TSfrReaches.GetReach(Index: integer): TSfrLocationObject;
begin
  result := Objects[Index] as TSfrLocationObject;
end;

{ TStressPeriodSegments }

function TStressPeriodSegments.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSegmentArray;
end;

function TStressPeriodSegments.GetSegmentArray(Index: integer): TSegmentArray;
begin
  result := Objects[Index] as TSegmentArray;
end;

function TListStressPeriod.IndexOfParameter(
  const ParameterName: string): integer;
var
  Index: Integer;
begin
  result := -1;
  for Index := 0 to Length(Parameters) - 1 do
  begin
    if SameText(ParameterName, Parameters[Index]) then
    begin
      result := Index;
      Exit;
    end;
  end;
end;

function TListParameterObject.GetInstanceByName(
  const InstanceName: string): TListInstanceObject;
var
  Index: Integer;
  Instance: TListInstanceObject;
begin
  result := nil;
  for Index := 0 to ArrayLength - 1 do
  begin
    Instance := Instances[Index];
    if AnsiCompareText(Instance.Name, InstanceName) = 0 then
    begin
      result := Instance;
      Exit;
    end;
  end;
end;

{ THobImporter }

function ML_Compare(Item1, Item2: Pointer): Integer;
var
  ML1, ML2: TMultLayerFactor;
begin
  ML1 := Item1;
  ML2 := Item2;
  result := ML1.Layer - ML2.Layer;
end;



constructor THobImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'HOB');
  FHeadObservations:= THeadObsevationArray.Create;
  FCurrentObsIndex := -1;
end;

destructor THobImporter.Destroy;
begin
  FHeadObservations.Free;
  inherited;
end;

procedure THobImporter.HandlePackage;
var
  ObsIndex: Integer;
  Obs: THeadObservation;
  ScreenObject: TScreenObject;
  UndoCreateScreenObject: TCustomUndo;
  APoint: TPoint2D;
  HeadObservations: THobBoundary;
  ValueIndex: Integer;
  ObsTime: TMultiTimeObs;
  ObsItem: THobItem;
  Layer: Integer;
  Elevation: Real;
  HighLayer: Integer;
  LowLayer: Integer;
  LayerIndex: Integer;
  ML: TMultLayerFactor;
  MHItem: TMultiHeadItem;
  ML_List: TList;
  Row: integer;
  Column: integer;
const
  ScreenObjectNameRoot = 'Imported_Head_Observation';
begin
  inherited;
  FHobPackage := FModel.ModflowPackages.HobPackage;
  FHobPackage.IsSelected := True;
  frmGoPhast.EnableManageHeadObservations;

  frmErrorsAndWarnings.RemoveWarningGroup(FModel, StrObservationsWithIn);

  FHobPackage.Comments := FComments;
  FHobPackage.DryHead := HOBDRY;
  FHeadObservations.ArrayLength := FCurrentObsIndex+1;
  for ObsIndex := 0 to FHeadObservations.ArrayLength - 1 do
  begin
    Obs := FHeadObservations[ObsIndex];

    ScreenObject := TScreenObject.CreateWithViewDirection(FModel, vdTop,
      UndoCreateScreenObject, False);
    ScreenObject.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);
    ScreenObject.Name := ScreenObjectNameRoot + '_'
      + IntToStr(ObsIndex+1);
    FModel.AddScreenObject(ScreenObject);
    ScreenObject.ElevationCount := ecZero;
    ScreenObject.SetValuesOfIntersectedCells := True;
    ScreenObject.EvaluatedAt := eaBlocks;
    ScreenObject.Visible := False;
    ScreenObject.Capacity := 1;
    APoint := FImporter.CenterPoints[Obs.Row-1, Obs.Column-1];
    APoint := FModel.Grid.
      RotateFromRealWorldCoordinatesToGridCoordinates(APoint);
    APoint.x := APoint.x
      + FModel.Grid.ColumnWidth[Obs.Column-1]*Obs.ColumnOffset;
    APoint.y := APoint.y - FModel.Grid.RowWidth[Obs.Row-1]*Obs.RowOffset;
    APoint := FModel.Grid.
      RotateFromGridCoordinatesToRealWorldCoordinates(APoint);
    ScreenObject.AddPoint(APoint, True);

    Row := Obs.Row-1;
    if (Obs.RowOffset = -0.5) and (Row > 0) then
    begin
      Dec(Row);
    end;
    Column := Obs.Column-1;
    if (Obs.ColumnOffset = 0.5) and (Column < FModel.Grid.ColumnCount-1) then
    begin
      Inc(Column);
    end;
    if Obs.FMultiLayers.ArrayLength > 0 then
    begin
      HighLayer := Obs.FMultiLayers[0].Layer;
      LowLayer := HighLayer;
      for LayerIndex := 1 to Obs.FMultiLayers.ArrayLength - 1 do
      begin
        HighLayer := Min(HighLayer, Obs.FMultiLayers[LayerIndex].Layer);
        LowLayer  := Max(LowLayer , Obs.FMultiLayers[LayerIndex].Layer);
      end;
      ScreenObject.ElevationCount := ecTwo;

      Layer := FModel.ModflowLayerToDataSetLayer(HighLayer);
      Elevation := FModel.Grid.ThreeDElementCenter(ZeroBasedID(Layer, Row, Column)).Z;
      ScreenObject.HigherElevationFormula := FortranFloatToStr(Elevation);

      Layer := FModel.ModflowLayerToDataSetLayer(LowLayer);
      Elevation := FModel.Grid.ThreeDElementCenter(ZeroBasedID(Layer, Row, Column)).Z;
      ScreenObject.LowerElevationFormula := FortranFloatToStr(Elevation);
    end
    else
    begin
      Layer := FModel.ModflowLayerToDataSetLayer(Obs.Layer);
      Elevation := FModel.Grid.ThreeDElementCenter(ZeroBasedID(Layer, Row, Column)).Z;
      ScreenObject.ElevationCount := ecOne;
      ScreenObject.ElevationFormula := FortranFloatToStr(Elevation);
    end;

    ScreenObject.CreateHeadObservations;
    HeadObservations := ScreenObject.ModflowHeadObservations;
    HeadObservations.ObservationName := Trim(Obs.OBSNAM);
    HeadObservations.Values.Capacity := Obs.FObsTimes.ArrayLength;
    for ValueIndex := 0 to Obs.FObsTimes.ArrayLength - 1 do
    begin
      ObsTime := Obs.FObsTimes[ValueIndex];
      if ObsTime.RefStressPeriod-1 < FModel.ModflowStressPeriods.Count then
      begin
        ObsItem := HeadObservations.Values.Add as THobItem;
        ObsItem.Head := ObsTime.HeadObservation;
        ObsItem.Time := FModel.ModflowStressPeriods[
          ObsTime.RefStressPeriod-1].StartTime
          + ObsTime.TimeOffset;
      end
      else
      begin
        frmErrorsAndWarnings.AddWarning(FModel, StrObservationsWithIn,
          Format(StrObservationName, [ObsTime.Name, ObsTime.RefStressPeriod]));
      end;
    end;
    if Obs.FObsTimes.ArrayLength > 1 then
    begin
      case Obs.ITT of
        1:
          begin
            HeadObservations.MultiObsMethod := momAllHeads;
          end;
        2:
          begin
            HeadObservations.MultiObsMethod := momHeadAndDrawdown;
          end;
        else Assert(False);
      end;
    end;
    if Obs.FMultiLayers.ArrayLength > 0 then
    begin
      HeadObservations.LayerFractions.Capacity := Obs.FMultiLayers.ArrayLength;
      ML_List := TList.Create;
      try
        ML_List.Capacity := Obs.FMultiLayers.ArrayLength;
        for LayerIndex := 0 to Obs.FMultiLayers.ArrayLength - 1 do
        begin
          ML := Obs.FMultiLayers[LayerIndex];
          ML_List.Add(ML);
        end;
        ML_List.Sort(ML_Compare);
        for LayerIndex := 0 to ML_List.Count - 1 do
        begin
          ML := ML_List[LayerIndex];
          MHItem := HeadObservations.LayerFractions.Add as TMultiHeadItem;
          Layer := FModel.ModflowLayerToDataSetLayer(ML.Layer)+1;
          MHItem.Layer := Layer;
          MHItem.Proportion := ML.Proportion;
        end;
      finally
        ML_List.Free;
      end;
    end;
  end;
end;

procedure THobImporter.ReadDataSet6Values;
begin
  Read(FImporter.FFile, FCurrentObsTime.RefStressPeriod);
  Read(FImporter.FFile, FCurrentObsTime.TimeOffset);
  Read(FImporter.FFile, FCurrentObsTime.HeadObservation);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  FCurrentObsTime.TimeOffset := FCurrentObsTime.TimeOffset*TOMULTH;
end;

procedure THobImporter.ReadDataSet6ObsName;
var
  OBSNAM: string;
begin
  Readln(FImporter.FFile, OBSNAM);
  FImporter.UpdateProgress;
  Inc(FCurrentTimeIndex);
  FCurrentObsTime := FCurrentObs.FObsTimes[FCurrentTimeIndex];
  FCurrentObsTime.Name := OBSNAM;
end;

procedure THobImporter.ReadDataSet5;
begin
  Read(FImporter.FFile, FCurrentObs.ITT);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure THobImporter.ReadDataSet4;
var
  LayerIndex: Integer;
  ML: TMultLayerFactor;
begin
  Assert(FCurrentObs.FMultiLayers.ArrayLength > 0);
  for LayerIndex := 0 to FCurrentObs.FMultiLayers.ArrayLength - 1 do
  begin
    ML := FCurrentObs.FMultiLayers[LayerIndex];
    Read(FImporter.FFile, ML.Layer);
    Read(FImporter.FFile, ML.Proportion);
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure THobImporter.ReadDataSet3Observation;
begin
  Read(FImporter.FFile, FCurrentObs.LAYER);
  Read(FImporter.FFile, FCurrentObs.ROW);
  Read(FImporter.FFile, FCurrentObs.COLUMN);
  Read(FImporter.FFile, FCurrentObsTime.RefStressPeriod);
  Read(FImporter.FFile, FCurrentObsTime.TimeOffset);
  Read(FImporter.FFile, FCurrentObs.RowOffset);
  Read(FImporter.FFile, FCurrentObs.ColumnOffset);
  Read(FImporter.FFile, FCurrentObsTime.HeadObservation);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  if FCurrentObs.LAYER < 0 then
  begin
    FCurrentObs.FMultiLayers.ArrayLength := -FCurrentObs.LAYER;
  end;
  if FCurrentObsTime.RefStressPeriod < 0 then
  begin
    FCurrentObs.FObsTimes.ArrayLength := - FCurrentObsTime.RefStressPeriod
  end;
  FCurrentObsTime.TimeOffset := FCurrentObsTime.TimeOffset*TOMULTH;
end;

procedure THobImporter.ReadDataSet3ObsName;
begin
  Inc(FCurrentObsIndex);
  FCurrentObs := FHeadObservations[FCurrentObsIndex];
  Readln(FImporter.FFile, FCurrentObs.OBSNAM);
  FImporter.UpdateProgress;
  FCurrentObs.FObsTimes.ArrayLength := 1;
  FCurrentObsTime := FCurrentObs.FObsTimes[0];
  FCurrentObsTime.Name := FCurrentObs.OBSNAM;
  FCurrentTimeIndex := -1;
end;

procedure THobImporter.ReadDataSet2;
begin
  Read(FImporter.FFile, TOMULTH);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure THobImporter.ReadDataSet1;
var
  NH: integer;
//  MOBS: integer;
//  MAXM: integer;
//  IUHOBSV: integer;
begin
  Read(FImporter.FFile, NH);
  Read(FImporter.FFile, DummyInteger); // MOBS
  Read(FImporter.FFile, DummyInteger); // MAXM
  Read(FImporter.FFile, DummyInteger); // IUHOBSV
  Read(FImporter.FFile, HOBDRY);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  FHeadObservations.ArrayLength := NH
end;

procedure THobImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'NH, MOBS, MAXM, IUHOBSV, HOBDRY:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'TOMULTH:' then
  begin
    ReadDataSet2;
  end
  else if ALabel = 'OBSNAM_D3:' then
  begin
    ReadDataSet3ObsName;
  end
  else if ALabel = 'LAYER ROW COLUMN IREFSP TOFFSET ROFF COFF HOBS:' then
  begin
    ReadDataSet3Observation;
  end
  else if ALabel = '(MLAY(M,ML),PR(M,ML),M=1,NL):' then
  begin
    ReadDataSet4;
  end
  else if ALabel = 'ITT:' then
  begin
    ReadDataSet5;
  end
  else if ALabel = 'OBSNAM_D6:' then
  begin
    ReadDataSet6ObsName;
  end
  else if ALabel = 'IREFSP, TOFFSET, HOBS(N):' then
  begin
    ReadDataSet6Values;
  end
end;

{ TMultiLayers }

function TMultiLayerArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMultLayerFactor;
end;

function TMultiLayerArray.GetMultLayerFactor(Index: integer): TMultLayerFactor;
begin
  result := TMultLayerFactor(Objects[Index]);
end;

{ TMultiTimeObsArray }

function TMultiTimeObsArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMultiTimeObs;
end;

function TMultiTimeObsArray.GetMultiTimeObs(Index: integer): TMultiTimeObs;
begin
  result := TMultiTimeObs(Objects[Index]);
end;

{ THeadObsevationArray }

function THeadObsevationArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := THeadObservation;
end;

function THeadObsevationArray.GetHeadObservation(
  Index: integer): THeadObservation;
begin
  result := THeadObservation(Objects[Index]);
end;

{ THeadObservation }

constructor THeadObservation.Create;
begin
  inherited;
  FMultiLayers:= TMultiLayerArray.Create;
  FObsTimes:= TMultiTimeObsArray.Create;
end;

destructor THeadObservation.Destroy;
begin
  FObsTimes.Free;
  FMultiLayers.Free;
  inherited;
end;

{ THfbImporter }

constructor THfbImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'HFB');
  FParameters := THfbParamArray.Create;
  FStressPeriods := THfbStressPeriodArray.Create;
  FCurrentLocation := -1;
end;

destructor THfbImporter.Destroy;
begin
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

function THfbImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := nil;
  Assert(False);
end;

procedure THfbImporter.DefineBarrier(Location: THfbLocation;
  Const ParamName: string; var Count: integer);
var
  ScreenObject: TScreenObject;
  Boundary: THfbBoundary;
  UndoCreateScreenObject: TCustomUndo;
  Grid: TCustomModelGrid;
  Layer: Integer;
  Point1: TPoint2D;
  Point2: TPoint2D;
  Column: Integer;
  Row: Integer;
  HigherZ: Real;
  LowerZ: Real;
  Column2: Integer;
  Row2: Integer;
  Point1A: TPoint2D;
  Point2A: TPoint2D;
begin
  UndoCreateScreenObject := nil;
  Inc(Count);

  ScreenObject := TScreenObject.CreateWithViewDirection(FModel, vdTop,
    UndoCreateScreenObject, False);
  ScreenObject.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);
  ScreenObject.Name := ScreenObjectNameRoot + '_'
    + IntToStr(Count);
  FModel.AddScreenObject(ScreenObject);
  ScreenObject.ElevationCount := ecOne;
  ScreenObject.SetValuesOfIntersectedCells := True;
  ScreenObject.EvaluatedAt := eaBlocks;
  ScreenObject.Visible := False;
  ScreenObject.Capacity := 2;

  Layer := FModel.ModflowLayerToDataSetLayer(Location.Layer);
  Grid := FModel.Grid;

  Column := Max(Location.Column, Location.Col2)-1;
  Row := Max(Location.Row, Location.Row2)-1;

  Point1 := Grid.TwoDElementCorner(Column, Row);
  if Location.Column = Location.Col2 then
  begin
    HigherZ := Grid.CellElevation[ZeroBasedID(Layer, Row-1, Column)];
    LowerZ := Grid.CellElevation[ZeroBasedID(Layer+1, Row-1, Column)];
    Row2 := Row-1;
    Point1A := Grid.TwoDElementCorner(Column, Row2);
    Inc(Column);
    Column2 := Column;
  end
  else
  begin
    HigherZ := Grid.CellElevation[ZeroBasedID(Layer, Row, Column-1)];
    LowerZ := Grid.CellElevation[ZeroBasedID(Layer+1, Row, Column-1)];
    Column2 := Column-1;
    Point1A := Grid.TwoDElementCorner(Column2, Row);
    Inc(Row);
    Row2 := Row;
  end;

  HigherZ := (HigherZ+LowerZ)/2;
  ScreenObject.ElevationFormula := FortranFloatToStr(HigherZ);

  Point2 := Grid.TwoDElementCorner(Column, Row);
  Point2A := Grid.TwoDElementCorner(Column2, Row2);
  Point1.x := ((Point1.x*999)+Point1A.x)/1000;
  Point1.y := ((Point1.y*999)+Point1A.y)/1000;
  Point2.x := ((Point2.x*999)+Point1A.x)/1000;
  Point2.y := ((Point2.y*999)+Point1A.y)/1000;

  ScreenObject.AddPoint(Point1, True);
  ScreenObject.AddPoint(Point2, False);

  ScreenObject.CreateHfbBoundary;
  Boundary := ScreenObject.ModflowHfbBoundary;
  Boundary.IsUsed := True;
  Boundary.HydraulicConductivityFormula := FortranFloatToStr(Location.Factor);
  Boundary.ThicknessFormula := '1';
  Boundary.AdjustmentMethod := amNone;
  Boundary.ParameterName := ParamName;
end;

procedure THfbImporter.HandlePackage;
var
  ParamIndex: Integer;
  ParamItem: THfbParam;
  UsedParameters: TStringList;
  Param: TModflowSteadyParameter;
  LocationIndex: Integer;
  Locations: THfbLocations;
  Location: THfbLocation;
  SingleStressPeriod: THfbStressPeriod;
  Count: integer;
begin
  inherited;
  FHfbPackage := FModel.ModflowPackages.HfbPackage;
  FHfbPackage.IsSelected := True;
  FHfbPackage.Comments := FComments;
  Count := 0;
  UsedParameters := TStringList.Create;
  try
    for ParamIndex := 0 to Length(ParameterNames) - 1 do
    begin
      UsedParameters.Add(UpperCase(ParameterNames[ParamIndex]));
    end;
    for ParamIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      ParamItem := FParameters[ParamIndex] as THfbParam;
      if UsedParameters.IndexOf(UpperCase(ParamItem.PARNAM)) >= 0 then
      begin
        Param := FModel.ModflowSteadyParameters.Add as TModflowSteadyParameter;
        Param.ParameterName := ParamItem.PARNAM;
        Param.ParameterType := ptHFB;
        Param.Value := ParamItem.Parval;

        Locations := ParamItem.Instances[0] as THfbLocations;
        for LocationIndex := 0 to Locations.ArrayLength - 1 do
        begin
          Location := Locations[LocationIndex];
          DefineBarrier(Location, ParamItem.PARNAM, Count);
        end;
      end;
    end;
  finally
    UsedParameters.Free;
  end;
  SingleStressPeriod := FStressPeriods.StressPeriods[0] as THfbStressPeriod;
  Locations := SingleStressPeriod[0] as THfbLocations;
  for LocationIndex := 0 to Locations.ArrayLength - 1 do
  begin
    Location := Locations[LocationIndex];
    DefineBarrier(Location, '', Count);
  end;
  ReleaseMemory;
end;

procedure THfbImporter.ReadData(const ALabel: string);
var
  NPHFB: integer;
//  MXFBP: integer;
  SingleStressPeriod: THfbStressPeriod;
  Barrier: THfbLocation;
  ParameterName: string;
begin
  inherited;
  if ALabel = 'NPHFB,MXFBP,NHFBNP:' then
  begin
    Read(FImporter.FFile, NPHFB);
    Read(FImporter.FFile, DummyInteger); // MXFBP
    Read(FImporter.FFile, NHFBNP);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
    FStressPeriods.ArrayLength := 1;
    FParameters.ArrayLength := NPHFB;
  end
  else if ALabel = 'NOPRINT:' then
  begin
    NoPrintOption := True;
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadParameterName;
    FParam := FParameters[CurrentParameter] as THfbParam;
    FLocations := FParam[0] as THfbLocations;
    FCurrentLocation := -1;
  end
  else if ALabel = 'PARTYP:' then
  begin
    ReadParameterType;
  end
  else if ALabel = 'Parval,NLST:' then
  begin
    ReadParameterValueAndLocationCount;
  end
  else if ALabel = 'NACTHFB:' then
  begin
    Read(FImporter.FFile, NACTHFB);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
    SetLength(ParameterNames, NACTHFB);
    CurrentParameter := 0;
  end
  else if ALabel = 'BARRIERS NOT DEFINED BY PARAMETERS:' then
  begin
    SingleStressPeriod := FStressPeriods.StressPeriods[0] as THfbStressPeriod;
    SingleStressPeriod.ArrayLength := 1;
    FLocations := SingleStressPeriod[0] as THfbLocations;
    FLocations.ArrayLength := NHFBNP;
    FCurrentLocation := -1;
  end
  else if ALabel = 'Layer IROW1 ICOL1 IROW2  ICOL2 Factor:' then
  begin
    Inc(FCurrentLocation);
    Barrier := FLocations[FCurrentLocation];
    Read(FImporter.FFile, Barrier.Layer);
    Read(FImporter.FFile, Barrier.Row);
    Read(FImporter.FFile, Barrier.Column);
    Read(FImporter.FFile, Barrier.Row2);
    Read(FImporter.FFile, Barrier.Col2);
    Read(FImporter.FFile, Barrier.Factor);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'Pname:' then
  begin
    Readln(FImporter.FFile, ParameterName);
    FImporter.UpdateProgress;
    ParameterName := Trim(ParameterName);
    if Length(ParameterName) > 10 then
    begin
      SetLength(ParameterName, 10);
    end;
    ParameterNames[CurrentParameter] := ParameterName;
    Inc(CurrentParameter);
  end
  else
  begin
    Assert(False);
  end;
end;

function THfbImporter.ParameterType: TParameterType;
begin
  result := ptUndefined;
  Assert(False);
end;

procedure THfbImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'HFB');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

function THfbImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Hfb_';
end;

procedure THfbImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
begin
  Assert(False);
end;

{ THfbLocations }

function THfbLocations.ArrayMemberClass: TArrayMemberClass;
begin
  result := THfbLocation;
end;

function THfbLocations.GetBarriers(Index: integer): THfbLocation;
begin
  result := Objects[Index] as THfbLocation
end;

{ THfbParam }

function THfbParam.ArrayMemberClass: TArrayMemberClass;
begin
  result := THfbLocations;
end;

{ THfbParamArray }

function THfbParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := THfbParam;
end;

{ THfbStressPeriod }

function THfbStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := THfbLocations;
end;

function THfbStressPeriod.GetBarrierList(Index: integer): THfbLocations;
begin
  result := Objects[Index] as THfbLocations
end;

{ THfbStressPeriodArray }

function THfbStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := THfbStressPeriod;
end;

{ TLakeImporter }

constructor TLakImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'LAK', nil);
  FLakPackage := FModel.ModflowPackages.LakPackage;
  THETA := FLakPackage.Theta;
  NSSITR := FLakPackage.NumberOfIterations;
  SSCNCR := FLakPackage.ConvergenceCriterion;
  FCurrentStressPeriod := -1;
  FLakeStressPeriodValues := TLakeStressPeriodValues.Create;
  FPriorStressPeriodValues := nil;
  FTABLEINPUT := False;
end;

procedure TLakImporter.DefineLakeOutlines;
var
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
  CompleteLake: Boolean;
  Layer: Integer;
begin
  CheckVariableIntegerArrays(FConstantLkarr, LKARR);
  // define the lakes.
  // first check the rather unlikely possibility that the
  // entire top surface is a single lake.
  CompleteLake := True;
  for LayerIndex := 0 to Length(FConstantLkarr) - 1 do
  begin
    if FConstantLkarr[LayerIndex].IsConstant and
      (FConstantLkarr[LayerIndex].IntegerValue <> 0) then
    begin
      Layer := FModel.
        ModflowLayerToDataSetLayer(LayerIndex+1);

      for RowIndex := 0 to Length(FLakeOutline) - 1 do
      begin
        for ColIndex := 0 to Length(FLakeOutline[RowIndex]) - 1 do
        begin
          FLakeOutline[RowIndex, ColIndex] :=
            FConstantLkarr[LayerIndex].IntegerValue;
          FLakeBottom[RowIndex, ColIndex] :=
            FModel.ModflowGrid.CellElevation[ZeroBasedID(Layer+1,RowIndex,ColIndex)];
        end;
      end;

    end
    else
    begin
      CompleteLake := False;
      break;
    end;
  end;
  if not CompleteLake then
  begin
    for RowIndex := 0 to Length(FLakeOutline) - 1 do
    begin
      for ColIndex := 0 to Length(FLakeOutline[RowIndex]) - 1 do
      begin
        FLakeOutline[RowIndex, ColIndex] := 0;
        for LayerIndex := 0 to Length(LKARR) - 1 do
        begin
          Layer := FModel.
            ModflowLayerToDataSetLayer(LayerIndex+1);
          if LKARR[LayerIndex, RowIndex, ColIndex] <> 0 then
          begin
            FLakeOutline[RowIndex, ColIndex] :=
              LKARR[LayerIndex, RowIndex, ColIndex];
            FLakeBottom[RowIndex, ColIndex] :=
              FModel.ModflowGrid.CellElevation[ZeroBasedID(Layer+1,RowIndex,ColIndex)];
          end;
        end;
      end;
    end;
  end;
end;

destructor TLakImporter.Destroy;
begin
  FLakeStressPeriodValues.Free;
  inherited;
end;

procedure TLakImporter.ReadLakeTable;
var
  LM: Integer;
  LineIndex: Integer;
begin
  Read(FImporter.FFile, LM);
  for LineIndex := 0 to 150 do
  begin
    Read(FImporter.FFile, LakeTables[LM - 1][LineIndex].Depth);
    Read(FImporter.FFile, LakeTables[LM - 1][LineIndex].Volume);
    Read(FImporter.FFile, LakeTables[LM - 1][LineIndex].Area);
    ReadLn(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
end;

procedure TLakImporter.CreateBoundary(ScreenObject: TScreenObject);
begin
  ScreenObject.CreateLakBoundary;
end;

procedure TLakImporter.HandlePackage;
var
  LakeIndex: Integer;
  Cluster: TClusterObject;
  ScreenObject: TScreenObject;
  LakeBoundary: TLakBoundary;
  LakeID: Integer;
  LakeSystemIndex: Integer;
  SubLakeIndex: Integer;
  Lakes: TList;
  LayerIndex: Integer;
  Formula: string;
  FirstValue: Double;
  IsConstant: Boolean;
  Values: TStringList;
  Index: Integer;
  Layer: Integer;
  NewName: string;
  DataArray: TDataArray;
  TimeIndex: Integer;
  ValuesArray: TLakeValueArray;
  LakeValues: TLakeValues;
  LakeItem: TLakItem;
  StressPeriod: TModflowStressPeriod;
  ConstantLakeBottom: Boolean;
  RowIndex: Integer;
  ColIndex: Integer;
  BottomFormula: string;
  LakeIdDataArray: TDataArray;
  DataArrayIndex: Integer;
  ExternalLakeTable: TExternalLakeTable;
//  ExternalLakeUnitNumber: Integer;
  LakeTable: TLakeTable;
  LineIndex: Integer;
  LakeBathItem: TLakeTableItem;
begin
  if FCurrentStressPeriod < FModel.ModflowStressPeriods.Count-1 then
  begin
    Exit;
  end;
  inherited;
  FLakPackage := FModel.ModflowPackages.LakPackage;
  FLakPackage.IsSelected := True;
  FLakPackage.Comments := FComments;
  if FTABLEINPUT then
  begin
    FLakPackage.ExternalLakeChoice := elcAll;
  end
  else
  begin
    FLakPackage.ExternalLakeChoice := elcNone;
  end;
  FLakPackage.Theta := THETA;
  FLakPackage.NumberOfIterations := NSSITR;
  FLakPackage.ConvergenceCriterion := SSCNCR;
  FLakPackage.SurfDepth.Value := SURFDEPTH;

  FModel.DataArrayManager.CreateInitialDataSets;

  DefineLakeOutlines;

  ConstantLakeBottom := True;
  FirstValue := FLakeBottom[0,0];
  for RowIndex := 0 to Length(FLakeBottom) - 1 do
  begin
    for ColIndex := 0 to Length(FLakeBottom[0]) - 1 do
    begin
      ConstantLakeBottom := FirstValue = FLakeBottom[RowIndex,ColIndex];
      if not ConstantLakeBottom then
      begin
        break;
      end;
    end;
    if not ConstantLakeBottom then
    begin
      break;
    end;
  end;
  if ConstantLakeBottom then
  begin
    BottomFormula := FortranFloatToStr(FirstValue);
  end
  else
  begin
    BottomFormula := StrImportedLakeBottom;
    CreateTransientDataSet(-1, StrImportedLakeBottom, rdtDouble, DataArray);
    CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    AssignRealValuesToCellCenters(DataArray, ScreenObject, FLakeBottom);
  end;


  Lakes := TList.Create;
  try
    Cluster := TClusterObject.Create;
    try
      SetLength(Cluster.Zones, 1);
      for LakeIndex := 0 to NLAKES-1 do
      begin
        LakeID := LakeIndex+1;
        Cluster.Zones[0] := LakeID;
        ScreenObject := CreateScreenObjectAroundZones(
          FLakeOutline, Cluster, 'ImportedLake_'
          + IntToStr(LakeID));
        ScreenObject.ElevationCount := ecTwo;
        ScreenObject.HigherElevationFormula := kModelTop;
        ScreenObject.LowerElevationFormula := BottomFormula;

        CreateBoundary(ScreenObject);
        ScreenObject.ModflowLakBoundary;
        LakeBoundary := ScreenObject.ModflowLakBoundary;
        LakeBoundary.LakeID := LakeID;
        LakeBoundary.InitialStage := Stages[LakeIndex];
        LakeBoundary.CenterLake := 0;
        Lakes.Add(LakeBoundary);
        LakeIdDataArray := FModel.DataArrayManager.GetDataSetByName(rsLakeID);
        DataArrayIndex := ScreenObject.AddDataSet(LakeIdDataArray);
        ScreenObject.DataSetFormulas[DataArrayIndex] := IntToStr(LakeID);

        if FTABLEINPUT then
        begin
          ExternalLakeTable := LakeBoundary.ExternalLakeTable;
          ExternalLakeTable.LakeTableChoice := lctInternal;
          LakeTable := ExternalLakeTable.LakeTable;
          LakeTable.Capacity := 151;
          for LineIndex := 0 to Length(LakeTables[LakeIndex]) -1 do
          begin
            LakeBathItem := LakeTable.Add;
            LakeBathItem.Stage := LakeTables[LakeIndex][LineIndex].Depth;
            LakeBathItem.Volume := LakeTables[LakeIndex][LineIndex].Volume;
            LakeBathItem.SurfaceArea := LakeTables[LakeIndex][LineIndex].Area;
          end;
        end;

        LakeItem := nil;
        for TimeIndex := 0 to FLakeStressPeriodValues.ArrayLength - 1 do
        begin
          StressPeriod := FModel.ModflowStressPeriods[TimeIndex];
          ValuesArray := FLakeStressPeriodValues[TimeIndex];
          if ValuesArray.Reuse then
          begin
            Assert(LakeItem <> nil);
            LakeItem.EndTime := StressPeriod.EndTime;
          end
          else
          begin
            LakeValues := ValuesArray[LakeIndex];
            LakeItem := LakeBoundary.Values.Add as TLakItem;
            LakeItem.StartTime := StressPeriod.StartTime;
            LakeItem.EndTime := StressPeriod.EndTime;
            LakeItem.MinimumStage := FortranFloatToStr(LakeValues.SSMN);
            LakeItem.MaximumStage := FortranFloatToStr(LakeValues.SSMX);
            LakeItem.Precipitation := FortranFloatToStr(LakeValues.PRCPLK);
            LakeItem.Evaporation := FortranFloatToStr(LakeValues.EVAPLK);
            LakeItem.OverlandRunoff := FortranFloatToStr(LakeValues.RNF);
            LakeItem.Withdrawal := FortranFloatToStr(LakeValues.WTHDRW);
          end;
        end;
      end;
    finally
      Cluster.Free;
    end;
    for LakeSystemIndex := 0 to Length(SubLakes) - 1 do
    begin
      for SubLakeIndex := 1 to Length(SubLakes[LakeSystemIndex]) - 1 do
      begin
        LakeIndex := SubLakes[LakeSystemIndex,SubLakeIndex]-1;
        LakeBoundary := Lakes[LakeIndex];
        LakeBoundary.CenterLake := SubLakes[LakeSystemIndex,0];
        LakeBoundary.Sill := Sills[LakeSystemIndex,SubLakeIndex-1];
      end;
    end;
  finally
    Lakes.Free;
  end;

  CheckVariableRealArrays(FConstantBdlknc, BDLKNC);
  IsConstant := True;
  for LayerIndex := 0 to Length(FConstantBdlknc) - 1 do
  begin
    if FConstantBdlknc[LayerIndex].IsConstant then
    begin
      if LayerIndex = 0 then
      begin
        FirstValue := FConstantBdlknc[LayerIndex].RealValue;
      end
      else if FConstantBdlknc[LayerIndex].RealValue <> FirstValue then
      begin
        IsConstant := False;
        break;
      end;
    end
    else
    begin
      IsConstant := False;
      break;
    end;
  end;
  ScreenObject := nil;
  if IsConstant then
  begin
    Formula := FortranFloatToStr(FirstValue);
  end
  else
  begin
    Values := TStringList.Create;
    try
      Values.Capacity := FModel.Grid.LayerCount;
      for Index := 0 to Values.Capacity - 1 do
      begin
        Values.Add('0');
      end;

      for LayerIndex := 0 to Length(FConstantBdlknc) - 1 do
      begin
        Layer :=FModel.
          ModflowLayerToDataSetLayer(LayerIndex + 1);
        if FConstantBdlknc[LayerIndex].IsConstant then
        begin
          Values[Layer] := FortranFloatToStr(FConstantBdlknc[LayerIndex].RealValue);
        end
        else
        begin
          NewName := 'Imported_LakeLeakance_' + IntToStr(LayerIndex+1);
          CreateTransientDataSet(-1, NewName, rdtDouble, DataArray);
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          end;
          AssignRealValuesToCellCenters(DataArray, ScreenObject,
            BDLKNC[LayerIndex]);
          Values[Layer] := DataArray.Name;
        end;
      end;
      Values.Delimiter := ',';
      if FModel.Grid.LayerCount = 1 then
      begin
        Formula := Values.DelimitedText;
      end
      else
      begin
        Formula := 'CaseR(Layer, ' + Values.DelimitedText + ')';
      end;
    finally
      Values.Free;
    end;
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(rsLakeLeakance);
  DataArray.Formula := Formula;

end;

procedure TLakImporter.ReadDataSet1b;
var
//  ILKCB: Integer;
  NLAY: Integer;
  NROW: Integer;
  NCOL: Integer;
  Index: Integer;
begin
  FIsSelected := True;
  Read(FImporter.FFile, NLAKES);
  Read(FImporter.FFile, DummyInteger); // ILKCB
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(Stages, NLAKES);
  SetLength(MinStages, NLAKES);
  SetLength(MaxStages, NLAKES);
  if FTABLEINPUT then
  begin
    SetLength(LakeTables, NLAKES);
  end
  else
  begin
    SetLength(LakeTables, 0);
  end;

  NLAY := FModel.ModflowLayerCount;
  NROW := FGrid.RowCount;
  NCOL := FGrid.ColumnCount;

  SetLength(FLakeOutline, NROW, NCOL);
  SetLength(FLakeBottom, NROW, NCOL);


  SetLength(LKARR, NLAY, NROW, NCOL);
  SetLength(FConstantLkarr, NLAY);
  for Index := 0 to NLAY - 1 do
  begin
    FConstantLkarr[Index].IsConstant := False;
  end;

  SetLength(BDLKNC, NLAY, NROW, NCOL);
  SetLength(FConstantBdlknc, NLAY);
  for Index := 0 to NLAY - 1 do
  begin
    FConstantBdlknc[Index].IsConstant := False;
  end;

  FLakeStressPeriodValues.ArrayLength := FModel.ModflowStressPeriods.Count;
end;

procedure TLakImporter.ReadTheta;
begin
  Read(FImporter.FFile, THETA);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadTransientControls;
begin
  Read(FImporter.FFile, NSSITR);
  Read(FImporter.FFile, SSCNCR);
  Read(FImporter.FFile, SURFDEPTH);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadLakeStageAndLimits;
var
  LM: Integer;
begin
  Read(FImporter.FFile, LM);
  Read(FImporter.FFile, Stages[LM - 1]);
  Read(FImporter.FFile, MinStages[LM - 1]);
  Read(FImporter.FFile, MaxStages[LM - 1]);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadLakeStage;
var
  LM: Integer;
begin
  Read(FImporter.FFile, LM);
  Read(FImporter.FFile, Stages[LM - 1]);
  // supply default values for min and max stage.
  MinStages[LM - 1] := Stages[LM - 1] - 1;
  MaxStages[LM - 1] := Stages[LM - 1] + 1;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadNumberOfSolutes;
begin
  Read(FImporter.FFile, NSOL);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadLakeSolutes;
var
//  CLAKE: Double;
  Index: Integer;
  LM: Integer;
begin
  Read(FImporter.FFile, LM);
  for Index := 0 to LM - 1 do
  begin
    Read(FImporter.FFile, DummyDouble); // CLAKE
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadDataSet4;
var
//  ITMP: Integer;
  ITMP1: Integer;
//  LWRT: Integer;
  StressPeriodValues: TLakeValueArray;
begin
  Read(FImporter.FFile, DummyInteger); // ITMP
  Read(FImporter.FFile, ITMP1);
  Read(FImporter.FFile, DummyInteger); // LWRT
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(FCurrentStressPeriod);
  FCurrentLakeDefinition := -1;
  FCurrentLakeValues := -1;
  StressPeriodValues := FLakeStressPeriodValues[FCurrentStressPeriod];
  StressPeriodValues.Reuse := ITMP1 < 0;
  if not StressPeriodValues.Reuse then
  begin
    StressPeriodValues.ArrayLength := NLAKES;
    FPriorStressPeriodValues := FCurrentStressPeriodValues;
  end;
  FCurrentStressPeriodValues := StressPeriodValues;
end;

procedure TLakImporter.ReadVariableLakeID;
var
  IntArray: T2DIntArray;
  Layer: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = StrLAKEIDARRAY);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  IntArray := LKARR[Layer];
  ReadVariable2DIntArray(IntArray);
end;

procedure TLakImporter.ReadConstantLakeID;
var
  ColIndex: Integer;
  RowIndex: Integer;
  IntegerConstant: Integer;
  IntArray: T2DIntArray;
  Layer: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = StrLAKEIDARRAY);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  ReadLn(FImporter.FFile, IntegerConstant);
  FImporter.UpdateProgress;
  IntArray := LKARR[Layer];
  for RowIndex := 0 to Length(IntArray) - 1 do
  begin
    for ColIndex := 0 to Length(IntArray[RowIndex]) - 1 do
    begin
      IntArray[RowIndex, ColIndex] := IntegerConstant;
    end;
  end;
  FConstantLkarr[Layer].IsConstant := True;
  FConstantLkarr[Layer].IntegerValue := IntegerConstant;
end;

procedure TLakImporter.ReadVariableLakebedLeakance;
var
  Layer: Integer;
  ID: string;
  RealArray: T2DDoubleArray;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = StrLAKEBEDLEAKANCEARR);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  RealArray := BDLKNC[Layer];
  Read2DRealArray(RealArray, 'Lakebed Leakance');
end;

procedure TLakImporter.ReadConstantLakebedLeakance;
var
  Value: Double;
  ID: string;
  RealArray: T2DDoubleArray;
  Layer: Integer;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = StrLAKEBEDLEAKANCEARR);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  RealArray := BDLKNC[Layer];
  AssignConstant2DArray(Value, RealArray);
  FConstantBdlknc[Layer].IsConstant := True;
  FConstantBdlknc[Layer].RealValue := Value;
end;

procedure TLakImporter.ReadNumberOfSublakes;
begin
  Read(FImporter.FFile, NSLMS);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  if FCurrentStressPeriod > 0 then
  begin
    Exit;
  end;
  SetLength(SubLakes, NSLMS);
  SetLength(Sills, NSLMS);
end;

procedure TLakImporter.ReadSublakes;
var
  ISUB: Integer;
  Index: Integer;
begin
  Inc(FCurrentLakeDefinition);
  Read(FImporter.FFile, IC);
  if FCurrentStressPeriod = 0 then
  begin
    SetLength(SubLakes[FCurrentLakeDefinition],IC);
  end;
  for Index := 0 to IC - 1 do
  begin
    Read(FImporter.FFile, ISUB);
    if FCurrentStressPeriod = 0 then
    begin
      SubLakes[FCurrentLakeDefinition, Index] := ISUB;
    end;
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadSills;
var
  IC1: Integer;
  SILLVT: Double;
  Index: Integer;
begin
  IC1 := IC - 1;
  if FCurrentStressPeriod = 0 then
  begin
    SetLength(Sills[FCurrentLakeDefinition],IC1);
  end;
  for Index := 0 to IC1 - 1 do
  begin
    Read(FImporter.FFile, SILLVT);
    if FCurrentStressPeriod = 0 then
    begin
      Sills[FCurrentLakeDefinition, Index] := SILLVT;
    end;
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadDataSet9aWithLimits;
var
  CurrentValues: TLakeValues;
begin
  Inc(FCurrentLakeValues);
  CurrentValues := FCurrentStressPeriodValues[FCurrentLakeValues];

  Read(FImporter.FFile, CurrentValues.PRCPLK);
  Read(FImporter.FFile, CurrentValues.EVAPLK);
  Read(FImporter.FFile, CurrentValues.RNF);
  Read(FImporter.FFile, CurrentValues.WTHDRW);
  Read(FImporter.FFile, CurrentValues.SSMN);
  Read(FImporter.FFile, CurrentValues.SSMX);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(FCurrentLakeValues);
end;

procedure TLakImporter.ReadDataSet9aNoLimits;
var
  CurrentValues: TLakeValues;
  PriorValues: TLakeValues;
begin
  Inc(FCurrentLakeValues);
  CurrentValues := FCurrentStressPeriodValues[FCurrentLakeValues];

  Read(FImporter.FFile, CurrentValues.PRCPLK);
  Read(FImporter.FFile, CurrentValues.EVAPLK);
  Read(FImporter.FFile, CurrentValues.RNF);
  Read(FImporter.FFile, CurrentValues.WTHDRW);

  // use previous values of SSMN and SSMX.
  if FPriorStressPeriodValues = nil then
  begin
    CurrentValues.SSMN := MinStages[FCurrentLakeValues];
    CurrentValues.SSMX := MaxStages[FCurrentLakeValues];
  end
  else
  begin
    PriorValues := FPriorStressPeriodValues[FCurrentLakeValues];
    CurrentValues.SSMN := PriorValues.SSMN;
    CurrentValues.SSMX := PriorValues.SSMX;
  end;

  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadDataSet9bWithAugmentation;
//var
//  CAUG: Double;
//  CRNF: Double;
//  CPPT: Double;
begin
  Read(FImporter.FFile, DummyDouble); // CPPT
  Read(FImporter.FFile, DummyDouble); // CRNF
  Read(FImporter.FFile, DummyDouble); // CAUG
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadDataSet9bNoAugmentation;
//var
//  CRNF: Double;
//  CPPT: Double;
begin
  Read(FImporter.FFile, DummyDouble); // CPPT
  Read(FImporter.FFile, DummyDouble); // CRNF
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TLakImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'TABLEINPUT:' then
  begin
    FTABLEINPUT := True;
  end
  else if ALabel = 'NLAKES,ILKCB:' then
  begin
    ReadDataSet1b;
  end
  else if ALabel = 'THETA:' then
  begin
    ReadTheta;
  end
  else if ALabel = 'NSSITR,SSCNCR,SURFDEPTH:' then
  begin
    ReadTransientControls;
  end
  else if ALabel = 'LM,STAGES(LM),SSMN(LM),SSMX(LM):' then
  begin
    ReadLakeStageAndLimits;
  end
  else if ALabel = 'LM,STAGES(LM):' then
  begin
    ReadLakeStage;
  end
  else if ALabel = 'L1, DEPTHTABLE, VOLUMETABLE, AREATABLE:' then
  begin
    ReadLakeTable;
  end
  else if ALabel = 'NSOL:' then
  begin
    ReadNumberOfSolutes;
  end
  else if ALabel = 'LM,(CLAKE(LM,ISOL),ISOL=1,NSOL):' then
  begin
    ReadLakeSolutes;
  end
  else if ALabel = 'ITMP, ITMP1, LWRT:' then
  begin
    ReadDataSet4;
  end
  else if ALabel = StrVariable2DIntegerArrayForLayer then
  begin
    ReadVariableLakeID;
  end
  else if ALabel = StrConstant2DIntegerArrayForLayer then
  begin
    ReadConstantLakeID;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableLakebedLeakance;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstantLakebedLeakance;
  end
  else if ALabel = 'NSLMS:' then
  begin
    ReadNumberOfSublakes;
  end
  else if ALabel = 'IC,(ISUB(IS,I),I=1,IC):' then
  begin
    ReadSublakes;
  end
  else if ALabel = '(SILLVT(IS,I),I=1,IC1):' then
  begin
    ReadSills;
  end
  else if ALabel =
    'PRCPLK(LM),EVAPLK(LM),RNF(LM),WTHDRW(LM),SSMN(LM),SSMX(LM):' then
  begin
    ReadDataSet9aWithLimits;
  end
  else if ALabel = 'PRCPLK(LM),EVAPLK(LM),RNF(LM),WTHDRW(LM):' then
  begin
    ReadDataSet9aNoLimits;
  end
  else if ALabel = 'CPPT(LM,ISOL),CRNF(LM,ISOL),CAUG(LM,ISOL):' then
  begin
    ReadDataSet9bWithAugmentation;
  end
  else if ALabel = 'CPPT(LM,ISOL),CRNF(LM,ISOL):' then
  begin
    ReadDataSet9bNoAugmentation;
  end
  else
  begin
    Assert(False, Format('Unrecognized label %s', [ALabel]));
  end;
end;

{ TLakeValueArray }

function TLakeValueArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TLakeValues;
end;

function TLakeValueArray.GetLakeValues(Index: integer): TLakeValues;
begin
  result := Objects[Index] as TLakeValues;
end;

{ TLakeStressPeriodValues }

function TLakeStressPeriodValues.ArrayMemberClass: TArrayMemberClass;
begin
  result := TLakeValueArray;
end;

function TLakeStressPeriodValues.GetLakeValueArray(
  Index: integer): TLakeValueArray;
begin
  result := Objects[Index] as TLakeValueArray;
end;

{ TDrtInstanceObject }

function TDrtInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrtLocationObject;
end;

{ TDrtParameterObject }

function TDrtParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrtInstanceObject;
end;

{ TDrtParamArray }

function TDrtParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrtParameterObject;
end;

{ TDrtStressPeriod }

function TDrtStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrtLocationObject;
end;

{ TDrtStressPeriodArray }

function TDrtStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDrtStressPeriod;
end;

{ TDrtImporter }

constructor TDrtImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'DRT:');
  FStressPeriods:= TDrtStressPeriodArray.Create;
  FParameters:= TDrtParamArray.Create;
end;

function TDrtImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: Integer; LayerIndex,
  StressPeriodIndex: integer; ObjectType: TObjectType): TScreenObject;
begin
  result := inherited CreateScreenObject(List, ScreenObjectIndex,
    LayerIndex, StressPeriodIndex, otPolygon);
  if result <> nil then
  begin
    result.CreateDrtBoundary;
    result.ModflowDrtBoundary.FormulaInterpretation := fiSpecific;
  end;
end;

destructor TDrtImporter.Destroy;
begin
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

procedure TDrtImporter.ReadAuxilliaryVariables;
var
  AuxVar: Double;
  Index: Integer;
begin
  for Index := 0 to FAuxillaryVariables.Count - 1 do
  begin
    Read(FImporter.FFile, AuxVar);
    FCurrentDrtBoundary.AuxilliaryVariables[Index] := AuxVar;
  end;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TDrtImporter.ReadDataSet1DRT;
//var
//  IDRTCB: Integer;
//  MXADRT: Integer;
//  MXL: Integer;
begin
  Read(FImporter.FFile, DummyInteger); // MXADRT
  Read(FImporter.FFile, DummyInteger); // IDRTCB
  Read(FImporter.FFile, NP);
  Read(FImporter.FFile, DummyInteger); // MXL
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FParameters.ArrayLength := NP;
end;

procedure TDrtImporter.ReadNonParameterLocationsWithoutReturnFlow;
begin
  FCurrentDrtBoundary := FStressPeriods[FCurrentStressPeriod].
    Boundaries[CurrentInstance] as TDrtLocationObject;
  Read(FImporter.FFile, FCurrentDrtBoundary.Layer);
  Read(FImporter.FFile, FCurrentDrtBoundary.Row);
  Read(FImporter.FFile, FCurrentDrtBoundary.Column);
  Read(FImporter.FFile, FCurrentDrtBoundary.Elevation);
  Read(FImporter.FFile, FCurrentDrtBoundary.Conductance);
  FCurrentDrtBoundary.LayR := 0;
  FCurrentDrtBoundary.RowR := 0;
  FCurrentDrtBoundary.ColR := 0;
  FCurrentDrtBoundary.Rfprop := 0;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TDrtImporter.ReadNonParameterLocationsWithReturnFlow;
begin
  FCurrentDrtBoundary := FStressPeriods[FCurrentStressPeriod].
    Boundaries[CurrentInstance] as TDrtLocationObject;
  Read(FImporter.FFile, FCurrentDrtBoundary.Layer);
  Read(FImporter.FFile, FCurrentDrtBoundary.Row);
  Read(FImporter.FFile, FCurrentDrtBoundary.Column);
  Read(FImporter.FFile, FCurrentDrtBoundary.Elevation);
  Read(FImporter.FFile, FCurrentDrtBoundary.Conductance);

  Read(FImporter.FFile, FCurrentDrtBoundary.LayR);
  Read(FImporter.FFile, FCurrentDrtBoundary.RowR);
  Read(FImporter.FFile, FCurrentDrtBoundary.ColR);
  Read(FImporter.FFile, FCurrentDrtBoundary.Rfprop);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(CurrentInstance);
end;

procedure TDrtImporter.ReadParameterLocationsWithoutReturnFlow;
begin
  Inc(FBoundaryIndex);
  FCurrentDrtBoundary :=
    FParameters[CurrentParameter].Instances[CurrentInstance].
    Locations[FBoundaryIndex] as TDrtLocationObject;
  Read(FImporter.FFile, FCurrentDrtBoundary.Layer);
  Read(FImporter.FFile, FCurrentDrtBoundary.Row);
  Read(FImporter.FFile, FCurrentDrtBoundary.Column);
  Read(FImporter.FFile, FCurrentDrtBoundary.Elevation);
  Read(FImporter.FFile, FCurrentDrtBoundary.Conductance);
  FCurrentDrtBoundary.LayR := 0;
  FCurrentDrtBoundary.RowR := 0;
  FCurrentDrtBoundary.ColR := 0;
  FCurrentDrtBoundary.Rfprop := 0;
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;

  if FBoundaryIndex = NLST - 1 then
  begin
    Inc(CurrentInstance);
    FBoundaryIndex := -1;
  end;
end;

procedure TDrtImporter.ReadParameterLocationsWithReturnFlow;
begin
  Inc(FBoundaryIndex);
  FCurrentDrtBoundary :=
    FParameters[CurrentParameter].Instances[CurrentInstance].
    Locations[FBoundaryIndex] as TDrtLocationObject;
  Read(FImporter.FFile, FCurrentDrtBoundary.Layer);
  Read(FImporter.FFile, FCurrentDrtBoundary.Row);
  Read(FImporter.FFile, FCurrentDrtBoundary.Column);
  Read(FImporter.FFile, FCurrentDrtBoundary.Elevation);
  Read(FImporter.FFile, FCurrentDrtBoundary.Conductance);

  Read(FImporter.FFile, FCurrentDrtBoundary.LayR);
  Read(FImporter.FFile, FCurrentDrtBoundary.RowR);
  Read(FImporter.FFile, FCurrentDrtBoundary.ColR);
  Read(FImporter.FFile, FCurrentDrtBoundary.Rfprop);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
  if FBoundaryIndex = NLST - 1 then
  begin
    Inc(CurrentInstance);
    FBoundaryIndex := -1;
  end;
end;

procedure TDrtImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'DRT');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

function TDrtImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowDrtBoundary;
end;

procedure TDrtImporter.HandlePackage;
var
  ScreenObjectIndex: integer;
  DrtPackage: TModflowPackageSelection;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  inherited;
  DrtPackage := FModel.ModflowPackages.DrtPackage;
  DrtPackage.IsSelected := True;
  DrtPackage.Comments := FComments;

  ScreenObjectIndex := 0;
  ImportNonParameterBoundaries(ScreenObjectIndex);
  ImportParameterBoundaries(ScreenObjectIndex);
  ReleaseMemory;
end;

procedure TDrtImporter.ReadData(const ALabel: string);
begin
  inherited;
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'MXADRT,IDRTCB,NPDRT,MXL:' then
    begin
      ReadDataSet1DRT;
    end
    else if ALabel = 'DRTAUX(NAUX):' then
    begin
      ReadAuxilliaryVariableName;
    end
    else if ALabel = 'RETURNFLOW:' then
    begin
      ReturnFlow := True;
    end
    else if ALabel = 'NOPRINT:' then
    begin
      FNoPrint := True;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
    end
    else if ALabel = 'INSTANCES:' then
    begin
//       do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
    end
    else if ALabel = 'Layer Row Column Elevation Cond:' then
    begin
      ReadParameterLocationsWithoutReturnFlow;
    end
    else if ALabel
      = 'Layer Row Column Elevation Cond LayR RowR ColR Rfprop:' then
    begin
      ReadParameterLocationsWithReturnFlow;
    end
    else if ALabel = 'xyz:' then
    begin
      ReadAuxilliaryVariables;
    end
    else if ALabel = 'ITMP,NP:' then
    begin
      ReadFirstStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadFirstStressPeriodDataSet5WithoutParameters;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,NP:' then
    begin
      ReadNewStressPeriodDataSet5WithParameters;
    end
    else if ALabel = 'ITMP:' then
    begin
      ReadNewStressPeriodDataSet5WithoutParameters;
    end
    else if ALabel = 'Layer Row Column Elevation Cond:' then
    begin
      ReadNonParameterLocationsWithoutReturnFlow;
    end
    else if ALabel
      = 'Layer Row Column Elevation Cond LayR RowR ColR Rfprop:' then
    begin
      ReadNonParameterLocationsWithReturnFlow;
    end
    else if ALabel = 'xyz:' then
    begin
      ReadAuxilliaryVariables;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadParamNameForStressPeriod;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadInstanceNameForStressPeriod;
    end
    else
    begin
      Assert(False, ALabel);
    end;
  end;
end;

procedure TDrtImporter.ImportNonParameterBoundaries(
  var ScreenObjectIndex: Integer);
var
  Item: TCustomModflowBoundaryItem;
  SO_Boundary: TModflowParamBoundary;
  ScreenObject: TScreenObject;
  Boundary, AnotherBoundary: TDrtLocationObject;
  BoundaryIndex: Integer;
  SP: TListStressPeriod;
  InnerIndex: Integer;
  StressPeriod: TListStressPeriod;
  EndTime: Double;
  StartTime: Double;
  StressPeriodIndex: Integer;
  UsedLocations: array of TBooleanDynArray;
  LocationsToUse: TList;
  InnerBoundaryIndex: Integer;
  InstanceCount: integer;
  procedure InitializeTestArray;
  var
    RowIndex: Integer;
    ColIndex: Integer;
  begin
    for RowIndex := 0 to FGrid.RowCount - 1 do
    begin
      for ColIndex := 0 to FGrid.ColumnCount - 1 do
      begin
        UsedLocations[RowIndex,ColIndex] := false;
      end;
    end;
  end;
begin
  InstanceCount := 0;
  SetLength(UsedLocations, FGrid.RowCount, FGrid.ColumnCount);
  LocationsToUse := TList.Create;
  try
    for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
    begin
      // initialize the start and end times for when the boundary will be
      // applied.
      StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
      StressPeriod := FStressPeriods[StressPeriodIndex];
      if StressPeriod.Reuse then
      begin
        Continue;
      end
      else
      begin
        // Update the endtime if the boundaries from the current
        // stress period will be reused in subsequent stress periods.
        for InnerIndex := StressPeriodIndex + 1 to
          FStressPeriods.ArrayLength - 1 do
        begin
          SP := FStressPeriods[InnerIndex];
          if SP.Reuse then
          begin
            EndTime := FModel.ModflowStressPeriods[InnerIndex].EndTime;
          end
          else
          begin
            break;
          end;
        end;

        for BoundaryIndex := 0 to StressPeriod.ArrayLength - 1 do
        begin
          Boundary := StressPeriod.Boundaries[BoundaryIndex]
            as TDrtLocationObject;
          if Boundary.Used then
          begin
            Continue;
          end;
          InitializeTestArray;
          LocationsToUse.Clear;
          LocationsToUse.Add(Boundary);
          UsedLocations[Boundary.Row-1, Boundary.Column-1] := True;
          Boundary.Used := True;
          for InnerBoundaryIndex := BoundaryIndex+1 to
            StressPeriod.ArrayLength - 1 do
          begin
            AnotherBoundary := StressPeriod.Boundaries[InnerBoundaryIndex]
              as TDrtLocationObject;
            if not AnotherBoundary.Used
              and (Boundary.Layer = AnotherBoundary.Layer)
              and not UsedLocations[AnotherBoundary.Row-1,
              AnotherBoundary.Column-1]
              and (Boundary.LayR = AnotherBoundary.LayR)
              and (Boundary.RowR = AnotherBoundary.RowR)
              and (Boundary.ColR = AnotherBoundary.ColR)
              then
            begin
              LocationsToUse.Add(AnotherBoundary);
              UsedLocations[AnotherBoundary.Row-1,
                AnotherBoundary.Column-1] := True;
              AnotherBoundary.Used := True;
            end;
          end;
          ScreenObject := CreateScreenObject(LocationsToUse, ScreenObjectIndex,
            Boundary.Layer, StressPeriodIndex, otPoint);

          // Assign values to the TScreenObject
          // for the current stress period(s).
          SO_Boundary := GetBoundary(ScreenObject);
          Item := SO_Boundary.Values.Add as TCustomModflowBoundaryItem;
          Inc(InstanceCount);
          SetItemValues(Item, LocationsToUse, EndTime, StartTime, ScreenObject,
            IntToStr(InstanceCount));
        end;
      end;
    end;
  finally
    LocationsToUse.Free;
  end;
end;

procedure TDrtImporter.ImportParameterBoundaries(ScreenObjectIndex: Integer);
var
  Item: TCustomModflowBoundaryItem;
  EndTime: Double;
  LocationIndex: Integer;
  InnerParamIndex: Integer;
  StressPeriod: TListStressPeriod;
  StressPeriodIndex: Integer;
  Instance: TListInstanceObject;
  InstanceIndex: Integer;
  InstanceCount: Integer;
  Instances: TIntegerList;
  UsedStressPeriods: TIntegerList;
  NewParameter: TModflowTransientListParameter;
  Parameter: TListParameterObject;
  ParameterIndex: Integer;
  Parameters: TModflowTransientListParameters;
  StartTime: Double;
  StressPeriodI: Integer;
  Param: TCustomMF_BoundColl;
  ParamItem: TModflowParamItem;
  SO_Boundary: TModflowParamBoundary;
  ScreenObject: TScreenObject;
  Boundary: TDrtLocationObject;
  UsedLocations: array of TBooleanDynArray;
  LocationsToUse: TList;
  InnerBoundaryIndex: Integer;
  AnotherBoundary: TDrtLocationObject;
  ACount: integer;
  procedure InitializeTestArray;
  var
    RowIndex: Integer;
    ColIndex: Integer;
  begin
    for RowIndex := 0 to FGrid.RowCount - 1 do
    begin
      for ColIndex := 0 to FGrid.ColumnCount - 1 do
      begin
        UsedLocations[RowIndex,ColIndex] := false;
      end;
    end;
  end;
begin
  ACount := 0;
  SetLength(UsedLocations, FGrid.RowCount, FGrid.ColumnCount);
  // Create parameters in the model.
  Parameters := TModflowTransientListParameters.Create(nil);
  try
    Parameters.Assign(FModel.ModflowTransientParameters);
    for ParameterIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      Parameter := FParameters[ParameterIndex];
      NewParameter := Parameters.Add as TModflowTransientListParameter;
      NewParameter.ParameterName := Parameter.PARNAM;
      Parameter.ModifiedParamName := NewParameter.ParameterName;
      NewParameter.ParameterType := ParameterType;
      NewParameter.Value := Parameter.Parval;
    end;
    FModel.ModflowTransientParameters := Parameters;
  finally
    Parameters.Free;
  end;

  LocationsToUse := TList.Create;
  // Create TScreenObjects to represent the boundaries.
  // UsedStressPeriods will list the stress periods
  // in which a parameter is used.
  UsedStressPeriods := TIntegerList.Create;
  // Instances will indicate which instance of a parameter will be used
  // in any particular stress period.
  Instances := TIntegerList.Create;
  try
    for ParameterIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      Parameter := FParameters[ParameterIndex];
      InstanceCount := Parameter.ArrayLength;
      UsedStressPeriods.Clear;
      Instances.Clear;
      if InstanceCount > 1 then
      begin
        for InstanceIndex := 0 to InstanceCount - 1 do
        begin
          Instance := Parameter.Instances[InstanceIndex];
          Assert(Instance.Name <> '');
        end;
      end;
      // Identify the stress periods in which the parameter is used
      // and the instance used in each stress period.
      for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
      begin
        StressPeriod := FStressPeriods[StressPeriodIndex];
        for InnerParamIndex := 0 to Length(StressPeriod.Parameters) - 1 do
        begin
          if UpperCase(Parameter.PARNAM) =
            UpperCase(StressPeriod.Parameters[InnerParamIndex]) then
          begin
            if InstanceCount = 1 then
            begin
              UsedStressPeriods.Add(StressPeriodIndex);
              Instances.Add(0);
            end
            else
            begin
              for InstanceIndex := 0 to InstanceCount - 1 do
              begin
                Instance := Parameter.Instances[InstanceIndex];
                if (UpperCase(Instance.Name) =
                  UpperCase(StressPeriod.Instances[InnerParamIndex])) then
                begin
                  UsedStressPeriods.Add(StressPeriodIndex);
                  Instances.Add(InstanceIndex);
                end;
              end;
            end;
          end;
        end;
      end;
      // Create the TScreenObjects to represent the boundaries.
      for InstanceIndex := 0 to InstanceCount - 1 do
      begin
        Instance := Parameter.Instances[InstanceIndex];
        for LocationIndex := 0 to Instance.ArrayLength - 1 do
        begin
          Boundary := Instance.Locations[LocationIndex] as TDrtLocationObject;
          if Boundary.Used then
          begin
            Continue;
          end;
          InitializeTestArray;
          LocationsToUse.Clear;
          LocationsToUse.Add(Boundary);
          UsedLocations[Boundary.Row-1, Boundary.Column-1] := True;
          Boundary.Used := True;
          for InnerBoundaryIndex := LocationIndex+1 to
            Instance.ArrayLength - 1 do
          begin
            AnotherBoundary := Instance.Locations[InnerBoundaryIndex]
              as TDrtLocationObject;
            if not AnotherBoundary.Used
              and (Boundary.Layer = AnotherBoundary.Layer)
              and not UsedLocations[AnotherBoundary.Row-1,
              AnotherBoundary.Column-1]
              and (Boundary.LayR = AnotherBoundary.LayR)
              and (Boundary.RowR = AnotherBoundary.RowR)
              and (Boundary.ColR = AnotherBoundary.ColR)
              then
            begin
              LocationsToUse.Add(AnotherBoundary);
              UsedLocations[AnotherBoundary.Row-1,
                AnotherBoundary.Column-1] := True;
              AnotherBoundary.Used := True;
            end;
          end;
          ScreenObject := CreateScreenObject(LocationsToUse, ScreenObjectIndex,
            Boundary.Layer, InstanceIndex, otPoint);
          SO_Boundary := GetBoundary(ScreenObject);
          ParamItem := SO_Boundary.Parameters.Add;
          Param := ParamItem.Param;
          Param.ParamName := Parameter.ModifiedParamName;
          // Loop over the stress periods in which this parameter
          // is used.
          for StressPeriodI := 0 to UsedStressPeriods.Count - 1 do
          begin
            // If this instance is used in the current stress period,
            // assign new values.
            if Instances[StressPeriodI] = InstanceIndex then
            begin
              StressPeriodIndex := UsedStressPeriods[StressPeriodI];
              StartTime :=
                FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
              EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
              Item := Param.Add as TCustomModflowBoundaryItem;
              Inc(ACount);
              SetItemValues(Item, LocationsToUse, EndTime, StartTime,
                ScreenObject, IntToStr(ACount));
            end;
          end;
        end;
      end;
    end;
  finally
    UsedStressPeriods.Free;
    Instances.Free;
    LocationsToUse.Free;
  end;
end;

function TDrtImporter.ParameterType: TParameterType;
begin
  result := ptDRT;
end;

function TDrtImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_DRT_'
end;

procedure TDrtImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
var
  DrtBoundary: TDrtLocationObject;
  DrtItem: TDrtItem;
  ValueItem: TValueArrayItem;
  Index: Integer;
  DrtHeadValues: TValueArrayStorage;
  DrtConductanceValues: TValueArrayStorage;
  DrtElevName: string;
  ConductanceName: string;
  Layer: Integer;
  ReturnLocation: TPoint3D;
  DrainReturn: TDrainReturn;
  APoint: TPoint2D;
begin
  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  DrtElevName := 'DrtElevation' + ParamName;
  ValueItem.Name := DrtElevName;
  DrtHeadValues := ValueItem.Values;
  DrtHeadValues.DataType := rdtDouble;
  DrtHeadValues.Count := Boundaries.Count;

  ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
  ConductanceName := 'DrtConductance' + ParamName;
  ValueItem.Name := ConductanceName;
  DrtConductanceValues := ValueItem.Values;
  DrtConductanceValues.DataType := rdtDouble;
  DrtConductanceValues.Count := Boundaries.Count;

  DrtItem := Item as TDrtItem;
  DrtItem.StartTime := StartTime;
  DrtItem.EndTime := EndTime;
  for Index := 0 to Boundaries.Count - 1 do
  begin
    DrtBoundary := Boundaries[Index];
    APoint := FImporter.CenterPoints[DrtBoundary.Row-1, DrtBoundary.Column-1];
    if (FImporter.FImportParameters.Outline = nil)
      or FImporter.FImportParameters.Outline.PointInside(APoint) then
    begin
      DrtHeadValues.RealValues[Index] := DrtBoundary.Elevation;
      DrtConductanceValues.RealValues[Index] := DrtBoundary.Conductance
        / FImporter.CellAreas[DrtBoundary.Row-1, DrtBoundary.Column-1];
    end;
  end;
  DrtItem.Elevation := rsObjectImportedValuesR + '("' + DrtElevName + '")';
  DrtItem.Conductance := rsObjectImportedValuesR
    + '("' + ConductanceName + '")';

  DrtBoundary := Boundaries[0];

  if DrtBoundary.LayR > 0 then
  begin
    Layer := FModel.ModflowLayerToDataSetLayer
      (DrtBoundary.LayR);
    ReturnLocation := FModel.ModflowGrid.ThreeDElementCenter(ZeroBasedID(Layer,
      DrtBoundary.RowR-1, DrtBoundary.ColR-1));
    APoint := FModel.ModflowGrid.TwoDElementCenter(DrtBoundary.ColR-1,
      DrtBoundary.RowR-1);

    DrainReturn := ScreenObject.ModflowDrtBoundary.DrainReturn;
    DrainReturn.ReturnChoice := rtLocation;
    DrainReturn.ReturnLocation.X := APoint.X;
    DrainReturn.ReturnLocation.Y := APoint.Y;
    DrainReturn.ReturnLocation.Z := ReturnLocation.Z;

    DrtItem.ReturnFraction := FortranFloatToStr(DrtBoundary.Rfprop);
  end
  else
  begin
    DrainReturn := ScreenObject.ModflowDrtBoundary.DrainReturn;
    DrainReturn.ReturnChoice := rtNone;
  end;
  DrtHeadValues.CacheData;
  DrtConductanceValues.CacheData;

end;

{ TEtsImporter }

procedure TEtsImporter.AssignEtsLayerNonParam(NewItemNeeded: Boolean;
  var LayerItem: TEvtLayerItem; EvtBoundary: TEtsBoundary; EvtLayerName: string;
  StressPeriodIndex: Integer);
begin
  if FEtsPackage.TimeVaryingLayers then
  begin
    if NewItemNeeded then
    begin
      LayerItem := EvtBoundary.EvapotranspirationLayers.Add as TEvtLayerItem;
      LayerItem.EvapotranspirationLayer := EvtLayerName;
      LayerItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

procedure TEtsImporter.AssignEtsSurfaceNonParam(EvtSurfaceName,
  EvtExtinctName: string; NewItemNeeded: Boolean;
  var EvtItem: TEtsSurfDepthItem; EvtBoundary: TEtsBoundary;
  StressPeriodIndex: Integer);
begin
  if NewItemNeeded then
  begin
    EvtItem := EvtBoundary.EtsSurfDepthCollection.Add as TEtsSurfDepthItem;
    EvtItem.EvapotranspirationSurface := EvtSurfaceName;
    EvtItem.EvapotranspirationDepth := EvtExtinctName;
    EvtItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    AssignSegments(EvtItem, StressPeriodIndex);
  end
  else
  begin
    EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end;
end;

function TEtsImporter.SegIndexToStr(SegIndex: integer): string;
var
  MaxSeg: Integer;
begin
  MaxSeg := Length(IntToStr(NETSEG - 1));
  result := IntToStr(SegIndex);
  while Length(result) < MaxSeg do
  begin
    result := '0' + result;
  end;
end;

procedure TEtsImporter.AssignSurfaceAndDepth(ScreenObject: TScreenObject;
  EvtSurfaceName, EvtDepthName: string; StressPeriodIndex: Integer);
var
  EtsBoundary: TEtsBoundary;
  LayerItem: TEtsSurfDepthItem;
begin
  EtsBoundary := ScreenObject.ModflowEtsBoundary;
  if (EtsBoundary.EtsSurfDepthCollection.Count > 0)
    and FReuseEtSurface[StressPeriodIndex]
    and FReuseEtExtinctionDepth[StressPeriodIndex]
    and FReuseSegmentDefinition[StressPeriodIndex] then
  begin
    LayerItem := EtsBoundary.EtsSurfDepthCollection.
      Items[EtsBoundary.EtsSurfDepthCollection.Count - 1] as TEtsSurfDepthItem;
    LayerItem.EndTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end
  else
  begin
    LayerItem := EtsBoundary.EtsSurfDepthCollection.Add as TEtsSurfDepthItem;
    LayerItem.EvapotranspirationSurface := EvtSurfaceName;
    LayerItem.EvapotranspirationDepth := EvtDepthName;
    LayerItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    LayerItem.EndTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;

    AssignSegments(LayerItem, StressPeriodIndex);
  end;
end;

procedure TEtsImporter.AssignTimeVaryingLayer(ScreenObject: TScreenObject;
  EvtLayerName: string; StressPeriodIndex: Integer);
var
  LayerItem: TEvtLayerItem;
  EtsBoundary: TEtsBoundary;
begin
  if Package.TimeVaryingLayers then
  begin
    EtsBoundary := ScreenObject.ModflowEtsBoundary;
    if not FReuseLayerIndicator[StressPeriodIndex] then
    begin
      LayerItem := EtsBoundary.EvapotranspirationLayers.Add as TEvtLayerItem;
      LayerItem.EvapotranspirationLayer := EvtLayerName;
      LayerItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      LayerItem := EtsBoundary.EvapotranspirationLayers.
        Items[EtsBoundary.EvapotranspirationLayers.Count - 1] as TEvtLayerItem;
      LayerItem.EndTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

constructor TEtsImporter.Create(Importer: TModflow2005Importer;
  ZoneImporter: TMultZoneImporter);
begin
  inherited Create(Importer, 'ETS:', ZoneImporter);
end;

procedure TEtsImporter.AssignSegments(LayerItem: TEtsSurfDepthItem;
  StressPeriodIndex: Integer);
var
  Item: TEtsStringValueItem;
  EtFProportionName: string;
  SegString: string;
  SegIndex: Integer;
  DepthProportionName: string;
  StressPeriodString: string;
  SPIndex: Integer;
begin
  if FReuseSegmentDefinition = nil then
  begin
    Exit;
  end;
  StressPeriodString := '';
  for SPIndex := StressPeriodIndex downto 0 do
  begin
    if not FReuseSegmentDefinition[SPIndex] then
    begin
      StressPeriodString := GetStressPeriodString(SPIndex);
      break;
    end;
  end;
  Assert(StressPeriodString <> '');
  LayerItem.EtFractions.Capacity := NETSEG - 1;
  LayerItem.DepthFractions.Capacity := NETSEG - 1;
  for SegIndex := 1 to NETSEG - 1 do
  begin
    SegString := SegIndexToStr(SegIndex);
    EtFProportionName := StrImportedETSFractionalRate + SegString
      + '_' + StressPeriodString;
    Item := LayerItem.EtFractions.Add as TEtsStringValueItem;
    Item.Value := EtFProportionName;
    DepthProportionName := 'Imported_ETS_FractionalDepth_' + SegString
      + '_' + StressPeriodString;
    Item := LayerItem.DepthFractions.Add as TEtsStringValueItem;
    Item.Value := DepthProportionName;
  end;
end;

procedure TEtsImporter.CreateBoundary(ScreenObject: TScreenObject);
begin
  ScreenObject.CreateEtsBoundary;
end;

procedure TEtsImporter.CreateDepthFractionDataSet(SegmentIndex,
  StressPeriodIndex: Integer);
var
  DataSet: TDataArray;
  ScreenObject: TScreenObject;
  ValueList: TRealList;
  Values: T2DDoubleArray;
  MaxCount: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Value: Double;
  Root: string;
  DataSetRoot: string;
  SegString: string;
begin
  ScreenObject := nil;
  if not FReuseSegmentDefinition[StressPeriodIndex] then
  begin
    SegString := SegIndexToStr(SegmentIndex);
    DataSetRoot := StrImportedETSFractionalDepth
      + SegString + '_';
    CreateTransientDataSet(StressPeriodIndex, DataSetRoot,
      rdtDouble, DataSet);
    if (FConstantDepthProportions[SegmentIndex-1] <> nil)
      and FConstantDepthProportions[SegmentIndex-1][
      StressPeriodIndex].IsConstant then
    begin
      DataSet.Formula :=
        FortranFloatToStr(FConstantDepthProportions[SegmentIndex-1][
        StressPeriodIndex].RealValue);
    end
    else
    begin
      DataSet.Formula := '0';
      Assert(FVariableDepthProportions[SegmentIndex-1] <> nil);
      Assert(FVariableDepthProportions[SegmentIndex-1][
        StressPeriodIndex] <> nil);

      ValueList := TRealList.Create;
      try
        ValueList.Sorted := True;
        Values := FVariableDepthProportions[SegmentIndex-1][StressPeriodIndex];
//        MaxCount := Min((Length(Values) * Length(Values[0])) div 10, 100);
        MaxCount := 2;
        for RowIndex := 0 to Length(Values) - 1 do
        begin
          for ColIndex := 0 to Length(Values[0]) - 1 do
          begin
            Value := Values[RowIndex,ColIndex];
            ValueList.AddUnique(Value);
            if ValueList.Count >= MaxCount then
            begin
              break;
            end;
          end;
          if ValueList.Count >= MaxCount then
          begin
            break;
          end;
        end;
        if ValueList.Count >= MaxCount then
        begin
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          end;
          AssignRealValuesToCellCenters(DataSet, ScreenObject,
            FVariableDepthProportions[SegmentIndex-1][StressPeriodIndex]);
        end
        else if ValueList.Count = 1 then
        begin
          DataSet.Formula :=
            FortranFloatToStr(ValueList[0]);
        end
        else
        begin
          Root := StrETSImportedFractionalDepth + SegString + '_'
            + GetStressPeriodString(StressPeriodIndex) + '_Obj_';
          CreateScreenObjectsAroundValues(Values, Root,
            DataSet, ValueList);
        end;
      finally
        ValueList.Free;
      end;
    end;
  end;
end;

procedure TEtsImporter.CreateRateFractionDataSet(SegmentIndex,
  StressPeriodIndex: Integer);
var
  DataSet: TDataArray;
  ScreenObject: TScreenObject;
  ValueList: TRealList;
  Values: T2DDoubleArray;
  MaxCount: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  Value: Double;
  Root: string;
  DataSetRoot: string;
  SegString: string;
begin
  ScreenObject := nil;
  if not FReuseSegmentDefinition[StressPeriodIndex] then
  begin
    SegString := SegIndexToStr(SegmentIndex);
    DataSetRoot := StrImportedETSFractionalRate
      + SegString + '_';
    CreateTransientDataSet(StressPeriodIndex, DataSetRoot,
      rdtDouble, DataSet);
    if (FConstantRateProportions[SegmentIndex-1] <> nil)
      and FConstantRateProportions[SegmentIndex-1][
      StressPeriodIndex].IsConstant then
    begin
      DataSet.Formula :=
        FortranFloatToStr(FConstantRateProportions[SegmentIndex-1][
        StressPeriodIndex].RealValue);
    end
    else
    begin
      DataSet.Formula := '0';
      Assert(FVariableRateProportions[SegmentIndex-1] <> nil);
      Assert(FVariableRateProportions[SegmentIndex-1][
        StressPeriodIndex] <> nil);

      ValueList := TRealList.Create;
      try
        ValueList.Sorted := True;
        Values := FVariableRateProportions[SegmentIndex-1][StressPeriodIndex];
//        MaxCount := Min((Length(Values) * Length(Values[0])) div 10, 100);
        MaxCount := 2;
        for RowIndex := 0 to Length(Values) - 1 do
        begin
          for ColIndex := 0 to Length(Values[0]) - 1 do
          begin
            Value := Values[RowIndex,ColIndex];
            ValueList.AddUnique(Value);
            if ValueList.Count >= MaxCount then
            begin
              break;
            end;
          end;
          if ValueList.Count >= MaxCount then
          begin
            break;
          end;
        end;
        if ValueList.Count >= MaxCount then
        begin
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          end;
          AssignRealValuesToCellCenters(DataSet, ScreenObject,
            FVariableRateProportions[SegmentIndex-1][StressPeriodIndex]);
        end
        else if ValueList.Count = 1 then
        begin
          DataSet.Formula :=
            FortranFloatToStr(ValueList[0]);
        end
        else
        begin
          Root := StrETSImportedFractionalRate
            + GetStressPeriodString(StressPeriodIndex) + '_Obj_';
          CreateScreenObjectsAroundValues(Values, Root,
            DataSet, ValueList);
        end;
      finally
        ValueList.Free;
      end;
    end;
  end;
end;

class function TEtsImporter.EtExtinctionDepth_Name: string;
begin
  result := 'Imported_EtsExtinctionDepth_StressPeriod';
end;

class function TEtsImporter.EtExtinctionDepth_SP: string;
begin
  result := 'Imported_ETS_ExtinctionDepth_SP_';
end;

function TEtsImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowEtsBoundary;
end;

procedure TEtsImporter.HandlePackage;
var
  StressPeriodIndex: Integer;
  ScreenObject: TScreenObject;
  EtLayerDataSet: TDataArray;
  NewItemNeeded: Boolean;
  EtsBoundary: TEtsBoundary;
  EvtItem: TEvtItem;
  LayerItem: TEvtLayerItem;
  EvtName: string;
  EvtLayerName: string;
  EvtSurfaceName: string;
  ParamIndex: Integer;
  Param: TArrayParameterObject;
  Instance: TArrayInstanceObject;
  ClusterIndex: Integer;
  Cluster: TClusterObject;
  ObjectIndex: integer;
  ClusterList: TList;
  ScreenObjectList: TList;
  StressPeriod: TArrayStressPeriod;
  ScreenObIndex: Integer;
  EvtExtinctName: string;
  EvtSurf: TEtsSurfDepthItem;
  SegmentIndex: Integer;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  FEtsPackage := FModel.ModflowPackages.EtsPackage;
  Package := FEtsPackage;
  FEtsPackage.IsSelected := True;
  FEtsPackage.Comments := FComments;
  SetEtsOption;
  FEtsPackage.SegmentCount := NETSEG;
  FEtsPackage.UpdateEtsSegmentCount;
  EvaluateTimeVaryingLayers(FEtsPackage);

  CreateAssignedLayerDataSet(FEtsPackage, 'Imported_Ets_Elevation',
    'Imported_Ets_Elevation', EtLayerDataSet);

  if NP > 0 then
  begin
    ClusterList := TList.Create;
    ScreenObjectList := TList.Create;
    try
//      ObjectIndex := 0;
      for ParamIndex := 0 to FParams.ArrayLength - 1 do
      begin
        Param := FParams[ParamIndex];
        CreateTransientParam(Param);

        ScreenObjectList.Clear;
        ClusterList.Clear;
        CreateScreenObjectsFromClusters(Param, ObjectIndex,
          ScreenObjectList, ClusterList, 'ImportedEtsParam_',
          'Imported_Ets_Elevation', FEtsPackage);
        // At this point, ScreenObjectList contains each TScreenObject
        // that has been created for a particular parameter
        // and Cluster list contains a TClusterObject that has the
        // zone array and zones used to define the geometry of the
        // TScreenObject but not necessarily the corresponding Multiplier
        // array.

        // What need's to be done is to identify the stress periods in which
        // each parameter instance was used and find the corresponding
        // TScreenObjects and assign the formulas for those
        // stress periods using the appropriate multiplier arrays.

        // Loop over stress periods
        for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
        begin
          if ParamIndex = 0 then
          begin
            CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex,
              'Imported_Ets_Layer_StressPeriod',
              'Imported_ETS_Layers_SP_', FEtsPackage);
            CreateEtSurfaceDataSet(StressPeriodIndex);
            CreateEtExtinctionDepthDataSet(StressPeriodIndex);
            for SegmentIndex := 1 to NETSEG - 1 do
            begin
              CreateDepthFractionDataSet(SegmentIndex,StressPeriodIndex);
              CreateRateFractionDataSet(SegmentIndex,StressPeriodIndex);
            end;
          end;
          if FEtsPackage.TimeVaryingLayers and
            (not FReuseLayerIndicator[StressPeriodIndex]) then
          begin
            EvtLayerName := 'Imported_Ets_Layer_StressPeriod' +
              GetStressPeriodString(StressPeriodIndex);
          end;
          if not FReuseEtSurface[StressPeriodIndex] then
          begin
            EvtSurfaceName := 'Imported_EtsSurface_StressPeriod'
              + GetStressPeriodString(StressPeriodIndex);
          end;
          if not FReuseEtExtinctionDepth[StressPeriodIndex] then
          begin
            EvtExtinctName := 'Imported_EtsExtinctionDepth_StressPeriod'
              + GetStressPeriodString(StressPeriodIndex);
          end;
          StressPeriod := FStressPeriods[StressPeriodIndex];
          if StressPeriod.Reuse then
          begin
            ReuseEtStressPeriodWithParameters(StressPeriodIndex,
              Param, ScreenObjectList, EvtLayerName, EvtSurfaceName,
              EvtExtinctName);
          end
          else
          begin
            // In each stress period, identify whether the parameter was used.
            // If it was used, identify the intance used.
            GetParamInstanceForCurrentStressPeriod(Instance, Param,
              StressPeriod);
            if Instance <> nil then
            begin
              // Identify the cluster associated with the instance.
              for ClusterIndex := 0 to Instance.ArrayLength - 1 do
              begin
                Cluster := Instance.Clusters[ClusterIndex];
                ScreenObIndex := ClusterList.IndexOf(Cluster);
                Assert(ScreenObIndex >= 0);
                // Identify the cluster in ClusterList with the same geometry
                // as the cluster used.
                // Retrieve the corresponding TScreenObject from
                // ScreenObjectList.
                // Assign a formula for this parameter in this
                // stress period.
                // The formula should be either the
                // name of the multiplier array,
                // if one is used, or 1 if a multiplier array is not used.
                ScreenObject := ScreenObjectList[ScreenObIndex];
                AssignParamEvtRate(ScreenObject, StressPeriodIndex,
                  Cluster, Param);
                AssignTimeVaryingLayer(ScreenObject,
                  EvtLayerName, StressPeriodIndex);
                AssignSurfaceAndDepth(ScreenObject, EvtSurfaceName,
                  EvtExtinctName, StressPeriodIndex);
              end;
            end;
          end;
        end;
      end;
    finally
      ScreenObjectList.Free;
      ClusterList.Free;
    end;
  end
  else
  begin
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      CreateEvtRateDataSet(StressPeriodIndex);
      CreateEtSurfaceDataSet(StressPeriodIndex);
      CreateEtExtinctionDepthDataSet(StressPeriodIndex);
      for SegmentIndex := 1 to NETSEG - 1 do
      begin
        CreateDepthFractionDataSet(SegmentIndex,StressPeriodIndex);
        CreateRateFractionDataSet(SegmentIndex,StressPeriodIndex);
      end;
      CreateTimeVaryingAssignedLayerDataSet(StressPeriodIndex,
        'Imported_Ets_Layer_StressPeriod', 'Imported_ETS_Layers_SP_',
        FEtsPackage);
    end;

    ScreenObject := CreateScreenObjectAroundGrid('ImportedEts');
    if (FEtsPackage.LayerOption = loSpecified)
      and not FEtsPackage.TimeVaryingLayers then
    begin
      ScreenObject.ElevationFormula := 'Imported_Ets_Elevation';
    end
    else
    begin
      ScreenObject.ElevationFormula := kModelTop;
    end;

    CreateBoundary(ScreenObject);
    EtsBoundary := ScreenObject.ModflowEtsBoundary;
    EvtItem := nil;
    LayerItem := nil;
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      NewItemNeeded := not FReuseEtRate[StressPeriodIndex];
      if FEtsPackage.TimeVaryingLayers then
      begin
        if not FReuseLayerIndicator[StressPeriodIndex] then
        begin
          NewItemNeeded := True;
        end;
      end;
      if not FReuseEtSurface[StressPeriodIndex] then
      begin
        NewItemNeeded := True;
      end;
      if not FReuseEtExtinctionDepth[StressPeriodIndex] then
      begin
        NewItemNeeded := True;
      end;
      if (FReuseSegmentDefinition <> nil) and not FReuseSegmentDefinition[StressPeriodIndex] then
      begin
        NewItemNeeded := True;
      end;

      if not FReuseEtRate[StressPeriodIndex] then
      begin
        EvtName := ImportedEtRateName
          + GetStressPeriodString(StressPeriodIndex);
      end;
      if FEtsPackage.TimeVaryingLayers and
        (not FReuseLayerIndicator[StressPeriodIndex]) then
      begin
        EvtLayerName := 'Imported_Ets_Layer_StressPeriod' +
          GetStressPeriodString(StressPeriodIndex);
      end;
      if not FReuseEtSurface[StressPeriodIndex] then
      begin
        EvtSurfaceName := ImportedEtSurfaceName
          + GetStressPeriodString(StressPeriodIndex);
      end;
      if not FReuseEtExtinctionDepth[StressPeriodIndex] then
      begin
        EvtExtinctName := EtExtinctionDepth_Name
          + GetStressPeriodString(StressPeriodIndex);
      end;

      AssignEtRateNonParam(EvtName, NewItemNeeded, EvtItem,
        EtsBoundary, StressPeriodIndex);
      AssignEtsLayerNonParam(NewItemNeeded, LayerItem,
        EtsBoundary, EvtLayerName, StressPeriodIndex);
      AssignEtsSurfaceNonParam(EvtSurfaceName,EvtExtinctName, NewItemNeeded,
        EvtSurf, EtsBoundary, StressPeriodIndex);
    end;
  end;
end;

procedure TEtsImporter.ReadData(const ALabel: string);
var
  Handled: Boolean;
  INETSS: integer;
  INETSR: integer;
  INETSX: integer;
  INIETS: integer;
  INSGDF: integer;
  ALine: string;
  Value: double;
  IntValue: integer;
  ID: string;
begin
  inherited;
  FRequiredType := 'ETS';
  ImportSharedData(ALabel, Handled);
  if not Handled then
  begin
    if ALabel = 'NETSOP,IETSCB,NPETS,NETSEG:' then
    begin
      Read(FImporter.FFile, NETSOP);
      Read(FImporter.FFile, DummyInteger); // IETSCB
      Read(FImporter.FFile, DummyInteger); // NPETS
      Read(FImporter.FFile, NETSEG);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      SetLength(FConstantDepthProportions, NETSEG-1);
      SetLength(FVariableDepthProportions, NETSEG-1);
      SetLength(FConstantRateProportions, NETSEG-1);
      SetLength(FVariableRateProportions, NETSEG-1);
    end
    else if ALabel = 'INETSS,INETSR,INETSX,INIETS,INSGDF:' then
    begin
      Read(FImporter.FFile, INETSS);
      Read(FImporter.FFile, INETSR);
      Read(FImporter.FFile, INETSX);
      Read(FImporter.FFile, INIETS);
      Read(FImporter.FFile, INSGDF);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      FCurrentSegment := -1;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INETSR);
      InitializeReuseEtSurface;
      FReuseEtSurface[FCurrentStressPeriod] := INETSS < 0;
      InitializeReuseEtRate;
      FReuseEtRate[FCurrentStressPeriod] := INETSR < 0;
      InitializeReuseExtinctionDepth;
      FReuseEtExtinctionDepth[FCurrentStressPeriod] := INETSX < 0;
      InitializeReuseLayerIndicator;
      FReuseLayerIndicator[FCurrentStressPeriod] := INIETS < 0;
      InitializeReuseSegmentDefinition;
      FReuseSegmentDefinition[FCurrentStressPeriod] := INSGDF < 0;
      CurrentParameter := 0;
    end
    else if ALabel = 'INETSS,INETSR,INETSX,INIETS:' then
    begin
      Read(FImporter.FFile, INETSS);
      Read(FImporter.FFile, INETSR);
      Read(FImporter.FFile, INETSX);
      Read(FImporter.FFile, INIETS);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INETSR);
      InitializeReuseEtSurface;
      FReuseEtSurface[FCurrentStressPeriod] := INETSS < 0;
      InitializeReuseEtRate;
      FReuseEtRate[FCurrentStressPeriod] := INETSR < 0;
      InitializeReuseExtinctionDepth;
      FReuseEtExtinctionDepth[FCurrentStressPeriod] := INETSX < 0;
      InitializeReuseLayerIndicator;
      FReuseLayerIndicator[FCurrentStressPeriod] := INIETS < 0;
      CurrentParameter := 0;
    end
    else if ALabel = 'INETSS,INETSR,INETSX:' then
    begin
      Read(FImporter.FFile, INETSS);
      Read(FImporter.FFile, INETSR);
      Read(FImporter.FFile, INETSX);
      ReadLn(FImporter.FFile);
      FImporter.UpdateProgress;
      Inc(FCurrentStressPeriod);
      InitializeStressPeriods;
      InitializeCurrentStressPeriod(INETSR);
      InitializeReuseEtSurface;
      FReuseEtSurface[FCurrentStressPeriod] := INETSS < 0;
      InitializeReuseEtRate;
      FReuseEtRate[FCurrentStressPeriod] := INETSR < 0;
      InitializeReuseExtinctionDepth;
      FReuseEtExtinctionDepth[FCurrentStressPeriod] := INETSX < 0;
      CurrentParameter := 0;
    end
    else if ALabel = StrConstant2DRealArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      Readln(FImporter.FFile, Value);
      if ALine = StrETSURFACEETSS then
      begin
        ReadRealConstantArrayItem(Value, FConstantEtSurface);
      end
      else if ALine = StrEVAPOTRANSRATEET then
      begin
        ReadRealConstantArrayItem(Value, FConstantEtRate);
      end
      else if ALine = StrEXTINCTIONDEPTHET then
      begin
        ReadRealConstantArrayItem(Value, FConstantExtinctionDepth);
      end
      else if ALine = 'EXTINCT. DEP. PROPORTION' then
      begin
        Inc(FCurrentSegment);
        ReadRealConstantArrayItem(Value,
          FConstantDepthProportions[FCurrentSegment]);
      end
      else if ALine = 'ET RATE PROPORTION' then
      begin
        ReadRealConstantArrayItem(Value,
          FConstantRateProportions[FCurrentSegment]);
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrVariable2DRealArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      if ALine = StrETSURFACEETSS then
      begin
        ReadRealVariableArray(FVariableEtSurface, Format('ETS Surface %d', [FCurrentStressPeriod]));
      end
      else if ALine = StrEVAPOTRANSRATEET then
      begin
        ReadRealVariableArray(FVariableEtRate, Format('ETS Evapotranspiration Rat %d', [FCurrentStressPeriod]));
      end
      else if ALine = StrEXTINCTIONDEPTHET then
      begin
        ReadRealVariableArray(FVariableExtinctionDepth, Format('ETS Extinction depth %d', [FCurrentStressPeriod]));
      end
      else if ALine = 'EXTINCT. DEP. PROPORTION' then
      begin
        Inc(FCurrentSegment);
        ReadRealVariableArray(FVariableDepthProportions[FCurrentSegment],
          Format('ETS Extinction depth fraction %d', [FCurrentStressPeriod]));
      end
      else if ALine = 'ET RATE PROPORTION' then
      begin
        ReadRealVariableArray(FVariableRateProportions[FCurrentSegment],
          Format('ETS Extinction rate fraction %d', [FCurrentStressPeriod]));
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrConstant2DIntegerArray then
    begin
      ReadLn(FImporter.FFile, ALine);
      ALine := Trim(ALine);
      Readln(FImporter.FFile, IntValue);
      if ALine = StrETLAYERINDEXIETS then
      begin
        ReadConstantIntArray(IntValue, FConstantLayerIndicators);
      end
      else
      begin
        Assert(False);
      end;
    end
    else if ALabel = StrVariable2DIntegerArray then
    begin
      ReadLn(FImporter.FFile, ID);
      ID := Trim(ID);
      if ID = StrETLAYERINDEXIETS then
      begin
        ReadVariableIntArray(FVariableLayerIndicators);
      end
      else
      begin
        Assert(False);
      end;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

class function TEtsImporter.ImportedEtRateName: string;
begin
  result := 'Imported_EtsRate_StressPeriod';
end;

class function TEtsImporter.ImportedEtSurfaceName: string;
begin
  result := 'Imported_EtsSurface_StressPeriod';
end;

class function TEtsImporter.ImportedEtSurfaceSP: string;
begin
  result := 'Imported_ETS_Surface_SP_';
end;

class function TEtsImporter.ImportedEtValuesName: string;
begin
  result := 'Imported_ETS_Values_SP_';
end;

procedure TEtsImporter.InitializeReuseSegmentDefinition;
var
  Index: Integer;
begin
  if FReuseSegmentDefinition = nil then
  begin
    SetLength(FReuseSegmentDefinition, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(FReuseSegmentDefinition) - 1 do
    begin
      FReuseSegmentDefinition[Index] := False;
    end;
  end;
end;

procedure TEtsImporter.SetEtsOption;
var
  Option: Integer;
begin
  Option := NETSOP - 1;
  if Option < 0 then
  begin
    Option := 0;
  end;
  if Option > 2 then
  begin
    Option := 2;
  end;
  FEtsPackage.LayerOption := TLayerOption(Option);
end;

procedure TCustomETImporter.InitializeReuseEtSurface;
var
  Index: Integer;
begin
  if FReuseEtSurface = nil then
  begin
    SetLength(FReuseEtSurface, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(FReuseEtSurface) - 1 do
    begin
      FReuseEtSurface[Index] := False;
    end;
  end;
end;

procedure TCustomETImporter.InitializeReuseExtinctionDepth;
var
  Index: Integer;
begin
  if FReuseEtExtinctionDepth = nil then
  begin
    SetLength(FReuseEtExtinctionDepth, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(FReuseEtExtinctionDepth) - 1 do
    begin
      FReuseEtExtinctionDepth[Index] := False;
    end;
  end;
end;

procedure TCustomETImporter.InitializeReuseEtRate;
var
  Index: Integer;
begin
  if FReuseEtRate = nil then
  begin
    SetLength(FReuseEtRate, FModel.ModflowStressPeriods.Count);
    for Index := 0 to Length(FReuseEtRate) - 1 do
    begin
      FReuseEtRate[Index] := False;
    end;
  end;
end;

{ TResImporter }

constructor TResImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'RES', nil);
  FStressPeriods:= TResStressPeriods.Create;
end;

procedure TResImporter.CreateBoundary(ScreenObject: TScreenObject);
begin
  ScreenObject.CreateResBoundary;
end;

destructor TResImporter.Destroy;
begin
  FStressPeriods.Free;
  inherited;
end;

procedure TResImporter.HandlePackage;
var
  DataArray: TDataArray;
  LayerIndex: Integer;
  Cluster : TClusterObject;
  ScreenObjectName: string;
  ScreenObject: TScreenObject;
  Position: Integer;
  ResIndex: Integer;
  ResBoundary: TResBoundary;
  StressPeriodIndex: Integer;
  StressPeriod: TModflowStressPeriod;
  ResItem: TResItem;
  ResStressPeriod: TResStressPeriod;
  ResValues: TResStage;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  FResPackage := FModel.ModflowPackages.ResPackage;
  FResPackage.IsSelected := True;
  FResPackage.Comments := FComments;
  FResPackage.LayerOption := TLayerOption(NRESOP-1);
  FResPackage.PrintStage := IRESPT > 0;
  FResPackage.TableStages := NPTS;

  FModel.DataArrayManager.CreateInitialDataSets;

  if FResPackage.LayerOption = loSpecified then
  begin
    DataArray := FModel.DataArrayManager.GetDataSetByName(rsResLayer);
    Assert(DataArray <> nil);
    if ConstantResLayer then
    begin
      DataArray.Formula := IntToStr(ResLayer[0,0]);
    end
    else
    begin
      Cluster := TClusterObject.Create;
      try
        SetLength(Cluster.Zones, 1);
        for LayerIndex := 1 to FModel.ModflowLayerCount do
        begin
          Cluster.Zones[0] := LayerIndex;
          ScreenObjectName := 'Imported_RES_Layer_' + IntToStr(LayerIndex);
          ScreenObject := CreateScreenObjectAroundZones(
            ResLayer, Cluster, ScreenObjectName);
          ScreenObject.ElevationFormula := kModelTop;
          Position := ScreenObject.AddDataSet(DataArray);
          ScreenObject.DataSetFormulas[Position] := IntToStr(LayerIndex);
        end;
      finally
        Cluster.Free;
      end;
    end;
  end;

  ScreenObject := nil;
  DataArray := FModel.DataArrayManager.GetDataSetByName(rsResBottom);
  Assert(DataArray <> nil);
  if ConstantLandSurface then
  begin
    DataArray.Formula := FortranFloatToStr(LandSurface[0,0]);
  end
  else
  begin
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
//      ScreenObject.Name := 'Imported_RES_Land_Surface';
    end;
    AssignRealValuesToCellCenters(DataArray, ScreenObject, LandSurface);
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(rsResKv);
  Assert(DataArray <> nil);
  if ConstantVertK then
  begin
    DataArray.Formula := FortranFloatToStr(VertK[0,0]);
  end
  else
  begin
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
//      ScreenObject.Name := 'Imported_RES_Vertical_K';
    end;
    AssignRealValuesToCellCenters(DataArray, ScreenObject, VertK);
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(rsResBedThickness);
  Assert(DataArray <> nil);
  if ConstantBedThick then
  begin
    DataArray.Formula := FortranFloatToStr(BedThickness[0,0]);
  end
  else
  begin
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    AssignRealValuesToCellCenters(DataArray, ScreenObject, BedThickness);
  end;

  Cluster := TClusterObject.Create;
  try
    SetLength(Cluster.Zones, 1);
    for ResIndex := 1 to NRES do
    begin
      Cluster.Zones[0] := ResIndex;
      ScreenObjectName := 'Imported_Reservoir_' + IntToStr(ResIndex);
      ScreenObject := CreateScreenObjectAroundZones(
        ResLocation, Cluster, ScreenObjectName);
      ScreenObject.ElevationFormula := kModelTop;
      CreateBoundary(ScreenObject);
      ResBoundary := ScreenObject.ModflowResBoundary;
      ResBoundary.Values.Capacity := FModel.ModflowStressPeriods.Count;
      for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
      begin
        StressPeriod := FModel.ModflowStressPeriods[StressPeriodIndex];
        ResItem := ResBoundary.Values.Add as TResItem;
        ResStressPeriod := FStressPeriods[StressPeriodIndex];
        ResValues := ResStressPeriod[ResIndex-1];
        ResItem.StartTime := StressPeriod.StartTime;
        ResItem.EndTime := StressPeriod.EndTime;
        ResItem.StartHead := FortranFloatToStr(ResValues.Ststage);
        ResItem.EndHead := FortranFloatToStr(ResValues.Endstage);
      end;
    end;
  finally
    Cluster.Free;
  end;

end;

procedure TResImporter.ReadData(const ALabel: string);
var
  ID: string;
  Value: double;
  IntValue: integer;
//  Layer: integer;
//  IRESCB: integer;
  Index: Integer;
  FResStressPeriod: TResStressPeriod;
begin
  inherited;
  if ALabel = 'NRES,IRESCB,NRESOP,IRESPT,NPTS:' then
  begin
    Read(FImporter.FFile, NRES);
    Read(FImporter.FFile, DummyInteger); // IRESCB
    Read(FImporter.FFile, NRESOP);
    Read(FImporter.FFile, IRESPT);
    Read(FImporter.FFile, NPTS);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
    FStressPeriods.ArrayLength := FModel.ModflowStressPeriods.Count;
  end
  else if ALabel = 'HRESSE(1,N),HRESSE(2,N):' then
  begin
    Inc(FCurrentStressPeriod);
    FResStressPeriod := FStressPeriods[FCurrentStressPeriod];
    FResStressPeriod.ArrayLength := NRES;
    for Index := 0 to NRES - 1 do
    begin
      Read(FImporter.FFile, FResStressPeriod[Index].Ststage);
      Read(FImporter.FFile, FResStressPeriod[Index].Endstage);
      ReadLn(FImporter.FFile);
    end;
    FImporter.UpdateProgress;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    ReadLn(FImporter.FFile, DummyInteger); // Layer
    Readln(FImporter.FFile, Value);
    ID := Trim(ID);
    if ID = 'RESERVOIR LAND SURF ELEV' then
    begin
      ConstantLandSurface := True;
      SetLength(LandSurface, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      AssignConstant2DArray(Value, LandSurface);
    end
    else if ID = 'RES. BED VERT HYD COND' then
    begin
      ConstantVertK := True;
      SetLength(VertK, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      AssignConstant2DArray(Value, VertK);
    end
    else if ID = 'RESERVOIR BED THICKNESS' then
    begin
      ConstantBedThick := True;
      SetLength(BedThickness, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      AssignConstant2DArray(Value, BedThickness);
    end
    else
    begin
      Assert(False);
    end;
    FImporter.UpdateProgress;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    ReadLn(FImporter.FFile, DummyInteger); // Layer
    ID := Trim(ID);
    if ID = 'RESERVOIR LAND SURF ELEV' then
    begin
      ConstantLandSurface := False;
      SetLength(LandSurface, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      Read2DRealArray(LandSurface, 'Reservoir land surface elevation');
    end
    else if ID = 'RES. BED VERT HYD COND' then
    begin
      ConstantVertK := False;
      SetLength(VertK, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      Read2DRealArray(VertK, 'Reservoir bed vertical hydraulic conductivity');
    end
    else if ID = 'RESERVOIR BED THICKNESS' then
    begin
      ConstantBedThick := False;
      SetLength(BedThickness, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      Read2DRealArray(BedThickness, 'Reservoir bed thickness');
    end
    else
    begin
      Assert(False);
    end;
  end
  else if ALabel = StrConstant2DIntegerArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    ReadLn(FImporter.FFile, DummyInteger); // Layer
//    Dec(Layer);
    ReadLn(FImporter.FFile, IntValue);
    ID := Trim(ID);
    if ID = 'RESERVOIR LOCATION' then
    begin
      ConstantResLocation := True;
      SetLength(ResLocation, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      AssignConstant2DIntArray(IntValue, ResLocation);
    end
    else if ID = 'RESERVOIR LAYER INDEX' then
    begin
      ConstantResLayer := True;
      SetLength(ResLayer, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      AssignConstant2DIntArray(IntValue, ResLayer);
    end
    else
    begin
      Assert(False);
    end;
    FImporter.UpdateProgress;
  end
  else if ALabel = StrVariable2DIntegerArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    ReadLn(FImporter.FFile, DummyInteger); // Layer
    ID := Trim(ID);
    if ID = 'RESERVOIR LOCATION' then
    begin
      ConstantResLocation := False;
      SetLength(ResLocation, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      ReadVariable2DIntArray(ResLocation);
    end
    else if ID = 'RESERVOIR LAYER INDEX' then
    begin
      ConstantResLayer := False;
      SetLength(ResLayer, FModel.Grid.RowCount, FModel.Grid.ColumnCount);
      ReadVariable2DIntArray(ResLayer);
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TResStressPeriod }

function TResStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TResStage;
end;

function TResStressPeriod.GetStages(Index: integer): TResStage;
begin
  result := Objects[Index] as TResStage
end;

{ TResStressPeriods }

function TResStressPeriods.ArrayMemberClass: TArrayMemberClass;
begin
  result := TResStressPeriod;
end;

function TResStressPeriods.GetStressPeriods(Index: integer): TResStressPeriod;
begin
  result := Objects[Index] as TResStressPeriod
end;

{ TUzfImporter }

constructor TUzfImporter.Create(Importer: TModflow2005Importer;
  LakImporter: TLakImporter; SfrImporter: TSfrImporter);
begin
  inherited Create(Importer, 'UZF', nil);
  FLakImporter := LakImporter;
  FSfrImporter := SfrImporter;
  FEtStressPeriods:= TArrayStressPeriodArray.Create;
  FEtExtinctDepthStressPeriods:= TArrayStressPeriodArray.Create;
  FEtExtinctWaterContentStressPeriods:= TArrayStressPeriodArray.Create;
  FGages:= TUzfGageArray.Create;
  FCurrentGage := -1;
  SPECIFYTHTR := False;
  SPECIFYTHTI := False;
  NOSURFLEAK := False;
end;

procedure TUzfImporter.CreateBoundary(ScreenObject: TScreenObject);
begin
  ScreenObject.CreateUzfBoundary;
end;

procedure TUzfImporter.CreateInfiltrationDataArray(StressPeriodIndex: integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseInfiltration,
    StrImportedUZFInfiltr, FConstantInfiltration,
    FVariableInfiltration, 'Imported_UZF_Infiltration_Values_SP_');
end;

procedure TUzfImporter.CreateETDataArray(StressPeriodIndex: integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseET,
    StrImportedUZFEvapotr, FConstantET,
    FVariableET, 'Imported_UZF_Evapotranspiration_Values_SP_');
end;

procedure TUzfImporter.CreateExtinctionDepthDataArray(StressPeriodIndex: integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseExtictionDepth,
    StrImportedUZFExtinct, FConstantExtinctDepth,
    FVariableExtinctDepth, 'Imported_UZF_Extinction_Depth_Values_SP_');
end;

procedure TUzfImporter.CreateExtinctionWaterContentDataArray(StressPeriodIndex: integer);
begin
  CreateTransientRealDataArray(StressPeriodIndex, FReuseExtictionWaterContent,
    StrImportedUZFExWC, FConstantExtinctWaterContent,
    FVariableExtinctWaterContent, 'Imported_UZF_Extinction_Water_Content_Values_SP_');
end;

destructor TUzfImporter.Destroy;
begin
  FGages.Free;
  FEtStressPeriods.Free;
  FEtExtinctDepthStressPeriods.Free;
  FEtExtinctWaterContentStressPeriods.Free;
  inherited;
end;

procedure TPackageImporter.AssignImportedValues(ImportedValues: TValueArrayItem;
  ImportedData: T2DDoubleArray);
var
  RowIndex: Integer;
  ColIndex: Integer;
  PointIndex: Integer;
  APoint: TPoint2D;
begin
  ImportedValues.Values.DataType := rdtDouble;
  ImportedValues.Values.Count := FGrid.RowCount * FGrid.ColumnCount;
  PointIndex := 0;
  for RowIndex := 0 to FGrid.RowCount - 1 do
  begin
    for ColIndex := 0 to FGrid.ColumnCount - 1 do
    begin
      APoint := FImporter.CenterPoints[RowIndex, ColIndex];
      if (FImporter.FImportParameters.Outline = nil)
        or FImporter.FImportParameters.Outline.PointInside(APoint) then
      begin
        ImportedValues.Values.RealValues[PointIndex] :=
          ImportedData[RowIndex, ColIndex];
        Inc(PointIndex);
      end;
    end;
  end;
  ImportedValues.Values.Count := PointIndex;
end;

procedure TUzfImporter.HandlePackage;
var
  DataArray: TDataArray;
  Index: Integer;
  Gage: TUzfGage;
  GageIndex: Integer;
  AScreenObject: TScreenObject;
  APoint: TPoint2D;
  Boundary: TUzfBoundary;
  StressPeriodIndex: Integer;
  InfiltrationItem: TRchItem;
  EvtItem: TEvtItem;
  ExtinctDepthItem: TUzfExtinctDepthItem;
  WaterContentItem: TUzfWaterContentItem;
  CellCenterScreenObject: TScreenObject;
  NewItemsNeeded: Boolean;
  InfiltrationName: string;
  EtName: string;
  ExtinctionDepthName: string;
  ExtinctionWaterContentName: string;
  procedure AssignVariableIntValues(const ScreenObjectName: string;
    Data: T2DIntArray);
  var
    Interpolator: TNearestPoint2DInterpolator;
  begin
    if CellCenterScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(CellCenterScreenObject);
    end;


    AssignIntegerValuesToCellCenters(DataArray, CellCenterScreenObject, Data);
    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
  procedure AssignVariableRealValues(const ScreenObjectName: string;
    Data: T2DDoubleArray);
  var
    Interpolator: TNearestPoint2DInterpolator;
  begin
    if CellCenterScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(CellCenterScreenObject);
    end;

    AssignRealValuesToCellCenters(DataArray, CellCenterScreenObject, Data);
    Interpolator := TNearestPoint2DInterpolator.Create(nil);
    try
      DataArray.TwoDInterpolator := Interpolator;
    finally
      Interpolator.Free;
    end;
  end;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  frmErrorsAndWarnings.RemoveWarningGroup(FModel, StrUZFRoutingSpecifie);
  CellCenterScreenObject := nil;
  inherited;
  FUzfPackage := FModel.ModflowPackages.UzfPackage;
  FUzfPackage.IsSelected := True;
  FUzfPackage.Comments := FComments;

  FModel.ModflowPackages.SfrPackage.IsSelected := FSfrImporter.FIsSelected;
  FModel.ModflowPackages.LakPackage.IsSelected := FLakImporter.FIsSelected;

  FUzfPackage.SpecifyResidualWaterContent := SPECIFYTHTR;
  FUzfPackage.SpecifyInitialWaterContent := SPECIFYTHTI;
  FUzfPackage.CalulateSurfaceLeakage := not NOSURFLEAK;

  if NUZTOP < 1 then
  begin
    NUZTOP := 1;
  end;
  if NUZTOP > 4 then
  begin
    NUZTOP := 3;
  end;
  FUzfPackage.LayerOption := TLayerOption(NUZTOP-1);
  FUzfPackage.VerticalKSource := Abs(IUZFOPT);
  FUzfPackage.RouteDischargeToStreams := IRUNFLG <> 0;
  FUzfPackage.SimulateET := IETFLG <> 0;
  FUzfPackage.NumberOfTrailingWaves := NTRAIL2;
  FUzfPackage.NumberOfWaveSets := NSETS2;
  FUzfPackage.DepthOfUndulations := SURFDEP;

  FUzfPackage.ETSmoothed := FEtSquare;
  if FUzfPackage.ETSmoothed then
  begin
    FModel.ModelSelection := msModflowNWT;
    FUzfPackage.SmoothFactor := Fsmoothfact;
  end;

  if FSpecifySurfK then
  begin
    FModel.ModelSelection := msModflowNWT;
    FUzfPackage.SurfaceKUsedToCalculateRejection := FRejectSurfK;
    FUzfPackage.SurfaceKUsedToCalculateSeepage := FSeepSurfK;
  end;

  FUzfPackage.WriteRechargeAndDischarge := FNetFlux;
  if FUzfPackage.WriteRechargeAndDischarge then
  begin
    FModel.ModelSelection := msModflowNWT;
  end;

  FModel.DataArrayManager.CreateInitialDataSets;

  DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfLayer);
  if IsConstIUZFBND then
  begin
    DataArray.Formula := IntToStr(ConstIUZFBND);
  end
  else
  begin
    AssignVariableIntValues('Imported_IUZFBND', IUZFBND);
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfSurfaceK);
  if DataArray <> nil then
  begin
    if IsConstSeepK then
    begin
      DataArray.Formula := FortranFloatToStr(ConstSeepKhtr);
    end
    else
    begin
      AssignVariableRealValues('Imported_Surficial_K', SeepK);
    end;
  end;


  if IRUNFLG > 0 then
  begin
    DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfDischargeRouting);
    if DataArray <> nil then
    begin
      if IsConstIRUNBND then
      begin
        DataArray.Formula := IntToStr(ConstIRUNBND);
      end
      else
      begin
        AssignVariableIntValues('Imported_IRUNBND', IRUNBND);
      end;
    end
    else
    begin
      frmErrorsAndWarnings.AddWarning(FModel, StrUZFRoutingSpecifie,
        StrInTheUZFPackage);
    end;
  end;

  if Abs(IUZFOPT) = 1 then
  begin
    DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfVerticalK);
    if IsConstVks then
    begin
      DataArray.Formula := FortranFloatToStr(ConstVks);
    end
    else
    begin
      AssignVariableRealValues('Imported_IRUNBND', VKS);
    end;
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfBrooksCoreyEpsilon);
  if IsConstEps then
  begin
    DataArray.Formula := FortranFloatToStr(ConstEps);
  end
  else
  begin
    AssignVariableRealValues('Imported_EPS', EPS);
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfSaturatedWaterContent);
  if IsConstThts then
  begin
    DataArray.Formula := FortranFloatToStr(ConstThts);
  end
  else
  begin
    AssignVariableRealValues('Imported_THTS', THTS);
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfInitialUnsaturatedWaterContent);
  if DataArray <> nil then
  begin
    if IsConstThti then
    begin
      DataArray.Formula := FortranFloatToStr(ConstThti);
    end
    else
    begin
      Assert(Length(THTI) > 0);
      AssignVariableRealValues('Imported_THTI', THTI);
    end;
  end;

  DataArray := FModel.DataArrayManager.GetDataSetByName(StrUzfReisidualWaterContent);
  if DataArray <> nil then
  begin
    if IsConstThtr then
    begin
      DataArray.Formula := FortranFloatToStr(ConstThtr);
    end
    else
    begin
      Assert(Length(THTR) > 0);
      AssignVariableRealValues('Imported_THTR', THTR);
    end;
  end;

  GageIndex := 1;
  for Index := 0 to FGages.ArrayLength - 1 do
  begin
    Gage := FGages[Index];
    if Gage.IFTUNIT < 0 then
    begin
      FUzfPackage.PrintSummary := 1;
    end
    else
    begin
      AScreenObject := CreateScreenObject('Imported_UZF_Gage'
        + IntToStr(GageIndex));
      Inc(GageIndex);
      APoint := FGrid.TwoDElementCenter(Gage.IUZCOL-1, Gage.IUZROW-1);
      AScreenObject.AddPoint(APoint, True);
      AScreenObject.ElevationCount := ecZero;
      AScreenObject.SetValuesOfIntersectedCells := True;
      CreateBoundary(AScreenObject);
      Boundary := AScreenObject.ModflowUzfBoundary;
      case Gage.IUZOPT of
        1:
          begin
            Boundary.GageOption1 := 1;
          end;
        2:
          begin
            Boundary.GageOption1 := 2;
          end;
        3:
          begin
            Boundary.GageOption2 := 3;
          end;
        else Assert(False);
      end;
    end;
  end;

  InfiltrationItem := nil;
  EvtItem := nil;
  ExtinctDepthItem := nil;
  WaterContentItem := nil;
//  AScreenObject := nil;

  for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
  begin
    CreateInfiltrationDataArray(StressPeriodIndex);
    if FUzfPackage.SimulateET then
    begin
      CreateETDataArray(StressPeriodIndex);
      CreateExtinctionDepthDataArray(StressPeriodIndex);
      CreateExtinctionWaterContentDataArray(StressPeriodIndex);
    end;
  end;

  AScreenObject := CreateScreenObjectAroundGrid('Imported_UZF_Rates');
  AScreenObject.ElevationFormula := kModelTop;

  CreateBoundary(AScreenObject);
  Boundary := AScreenObject.ModflowUzfBoundary;
  InfiltrationItem := nil;
  EvtItem := nil;

  InfiltrationName := '';
  EtName := '';
  ExtinctionDepthName := '';
  ExtinctionWaterContentName := '';

  for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
  begin
    NewItemsNeeded := not FReuseInfiltration[StressPeriodIndex];
    if FUzfPackage.SimulateET then
    begin
      NewItemsNeeded := NewItemsNeeded
        or not FReuseET[StressPeriodIndex]
        or not FReuseExtictionDepth[StressPeriodIndex]
        or not FReuseExtictionWaterContent[StressPeriodIndex];
    end;

    if not FReuseInfiltration[StressPeriodIndex] then
    begin
      InfiltrationName := StrImportedUZFInfiltr
        + GetStressPeriodString(StressPeriodIndex);
    end;

    AssignInfiltation(NewItemsNeeded, Boundary, InfiltrationItem,
      InfiltrationName, StressPeriodIndex);
    if FUzfPackage.SimulateET then
    begin
      if not FReuseET[StressPeriodIndex] then
      begin
        EtName := StrImportedUZFEvapotr
          + GetStressPeriodString(StressPeriodIndex);
      end;

      if not FReuseExtictionDepth[StressPeriodIndex] then
      begin
        ExtinctionDepthName := StrImportedUZFExtinct
          + GetStressPeriodString(StressPeriodIndex);
      end;

      if not FReuseExtictionWaterContent[StressPeriodIndex] then
      begin
        ExtinctionWaterContentName := StrImportedUZFExWC
          + GetStressPeriodString(StressPeriodIndex);
      end;

      AssignEt(NewItemsNeeded, Boundary, EvtItem,
        EtName, StressPeriodIndex);
      AssignExtinctionDepth(NewItemsNeeded, Boundary, ExtinctDepthItem,
        ExtinctionDepthName, StressPeriodIndex);
      AssignWaterContent(NewItemsNeeded, Boundary, WaterContentItem,
        ExtinctionWaterContentName, StressPeriodIndex);
    end;
  end;


//  for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
//  begin
//    StressPeriod := FModel.ModflowStressPeriods[StressPeriodIndex];
//
//    ReUse := FStressPeriods[StressPeriodIndex].Reuse;
//    if ReUse and FUzfPackage.SimulateET then
//    begin
//      ReUse := FEtStressPeriods[StressPeriodIndex].Reuse
//        and FEtExtinctDepthStressPeriods[StressPeriodIndex].Reuse
//        and FEtExtinctWaterContentStressPeriods[StressPeriodIndex].Reuse;
//    end;
//
//    if Reuse then
//    begin
//      InfiltrationItem.EndTime := StressPeriod.EndTime;
//      if FUzfPackage.SimulateET then
//      begin
//        EvtItem.EndTime := StressPeriod.EndTime;
//        ExtinctDepthItem.EndTime := StressPeriod.EndTime;
//        WaterContentItem.EndTime := StressPeriod.EndTime;
//      end;
//    end
//    else
//    begin
////      Boundary := nil;
//      if AScreenObject = nil then
//      begin
//        AScreenObject := TScreenObject.CreateWithViewDirection(FModel, vdTop,
//          UndoCreateScreenObject, False);
//        AScreenObject.Name := 'Imported_UZF_Rates';
//
//        FModel.AddScreenObject(AScreenObject);
//        AScreenObject.ElevationCount := ecZero;
//        AScreenObject.SetValuesByInterpolation := True;
//        AScreenObject.EvaluatedAt := eaBlocks;
//        AScreenObject.Visible := False;
//        AScreenObject.Capacity := FGrid.RowCount * FGrid.ColumnCount;
//        for RowIndex := 0 to FGrid.RowCount - 1 do
//        begin
//          for ColIndex := 0 to FGrid.ColumnCount - 1 do
//          begin
//            AScreenObject.AddPoint(FImporter.
//              CenterPoints[RowIndex, ColIndex], True);
//          end;
//        end;
//        AScreenObject.SectionStarts.CacheData;
//        AScreenObject.SetValuesOfIntersectedCells := True;
//        AScreenObject.SetValuesByInterpolation := False;
//
//        CreateBoundary(AScreenObject);
//      end;
//      Boundary := AScreenObject.ModflowUzfBoundary;
//      InfiltrationItem := Boundary.Values.Add as TRchItem;
//      InfiltrationItem.StartTime := StressPeriod.StartTime;
//      InfiltrationItem.EndTime := StressPeriod.EndTime;
//
//      if FStressPeriods[StressPeriodIndex].Reuse then
//      begin
//        PriorInfiltrationItem := Boundary.Values[Boundary.Values.Count -2]
//          as TRchItem;
//        InfiltrationItem.RechargeRate := PriorInfiltrationItem.RechargeRate
//      end
//      else
//      begin
//        if FConstantInfiltration[StressPeriodIndex].IsConstant then
//        begin
//          InfiltrationItem.RechargeRate :=
//            FortranFloatToStr(FConstantInfiltration[StressPeriodIndex].RealValue)
//        end
//        else
//        begin
//          ImportedData := FVariableInfiltration[StressPeriodIndex];
//          ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
//          ImportedValues.Name := 'Imported_UZF_Infiltration_'
//            + IntToStr(StressPeriodIndex+1);
//          AssignImportedValues(ImportedValues, ImportedData);
//          InfiltrationItem.RechargeRate := rsObjectImportedValuesR
//            + '("' + ImportedValues.Name + '")';
//        end;
//      end;
//      if FUzfPackage.SimulateET then
//      begin
//        if Reuse then
//        begin
//          EvtItem.EndTime := StressPeriod.EndTime;
//        end
//        else
//        begin
//          EvtItem := Boundary.EvapotranspirationDemand.Add as TEvtItem;
//          EvtItem.StartTime := StressPeriod.StartTime;
//          EvtItem.EndTime := StressPeriod.EndTime;
//          if FEtStressPeriods[StressPeriodIndex].Reuse then
//          begin
//            PriorEvtItem := Boundary.EvapotranspirationDemand.Items[
//              Boundary.EvapotranspirationDemand.Count-2] as TEvtItem;
//            EvtItem.EvapotranspirationRate :=
//              PriorEvtItem.EvapotranspirationRate;
//          end
//          else
//          begin
//            if FConstantET[StressPeriodIndex].IsConstant then
//            begin
//              EvtItem.EvapotranspirationRate :=
//                FortranFloatToStr(FConstantET[StressPeriodIndex].RealValue)
//            end
//            else
//            begin
//              ImportedData := FVariableET[StressPeriodIndex];
//              ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
//              ImportedValues.Name := 'Imported_UZF_ET_'
//                + IntToStr(StressPeriodIndex+1);
//              AssignImportedValues(ImportedValues, ImportedData);
//              EvtItem.EvapotranspirationRate := rsObjectImportedValuesR
//                + '("' + ImportedValues.Name + '")';
//            end;
//          end;
//        end;
//
//        if Reuse then
//        begin
//          ExtinctDepthItem.EndTime := StressPeriod.EndTime;
//        end
//        else
//        begin
//          ExtinctDepthItem := Boundary.ExtinctionDepth.Add as TUzfExtinctDepthItem;
//          ExtinctDepthItem.StartTime := StressPeriod.StartTime;
//          ExtinctDepthItem.EndTime := StressPeriod.EndTime;
//          if FEtExtinctDepthStressPeriods[StressPeriodIndex].Reuse then
//          begin
//            PriorExtinctDetphItem := Boundary.ExtinctionDepth.Items[
//              Boundary.ExtinctionDepth.Count-2] as TUzfExtinctDepthItem;
//            ExtinctDepthItem.UzfExtinctDepth :=
//              PriorExtinctDetphItem.UzfExtinctDepth;
//          end
//          else
//          begin
//            if FConstantExtinctDepth[StressPeriodIndex].IsConstant then
//            begin
//              ExtinctDepthItem.UzfExtinctDepth :=
//                FortranFloatToStr(FConstantExtinctDepth[StressPeriodIndex].RealValue)
//            end
//            else
//            begin
//              ImportedData := FVariableExtinctDepth[StressPeriodIndex];
//              ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
//              ImportedValues.Name := 'Imported_UZF_ExtinctionDepth_'
//                + IntToStr(StressPeriodIndex+1);
//              AssignImportedValues(ImportedValues, ImportedData);
//              ExtinctDepthItem.UzfExtinctDepth := rsObjectImportedValuesR
//                + '("' + ImportedValues.Name + '")';
//            end;
//          end;
//        end;
//
//        if Reuse then
//        begin
//          WaterContentItem.EndTime := StressPeriod.EndTime;
//        end
//        else
//        begin
//          WaterContentItem := Boundary.WaterContent.Add as TUzfWaterContentItem;
//          WaterContentItem.StartTime := StressPeriod.StartTime;
//          WaterContentItem.EndTime := StressPeriod.EndTime;
//          if FEtExtinctWaterContentStressPeriods[StressPeriodIndex].Reuse then
//          begin
//            PriorWaterContentItem := Boundary.WaterContent.Items[
//              Boundary.WaterContent.Count-2] as TUzfWaterContentItem;
//            WaterContentItem.UzfWaterContent := PriorWaterContentItem.UzfWaterContent;
//          end
//          else
//          begin
//            if FConstantExtinctWaterContent[StressPeriodIndex].IsConstant then
//            begin
//              WaterContentItem.UzfWaterContent :=
//                FortranFloatToStr(FConstantExtinctWaterContent[StressPeriodIndex].RealValue)
//            end
//            else
//            begin
//              ImportedData := FVariableExtinctWaterContent[StressPeriodIndex];
//              ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
//              ImportedValues.Name := 'Imported_UZF_ExtinctionWaterContent_'
//                + IntToStr(StressPeriodIndex+1);
//              AssignImportedValues(ImportedValues, ImportedData);
//              WaterContentItem.UzfWaterContent := rsObjectImportedValuesR
//                + '("' + ImportedValues.Name + '")';
//            end;
//          end;
//        end;
//      end;
//    end;
//  end;
end;

procedure TUzfImporter.AssignInfiltation(NewItemsNeeded: boolean;
  Boundary: TUzfBoundary; var InfiltrationItem: TRchItem;
  const InfiltationRate: string; StressPeriodIndex: Integer);
begin
  if NewItemsNeeded then
  begin
    Assert(InfiltationRate <> '');
    InfiltrationItem := Boundary.Values.Add as TRchItem;
    InfiltrationItem.RechargeRate := InfiltationRate;
    InfiltrationItem.StartTime :=
      FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    InfiltrationItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end
  else
  begin
    InfiltrationItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
  end;
end;

procedure TUzfImporter.AssignEt(NewItemsNeeded: boolean;
  Boundary: TUzfBoundary;
  var EvtItem: TEvtItem;
  const EtRate: string; StressPeriodIndex: Integer);
begin
  if FUzfPackage.SimulateET then
  begin
    if NewItemsNeeded then
    begin
      Assert(EtRate <> '');
      EvtItem := Boundary.EvapotranspirationDemand.Add as TEvtItem;
      EvtItem.EvapotranspirationRate := EtRate;
      EvtItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      EvtItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

procedure TUzfImporter.AssignExtinctionDepth(NewItemsNeeded: boolean;
  Boundary: TUzfBoundary;  var ExtinctDepthItem: TUzfExtinctDepthItem;
  const ExtinctionDepth: string; StressPeriodIndex: Integer);
begin
  if FUzfPackage.SimulateET then
  begin
    if NewItemsNeeded then
    begin
      Assert(ExtinctionDepth <> '');
      ExtinctDepthItem := Boundary.ExtinctionDepth.Add as TUzfExtinctDepthItem;
      ExtinctDepthItem.UzfExtinctDepth := ExtinctionDepth;
      ExtinctDepthItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      ExtinctDepthItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      ExtinctDepthItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;


procedure TUzfImporter.AssignWaterContent(NewItemsNeeded: boolean;
  Boundary: TUzfBoundary;
  var WaterContentItem: TUzfWaterContentItem;
  const WaterContent: string; StressPeriodIndex: Integer);
begin
  if FUzfPackage.SimulateET then
  begin
    if NewItemsNeeded then
    begin
      Assert(WaterContent <> '');
      WaterContentItem := Boundary.WaterContent.Add as TUzfWaterContentItem;
      WaterContentItem.UzfWaterContent := WaterContent;
      WaterContentItem.StartTime :=
        FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      WaterContentItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end
    else
    begin
      WaterContentItem.EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    end;
  end;
end;

procedure TUzfImporter.ReadData(const ALabel: string);
var
//  IUZFCB1: integer;
//  IUZFCB2: integer;
  Gage: TUzfGage;
  nuzf1: integer;
  nuzf2: integer;
  nuzf3: integer;
  nuzf4: integer;
  ID: string;
  Value: double;
  IntValue: integer;
begin
  inherited;
  if ALabel = 'NUZTOP IUZFOPT IRUNFLG IETFLG IUZFCB1 IUZFCB2 NTRAIL NSETS2 NUZGAG:' then
  begin
    Read(FImporter.FFile, NUZTOP);
    Read(FImporter.FFile, IUZFOPT);
    Read(FImporter.FFile, IRUNFLG);
    Read(FImporter.FFile, IETFLG);
    Read(FImporter.FFile, DummyInteger); // IUZFCB1
    Read(FImporter.FFile, DummyInteger); // IUZFCB2
    Read(FImporter.FFile, NTRAIL2);
    Read(FImporter.FFile, NSETS2);
    Read(FImporter.FFile, NUZGAG);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    FGages.ArrayLength := NUZGAG;
  end
  else if ALabel = 'NUZTOP IUZFOPT IRUNFLG IETFLG IUZFCB1 IUZFCB2 NUZGAG:'
     then
  begin
    Read(FImporter.FFile, NUZTOP);
    Read(FImporter.FFile, IUZFOPT);
    Read(FImporter.FFile, IRUNFLG);
    Read(FImporter.FFile, IETFLG);
    Read(FImporter.FFile, DummyInteger); // IUZFCB1
    Read(FImporter.FFile, DummyInteger); // IUZFCB2
    Read(FImporter.FFile, NUZGAG);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    FGages.ArrayLength := NUZGAG;
  end
  else if ALabel = 'SPECIFYTHTR:' then
  begin
    SPECIFYTHTR := True;
  end
  else if ALabel = 'SPECIFYTHTI:' then
  begin
    SPECIFYTHTI := True;
  end
  else if ALabel = 'NOSURFLEAK:' then
  begin
    NOSURFLEAK := True;
  end
  else if ALabel = 'SURFDEP:' then
  begin
    Read(FImporter.FFile, SURFDEP);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'ETSQUARE smoothfact:' then
  begin
    Read(FImporter.FFile, Fsmoothfact);
    FEtSquare := True;
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'SPECIFYSURFK:' then
  begin
    FSpecifySurfK := true;
  end
  else if ALabel = 'REJECTSURFK:' then
  begin
    FRejectSurfK := True;
  end
  else if ALabel = 'SEEPSURFK:' then
  begin
    FSeepSurfK := true;
  end
  else if ALabel = 'NETFLUX:' then
  begin
    FNetFlux := True;
  end
  else if ALabel = 'IUZROW IUZCOL IFTUNIT IUZOPT:' then
  begin
    Inc(FCurrentGage);
    Gage := FGages[FCurrentGage];
    Read(FImporter.FFile, Gage.IUZROW);
    Read(FImporter.FFile, Gage.IUZCOL);
    Read(FImporter.FFile, Gage.IFTUNIT);
    Read(FImporter.FFile, Gage.IUZOPT);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'IFTUNIT:' then
  begin
    Inc(FCurrentGage);
    Gage := FGages[FCurrentGage];
    Read(FImporter.FFile, Gage.IFTUNIT);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'nuzf1:' then
  begin
    Read(FImporter.FFile, nuzf1);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    Inc(FCurrentStressPeriod);
    if FCurrentStressPeriod = 0 then
    begin
      FStressPeriods.ArrayLength :=
        FModel.ModflowStressPeriods.Count;
      SetLength(FConstantInfiltration,
        FModel.ModflowStressPeriods.Count);
      SetLength(FVariableInfiltration,
        FModel.ModflowStressPeriods.Count);
      SetLength(FReuseInfiltration,
        FModel.ModflowStressPeriods.Count);
    end;
    FStressPeriods[FCurrentStressPeriod].Reuse := nuzf1 < 0;
    FReuseInfiltration[FCurrentStressPeriod] := nuzf1 < 0;
  end
  else if ALabel = 'nuzf2:' then
  begin
    Read(FImporter.FFile, nuzf2);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    if FCurrentStressPeriod = 0 then
    begin
      FEtStressPeriods.ArrayLength :=
        FModel.ModflowStressPeriods.Count;
      SetLength(FConstantET,
        FModel.ModflowStressPeriods.Count);
      SetLength(FVariableET,
        FModel.ModflowStressPeriods.Count);
      SetLength(FReuseET,
        FModel.ModflowStressPeriods.Count);
    end;
    FEtStressPeriods[FCurrentStressPeriod].Reuse := nuzf2 < 0;
    FReuseET[FCurrentStressPeriod] := nuzf2 < 0;
  end
  else if ALabel = 'nuzf3:' then
  begin
    Read(FImporter.FFile, nuzf3);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    if FCurrentStressPeriod = 0 then
    begin
      FEtExtinctDepthStressPeriods.ArrayLength :=
        FModel.ModflowStressPeriods.Count;
      SetLength(FConstantExtinctDepth,
        FModel.ModflowStressPeriods.Count);
      SetLength(FVariableExtinctDepth,
        FModel.ModflowStressPeriods.Count);
      SetLength(FReuseExtictionDepth,
        FModel.ModflowStressPeriods.Count);

    end;
    FEtExtinctDepthStressPeriods[FCurrentStressPeriod].Reuse := nuzf3 < 0;
    FReuseExtictionDepth[FCurrentStressPeriod] := nuzf3 < 0;
  end
  else if ALabel = 'nuzf4:' then
  begin
    Read(FImporter.FFile, nuzf4);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    if FCurrentStressPeriod = 0 then
    begin
      FEtExtinctWaterContentStressPeriods.ArrayLength :=
        FModel.ModflowStressPeriods.Count;
      SetLength(FConstantExtinctWaterContent,
        FModel.ModflowStressPeriods.Count);
      SetLength(FVariableExtinctWaterContent,
        FModel.ModflowStressPeriods.Count);
      SetLength(FReuseExtictionWaterContent,
        FModel.ModflowStressPeriods.Count);
    end;
    FEtExtinctWaterContentStressPeriods[FCurrentStressPeriod].
      Reuse := nuzf4 < 0;
    FReuseExtictionWaterContent[FCurrentStressPeriod] := nuzf4 < 0;
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    Readln(FImporter.FFile, Value);
    if ID = 'SATURATED VERTICAL K' then
    begin
      IsConstVks := True;
      ConstVks := Value;
    end
    else if ID = 'BROOKS-COREY EPSILON' then
    begin
      IsConstEps := True;
      ConstEps := Value;
    end
    else if ID = 'SATURATED WATER CONTENT' then
    begin
      IsConstThts := True;
      ConstThts := Value;
    end
    else if ID = 'INITIAL WATER CONTENT' then
    begin
      IsConstThti := True;
      ConstThti := Value;
    end
    else if ID = 'RESIDUAL WATER CONTENT' then
    begin
      IsConstThtr := True;
      ConstThtr := Value;
    end
    else if ID = 'LAND SURFACE VERTICAL K' then
    begin
      IsConstSeepK := True;
      ConstSeepKhtr := Value;
    end
    else if ID = 'AREAL INFILTRATION RATE' then
    begin
      ReadRealConstantArrayItem(Value, FConstantInfiltration);
    end
    else if ID = 'ET RATE' then
    begin
      ReadRealConstantArrayItem(Value, FConstantET);
    end
    else if ID = 'ET EXTINCTION DEPTH' then
    begin
      ReadRealConstantArrayItem(Value, FConstantExtinctDepth);
    end
    else if ID = 'EXTINCTION WATER CONTENT' then
    begin
      ReadRealConstantArrayItem(Value, FConstantExtinctWaterContent);
    end
    else
    begin
      Assert(False);
    end;
    FImporter.UpdateProgress;
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    if ID = 'SATURATED VERTICAL K' then
    begin
      IsConstVks := False;
      SetLength(VKS, FGrid.RowCount, FGrid.ColumnCount);
      Read2DRealArray(VKS, 'UZF Saturated vertical hydraulic conductivity');
    end
    else if ID = 'BROOKS-COREY EPSILON' then
    begin
      IsConstEps := False;
      SetLength(EPS, FGrid.RowCount, FGrid.ColumnCount);
      Read2DRealArray(EPS, 'UZF Brooks-Correy Epsilon');
    end
    else if ID = 'SATURATED WATER CONTENT' then
    begin
      IsConstThts := False;
      SetLength(THTS, FGrid.RowCount, FGrid.ColumnCount);
      Read2DRealArray(THTS, 'UZF aturated water content');
    end
    else if ID = 'INITIAL WATER CONTENT' then
    begin
      IsConstThti := False;
      SetLength(THTI, FGrid.RowCount, FGrid.ColumnCount);
      Read2DRealArray(THTI, 'UZF Initial water content');
    end
    else if ID = 'RESIDUAL WATER CONTENT' then
    begin
      IsConstThtr := False;
      SetLength(THTR, FGrid.RowCount, FGrid.ColumnCount);
      Read2DRealArray(THTR, 'UZF Residual water content');
    end
    else if ID = 'LAND SURFACE VERTICAL K' then
    begin
      IsConstSeepK := False;
      SetLength(SeepK, FGrid.RowCount, FGrid.ColumnCount);
      Read2DRealArray(SeepK , 'UZF LAND SURFACE VERTICAL K');
    end
    else if ID = 'AREAL INFILTRATION RATE' then
    begin
      ReadRealVariableArray(FVariableInfiltration, 'UZF Infiltration Rate')
    end
    else if ID = 'ET RATE' then
    begin
      ReadRealVariableArray(FVariableET, 'UZF ET Rate')
    end
    else if ID = 'ET EXTINCTION DEPTH' then
    begin
      ReadRealVariableArray(FVariableExtinctDepth, 'UZF Extinction Depth')
    end
    else if ID = 'EXTINCTION WATER CONTENT' then
    begin
      ReadRealVariableArray(FVariableExtinctWaterContent, 'UZF Extinction Water Content')
    end
    else
    begin
      Assert(False);
    end;
  end
  else if ALabel = StrConstant2DIntegerArray then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    Readln(FImporter.FFile, IntValue);
    if ID = 'AREAL EXTENT OF UZ FLOW' then
    begin
      IsConstIUZFBND := True;
      ConstIUZFBND := IntValue;
    end
    else if ID = 'ROUTING OVERLAND RUNOFF' then
    begin
      IsConstIRUNBND := True;
      ConstIRUNBND := IntValue;
    end
    else
    begin
      Assert(False);
    end;
    FImporter.UpdateProgress;
  end
  else if ALabel = StrVariable2DIntegerArray then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    if ID = 'AREAL EXTENT OF UZ FLOW' then
    begin
      IsConstIUZFBND := False;
      SetLength(IUZFBND, FGrid.RowCount, FGrid.ColumnCount);
      ReadVariable2DIntArray(IUZFBND);
    end
    else if ID = 'ROUTING OVERLAND RUNOFF' then
    begin
      IsConstIRUNBND := False;
      SetLength(IRUNBND, FGrid.RowCount, FGrid.ColumnCount);
      ReadVariable2DIntArray(IRUNBND);
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    Assert(False, 'Unrecognized label: ' + ALabel);
  end;
end;

{ TUzfGageArray }

function TUzfGageArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TUzfGage;
end;

function TUzfGageArray.GetGage(Index: integer): TUzfGage;
begin
  result := Objects[Index] as TUzfGage;
end;

{ TSolverImporter }

procedure TSolverImporter.DeselectAllSolvers;
begin
  FModel.ModflowPackages.PcgPackage.IsSelected := False;
  FModel.ModflowPackages.GmgPackage.IsSelected := False;
  FModel.ModflowPackages.SipPackage.IsSelected := False;
  FModel.ModflowPackages.De4Package.IsSelected := False;
  FModel.ModflowPackages.PcgnPackage.IsSelected := False;
  FModel.ModflowPackages.NwtPackage.IsSelected := False;
end;

procedure TSolverImporter.HandlePackage;
begin
  inherited;
  DeselectAllSolvers;
end;

{ TGageImporter }

constructor TGageImporter.Create(Importer: TModflow2005Importer;
  LakImporter: TLakImporter; SfrImporter: TSfrImporter);
begin
  inherited Create(Importer, 'GAG');
  FGages := TGageArray.Create;
  FCurrentGage := -1;
  FLakImporter := LakImporter;
  FSfrImporter := SfrImporter;
end;

destructor TGageImporter.Destroy;
begin
  FGages.Free;
  inherited;
end;

procedure TGageImporter.HandlePackage;
var
  GageIndex: Integer;
  Gage: TGage;
  ScreenObjectIndex: Integer;
  ScreenObject: TScreenObject;
  Lake: TLakBoundary;
  ReachIndex: Integer;
  Reach: TSfrLocationObject;
  Layer: Integer;
  Point3D: T3DRealPoint;
  Point2D: TPoint2D;
  SfrGageNumber: Integer;
  SfrGage: TStreamGage;
begin
  if FImportedPackage then
  begin
    Exit;
  end;
  if (FModel.ModflowPackages.SfrPackage.IsSelected
    or (FSfrImporter.FReaches.ArrayLength > 0))
    and not FSfrImporter.FImportedPackage then
  begin
    Exit;
  end;
  if (FModel.ModflowPackages.LakPackage.IsSelected
    or (FLakImporter.FLakeStressPeriodValues.ArrayLength > 0))
    and not FLakImporter.FImportedPackage then
  begin
    Exit;
  end;
  inherited HandlePackage;
  SfrGageNumber := 0;
  for GageIndex := 0 to FGages.ArrayLength - 1 do
  begin
    Gage := FGages[GageIndex];
    case Gage.GageType of
      gtLake:
        begin
          for ScreenObjectIndex := 0 to FModel.ScreenObjectCount - 1 do
          begin
            ScreenObject := FModel.ScreenObjects[ScreenObjectIndex];
            Lake := ScreenObject.ModflowLakBoundary;
            if (Lake <> nil) and (Gage.LakeNumber = Lake.LakeID) then
            begin
              case Gage.OUTTYPE of
                0:
                  begin
                    Lake.StandardGage := True;
                  end;
                1:
                  begin
                    Lake.FluxCondGage := True;
                  end;
                2:
                  begin
                    Lake.DeltaGage := True;
                  end;
                3:
                  begin
                    Lake.StandardGage := True;
                    Lake.FluxCondGage := True;
                    Lake.DeltaGage := True;
                  end;
                4:
                  begin
                    Lake.Gage4 := True;
                  end;
                else Assert(False);
              end;
              break;
            end;
          end;
        end;
      gtStream:
        begin
          for ReachIndex := 0 to FSfrImporter.FReaches.ArrayLength - 1 do
          begin
            Reach := FSfrImporter.FReaches[ReachIndex];
            if (Gage.GAGESEG = Reach.SegmentNumber)
              and (Gage.GAGERCH = Reach.ReachNumber) then
            begin
              Layer := FModel.ModflowLayerToDataSetLayer(
                Reach.Layer);
              Point3D := FGrid.ThreeDElementCenter(ZeroBasedID(
                Layer, Reach.Row-1, Reach.Column-1));
              Point2D := FGrid.TwoDElementCenter(Reach.Column-1, Reach.Row-1);
              Inc(SfrGageNumber);
              ScreenObject := CreateScreenObject('Imported_SFR_Gage_'
                + IntToStr(SfrGageNumber));
              ScreenObject.AddPoint(Point2D, True);
              ScreenObject.SetValuesOfEnclosedCells := False;
              ScreenObject.SetValuesOfIntersectedCells := True;

              ScreenObject.ElevationFormula := FortranFloatToStr(Point3D.Z);
              ScreenObject.CreateGagBoundary;
              ScreenObject.ModflowStreamGage;
              SfrGage := ScreenObject.ModflowStreamGage;
              case Gage.OUTTYPE of
                0:
                  begin
                    SfrGage.Gage0 := True;
                  end;
                1:
                  begin
                    SfrGage.Gage1 := True;
                  end;
                2:
                  begin
                    SfrGage.Gage2 := True;
                  end;
                3:
                  begin
                    SfrGage.Gage3 := True;
                  end;
                4:
                  begin
                    SfrGage.Gage0 := True;
                    SfrGage.Gage1 := True;
                    SfrGage.Gage2 := True;
                    SfrGage.Gage3 := True;
                  end;
                5:
                  begin
                    SfrGage.Gage5 := True;
                  end;
                6:
                  begin
                    SfrGage.Gage6 := True;
                  end;
                7:
                  begin
                    SfrGage.Gage7 := True;
                  end;
                8:
                  begin
                    FModel.ModflowPackages.SfrPackage.GageOverallBudget := True;
                  end;
              end;
              break;
            end;
          end;
        end;
      else Assert(False);
    end;
  end;
end;

procedure TGageImporter.ReadData(const ALabel: string);
var
  NUMGAGE: integer;
//  UNIT_Number: integer;
  LAKE: integer;
  Gage: TGage;
begin
  inherited;
  if ALabel = 'NUMGAGE:' then
  begin
    Read(FImporter.FFile, NUMGAGE);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    FGages.ArrayLength := NUMGAGE
  end
  else if ALabel = 'GAGESEG GAGERCH UNIT OUTTYPE:' then
  begin
    Inc(FCurrentGage);
    Gage := FGages[FCurrentGage];
    Gage.GageType := gtStream;
    Read(FImporter.FFile, Gage.GAGESEG);
    Read(FImporter.FFile, Gage.GAGERCH);
    Read(FImporter.FFile, DummyInteger); // UNIT_Number
    Read(FImporter.FFile, Gage.OUTTYPE);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'LAKE UNIT OUTTYPE:' then
  begin
    Inc(FCurrentGage);
    Gage := FGages[FCurrentGage];
    Gage.GageType := gtLake;
    Read(FImporter.FFile, LAKE);
    Gage.LakeNumber := Abs(LAKE);
    Read(FImporter.FFile, DummyInteger); // UNIT_Number
    Read(FImporter.FFile, Gage.OUTTYPE);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TGageArray }

function TGageArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TGage;
end;

function TGageArray.GetGage(Index: integer): TGage;
begin
  result := Objects[Index] as TGage;
end;

function TPackageImporter.CreateScreenObject(const Name: string): TScreenObject;
var
  UndoCreateScreenObject: TCustomUndo;
begin
  result := TScreenObject.CreateWithViewDirection(FModel, vdTop,
    UndoCreateScreenObject, False);
  result.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);
  FModel.AddScreenObject(result);
  result.Name := Name;
  result.ElevationCount := ecOne;
  result.SetValuesOfEnclosedCells := True;
  result.EvaluatedAt := eaBlocks;
  result.Visible := False;
end;

{ THufImporter }

constructor THufImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'HUF2:');
  FNextHufIndexIndex := -1;
  FNextParameterIndex := -1;
  FIsSelected := False;
  FReadLthuf := False;
  FReadKdep := True;
  FReadLvda := True;
end;

procedure THufImporter.CreateParameters(
  HydrogeologicUnits: THydrogeologicUnits);
var
  UsedParam: THufUsedParameter;
  ClusterIndex: Integer;
  Clusters: TClusterRecordArray;
  SteadyParam: TModflowSteadyParameter;
  Param: THufParameter;
  ParamIndex: Integer;
  ModflowSteadyParameters: TModflowSteadyParameters;
  HufParameters: THufModflowParameters;
  HGU: THydrogeologicUnit;
begin
  HufParameters := THufModflowParameters.Create(nil);
  ModflowSteadyParameters := TModflowSteadyParameters.Create(nil);
  try
    HufParameters.Assign(FModel.HufParameters);
    ModflowSteadyParameters.Assign(FModel.ModflowSteadyParameters);
    for ParamIndex := 0 to Length(FParameters) - 1 do
    begin
      Param := nil;
      SteadyParam := nil;
      if SameText(FParameters[ParamIndex].PARTYP, 'HK') then
      begin
        Param := HufParameters.Add as THufParameter;
        Param.ParameterType := ptHUF_HK;
      end
      else if SameText(FParameters[ParamIndex].PARTYP, 'HANI') then
      begin
        Param := HufParameters.Add as THufParameter;
        Param.ParameterType := ptHUF_HANI;
      end
      else if SameText(FParameters[ParamIndex].PARTYP, 'VK') then
      begin
        Param := HufParameters.Add as THufParameter;
        Param.ParameterType := ptHUF_VK;
      end
      else if SameText(FParameters[ParamIndex].PARTYP, 'VANI') then
      begin
        Param := HufParameters.Add as THufParameter;
        Param.ParameterType := ptHUF_VANI;
      end
      else if SameText(FParameters[ParamIndex].PARTYP, 'SS') then
      begin
        Param := HufParameters.Add as THufParameter;
        Param.ParameterType := ptHUF_SS;
      end
      else if SameText(FParameters[ParamIndex].PARTYP, 'SY') then
      begin
        Param := HufParameters.Add as THufParameter;
        Param.ParameterType := ptHUF_SY;
      end
      else if SameText(FParameters[ParamIndex].PARTYP, 'SYTP') then
      begin
        SteadyParam := ModflowSteadyParameters.Add as TModflowSteadyParameter;
        SteadyParam.ParameterType := ptHUF_SYTP;
      end
      else
      begin
        Assert(False);
      end;
      Clusters := FParameters[ParamIndex].Instances[0].Clusters;
      if Param <> nil then
      begin
        Param.ParameterName := FParameters[ParamIndex].PARNAM;
        Param.Value := FParameters[ParamIndex].Parval;
        for ClusterIndex := 0 to Length(Clusters) - 1 do
        begin
          HGU := HydrogeologicUnits[Clusters[ClusterIndex].Layer - 1];
          UsedParam := HGU.HufUsedParameters.Add as THufUsedParameter;
          UsedParam.ParameterName := Param.ParameterName;
          UsedParam.UseMultiplier :=
            not SameText(Clusters[ClusterIndex].MultiplierName, 'NONE');
          UsedParam.UseZone :=
            not SameText(Clusters[ClusterIndex].ZoneName, 'ALL');
        end;
      end
      else
      begin
        Assert(SteadyParam <> nil);
        SteadyParam.ParameterName := FParameters[ParamIndex].PARNAM;
        SteadyParam.Value := FParameters[ParamIndex].Parval;
        SteadyParam.UseMultiplier := False;
        SteadyParam.UseZone := False;
        for ClusterIndex := 0 to Length(Clusters) - 1 do
        begin
          if not SameText(Clusters[ClusterIndex].MultiplierName, 'NONE') then
          begin
            SteadyParam.UseMultiplier := True;
          end;
          if SameText(Clusters[ClusterIndex].MultiplierName, 'ALL') then
          begin
            SteadyParam.UseZone := True;
          end;
        end;
      end;
    end;
    FModel.HufParameters := HufParameters;
    FModel.ModflowSteadyParameters := ModflowSteadyParameters;
  finally
    HufParameters.Free;
    ModflowSteadyParameters.Free;
  end;
end;

procedure THufImporter.AssignSteadyParametersZoneAndMultiplier;
var
  ZoneFunctionList: TStringList;
  ParamIndex: Integer;
  MultFunction: string;
  ZoneIndex: Integer;
  ZoneFunction: string;
  LayerIndex: Integer;
  MultFunctionList: TStringList;
  ZoneDataArray: TDataArray;
  MultDataArray: TDataArray;
  SteadyParam: TModflowSteadyParameter;
  Cluster: TClusterRecord;
  ClusterIndex: Integer;
  PIndex: Integer;
  Clusters: TClusterRecordArray;
begin
  for ParamIndex := 0 to FModel.ModflowSteadyParameters.Count - 1 do
  begin
    SteadyParam := FModel.ModflowSteadyParameters[ParamIndex];
    if SteadyParam.ParameterType = ptHUF_SYTP then
    begin
      MultDataArray := nil;
      if SteadyParam.UseMultiplier then
      begin
        MultDataArray := FModel.DataArrayManager.GetDataSetByName(SteadyParam.MultiplierName);
      end;
      ZoneDataArray := nil;
      if SteadyParam.UseZone then
      begin
        ZoneDataArray := FModel.DataArrayManager.GetDataSetByName(SteadyParam.ZoneName);
      end;
      if (MultDataArray = nil) and (ZoneDataArray = nil) then
      begin
        Continue;
      end;
      MultFunctionList := TStringList.Create;
      ZoneFunctionList := TStringList.Create;
      try
        MultFunctionList.Add('0');
        ZoneFunctionList.Add('False');
        Clusters := nil;
        for PIndex := 0 to Length(FParameters) - 1 do
        begin
          if SameText(FParameters[PIndex].PARNAM,
            SteadyParam.ParameterName) then
          begin
            Clusters := FParameters[PIndex].Instances[0].Clusters;
            break;
          end;
        end;
        for ClusterIndex := 0 to Length(Clusters) - 1 do
        begin
          Cluster := Clusters[ClusterIndex];
          LayerIndex := 0;
          if SameText(Cluster.MultiplierName, StrNone) then
          begin
            MultFunctionList[LayerIndex] := '1';
          end
          else
          begin
            MultFunctionList[LayerIndex] := Cluster.MultiplierName;
          end;
          if SameText(Cluster.ZoneName, StrAll) then
          begin
            ZoneFunctionList[LayerIndex] := 'True';
          end
          else
          begin
            ZoneFunction := '';
            for ZoneIndex := 0 to Length(Cluster.ZoneValues) - 1 do
            begin
              ZoneFunction := ZoneFunction + '(' + Cluster.ZoneName
                + ' = ' + IntToStr(Cluster.ZoneValues[ZoneIndex]) + ')';
              if ZoneIndex < Length(Cluster.ZoneValues) - 1 then
              begin
                ZoneFunction := ZoneFunction + ' or ';
              end;
            end;
            ZoneFunctionList[LayerIndex] := ZoneFunction;
          end;
        end;
        if MultDataArray <> nil then
        begin
          Assert(MultFunctionList.Count = 1);
          MultFunction := MultFunctionList[0];
          MultDataArray.Formula := MultFunction;
        end;
        if ZoneDataArray <> nil then
        begin
          Assert(ZoneFunctionList.Count = 1);
          ZoneFunction := ZoneFunctionList[0];
          ZoneDataArray.Formula := ZoneFunction;
        end;
      finally
        MultFunctionList.Free;
        ZoneFunctionList.Free;
      end;
    end;
  end;
end;

procedure THufImporter.HandlePackage;
begin
  if FReadLthuf and FReadKdep and FReadLvda then
  begin
    inherited;
    HufPackage := FModel.ModflowPackages.HufPackage;
    HufPackage.IsSelected := FIsSelected;
    if FIsSelected then
    begin
      FModel.ModflowPackages.LpfPackage.IsSelected := False;
      FModel.ModflowPackages.BcfPackage.IsSelected := False;
      FModel.ModflowPackages.UpwPackage.IsSelected := False;
      HufPackage.Comments := FComments;
      ImportDataSet1;
      ImportDataSet2;
      ImportDataSet3;
      ImportDataSet4;
      ImportWetDry;
      ImportHydrogeologicUnits;
      AssignHufParametersZoneAndMultiplier;
      AssignSteadyParametersZoneAndMultiplier;
      ImportGeometry;
      frmGoPhast.EnableHufMenuItems;
      if (FKdepImporter <> nil) and not FKdepImporter.ImportedPackage then
      begin
        FKdepImporter.HandlePackage;
      end;
      if (FLvdaImporter <> nil) and not FLvdaImporter.ImportedPackage then
      begin
        FLvdaImporter.HandlePackage;
      end;
    end;
    ReleaseMemory;
  end;
end;

procedure THufImporter.ImportDataSet2;
var
  LayerGroup: TLayerGroup;
  Index: Integer;
  LayerIndex: Integer;
begin
  // Data set 2.
  LayerIndex := -1;
  for Index := 1 to FModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FModel.LayerStructure.LayerGroups[Index];
    if LayerGroup.RunTimeSimulated then
    begin
      Inc(LayerIndex);
    end;
    if LayerIndex >= 0 then
    begin
      if LTHUF[LayerIndex] <> 0 then
      begin
        LayerGroup.AquiferType := 1;
      end
      else if LTHUF[LayerIndex] = 0 then
      begin
        LayerGroup.AquiferType := 0;
      end
      else
      begin
        Assert(False);
      end;
    end;
  end;
  FModel.DataArrayManager.CreateInitialDataSets;
end;

procedure THufImporter.ImportDataSet3;
var
  LayerGroup: TLayerGroup;
  Index: Integer;
  LayerIndex: Integer;
begin
  // Data set 3.
  LayerIndex := -1;
  for Index := 1 to FModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FModel.LayerStructure.LayerGroups[Index];
    if LayerGroup.RunTimeSimulated then
    begin
      Inc(LayerIndex);
      if LAYWT[LayerIndex] <> 0 then
      begin
        FModel.ModflowWettingOptions.WettingActive := True;
        break;
      end;
    end;
  end;
end;

procedure THufImporter.ImportDataSet4;
begin
  if FWetDryConst <> nil then
  begin
    FModel.ModflowWettingOptions.WettingActive := True;
    FModel.DataArrayManager.CreateInitialDataSets;
  end;
  if FModel.ModflowWettingOptions.WettingActive then
  begin
    FModel.ModflowWettingOptions.WettingFactor := WETFCT;
    FModel.ModflowWettingOptions.WettingIterations := IWETIT;
    FModel.ModflowWettingOptions.WettingEquation := IHDWET;
  end;
end;

procedure THufImporter.ImportGeometry;
var
  HufIndex: Integer;
  HGU: THydrogeologicUnit;
  TopArray: TDataArray;
  ScreenObject: TScreenObject;
  ThicknessArray: TDataArray;
  Interpolator: TNearestPoint2DInterpolator;

begin
  ScreenObject := nil;
  for HufIndex := 0 to FModel.HydrogeologicUnits.Count - 1 do
  begin
    HGU := FModel.HydrogeologicUnits[HufIndex];
    TopArray := FModel.DataArrayManager.GetDataSetByName(HGU.TopDataArrayName);
    Assert(TopArray <> nil);
    if (FConstantTopElevations <> nil)
      and FConstantTopElevations[HufIndex].IsConstant then
    begin
      TopArray.Formula :=
        FortranFloatToStr(FConstantTopElevations[HufIndex].RealValue);
    end
    else
    begin
      if ScreenObject = nil then
      begin
        CreateOrRetrieveCellCenterScreenObject(ScreenObject);
      end;
      Interpolator := TNearestPoint2DInterpolator.Create(nil);
      try
        TopArray.TwoDInterpolator := Interpolator;
      finally
        Interpolator.Free;
      end;
      AssignRealValuesToCellCenters(TopArray,
        ScreenObject, Top[HufIndex]);
    end;

    ThicknessArray := FModel.DataArrayManager.GetDataSetByName(HGU.ThickessDataArrayName);
    Assert(ThicknessArray <> nil);
    if (FConstantThicknesses <> nil)
      and FConstantThicknesses[HufIndex].IsConstant then
    begin
      ThicknessArray.Formula :=
        FortranFloatToStr(FConstantThicknesses[HufIndex].RealValue);
    end
    else
    begin
      if ScreenObject = nil then
      begin
        CreateOrRetrieveCellCenterScreenObject(ScreenObject);
      end;
      Interpolator := TNearestPoint2DInterpolator.Create(nil);
      try
        ThicknessArray.TwoDInterpolator := Interpolator;
      finally
        Interpolator.Free;
      end;
      AssignRealValuesToCellCenters(ThicknessArray,
        ScreenObject, Thickness[HufIndex]);
    end;
  end;
end;

procedure THufImporter.ImportHydrogeologicUnits;
var
  HufIndex: Integer;
  HGU: THydrogeologicUnit;
  HydrogeologicUnits: THydrogeologicUnits;
begin
  HydrogeologicUnits:= THydrogeologicUnits.Create(nil);
  try
    for HufIndex := 0 to NHUF - 1 do
    begin
      HGU := HydrogeologicUnits.Add as THydrogeologicUnit;
      HGU.HufName := FHydrogeologicUnits[HufIndex].HUFNAME;
      HGU.HorizontalAnisotropy := FHydrogeologicUnits[HufIndex].HGUHANI;
      HGU.VerticalAnisotropy := FHydrogeologicUnits[HufIndex].HGUVANI;
      if HGU.VerticalAnisotropy = 0 then
      begin
        HGU.VK_Method := vkVK;
      end
      else
      begin
        HGU.VK_Method := vkVANI;
      end;
      if FHydrogeologicUnits[HufIndex].PrintCode <> 0 then
      begin
        HGU.PrintFormat := FHydrogeologicUnits[HufIndex].PrintCode;
        HGU.Print[pprHK] := FHydrogeologicUnits[HufIndex].PrintHK <> 0;
        HGU.Print[pprHANI] := FHydrogeologicUnits[HufIndex].PrintHANI <> 0;
        HGU.Print[pprVK] := FHydrogeologicUnits[HufIndex].PrintVK <> 0;
        HGU.Print[pprSS] := FHydrogeologicUnits[HufIndex].PrintSS <> 0;
        HGU.Print[pprSY] := FHydrogeologicUnits[HufIndex].PrintSY <> 0;
      end;
    end;
    CreateParameters(HydrogeologicUnits);
    FModel.HydrogeologicUnits := HydrogeologicUnits;
  finally
    HydrogeologicUnits.Free;
  end;
end;

procedure THufImporter.ImportWetDry;
begin
  ImportDataSet('WetDry', rsWetDry, FWetDryConst, FWetDry);
end;

procedure THufImporter.ImportDataSet1;
begin
  FModel.ModflowOptions.HDry := HDRY;
  HufPackage.SaveHeads := IOHUFHDS > 0;
  HufPackage.SaveFlows := IOHUFFLWS > 0;
end;

procedure THufImporter.ReadData(const ALabel: string);
var
  AnInt: integer;
begin
  inherited;
  if ALabel = 'IHUFCB, HDRY, NHUF, NPHUF, IOHUFHDS, IOHUFFLWS:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'NP:' then
  begin
    Readln(FImporter.FFile, AnInt);
    FImporter.UpdateProgress;
    Assert(AnInt = NPHUF);
  end
  else if ALabel = '(LTHUF(K),K=1,NLAY):' then
  begin
    ReadDataSet2;
  end
  else if ALabel = '(LAYWT(K),K=1,NLAY):' then
  begin
    ReadDataSet3;
  end
  else if ALabel = 'WETFCT,IWETIT,IHDWET:' then
  begin
    ReadDataSet4;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableWetDry;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstantWetDry;
  end
  else if ALabel = 'HGUNAM(M):' then
  begin
    ReadDataSet6;
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    ReadVariableHguGeometry
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadConstantHguGeometry;
  end
  else if ALabel = 'HUF ITEM 9:' then
  begin
    ReadDataSet9;
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadArrayParameter;
  end
  else if ALabel = 'HUF ITEM 12:' then
  begin
    ReadDataSet12;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure THufImporter.ReadDataSet12;
var
  HufIndex: Integer;
  ALine: string;
  HGUNAM: string;
begin
  for HufIndex := 0 to NHUF - 1 do
  begin
    ReadLn(FImporter.FFile, ALine);
    Assert(Trim(ALine) = 'HGUNAM(NU):');
    ReadLn(FImporter.FFile, ALine);
    HGUNAM := Trim(ALine);
    Assert(SameText(FHydrogeologicUnits[HufIndex].HUFNAME, HGUNAM));
    ReadLn(FImporter.FFile, ALine);
    Assert(Trim(ALine) = '(IHGUFLG(I,NU),I=1,5):');
    Readln(FImporter.FFile,
      FHydrogeologicUnits[HufIndex].PrintHK,
      FHydrogeologicUnits[HufIndex].PrintHANI,
      FHydrogeologicUnits[HufIndex].PrintVK,
      FHydrogeologicUnits[HufIndex].PrintSS,
      FHydrogeologicUnits[HufIndex].PrintSY);
    if FHydrogeologicUnits[HufIndex].PrintHK <> 0 then
    begin
      FHydrogeologicUnits[HufIndex].PrintCode :=
        FHydrogeologicUnits[HufIndex].PrintHK;
    end
    else if FHydrogeologicUnits[HufIndex].PrintHANI <> 0 then
    begin
      FHydrogeologicUnits[HufIndex].PrintCode :=
        FHydrogeologicUnits[HufIndex].PrintHANI;
    end
    else if FHydrogeologicUnits[HufIndex].PrintVK <> 0 then
    begin
      FHydrogeologicUnits[HufIndex].PrintCode :=
        FHydrogeologicUnits[HufIndex].PrintVK;
    end
    else if FHydrogeologicUnits[HufIndex].PrintSS <> 0 then
    begin
      FHydrogeologicUnits[HufIndex].PrintCode :=
        FHydrogeologicUnits[HufIndex].PrintSS;
    end
    else if FHydrogeologicUnits[HufIndex].PrintSY <> 0 then
    begin
      FHydrogeologicUnits[HufIndex].PrintCode :=
        FHydrogeologicUnits[HufIndex].PrintSY;
    end;
  end;
  FImporter.UpdateProgress;
end;

procedure THufImporter.ReadDataSet9;
var
  HufIndex: Integer;
  ALine: string;
  HGUNAM: string;
  HGUHANI: double;
  HGUVANI: double;
  InnerHufIndex: Integer;
begin
  for HufIndex := 0 to NHUF - 1 do
  begin
    ReadLn(FImporter.FFile, ALine);
    Assert(Trim(ALine) = 'HGUNAM:');
    ReadLn(FImporter.FFile, ALine);
    HGUNAM := Trim(ALine);
    Assert(SameText(FHydrogeologicUnits[HufIndex].HUFNAME, HGUNAM)
      or SameText('ALL', HGUNAM));
    ReadLn(FImporter.FFile, ALine);
    Assert(Trim(ALine) = 'HGUHANI, HGUVANI:');
    Readln(FImporter.FFile, HGUHANI, HGUVANI);
    if SameText('ALL', HGUNAM) then
    begin
      for InnerHufIndex := 0 to NHUF - 1 do
      begin
        FHydrogeologicUnits[InnerHufIndex].HGUHANI := HGUHANI;
        FHydrogeologicUnits[InnerHufIndex].HGUVANI := HGUVANI;
      end;
      break;
    end;
    FHydrogeologicUnits[HufIndex].HGUHANI := HGUHANI;
    FHydrogeologicUnits[HufIndex].HGUVANI := HGUVANI;
  end;
  FImporter.UpdateProgress;
end;

function THufImporter.ReadInstance: boolean;
begin
  result := False;
end;

procedure THufImporter.ReadConstantHguGeometry;
var
  Index: Integer;
  Value: Double;
  ALine: string;
begin
  Assert(FNextHufIndexIndex >= 0);
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  Readln(FImporter.FFile, Value);
  if Pos(StrTOPELEVATN, ALine) = 1 then
  begin
    if FConstantTopElevations = nil then
    begin
      SetLength(FConstantTopElevations, NHUF);
      for Index := 0 to NHUF - 1 do
      begin
        FConstantTopElevations[Index].IsConstant := False;
      end;
    end;
    FConstantTopElevations[FNextHufIndexIndex-1].IsConstant := True;
    FConstantTopElevations[FNextHufIndexIndex-1].RealValue := Value;
  end
  else if Pos(StrTHICKNESS, ALine) = 1 then
  begin
    if FConstantThicknesses = nil then
    begin
      SetLength(FConstantThicknesses, NHUF);
      for Index := 0 to NHUF - 1 do
      begin
        FConstantThicknesses[Index].IsConstant := False;
      end;
    end;
    FConstantThicknesses[FNextHufIndexIndex-1].IsConstant := True;
    FConstantThicknesses[FNextHufIndexIndex-1].RealValue := Value;
  end
  else
  begin
    Assert(False);
  end;
  FImporter.UpdateProgress;
end;

procedure THufImporter.ReadVariableHguGeometry;
var
  HUFNAME: string;
  ID: string;
begin
  Assert(FNextHufIndexIndex >= 0);
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  if Pos(StrTOPELEVATN, ID) = 1 then
  begin
    HUFNAME := Trim(Copy(ID, Length(StrTOPELEVATN) + 1, MAXINT));
    Assert(HUFNAME = FHydrogeologicUnits[FNextHufIndexIndex-1].HUFNAME);
    IsConstTopHuf := False;
    if Top = nil then
    begin
      SetLength(Top, NHUF);
    end;
    SetLength(TOP[FNextHufIndexIndex-1], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(TOP[FNextHufIndexIndex-1], 'Top elevation for HUF unit HUFNAME');
  end
  else if Pos(StrTHICKNESS, ID) = 1 then
  begin
    HUFNAME := Trim(Copy(ID, Length(StrTHICKNESS) + 1, MAXINT));
    Assert(HUFNAME = FHydrogeologicUnits[FNextHufIndexIndex-1].HUFNAME);
    IsConstThicknessHuf := False;
    if Thickness = nil then
    begin
      SetLength(Thickness, NHUF);
    end;
    SetLength(Thickness[FNextHufIndexIndex-1],
      FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(Thickness[FNextHufIndexIndex-1], 'Thickness for HUF unit HUFNAME');
  end
  else
  begin
    Assert(False);
  end;
end;

procedure THufImporter.ReadDataSet6;
var
  HUFNAME: string;
begin
  Readln(FImporter.FFile, HUFNAME);
  FImporter.UpdateProgress;
  FHydrogeologicUnits[FNextHufIndexIndex].HUFNAME := Trim(HUFNAME);
  Inc(FNextHufIndexIndex);
end;

procedure THufImporter.ReadConstantWetDry;
var
  Value: Double;
  Layer: Integer;
  ID: string;
  ConstArray: TRealConstantRecordArray;
  Index: Integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Readln(FImporter.FFile, Value);
  Dec(Layer);
  if ID = StrWetDry then
  begin
    if FWetDryConst = nil then
    begin
      SetLength(FWetDryConst, FModel.ModflowLayerCount);
      InitializeConstArray(FWetDryConst);
      for Index := 0 to Length(FWetDryConst) - 1 do
      begin
        FWetDryConst[Index].IsConstant := True;
      end;
    end;
    ConstArray := FWetDryConst;
  end
  else
  begin
    Assert(False);
  end;
  ConstArray[Layer].IsConstant := True;
  ConstArray[Layer].RealValue := Value;
  FImporter.UpdateProgress;
end;

procedure THufImporter.ReadVariableWetDry;
var
  ThreeDArray: T3DDoubleArray;
  Layer: Integer;
  ID: string;
  Index: Integer;
begin
  //    ReadDataSets10to16Variable;
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  if ID = StrWetDry then
  begin
    if FWetDryConst = nil then
    begin
      SetLength(FWetDryConst, FModel.ModflowLayerCount);
      InitializeConstArray(FWetDryConst);
      for Index := 0 to Length(FWetDryConst) - 1 do
      begin
        FWetDryConst[Index].IsConstant := True;
      end;
    end;
    if FWetDry = nil then
    begin
      SetLength(FWetDry, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FWetDry;
  end
  else
  begin
    Assert(False);
  end;
  if ThreeDArray[Layer] = nil then
  begin
    SetLength(ThreeDArray[Layer], FGrid.RowCount, FGrid.ColumnCount);
  end;
  Read2DRealArray(ThreeDArray[Layer], Format('WetDry for layer %d', [Layer+1]) );
  FWetDryConst[Layer].IsConstant := False;
  FImporter.UpdateProgress;
end;

procedure THufImporter.ReleaseMemory;
begin
  SetLength(FHydrogeologicUnits, 0);
  SetLength(LTHUF, 0);
  SetLength(LAYWT, 0);
  SetLength(Top, 0, 0 , 0);
  SetLength(Thickness, 0, 0 , 0);
  SetLength(FWetDry, 0, 0 , 0);
  SetLength(FConstantTopElevations, 0);
  SetLength(FConstantThicknesses, 0);
  SetLength(FWetDryConst, 0);
end;

function THufImporter.ScreenObjectNameRoot: string;
begin
  result := '';
  Assert(False);
end;

procedure THufImporter.ReadDataSet4;
begin
  Read(FImporter.FFile, WETFCT);
  Read(FImporter.FFile, IWETIT);
  Read(FImporter.FFile, IHDWET);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure THufImporter.ReadDataSet3;
var
  Index: Integer;
  NLAY: Integer;
begin
  NLAY := FModel.ModflowLayerCount;
  SetLength(LAYWT, NLAY);
  for Index := 0 to NLAY - 1 do
  begin
    Read(FImporter.FFile, LAYWT[Index]);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure THufImporter.ReadDataSet2;
var
  Index: Integer;
  NLAY: Integer;
begin
  NLAY := FModel.ModflowLayerCount;
  SetLength(LTHUF, NLAY);
  for Index := 0 to NLAY - 1 do
  begin
    Read(FImporter.FFile, LTHUF[Index]);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FReadLthuf := True;
end;

procedure THufImporter.ReadDataSet1;
//var
//  IHUFCB: integer;
begin
  FIsSelected := True;
  Read(FImporter.FFile, DummyInteger); // IHUFCB
  Read(FImporter.FFile, HDRY);
  Read(FImporter.FFile, NHUF);
  Read(FImporter.FFile, NPHUF);
  Read(FImporter.FFile, IOHUFHDS);
  Read(FImporter.FFile, IOHUFFLWS);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(FParameters, NPHUF);
  FNextParameterIndex := 0;
  SetLength(FHydrogeologicUnits, NHUF);
  FNextHufIndexIndex := 0;
end;

{ TKdepImporter }

constructor TKdepImporter.Create(Importer: TModflow2005Importer;
  HufImporter: THufImporter);
begin
  inherited Create(Importer, 'KDEP:');
  FHufImporter := HufImporter;
  FHufImporter.FKdepImporter := self;
end;

procedure TKdepImporter.CreateParameters;
var
  Param: THufParameter;
  ParamIndex: Integer;
  HufParameters: THufModflowParameters;
  HydrogeologicUnits: THydrogeologicUnits;
  UsedParam: THufUsedParameter;
  HGU: THydrogeologicUnit;
  ClusterIndex: Integer;
  Clusters: TClusterRecordArray;
begin
  HydrogeologicUnits := THydrogeologicUnits.Create(nil);
  HufParameters := THufModflowParameters.Create(nil);
  try
    HufParameters.Assign(FModel.HufParameters);
    HydrogeologicUnits.Assign(FModel.HydrogeologicUnits);
    for ParamIndex := 0 to Length(FParameters) - 1 do
    begin
      Param := HufParameters.Add as THufParameter;
      Param.ParameterType := ptHUF_KDEP;
      Clusters := FParameters[ParamIndex].Instances[0].Clusters;
      Param.ParameterName := FParameters[ParamIndex].PARNAM;
      Param.Value := FParameters[ParamIndex].Parval;
      for ClusterIndex := 0 to Length(Clusters) - 1 do
      begin
        HGU := HydrogeologicUnits[Clusters[ClusterIndex].Layer - 1];
        UsedParam := HGU.HufUsedParameters.Add as THufUsedParameter;
        UsedParam.ParameterName := Param.ParameterName;
        UsedParam.UseMultiplier :=
          not SameText(Clusters[ClusterIndex].MultiplierName, 'NONE');
        UsedParam.UseZone :=
          not SameText(Clusters[ClusterIndex].ZoneName, 'ALL');
      end;
    end;
    FModel.HufParameters := HufParameters;
    FModel.HydrogeologicUnits := HydrogeologicUnits;
  finally
    HufParameters.Free;
    HydrogeologicUnits.Free;
  end;
end;

procedure TKdepImporter.ImportReferenceLayer;
var
  RefDataArray: TDataArray;
  ScreenObject: TScreenObject;
  Interpolator: TNearestPoint2DInterpolator;
begin
  if FHufPackage.ReferenceChoice = hrcReferenceLayer then
  begin
    RefDataArray := FModel.DataArrayManager.GetDataSetByName(StrHufReferenceSurface);
    Assert(RefDataArray <> nil);
    if FIsConstantGroundSurface then
    begin
      RefDataArray.Formula := FortranFloatToStr(FConstantGroundSurface);
    end
    else
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
      Interpolator := TNearestPoint2DInterpolator.Create(nil);
      try
        RefDataArray.TwoDInterpolator := Interpolator;
      finally
        Interpolator.Free;
      end;
      AssignRealValuesToCellCenters(RefDataArray, ScreenObject, FGroundSurface);
    end;
  end;
end;

procedure TKdepImporter.ImportReferenceChoice;
begin
  if IFKDEP = 0 then
  begin
    FHufPackage.ReferenceChoice := hrcModelTop;
  end
  else
  begin
    FHufPackage.ReferenceChoice := hrcReferenceLayer;
  end;
end;

procedure TKdepImporter.ReadConstantGroundSurface;
var
  ALine: string;
begin
  FIsConstantGroundSurface := True;
  ReadLn(FImporter.FFile, ALine);
  ALine := Trim(ALine);
  Assert(ALine = 'GROUND SURFACE');
  Readln(FImporter.FFile, FConstantGroundSurface);
  FImporter.UpdateProgress;
end;

procedure TKdepImporter.ReadVariableGroundSurface;
var
  ID: string;
begin
  FIsConstantGroundSurface := False;
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Assert(ID = 'GROUND SURFACE');
  SetLength(FGroundSurface, FGrid.RowCount, FGrid.ColumnCount);
  Read2DRealArray(FGroundSurface, 'UZF Ground Surface');
end;

function TKdepImporter.ScreenObjectNameRoot: string;
begin
  result := '';
  Assert(False);
end;

procedure TKdepImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, NPKDEP);
  Read(FImporter.FFile, IFKDEP);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(FParameters, NPKDEP);
  FNextParameterIndex := 0;
  FHufImporter.FReadKdep := False;
  FHufImporter.FComments.AddStrings(FComments);
end;

function TKdepImporter.ReadInstance: boolean;
begin
  result := False;
end;

procedure TKdepImporter.HandlePackage;
begin
  if FHufImporter.FReadKdep then
  begin
    if not FHufImporter.ImportedPackage then
    begin
      FHufImporter.HandlePackage;
    end;
    if FHufImporter.ImportedPackage and not ImportedPackage then
    begin
      inherited;
      FHufPackage := FModel.ModflowPackages.HufPackage;
      ImportReferenceChoice;
      CreateParameters;
      AssignHufParametersZoneAndMultiplier;
      FModel.DataArrayManager.CreateInitialDataSets;
      ImportReferenceLayer;
    end;
  end;
end;

procedure TKdepImporter.ReadData(const ALabel: string);
var
  AnInt: integer;
begin
  inherited;
  if ALabel = 'NPKDEP, IFKDEP:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'NP:' then
  begin
    Readln(FImporter.FFile, AnInt);
    FImporter.UpdateProgress;
    Assert(AnInt = NPKDEP);
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    ReadVariableGroundSurface;
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadConstantGroundSurface;
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadArrayParameter;
    FHufImporter.FReadKdep := True;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TCustomHufImporter }

procedure TCustomHufImporter.AssignHufParametersZoneAndMultiplier;
var
  HGU: THydrogeologicUnit;
  ParamIndex: Integer;
  UsedParam: THufUsedParameter;
  MultDataArray: TDataArray;
  ZoneDataArray: TDataArray;
  PIndex: Integer;
  Clusters: TClusterRecordArray;
  ClusterIndex: Integer;
  Cluster: TClusterRecord;
  MultFunction: string;
  ZoneFunction: string;
  ZoneIndex: Integer;
  HufIndex: Integer;
begin
  for HufIndex := 0 to FModel.HydrogeologicUnits.Count - 1 do
  begin
    HGU := FModel.HydrogeologicUnits[HufIndex];
    for ParamIndex := 0 to HGU.HufUsedParameters.Count - 1 do
    begin
      UsedParam := HGU.HufUsedParameters[ParamIndex];
      MultDataArray := nil;
      if UsedParam.UseMultiplier then
      begin
        MultDataArray := FModel.DataArrayManager.GetDataSetByName(
          UsedParam.MultiplierDataSetName);
      end;
      ZoneDataArray := nil;
      if UsedParam.UseZone then
      begin
        ZoneDataArray := FModel.DataArrayManager.GetDataSetByName(UsedParam.ZoneDataSetName);
      end;
      if (MultDataArray = nil) and (ZoneDataArray = nil) then
      begin
        Continue;
      end;
      for PIndex := 0 to Length(FParameters) - 1 do
      begin
        if SameText(FParameters[PIndex].PARNAM, UsedParam.ParameterName) then
        begin
          Clusters := FParameters[PIndex].Instances[0].Clusters;
          for ClusterIndex := 0 to Length(Clusters) - 1 do
          begin
            if Clusters[ClusterIndex].Layer - 1 = HufIndex then
            begin
              Cluster := Clusters[ClusterIndex];
              if SameText(Cluster.MultiplierName, StrNone) then
              begin
                MultFunction := '1';
              end
              else
              begin
                MultFunction := Cluster.MultiplierName;
              end;
              if SameText(Cluster.ZoneName, StrAll) then
              begin
                ZoneFunction := 'True';
              end
              else
              begin
                ZoneFunction := '';
                for ZoneIndex := 0 to Length(Cluster.ZoneValues) - 1 do
                begin
                  ZoneFunction := ZoneFunction + '(' + Cluster.ZoneName
                    + ' = ' + IntToStr(Cluster.ZoneValues[ZoneIndex]) + ')';
                  if ZoneIndex < Length(Cluster.ZoneValues) - 1 then
                  begin
                    ZoneFunction := ZoneFunction + ' or ';
                  end;
                end;
              end;
              if MultDataArray <> nil then
              begin
                MultDataArray.Formula := MultFunction;
              end;
              if ZoneDataArray <> nil then
              begin
                ZoneDataArray.Formula := ZoneFunction;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

{ TLvdaImporter }

constructor TLvdaImporter.Create(Importer: TModflow2005Importer;
  HufImporter: THufImporter);
begin
  inherited Create(Importer, 'LVDA:');
  FHufImporter := HufImporter;
  FHufImporter.FLvdaImporter := self;
end;

procedure TLvdaImporter.ReadDataSet1;
begin
  Read(FImporter.FFile, NPLVDA);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(FParameters, NPLVDA);
  FNextParameterIndex := 0;
  FHufImporter.FReadLvda := False;
  FHufImporter.FComments.AddStrings(FComments);
end;

function TLvdaImporter.ReadInstance: boolean;
begin
  result := False;
end;

function TLvdaImporter.ScreenObjectNameRoot: string;
begin
  result := '';
  Assert(False);
end;

procedure TLvdaImporter.CreateParameters;
var
  ClusterIndex: Integer;
  Cluster: TClusterRecord;
  MultName: string;
  MultDataArray: TDataArray;
  ZoneName: string;
  ZoneDataArray: TDataArray;
  MultFunctionList: TStringList;
  ZoneFunctionList: TStringList;
  LayerIndex: Integer;
  ZoneFunction: string;
  ZoneIndex: Integer;
  MultFunction: string;
  MultIndex: Integer;
  Index: Integer;
  Param: TModflowSteadyParameter;
  Instance: TInstanceRecord;
  MultUsed: Boolean;
  ZoneUsed: Boolean;
  IntList: TIntegerList;
begin
  for Index := 0 to Length(FParameters) - 1 do
  begin
    Param := FModel.ModflowSteadyParameters.Add as TModflowSteadyParameter;
    Param.ParameterName := FParameters[Index].PARNAM;
    Param.Value := FParameters[Index].Parval;
    Assert(FParameters[Index].PARTYP = 'LVDA');
    Param.ParameterType := ptHUF_LVDA;
    Assert(Length(FParameters[Index].Instances) = 1);
    Instance := FParameters[Index].Instances[0];
    MultUsed := False;
    ZoneUsed := False;
    IntList := TIntegerList.Create;
    try
      IntList.Sorted := True;
      for ClusterIndex := 0 to Length(Instance.Clusters) - 1 do
      begin
        Cluster := Instance.Clusters[ClusterIndex];
        IntList.AddUnique(Cluster.Layer);
        if not SameText(Cluster.MultiplierName, StrNone) then
        begin
          MultUsed := True;
        end;
        if not SameText(Cluster.ZoneName, StrAll) then
        begin
          ZoneUsed := True;
        end;
      end;
      Param.UseMultiplier := MultUsed or
        (IntList.Count < FModel.ModflowLayerCount);
      if Param.UseMultiplier then
      begin
        MultName := Param.MultiplierName;
        MultDataArray := FModel.DataArrayManager.GetDataSetByName(MultName);
      end
      else
      begin
        MultDataArray := nil;
      end;
      Param.UseZone := ZoneUsed or
        (IntList.Count < FModel.ModflowLayerCount);
      if Param.UseZone then
      begin
        ZoneName := Param.ZoneName;
        ZoneDataArray := FModel.DataArrayManager.GetDataSetByName(ZoneName);
      end
      else
      begin
        ZoneDataArray := nil;
      end;
    finally
      IntList.Free;
    end;
    MultFunctionList := TStringList.Create;
    ZoneFunctionList := TStringList.Create;
    try
      for LayerIndex := 0 to FGrid.LayerCount - 1 do
      begin
        MultFunctionList.Add('0');
        ZoneFunctionList.Add('False');
      end;
      for ClusterIndex := 0 to Length(Instance.Clusters) - 1 do
      begin
        Cluster := Instance.Clusters[ClusterIndex];
        LayerIndex := FModel.
          ModflowLayerToDataSetLayer(Cluster.Layer);
        if Param.ParameterType = ptLPF_VKCB then
        begin
          Inc(LayerIndex);
        end;
        if SameText(Cluster.MultiplierName, StrNone) then
        begin
          MultFunctionList[LayerIndex] := '1';
        end
        else
        begin
          MultFunctionList[LayerIndex] := Cluster.MultiplierName;
        end;
        if SameText(Cluster.ZoneName, StrAll) then
        begin
          ZoneFunctionList[LayerIndex] := 'True';
        end
        else
        begin
          ZoneFunction := '';
          for ZoneIndex := 0 to Length(Cluster.ZoneValues) - 1 do
          begin
            ZoneFunction := ZoneFunction + '(' + Cluster.ZoneName
              + ' = ' + IntToStr(Cluster.ZoneValues[ZoneIndex]) + ')';
            if ZoneIndex < Length(Cluster.ZoneValues) - 1 then
            begin
              ZoneFunction := ZoneFunction + ' or ';
            end;
          end;
          ZoneFunctionList[LayerIndex] := ZoneFunction;
        end;
      end;
      if MultDataArray <> nil then
      begin
        if MultFunctionList.Count > 1 then
        begin
          MultFunction := 'CaseR(' + LayerString + ', ';
          for MultIndex := 0 to MultFunctionList.Count - 1 do
          begin
            MultFunction := MultFunction + MultFunctionList[MultIndex];
            if MultIndex < MultFunctionList.Count - 1 then
            begin
              MultFunction := MultFunction + ', ';
            end;
          end;
          MultFunction := MultFunction + ')';
          MultDataArray.Formula := MultFunction;
        end
        else
        begin
          MultDataArray.Formula := MultFunctionList[0];
        end;
      end;
      if ZoneDataArray <> nil then
      begin
        if ZoneFunctionList.Count = 1 then
        begin
          ZoneFunction :=ZoneFunctionList[0];
        end
        else
        begin
          ZoneFunction := 'CaseB(' + LayerString + ', ';
          for ZoneIndex := 0 to ZoneFunctionList.Count - 1 do
          begin
            ZoneFunction := ZoneFunction + ZoneFunctionList[ZoneIndex];
            if ZoneIndex < ZoneFunctionList.Count - 1 then
            begin
              ZoneFunction := ZoneFunction + ', ';
            end;
          end;
          ZoneFunction := ZoneFunction + ')';
        end;
        ZoneDataArray.Formula := ZoneFunction;
      end;
    finally
      MultFunctionList.Free;
      ZoneFunctionList.Free;
    end;
  end;
end;

procedure TLvdaImporter.HandlePackage;
begin
  if FHufImporter.FReadLvda then
  begin
    if not FHufImporter.ImportedPackage then
    begin
      FHufImporter.HandlePackage;
    end;
    if FHufImporter.ImportedPackage and not ImportedPackage then
    begin
      inherited;
      CreateParameters;
    end;
  end;
end;

procedure TLvdaImporter.ReadData(const ALabel: string);
var
  AnInt: integer;
begin
  inherited;
  if ALabel = 'NPLVDA:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'NP:' then
  begin
    Readln(FImporter.FFile, AnInt);
    FImporter.UpdateProgress;
    Assert(AnInt = NPLVDA);
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadArrayParameter;
    FHufImporter.FReadLvda := True;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TCustomFlowObservationImporter }

constructor TCustomFlowObservationImporter.Create(
  Importer: TModflow2005Importer; const PackageIdentifier: string);
begin
  inherited;
  FObservations:= TObservations.Create;
  FFlowObsGroups := TFluxObservationGroups.Create(nil);
end;

destructor TCustomFlowObservationImporter.Destroy;
begin
  FObservations.Free;
  FFlowObsGroups.Free;
  inherited;
end;

procedure TCustomFlowObservationImporter.CreateObservationGroups;
var
  ObsTime: TObservationTime;
  TimeIndex: Integer;
  Group: TFluxObservationGroup;
  ObsGroup: TObservationGroup;
  GroupIndex: Integer;
  RefStressPeriod: TModflowStressPeriod;
  FlowObs: TFluxObservation;
begin
  if FFlowObsGroups.Count > 0 then
  begin
    Exit;
  end;
  for GroupIndex := 0 to FObservations.ArrayLength - 1 do
  begin
    ObsGroup := FObservations[GroupIndex];
    Group := FFlowObsGroups.Add;
    Group.ObservationName := FObsPrefix + IntToStr(GroupIndex + 1);
    ObsGroup.FGroup := Group;
    for TimeIndex := 0 to ObsGroup.FTimes.ArrayLength - 1 do
    begin
      ObsTime := ObsGroup.FTimes[TimeIndex];
      FlowObs := Group.ObservationTimes.Add;
      FlowObs.ObservedValue := ObsTime.FLWOBS;
      if ObsTime.IREFSP - 1 >= FModel.ModflowStressPeriods.Count then
      begin
        RefStressPeriod := FModel.ModflowStressPeriods.Last;
        frmErrorsAndWarnings.AddError(FModel, StrInvalidReferenceSt,
          Format(StrOneOrMoreObservat,
          [TimeIndex + 1, Group.ObservationName, ObsTime.IREFSP]));
      end
      else
      begin
        RefStressPeriod := FModel.ModflowStressPeriods.Items[ObsTime.IREFSP - 1];
      end;
      FlowObs.Time := RefStressPeriod.StartTime + ObsTime.TOFFSET * TOMULT;
    end;
  end;
end;

procedure TCustomFlowObservationImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = FDataSet1Label then
  begin
    ReadDataSet1;
  end
  else if ALabel = FDataSet2Label then
  begin
    ReadDataSet2;
  end
  else if ALabel = FDataSet3Label then
  begin
    ReadDataSet3;
  end
  else if ALabel = FDataSet4Label then
  begin
    ReadDataSet4;
  end
  else if ALabel = FDataSet5Label then
  begin
    ReadDataSet5;
  end
  else
  begin
//    ShowMessage(ALabel);
    Assert(False);
  end;
end;

procedure TCustomFlowObservationImporter.ReadDataSet5;
var
  CurrentLoc: TFlowObservationLocation;
begin
  Inc(FCurrentLocationIndex);
  CurrentLoc := FCurrentGroup.FCells[FCurrentLocationIndex];
  Readln(FImporter.FFile, CurrentLoc.LAYER, CurrentLoc.ROW,
    CurrentLoc.COLUMN, CurrentLoc.FACTOR);
  FImporter.UpdateProgress;
  if NQCL < 0 then
  begin
    CurrentLoc.FACTOR := 1;
  end;
end;

procedure TCustomFlowObservationImporter.ReadDataSet4;
var
  CurrentObs: TObservationTime;
begin
  Inc(FCurrentTimeIndex);
  CurrentObs := FCurrentGroup.FTimes[FCurrentTimeIndex];
  Readln(FImporter.FFile, CurrentObs.OBSNAM);
  Readln(FImporter.FFile, CurrentObs.IREFSP,
    CurrentObs.TOFFSET, CurrentObs.FLWOBS);
  FImporter.UpdateProgress;
  CurrentObs.OBSNAM := Trim(CurrentObs.OBSNAM);
end;

procedure TCustomFlowObservationImporter.ReadDataSet3;
var
  NQOB: Integer;
begin
  Readln(FImporter.FFile, NQOB, NQCL);
  FImporter.UpdateProgress;
  Inc(FCurrentGroupIndex);
  FCurrentGroup := FObservations[FCurrentGroupIndex];
  FCurrentGroup.FTimes.ArrayLength := NQOB;
  FCurrentGroup.FCells.ArrayLength := Abs(NQCL);
  FCurrentTimeIndex := -1;
  FCurrentLocationIndex := -1;
end;

procedure TCustomFlowObservationImporter.ReadDataSet2;
begin
  Readln(FImporter.FFile, TOMULT);
  FImporter.UpdateProgress;
end;

procedure TCustomFlowObservationImporter.ReadDataSet1;
//var
//  NQC: integer;
//  NQT: integer;
begin
  Readln(FImporter.FFile, NQ, DummyInteger, DummyInteger, IUOBSV); // NQC, NQT
  FImporter.UpdateProgress;
  FObservations.ArrayLength := NQ;
  FCurrentGroupIndex := -1;
  FIsActive := True;
end;

{ TFlowObsLocArray }

function TFlowObsLocArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TFlowObservationLocation;
end;

function TFlowObsLocArray.GetItem(Index: integer): TFlowObservationLocation;
begin
  result := Objects[Index] as TFlowObservationLocation;
end;

{ TObsTimeArray }

function TObsTimeArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TObservationTime;
end;

function TObsTimeArray.GetItem(Index: integer): TObservationTime;
begin
  result := Objects[Index] as TObservationTime
end;

{ TObservations }

function TObservations.ArrayMemberClass: TArrayMemberClass;
begin
  result := TObservationGroup;
end;

function TObservations.GetItem(Index: integer): TObservationGroup;
begin
  result := Objects[Index] as TObservationGroup;
end;

{ TDrnObsImporter }

constructor TDrnObsImporter.Create(Importer: TModflow2005Importer;
      DrnImporter: TDrnImporter);
begin
  inherited Create(Importer, 'DROB');
  FDrnImporter := DrnImporter;
  FDrnImporter.FObsImporter := self;
  FDataSet1Label := 'NQDR, NQCDR, NQTDR, IUDROBSV:';
  FDataSet2Label := 'TOMULTDR:';
  FDataSet3Label := 'NQOBDR(IQ), NQCLDR(IQ):';
  FDataSet4Label := 'OBSNAM(J),IREFSP,TOFFSET,FLWOBS(J):';
  FDataSet5Label := 'Layer Row Column Factor:';
  FObsPrefix := 'DROB';
end;

procedure TDrnObsImporter.HandlePackage;
begin
  if FDrnImporter.ImportedPackage then
  begin
    inherited;
    FModel.ModflowPackages.DrobPackage.IsSelected := FIsActive;
    FModel.DrainObservations := FFlowObsGroups;
    frmGoPhast.EnableManageFlowObservations;
  end;
end;

{ TObservationGroup }

constructor TObservationGroup.Create;
begin
  inherited;
  FTimes:= TObsTimeArray.Create;
  FCells:= TFlowObsLocArray.Create;
end;

destructor TObservationGroup.Destroy;
begin
  FCells.Free;
  FTimes.Free;
  inherited;
end;

{ TLocation }

constructor TLocation.Create;
begin
  inherited;
  FObservationGroups := TList.Create;
  FObservationCells := TList.Create;
end;

destructor TLocation.Destroy;
begin
  FObservationCells.Free;
  FObservationGroups.Free;
  inherited;
end;

function TLocation.SameObservations(ALocation: TLocation): boolean;
var
  Index: Integer;
begin
  result := FObservationGroups.Count = ALocation.FObservationGroups.Count;
  if result then
  begin
    for Index := 0 to FObservationGroups.Count - 1 do
    begin
      result := FObservationGroups[Index] = ALocation.FObservationGroups[Index];
      if not result then
      begin
        Exit;
      end;
    end;
  end;
end;

{ TGhbObsImporter }

constructor TGhbObsImporter.Create(Importer: TModflow2005Importer;
  GhbImporter: TGhbImporter);
begin
  inherited Create(Importer, 'GBOB');
  FGhbImporter := GhbImporter;
  FGhbImporter.FObsImporter := self;
  FDataSet1Label := 'NQGB, NQCGB, NQTGB, IUGBOBSV:';
  FDataSet2Label := 'TOMULTGB:';
  FDataSet3Label := 'NQOBGB(IQ), NQCLGB(IQ):';
  FDataSet4Label := 'OBSNAM(J),IREFSP,TOFFSET,FLWOBS(J):';
  FDataSet5Label := 'Layer Row Column Factor:';
  FObsPrefix := 'GBOB';
end;

procedure TGhbObsImporter.HandlePackage;
begin
  if FGhbImporter.ImportedPackage then
  begin
    inherited;
    FModel.ModflowPackages.GbobPackage.IsSelected := FIsActive;
    FModel.GhbObservations := FFlowObsGroups;
    frmGoPhast.EnableManageFlowObservations;
  end;
end;

{ TRivObsImporter }

constructor TRivObsImporter.Create(Importer: TModflow2005Importer;
  RivImporter: TRivImporter);
begin
  inherited Create(Importer, 'RVOB');
  FRivImporter := RivImporter;
  FRivImporter.FObsImporter := self;
  FDataSet1Label := 'NQRV, NQCRV, NQTRV, IURVOBSV:';
  FDataSet2Label := 'TOMULTRV:';
  FDataSet3Label := 'NQOBRV(IQ), NQCLRV(IQ):';
  FDataSet4Label := 'OBSNAM(J),IREFSP,TOFFSET,FLWOBS(J):';
  FDataSet5Label := 'Layer Row Column Factor:';
  FObsPrefix := 'RVOB';
end;

procedure TRivObsImporter.HandlePackage;
begin
  if FRivImporter.ImportedPackage then
  begin
    inherited;
    FModel.ModflowPackages.RvobPackage.IsSelected := FIsActive;
    FModel.RiverObservations := FFlowObsGroups;
    frmGoPhast.EnableManageFlowObservations;
  end;
end;

{ TChdObsImporter }

constructor TChdObsImporter.Create(Importer: TModflow2005Importer;
  ChdImporter: TChdImporter; BasImporter: TBasImporter);
begin
  inherited Create(Importer, 'CHOB');
  FChdImporter := ChdImporter;
  FChdImporter.FObsImporter := self;
  FBasImporter := BasImporter;
  BasImporter.FObsImporter := self;
  FDataSet1Label := 'NQCH, NQCCH, NQTCH, IUCHOBSV:';
  FDataSet2Label := 'TOMULTCH:';
  FDataSet3Label := 'NQOBCH(IQ), NQCLCH(IQ):';
  FDataSet4Label := 'OBSNAM(N), IREFSP, TOFFSET, FLWOBS(N):';
  FDataSet5Label := 'Layer Row Column Factor:';
  FObsPrefix := 'CHOB';
end;

procedure TChdObsImporter.HandlePackage;
begin
  if not FImportedPackage and
    (FChdImporter.ImportedPackage or not FChdImporter.FReadData)
    and FBasImporter.ImportedPackage then
  begin

    CreateObservationGroups;
    FBasImporter.ImportSpecifiedHeads;
    inherited;
    FModel.ModflowPackages.ChobPackage.IsSelected := FIsActive;
    FModel.HeadFluxObservations := FFlowObsGroups;
    frmGoPhast.EnableManageFlowObservations;
  end;
end;

{ TBasChdObjects }

constructor TBasChdObjects.Create;
begin
  FList := TObjectList.Create;
end;

destructor TBasChdObjects.Destroy;
begin
  FList.Free;
  inherited;
end;

{ TPvalImporter }

constructor TPvalImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'PVAL');
  FPvalParams:= TPvalParamArray.Create;
  FCurrentParam := -1;
end;

destructor TPvalImporter.Destroy;
begin
  FPvalParams.Free;
  inherited;
end;

procedure TPvalImporter.HandlePackage;
var
  ReadAll: boolean;
  Index: Integer;
  AParam: TModflowParameter;
begin
  if FImportedPackage then
  begin
    Exit;
  end;
  ReadAll := True;
  for Index := 0 to FPvalParams.ArrayLength - 1 do
  begin
    AParam := FModel.ModflowSteadyParameters.
      GetParamByName(FPvalParams[Index].PARNAM);
    if AParam = nil then
    begin
      AParam := FModel.ModflowTransientParameters.
        GetParamByName(FPvalParams[Index].PARNAM);
    end;
    if AParam = nil then
    begin
      AParam := FModel.HufParameters.
        GetParamByName(FPvalParams[Index].PARNAM);
    end;
    if AParam = nil then
    begin
      ReadAll := False;
    end
    else
    begin
      AParam.Value := FPvalParams[Index].Value;
    end;
  end;
  if ReadAll then
  begin
    inherited;
  end;

end;

procedure TPvalImporter.ReadData(const ALabel: string);
var
  NPVAL: integer;
begin
  inherited;
  if ALabel = 'NPVAL:' then
  begin
    Readln(FImporter.FFile, NPVAL);
    FImporter.UpdateProgress;
    FPvalParams.ArrayLength := NPVAL;
  end
  else if ALabel = 'PARNAM(I),B(I):' then
  begin
    Inc(FCurrentParam);
    Readln(FImporter.FFile, FPvalParams[FCurrentParam].PARNAM);
    Readln(FImporter.FFile, FPvalParams[FCurrentParam].Value);
    FImporter.UpdateProgress;
    FPvalParams[FCurrentParam].PARNAM :=
      Trim(FPvalParams[FCurrentParam].PARNAM);
  end;
end;

{ TPvalParamArray }

function TPvalParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TPvalParam;
end;

function TPvalParamArray.GetParam(Index: integer): TPvalParam;
begin
  result := Objects[Index] as TPvalParam
end;

{ TMnw2Importer }

procedure TMnw2Importer.AddStressPeriod(ITMP: integer);
var
  Index: Integer;
  AWell: TMnw2Well;
  StressPeriod: TMnw2WellStressPeriod;
begin
  Inc(FCurrentStressPeriod);
  for Index := 0 to FWells.ArrayLength - 1 do
  begin
    AWell := FWells[Index];
    AWell.FStressPeriods.ArrayLength := FCurrentStressPeriod+1;
    StressPeriod := AWell.FStressPeriods[FCurrentStressPeriod];
    if ITMP < 0 then
    begin
      StressPeriod.WellState := wsReuse;
    end
    else
    begin
      StressPeriod.WellState := wsInactive;
    end;
    StressPeriod.Hlim := AWell.Hlim;
    StressPeriod.QCUT := AWell.QCUT;
    StressPeriod.Qfrcmn := AWell.Qfrcmn;
    StressPeriod.Qfrcmx := AWell.Qfrcmx;
  end;
end;

constructor TMnw2Importer.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'MNW2');
  FWells:= TMnw2WellArray.Create;
  FCurrentStressPeriod := -1;
end;

destructor TMnw2Importer.Destroy;
begin
  FWells.Free;
  inherited;
end;

procedure TMnw2Importer.AssignScreens(AScreenObject: TScreenObject;
  AWell: TMnw2Well);
var
  FirstScreen: TMnw2WellScreen;
  VerticalScreen: TVerticalScreen;
  AScreen: TMnw2WellScreen;
  ScreenIndex: Integer;
  APoint3D: T3DRealPoint;
  APoint: TPoint2D;
  SpatialItem: TMnw2SpatialItem;
begin
  Assert(AWell.FScreens <> nil);
  AScreenObject.Capacity := 1;
  AScreenObject.ElevationCount := ecTwo;
  FirstScreen := AWell.FScreens[0];
  AScreenObject.HigherElevationFormula := FortranFloatToStr(FirstScreen.Ztop);
  AScreenObject.LowerElevationFormula := FortranFloatToStr(FirstScreen.Zbotm);
  APoint := FGrid.TwoDElementCenter(FirstScreen.IC - 1, FirstScreen.IR - 1);
  AScreenObject.AddPoint(APoint, True);
  APoint3D := FGrid.ThreeDElementCenter(ZeroBasedID(0,
    FirstScreen.IR - 1, FirstScreen.IC - 1));

  SpatialItem := nil;
  if AWell.LossType in [mltThiem, mltSkin, mltEquation] then
  begin
    if SpatialItem = nil then
    begin
      SpatialItem := AScreenObject.ModflowMnw2Boundary.Values.Add
        as TMnw2SpatialItem;
      SpatialItem.WellRadius := FortranFloatToStr(FirstScreen.Rw);
    end;
  end;
  if AWell.LossType = mltSkin then
  begin
    if SpatialItem = nil then
    begin
      SpatialItem := AScreenObject.ModflowMnw2Boundary.Values.Add
        as TMnw2SpatialItem;
    end;
    SpatialItem.SkinRadius := FortranFloatToStr(FirstScreen.Rskin);
    SpatialItem.SkinK := FortranFloatToStr(FirstScreen.Kskin);
  end;
  if AWell.LossType = mltEquation then
  begin
    if SpatialItem = nil then
    begin
      SpatialItem := AScreenObject.ModflowMnw2Boundary.Values.Add
        as TMnw2SpatialItem;
    end;
    SpatialItem.B := FortranFloatToStr(FirstScreen.B);
    SpatialItem.C := FortranFloatToStr(FirstScreen.C);
    SpatialItem.P := FortranFloatToStr(FirstScreen.P);
  end;
  if AWell.LossType = mtlSpecify then
  begin
    if SpatialItem = nil then
    begin
      SpatialItem := AScreenObject.ModflowMnw2Boundary.Values.Add
        as TMnw2SpatialItem;
    end;
    SpatialItem.CellToWellConductance := FortranFloatToStr(FirstScreen.CWC);
  end;

  if AWell.FScreens.ArrayLength > 1 then
  begin
    AScreenObject.ModflowMnw2Boundary.VerticalScreens.Capacity :=
      AWell.FScreens.ArrayLength;
    for ScreenIndex := 0 to AWell.FScreens.ArrayLength - 1 do
    begin
      AScreen := AWell.FScreens[ScreenIndex];
      VerticalScreen := AScreenObject.ModflowMnw2Boundary.VerticalScreens.Add
        as TVerticalScreen;
      VerticalScreen.StartTime := ScreenIndex;
      VerticalScreen.EndTime := ScreenIndex+1;
      VerticalScreen.ZTop := AScreen.Ztop;
      VerticalScreen.ZBottom := AScreen.Zbotm;
      VerticalScreen.WellRadius := FortranFloatToStr(AScreen.Rw);
      VerticalScreen.SkinRadius := FortranFloatToStr(AScreen.Rskin);
      VerticalScreen.SkinK := FortranFloatToStr(AScreen.Kskin);
      VerticalScreen.B := FortranFloatToStr(AScreen.B);
      VerticalScreen.C := FortranFloatToStr(AScreen.C);
      VerticalScreen.P := FortranFloatToStr(AScreen.P);
      VerticalScreen.CellToWellConductance := FortranFloatToStr(AScreen.CWC);
    end;
  end;
end;

procedure TMnw2Importer.AssignCells(AScreenObject: TScreenObject;
  AWell: TMnw2Well);
var
  ImportedValues: TValueArrayItem;
  AValue: Double;
  SpatialItem: TMnw2SpatialItem;
  ACell: TMnw2WellCell;
  CellIndex: Integer;
  ImportedCWCData: TDoubleArray;
  ImportedPData: TDoubleArray;
  ImportedCData: TDoubleArray;
  ImportedBData: TDoubleArray;
  ImportedKSkinData: TDoubleArray;
  ImportedRSkinData: TDoubleArray;
  ImportedRwData: TDoubleArray;
  ImportedPPData: TDoubleArray;
  ImportedElevations: TValueArrayStorage;
  APoint3D: T3DRealPoint;
  APoint: TPoint2D;
  Layer: Integer;
begin
  AScreenObject.Capacity := AWell.FCells.ArrayLength;
  ImportedElevations := nil;
  if AWell.FCells.ArrayLength > 1 then
  begin
    ImportedElevations := AScreenObject.ImportedSectionElevations;
    ImportedElevations.DataType := rdtDouble;
    ImportedElevations.Count := AWell.FCells.ArrayLength;
    AScreenObject.ElevationFormula := rsObjectImportedValuesR
      + '("' + StrImportedElevations + '")';
  end;
  SetLength(ImportedRwData, AWell.FCells.ArrayLength);
  SetLength(ImportedRSkinData, AWell.FCells.ArrayLength);
  SetLength(ImportedKSkinData, AWell.FCells.ArrayLength);
  SetLength(ImportedBData, AWell.FCells.ArrayLength);
  SetLength(ImportedCData, AWell.FCells.ArrayLength);
  SetLength(ImportedPData, AWell.FCells.ArrayLength);
  SetLength(ImportedCWCData, AWell.FCells.ArrayLength);
  if AWell.PPFLAG > 0 then
  begin
    SetLength(ImportedPPData, AWell.FCells.ArrayLength);
  end;
  for CellIndex := 0 to AWell.FCells.ArrayLength - 1 do
  begin
    ACell := AWell.FCells[CellIndex];
    APoint := FGrid.TwoDElementCenter(ACell.IC - 1, ACell.IR - 1);
    AScreenObject.AddPoint(APoint, True);
    Layer := FModel.ModflowLayerToDataSetLayer(ACell.IL);
    APoint3D := FGrid.ThreeDElementCenter(ZeroBasedID(Layer,
      ACell.IR - 1, ACell.IC - 1));
    if AWell.FCells.ArrayLength > 1 then
    begin
      ImportedElevations.RealValues[CellIndex] := APoint3D.Z;
    end
    else
    begin
      AScreenObject.ElevationFormula := FortranFloatToStr(APoint3D.Z);
    end;
    ImportedRwData[CellIndex] := ACell.Rw;
    ImportedRSkinData[CellIndex] := ACell.Rskin;
    ImportedKSkinData[CellIndex] := ACell.Kskin;
    ImportedBData[CellIndex] := ACell.B;
    ImportedCData[CellIndex] := ACell.C;
    ImportedPData[CellIndex] := ACell.P;
    ImportedCWCData[CellIndex] := ACell.CWC;
    if AWell.PPFLAG > 0 then
    begin
      ImportedPPData[CellIndex] := ACell.PP;
    end;
  end;
  AScreenObject.SectionStarts.CacheData;

  SpatialItem := AScreenObject.ModflowMnw2Boundary.Values.Add
    as TMnw2SpatialItem;
  if AWell.PPFLAG > 0 then
  begin
    if UniformArray(ImportedPPData) then
    begin
      AValue := ImportedPPData[0];
      SpatialItem.PartialPenetration := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_PP';
      AssignImportedValues(ImportedValues, ImportedPPData);
      SpatialItem.PartialPenetration := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
  end;


  if AWell.LossType in [mltThiem, mltSkin, mltEquation] then
  begin
    if UniformArray(ImportedRwData) then
    begin
      AValue := ImportedRwData[0];
      SpatialItem.WellRadius := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_Well_Radius';
      AssignImportedValues(ImportedValues, ImportedRwData);
      SpatialItem.WellRadius := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
  end;
  if AWell.LossType = mltSkin then
  begin
    if UniformArray(ImportedRSkinData) then
    begin
      AValue := ImportedRSkinData[0];
      SpatialItem.SkinRadius := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_Skin_Radius';
      AssignImportedValues(ImportedValues, ImportedRSkinData);
      SpatialItem.SkinRadius := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
    if UniformArray(ImportedKSkinData) then
    begin
      AValue := ImportedKSkinData[0];
      SpatialItem.SkinK := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_Skin_K';
      AssignImportedValues(ImportedValues, ImportedKSkinData);
      SpatialItem.SkinK := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
  end;
  if AWell.LossType = mltEquation then
  begin
    if UniformArray(ImportedBData) then
    begin
      AValue := ImportedBData[0];
      SpatialItem.B := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_B';
      AssignImportedValues(ImportedValues, ImportedBData);
      SpatialItem.B := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
    if UniformArray(ImportedCData) then
    begin
      AValue := ImportedCData[0];
      SpatialItem.C := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_C';
      AssignImportedValues(ImportedValues, ImportedCData);
      SpatialItem.C := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
    if UniformArray(ImportedPData) then
    begin
      AValue := ImportedPData[0];
      SpatialItem.P := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_P';
      AssignImportedValues(ImportedValues, ImportedPData);
      SpatialItem.P := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
  end;
  if AWell.LossType = mtlSpecify then
  begin
    if UniformArray(ImportedCWCData) then
    begin
      AValue := ImportedCWCData[0];
      SpatialItem.CellToWellConductance := FortranFloatToStr(AValue);
    end
    else
    begin
      ImportedValues := AScreenObject.ImportedValues.Add as TValueArrayItem;
      ImportedValues.Name := 'Imported_MNW2_Cell_to_Well_Conductance';
      AssignImportedValues(ImportedValues, ImportedCWCData);
      SpatialItem.CellToWellConductance := rsObjectImportedValuesR
        + '("' + ImportedValues.Name + '")';
    end;
  end;
  AScreenObject.ImportedValues.CacheData;
  if ImportedElevations <> nil then
  begin
    ImportedElevations.CacheData;
  end;
end;

procedure TMnw2Importer.ReadWellForCurrentStressPeriod;
var
  AWell: TMnw2Well;
  StressPeriod: TMnw2WellStressPeriod;
  WELLNAME: string;
begin
  Readln(FImporter.FFile, WELLNAME);
  FImporter.UpdateProgress;
  WELLNAME := Trim(WELLNAME);
  AWell := FWells.GetWellByName(WELLNAME);
  StressPeriod := AWell.FStressPeriods[FCurrentStressPeriod];
  StressPeriod.WellState := wsActive;
end;

procedure TMnw2Importer.ReadItmp;
var
  ITMP: Integer;
begin
  Readln(FImporter.FFile, ITMP);
  FImporter.UpdateProgress;
  AddStressPeriod(ITMP);
end;

procedure TMnw2Importer.ReadLiftTableItem;
var
  AWell: TMnw2Well;
  PumpItem: TMnw2PumpTableItem;
begin
  AWell := FWells[FCurrentWell];
  Inc(AWell.FCurrentPumpItem);
  PumpItem := AWell.FPumpTable[AWell.FCurrentPumpItem];
  Readln(FImporter.FFile, PumpItem.Liftn, PumpItem.Qn);
  FImporter.UpdateProgress;
end;

procedure TMnw2Importer.ReadLiftTableLimits;
var
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, AWell.Hlift, AWell.LIFTq0,
    AWell.LIFTqdes, AWell.HWtol);
  FImporter.UpdateProgress;
end;

procedure TMnw2Importer.ReadPartialPumpLimits;
var
  AWell: TMnw2Well;
  StressPeriod: TMnw2WellStressPeriod;
begin
  if FCurrentStressPeriod < 0 then
  begin
    AWell := FWells[FCurrentWell];
    Readln(FImporter.FFile, AWell.Hlim, AWell.QCUT);
    FImporter.UpdateProgress;
  end
  else
  begin
    AWell := FWells.FCurrentWell;
    StressPeriod := AWell.FStressPeriods[FCurrentStressPeriod];
    Readln(FImporter.FFile, StressPeriod.Hlim, StressPeriod.QCUT);
    FImporter.UpdateProgress;
  end;
end;

procedure TMnw2Importer.ReadFullPumpLimits;
var
  AWell: TMnw2Well;
  StressPeriod: TMnw2WellStressPeriod;
begin
  if FCurrentStressPeriod < 0 then
  begin
    AWell := FWells[FCurrentWell];
    Readln(FImporter.FFile, AWell.Hlim, AWell.QCUT, AWell.Qfrcmn, AWell.Qfrcmx);
    FImporter.UpdateProgress;
  end
  else
  begin
    AWell := FWells.FCurrentWell;
    StressPeriod := AWell.FStressPeriods[FCurrentStressPeriod];
    Readln(FImporter.FFile, StressPeriod.Hlim, StressPeriod.QCUT,
      StressPeriod.Qfrcmn, StressPeriod.Qfrcmx);
    FImporter.UpdateProgress;
  end;
end;

procedure TMnw2Importer.ReadPumpZ;
var
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, AWell.Zpump);
  FImporter.UpdateProgress;
end;

procedure TMnw2Importer.ReadPumpCell;
var
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, AWell.PUMPLAY, AWell.PUMPROW, AWell.PUMPCOL);
  FImporter.UpdateProgress;
end;

procedure TMnw2Importer.ReadAWellScreen(const ALabel: string);
var
  B: Double;
  CWC: Double;
  AWell: TMnw2Well;
  AScreen: TMnw2WellScreen;
  DataLabels: TStringList;
  Index: Integer;
  Ztop: Double;
  Zbotm: Double;
  IR: Integer;
  IC: Integer;
  Rw: Double;
  Kskin: Double;
  Rskin: Double;
  P: Double;
  C: Double;
begin
  AWell := FWells[FCurrentWell];
  Inc(AWell.FCurrentScreen);
  AScreen := AWell.FScreens[AWell.FCurrentScreen];

//  AScreen.Rw := AWell.Rw;
//  AScreen.Rskin := AWell.Rskin;
//  AScreen.Kskin := AWell.Kskin;
//  AScreen.B := AWell.B;
//  AScreen.C := AWell.C;
//  AScreen.P := AWell.P;
//  AScreen.CWC := AWell.CWC;

  DataLabels := TStringList.Create;
  try
    DataLabels.Delimiter := ',';
    // Remove colon from ALabel and split.
    DataLabels.DelimitedText := Copy(ALabel, 1, Length(ALabel) - 1);
    for Index := 0 to DataLabels.Count - 1 do
    begin
      if DataLabels[Index] = 'Ztop' then
      begin
        Read(FImporter.FFile, Ztop);
        AScreen.Ztop := Ztop;
      end
      else if DataLabels[Index] = 'Zbotm' then
      begin
        Read(FImporter.FFile, Zbotm);
        AScreen.Zbotm := Zbotm;
      end
      else if DataLabels[Index] = 'IR' then
      begin
        Read(FImporter.FFile, IR);
        AScreen.IR := IR;
      end
      else if DataLabels[Index] = 'IC' then
      begin
        Read(FImporter.FFile, IC);
        AScreen.IC := IC;
      end
      else if DataLabels[Index] = 'RwNode' then
      begin
        Read(FImporter.FFile, Rw);
        AScreen.Rw := Rw;
      end
      else if DataLabels[Index] = 'KskinNode' then
      begin
        Read(FImporter.FFile, Kskin);
        AScreen.Kskin := Kskin;
      end
      else if DataLabels[Index] = 'RskinNode' then
      begin
        Read(FImporter.FFile, Rskin);
        AScreen.Rskin := Rskin;
      end
      else if DataLabels[Index] = 'PNode' then
      begin
        Read(FImporter.FFile, P);
        AScreen.P := P;
      end
      else if DataLabels[Index] = 'CNode' then
      begin
        Read(FImporter.FFile, C);
        AScreen.C := C;
      end
      else if DataLabels[Index] = 'BNode' then
      begin
        Read(FImporter.FFile, B);
        AScreen.B := B;
      end
      else if DataLabels[Index] = 'CWCNode' then
      begin
        Read(FImporter.FFile, CWC);
        AScreen.CWC := CWC;
      end
      else
      begin
//        ShowMessage(ALabel);
        Assert(False);
      end;
    end;
  finally
    DataLabels.Free;
  end;
end;

procedure TMnw2Importer.ReadACell(const ALabel: string);
var
  PP: Double;
  CWC: Double;
  B: Double;
  C: Double;
  P: Double;
  Rskin: Double;
  Kskin: Double;
  Rw: Double;
  IC: Integer;
  IR: Integer;
  IL: Integer;
  Index: Integer;
  DataLabels: TStringList;
  ACell: TMnw2WellCell;
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Inc(AWell.FCurrentCell);
  ACell := AWell.FCells[AWell.FCurrentCell];
//  ACell.Rw := AWell.Rw;
//  ACell.Rskin := AWell.Rskin;
//  ACell.Kskin := AWell.Kskin;
//  ACell.B := AWell.B;
//  ACell.C := AWell.C;
//  ACell.P := AWell.P;
//  ACell.CWC := AWell.CWC;

  DataLabels := TStringList.Create;
  try
    DataLabels.Delimiter := ',';
    // Remove colon from ALabel and split.
    DataLabels.DelimitedText := Copy(ALabel, 1, Length(ALabel) - 1);
    for Index := 0 to DataLabels.Count - 1 do
    begin
      if DataLabels[Index] = 'IL' then
      begin
        Read(FImporter.FFile, IL);
        ACell.IL := IL;
      end
      else if DataLabels[Index] = 'IR' then
      begin
        Read(FImporter.FFile, IR);
        ACell.IR := IR;
      end
      else if DataLabels[Index] = 'IC' then
      begin
        Read(FImporter.FFile, IC);
        ACell.IC := IC;
      end
      else if DataLabels[Index] = 'RwNode' then
      begin
        Read(FImporter.FFile, Rw);
        ACell.Rw := Rw;
      end
      else if DataLabels[Index] = 'KskinNode' then
      begin
        Read(FImporter.FFile, Kskin);
        ACell.Kskin := Kskin;
      end
      else if DataLabels[Index] = 'RskinNode' then
      begin
        Read(FImporter.FFile, Rskin);
        ACell.Rskin := Rskin;
      end
      else if DataLabels[Index] = 'PNode' then
      begin
        Read(FImporter.FFile, P);
        ACell.P := P;
      end
      else if DataLabels[Index] = 'CNode' then
      begin
        Read(FImporter.FFile, C);
        ACell.C := C;
      end
      else if DataLabels[Index] = 'BNode' then
      begin
        Read(FImporter.FFile, B);
        ACell.B := B;
      end
      else if DataLabels[Index] = 'CWCNode' then
      begin
        Read(FImporter.FFile, CWC);
        ACell.CWC := CWC;
      end
      else if DataLabels[Index] = 'PP' then
      begin
        Read(FImporter.FFile, PP);
        ACell.PP := PP;
      end
      else
      begin
//        ShowMessage(ALabel);
        Assert(False);
      end;
    end;
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  finally
    DataLabels.Free;
  end;
end;

procedure TMnw2Importer.ReadSpecifyCwcData;
var
  CWC: Double;
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, CWC);
  FImporter.UpdateProgress;
  AWell.CWC := CWC;
end;

procedure TMnw2Importer.ReadEquationData;
var
  Rw: Double;
  B: Double;
  C: Double;
  P: Double;
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, Rw, B, C, P);
  FImporter.UpdateProgress;
  AWell.Rw := Rw;
  AWell.B := B;
  AWell.C := C;
  AWell.P := P;
end;

procedure TMnw2Importer.ReadSkinData;
var
  Kskin: Double;
  Rskin: Double;
  Rw: Double;
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, Rw, Rskin, Kskin);
  FImporter.UpdateProgress;
  AWell.Rw := Rw;
  AWell.Rskin := Rskin;
  AWell.Kskin := Kskin;
end;

procedure TMnw2Importer.ReadThiemData;
var
  AWell: TMnw2Well;
  Rw: double;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, Rw);
  FImporter.UpdateProgress;
  AWell.Rw := Rw;
end;

procedure TMnw2Importer.ReadFlags;
var
  AWell: TMnw2Well;
  PUMPCAP: integer;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, AWell.PUMPLOC, AWell.Qlimit, AWell.PPFLAG, PUMPCAP);
  FImporter.UpdateProgress;
  AWell.PUMPCAP := PUMPCAP;
end;

procedure TMnw2Importer.ReadLossType;
var
  LOSSTYPE: string;
  AWell: TMnw2Well;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, LOSSTYPE);
  FImporter.UpdateProgress;
  LOSSTYPE := UpperCase(Trim(LOSSTYPE));
  if LOSSTYPE = 'NONE' then
  begin
    AWell.LossType := mltNone;
  end
  else if LOSSTYPE = 'THIEM' then
  begin
    AWell.LossType := mltThiem;
  end
  else if LOSSTYPE = 'SKIN' then
  begin
    AWell.LossType := mltSkin;
  end
  else if LOSSTYPE = 'GENERAL' then
  begin
    AWell.LossType := mltEquation;
  end
  else if LOSSTYPE = 'SPECIFYCWC' then
  begin
    AWell.LossType := mtlSpecify;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TMnw2Importer.ReadNumberOfNodes;
var
  AWell: TMnw2Well;
  NNodes: Integer;
begin
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, NNodes);
  FImporter.UpdateProgress;
  AWell.NNodes := NNodes;
end;

procedure TMnw2Importer.ReadWellId;
var
  AWell: TMnw2Well;
begin
  Inc(FCurrentWell);
  AWell := FWells[FCurrentWell];
  Readln(FImporter.FFile, AWell.WellId);
  FImporter.UpdateProgress;
  AWell.WellId := Trim(AWell.WellId);
end;

procedure TMnw2Importer.ReadAuxiliary;
var
  Auxiliary: string;
begin
  Readln(FImporter.FFile, Auxiliary);
  FImporter.UpdateProgress;
end;

procedure TMnw2Importer.ReadDataSet1;
var
  MNWMAX: integer;
//  IWL2CB: Integer;
begin
  Readln(FImporter.FFile, MNWMAX, DummyInteger, MNWPRNT); // IWL2CB
  FImporter.UpdateProgress;
  FWells.ArrayLength := MNWMAX;
  FCurrentWell := -1;
end;

procedure TMnw2Importer.HandlePackage;
const
  ScreenObjectNameRoot = 'ImportedMnw2_';
var
  WellIndex: Integer;
  AWell: TMnw2Well;
  AScreenObject: TScreenObject;
  APoint: TPoint2D;
  APoint3D: T3DRealPoint;
  Target: TTargetLocation;
  LiftIndex: Integer;
  Mnw2LiftItem: TMnw2PumpTableItem;
  LiftItem: TLiftItem;
  MnwStressPeriod: TMnw2WellStressPeriod;
  StressPeriodIndex: Integer;
  StressPeriod: TModflowStressPeriod;
  TimeItem: TMnw2TimeItem;
  ObsWell: TMnwiItem;
  Layer: Integer;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  FMnw2Package := FModel.ModflowPackages.Mnw2Package;
  FMnw2Package.IsSelected := True;
  FMnw2Package.Comments := FComments;
  if MNWPRNT < 0 then
  begin
    MNWPRNT := 0;
  end;
  if MNWPRNT > 2 then
  begin
    MNWPRNT := 2;
  end;
  FMnw2Package.PrintOption := TMnw2PrintOption(MNWPRNT);

  FMnw2Package.CreateWellFile := FMnwiImporter.Wel1flag <> 0;
  FMnw2Package.SummarizeByWell := FMnwiImporter.QSUMflag <> 0;
  FMnw2Package.SummarizeByNode := FMnwiImporter.BYNDflag <> 0;


  for WellIndex := 0 to FWells.ArrayLength - 1 do
  begin
    AWell := FWells[WellIndex];

    AScreenObject := CreateScreenObject(ScreenObjectNameRoot
      + IntToStr(WellIndex+1));
    AScreenObject.SetValuesOfEnclosedCells := False;
    AScreenObject.SetValuesOfIntersectedCells := True;
    AScreenObject.CreateMnw2Boundary;

    AScreenObject.ModflowMnw2Boundary.WellID := AWell.WellId;

    ObsWell := FMnwiImporter.GetWellByName(AWell.WellId);
    if ObsWell <> nil then
    begin
      AScreenObject.ModflowMnw2Boundary.SaveMnwiInfo := True;
      AScreenObject.ModflowMnw2Boundary.SaveExternalFlows :=
        ObsWell.QNDflag <> 0;
      AScreenObject.ModflowMnw2Boundary.SaveInternalFlows :=
        ObsWell.QBHflag <> 0
    end;

    AScreenObject.ModflowMnw2Boundary.LossType := AWell.LossType;
    AScreenObject.ModflowMnw2Boundary.SpecifyPump := AWell.PUMPLOC <> 0;
    if AWell.PUMPLOC < 0 then
    begin
      AScreenObject.ModflowMnw2Boundary.PumpElevation := AWell.Zpump;
    end;
    if AWell.PUMPLOC > 0 then
    begin
      APoint := FGrid.TwoDElementCenter(AWell.PUMPCOL-1, AWell.PUMPROW-1);
      Layer := FModel.ModflowLayerToDataSetLayer(AWell.PUMPLAY);
      APoint3D := FGrid.ThreeDElementCenter(ZeroBasedID(Layer,
        AWell.PUMPROW-1, AWell.PUMPCOL-1));

      AScreenObject.ModflowMnw2Boundary.PumpCellTarget.TargetType:= ttLocation;

      Target := TTargetLocation.Create(nil);
      try
        Target.X := APoint.X;
        Target.Y := APoint.Y;
        Target.Z := APoint3D.Z;
        AScreenObject.ModflowMnw2Boundary.
          PumpCellTarget.TargetLocation := Target;
        AScreenObject.ModflowMnw2Boundary.PumpElevation := APoint3D.Z;
      finally
        Target.Free;
      end;
    end;
    AScreenObject.ModflowMnw2Boundary.ConstrainPumping := AWell.Qlimit <> 0;
    AScreenObject.ModflowMnw2Boundary.PartialPenetrationCorrection :=
      AWell.PPFLAG > 0;
    AScreenObject.ModflowMnw2Boundary.AdjustPumping := AWell.PUMPCAP > 0;
    if AWell.PUMPCAP > 0 then
    begin
      AScreenObject.ModflowMnw2Boundary.ReferenceHead := AWell.Hlift;
      AScreenObject.ModflowMnw2Boundary.MaximumLift := AWell.LIFTq0;
      AScreenObject.ModflowMnw2Boundary.LiftAtMaxRate := AWell.LIFTqdes;
      AScreenObject.ModflowMnw2Boundary.WellTolerance := AWell.HWtol;
      AScreenObject.ModflowMnw2Boundary.LiftValues.Capacity :=
        AWell.FPumpTable.ArrayLength;
      for LiftIndex := 0 to AWell.FPumpTable.ArrayLength - 1 do
      begin
        Mnw2LiftItem := AWell.FPumpTable[LiftIndex];
        LiftItem := AScreenObject.ModflowMnw2Boundary.LiftValues.Add
          as TLiftItem;
        LiftItem.Lift := Mnw2LiftItem.LIFTn;
        LiftItem.Q := Mnw2LiftItem.Qn;
      end;
    end;

    if AWell.FCells <> nil then
    begin
      AssignCells(AScreenObject, AWell);
    end
    else
    begin
      AssignScreens(AScreenObject, AWell);
    end;

    Assert(AWell.FStressPeriods.ArrayLength =
      FModel.ModflowStressPeriods.Count);
    AScreenObject.ModflowMnw2Boundary.TimeValues.Capacity :=
      AWell.FStressPeriods.ArrayLength;
    TimeItem := nil;
    for StressPeriodIndex := 0 to AWell.FStressPeriods.ArrayLength - 1 do
    begin
      MnwStressPeriod := AWell.FStressPeriods[StressPeriodIndex];
      StressPeriod := FModel.ModflowStressPeriods[StressPeriodIndex];
      case MnwStressPeriod.WellState of
        wsInactive:
          begin
            TimeItem := nil;
          end;
        wsActive:
          begin
            TimeItem := AScreenObject.ModflowMnw2Boundary.TimeValues.Add
              as TMnw2TimeItem;
            TimeItem.StartTime := StressPeriod.StartTime;
            TimeItem.EndTime := StressPeriod.EndTime;
            TimeItem.PumpingRate := FortranFloatToStr(MnwStressPeriod.QDes);
            TimeItem.HeadCapacityMultiplier :=
              FortranFloatToStr(MnwStressPeriod.CapMult);
            TimeItem.LimitingWaterLevel := FortranFloatToStr(MnwStressPeriod.Hlim);
            TimeItem.InactivationPumpingRate :=
              FortranFloatToStr(MnwStressPeriod.Qfrcmn);
            TimeItem.ReactivationPumpingRate :=
              FortranFloatToStr(MnwStressPeriod.Qfrcmx);
            if MnwStressPeriod.QCUT > 0 then
            begin
              TimeItem.LimitMethod := mlmRate;
            end
            else if MnwStressPeriod.QCUT < 0 then
            begin
              TimeItem.LimitMethod := mlmFraction;
            end
            else
            begin
              TimeItem.LimitMethod := mlmNoMinimum;
            end;
          end;
        wsReuse:
          begin
            if TimeItem <> nil then
            begin
              TimeItem.EndTime := StressPeriod.EndTime;
            end;
          end
        else Assert(False);
      end;
    end;
  end;

end;

procedure TMnw2Importer.ReadData(const ALabel: string);
var
  AWell: TMnw2Well;
  StressPeriod: TMnw2WellStressPeriod;
  DataItems: TStringList;
  Index: Integer;
begin
  if ALabel = 'MNWMAX, IWL2CB, MNWPRNT:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'MNWAUX(NAUX):' then
  begin
    ReadAuxiliary;
  end
  else if ALabel = 'WELLID(MNWID):' then
  begin
    ReadWellId;
  end
  else if ALabel = 'NNODES:' then
  begin
    ReadNumberOfNodes;
  end
  else if ALabel = 'LOSSTYPE:' then
  begin
    ReadLossType;
  end
  else if ALabel = 'PUMPLOC,Qlimit,PPFLAG,PUMPCAP:' then
  begin
    ReadFlags;
  end
  else if ALabel = 'Rw:' then
  begin
    ReadThiemData;
  end
  else if ALabel = 'Rw,Rskin,Kskin:' then
  begin
    ReadSkinData;
  end
  else if ALabel = 'Rw,B,C,P:' then
  begin
    ReadEquationData;
  end
  else if ALabel = 'CWC:' then
  begin
    ReadSpecifyCwcData;
  end
  else if Pos('IL,IR,IC', ALabel) = 1 then
  begin
    ReadACell(ALabel);
  end
  else if Pos('Ztop,Zbotm,IR,IC', ALabel) = 1 then
  begin
    ReadAWellScreen(ALabel);
  end
  else if ALabel = 'PUMPLAY,PUMPROW,PUMPCOL:' then
  begin
    ReadPumpCell;
  end
  else if ALabel = 'Zpump:' then
  begin
    ReadPumpZ;
  end
  else if ALabel = 'Hlim,QCUT,Qfrcmn,Qfrcmx:' then
  begin
    ReadFullPumpLimits;
  end
  else if ALabel = 'Hlim,QCUT:' then
  begin
    ReadPartialPumpLimits;
  end
  else if ALabel = 'Hlift,LIFTq0,LIFTqdes,HWtol:' then
  begin
    ReadLiftTableLimits;
  end
  else if ALabel = 'Liftn,Qn:' then
  begin
    ReadLiftTableItem;
  end
  else if ALabel = 'ITMP:' then
  begin
    ReadItmp;
  end
  else if ALabel = 'WELLNAME:' then
  begin
    ReadWellForCurrentStressPeriod;
  end
  else if Pos('Qdes',ALabel) = 1 then
  begin
    AWell := FWells.FCurrentWell;
    StressPeriod := AWell.FStressPeriods[FCurrentStressPeriod];
    DataItems := TStringList.Create;
    try
      DataItems.Delimiter := ',';
      DataItems.DelimitedText := Copy(ALabel, 1, Length(ALabel)-1);
      for Index := 0 to DataItems.Count - 1 do
      begin
        if DataItems[Index] = 'Qdes' then
        begin
          Read(FImporter.FFile, StressPeriod.Qdes);
        end
        else if DataItems[Index] = 'CapMult' then
        begin
          Read(FImporter.FFile, StressPeriod.CapMult);
        end
        else if DataItems[Index] = 'Cprime' then
        begin
          break;
        end
        else if DataItems[Index] = 'AUX' then
        begin
          break;
        end
        else
        begin
//          ShowMessage(ALabel);
          Assert(False);
        end;
      end;
    finally
      DataItems.Free;
    end;
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else
  begin
//    ShowMessage(ALabel);
    Assert(False);
  end;
end;

{ TMnw2WellArray }

function TMnw2WellArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMnw2Well;
end;

function TMnw2WellArray.GetWell(Index: integer): TMnw2Well;
begin
  result := TMnw2Well(Objects[Index]);
end;

function TMnw2WellArray.GetWellByName(const AWellId: string): TMnw2Well;
var
  Index: Integer;
  AWell: TMnw2Well;
begin
  result := nil;
  for Index := 0 to ArrayLength - 1 do
  begin
    AWell := Wells[Index];
    if SameText(AWellId, AWell.WellId) then
    begin
      FCurrentWell := AWell;
      result := FCurrentWell;
    end;
  end;
end;

{ TMnw2Well }

constructor TMnw2Well.Create;
begin
  inherited;
  FCurrentCell := -1;
  FCurrentScreen := -1;
  FCurrentPumpItem := -1;
  FStressPeriods:= TMnw2StressPeriodArray.Create;
end;

destructor TMnw2Well.Destroy;
begin
  FStressPeriods.Free;
  FCells.Free;
  FScreens.Free;
  FPumpTable.Free;
  inherited;
end;

procedure TMnw2Well.SetB(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].B := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].B := Value;
    end;
  end;
end;

procedure TMnw2Well.SetC(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].C := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].C := Value;
    end;
  end;
end;

procedure TMnw2Well.SetCWC(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].CWC := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].CWC := Value;
    end;
  end;
end;

procedure TMnw2Well.SetKskin(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].Kskin := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].Kskin := Value;
    end;
  end;
end;

procedure TMnw2Well.SetNNodes(const Value: integer);
begin
  FNNodes := Value;
  if FNNodes > 0 then
  begin
    if FCells = nil then
    begin
      FCells := TMnw2CellArray.Create;
    end;
    FCells.ArrayLength := FNNodes;
  end
  else
  begin
    if FScreens = nil then
    begin
      FScreens := TMnw2ScreenArray.Create;
    end;
    FScreens.ArrayLength := -FNNodes;
  end;
end;

procedure TMnw2Well.SetP(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].P := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].P := Value;
    end;
  end;
end;

procedure TMnw2Well.SetPUMPCAP(const Value: integer);
begin
  FPUMPCAP := Value;
  if FPUMPCAP > 0 then
  begin
    if FPumpTable = nil then
    begin
      FPumpTable := TMnw2PumpTableArray.Create;
    end;
    FPumpTable.ArrayLength := FPUMPCAP;
  end
  else
  begin
    FreeAndNil(FPumpTable);
  end;
end;

procedure TMnw2Well.SetRskin(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].Rskin := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].Rskin := Value;
    end;
  end;
end;

procedure TMnw2Well.SetRw(const Value: double);
var
  Index: Integer;
begin
  if FCells <> nil then
  begin
    for Index := 0 to FCells.ArrayLength - 1 do
    begin
      FCells[Index].Rw := Value;
    end;
  end;
  if FScreens <> nil then
  begin
    for Index := 0 to FScreens.ArrayLength - 1 do
    begin
      FScreens[Index].Rw := Value;
    end;
  end;
end;

{ TMnw2CellArray }

function TMnw2CellArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMnw2WellCell;
end;

function TMnw2CellArray.GetCell(Index: integer): TMnw2WellCell;
begin
  result := TMnw2WellCell(Objects[Index]);
end;

{ TMnw2ScreenArray }

function TMnw2ScreenArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMnw2WellScreen;
end;

function TMnw2ScreenArray.GetScreen(Index: integer): TMnw2WellScreen;
begin
  result := TMnw2WellScreen(Objects[Index]);
end;

{ TMnw2PumpTableArray }

function TMnw2PumpTableArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMnw2PumpTableItem;
end;

function TMnw2PumpTableArray.GetItem(Index: integer): TMnw2PumpTableItem;
begin
  result := TMnw2PumpTableItem(Objects[Index]);
end;

{ TMnw2StressPeriodArray }

function TMnw2StressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMnw2WellStressPeriod;
end;

function TMnw2StressPeriodArray.GetStressPeriod(
  Index: integer): TMnw2WellStressPeriod;
begin
  result := TMnw2WellStressPeriod(Objects[Index]);
end;

{ TBcfImporter }

procedure TArrayImporter.CheckPositiveArrayValues(Values: T3DDoubleArray;
  ConstantRecordArray: TRealConstantRecordArray; Name: string;
  Bas: TBasImporter);
var
  LayerIndex: Integer;
  RowIndex: Integer;
  LayerArray: T2DDoubleArray;
  ColIndex: Integer;
  Active: T2DIntArray;
  ModelLayer: Integer;
  ErrorMessage: string;
begin
  ErrorMessage := Format(StrSIsNegativeOrZe, [Name]);
  for LayerIndex := 0 to Length(ConstantRecordArray) - 1 do
  begin
    if not ConstantRecordArray[LayerIndex].IsConstant then
    begin
      if LayerIndex < Length(Values) then
      begin
        ModelLayer := frmGoPhast.PhastModel.ModflowLayerToDataSetLayer(LayerIndex+1);
        LayerArray := Values[LayerIndex];
        Active := Bas.FIbound[LayerIndex];
        for RowIndex := 0 to Length(LayerArray) - 1 do
        begin
          for ColIndex := 0 to Length(LayerArray[0]) - 1 do
          begin
            if Active[RowIndex,ColIndex] <> 0 then
            begin
              if LayerArray[RowIndex,ColIndex] <= 0 then
              begin
                frmErrorsAndWarnings.AddWarning(frmGoPhast.PhastModel,
                  ErrorMessage, Format(Str0d1d2d3,
                  [ModelLayer+1, RowIndex+1, ColIndex+1,
                  LayerArray[RowIndex,ColIndex]]));
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TBcfImporter.CheckPositiveVcont(Values: T3DDoubleArray;
  ConstantRecordArray: TRealConstantRecordArray; Name: string;
  Bas: TBasImporter);
var
  LayerIndex: Integer;
  RowIndex: Integer;
  LayerArray: T2DDoubleArray;
  ColIndex: Integer;
  Active: T2DIntArray;
  ActiveBelow: T2DIntArray;
  ModelLayer: Integer;
  ErrorMessage: string;
begin
  ErrorMessage := Format(StrSIsNegativeOrZe, [Name]);
  for LayerIndex := 0 to Length(ConstantRecordArray) - 2 do
  begin
    if not ConstantRecordArray[LayerIndex].IsConstant then
    begin
      ModelLayer := frmGoPhast.PhastModel.ModflowLayerToDataSetLayer(LayerIndex+1);
      LayerArray := Values[LayerIndex];
      Active := Bas.FIbound[LayerIndex];
      ActiveBelow := Bas.FIbound[LayerIndex+1];
      for RowIndex := 0 to Length(LayerArray) - 1 do
      begin
        for ColIndex := 0 to Length(LayerArray[0]) - 1 do
        begin
          if (Active[RowIndex,ColIndex] <> 0)
            and (ActiveBelow[RowIndex,ColIndex] <> 0) then
          begin
            if LayerArray[RowIndex,ColIndex] <= 0 then
            begin
              frmErrorsAndWarnings.AddWarning(frmGoPhast.PhastModel,
                ErrorMessage, Format(Str0d1d2d3,
                [ModelLayer+1, RowIndex+1, ColIndex+1,
                LayerArray[RowIndex,ColIndex]]));
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TBcfImporter.ConvertConfinedStorageToSpecificStorage;
var
  LayerIndex: Integer;
  Layer: Integer;
  LayerGroup: TLayerGroup;
  DisImporter: TDisImporter;
  RowIndex: Integer;
  ColIndex: Integer;
  ConfinedStorage: Double;
  LayerThickness: Double;
begin
  if (FConfinedStorage = nil) and (FConfinedStorage_Const = nil) then
  begin
    Exit;
  end;
  DisImporter := FBas.FDis;
  SetLength(FSpecificStorage, NLAY);
  SetLength(FSpecificStorage_Const, NLAY);
  for LayerIndex := 0 to NLAY - 1 do
  begin
    FSpecificStorage_Const[LayerIndex].IsConstant := False;
  end;
  for LayerIndex := 0 to NLAY - 1 do
  begin
    Layer := FModel.ModflowLayerToDataSetLayer(LayerIndex + 1);
    LayerGroup := FModel.LayerStructure[Layer + 1];
    if LayerGroup.AquiferType in [0,2,3] then
    begin
      if FConfinedStorage_Const[LayerIndex].IsConstant
        and DisImporter.IsConstLayerThickness[Layer] then
      begin
        FSpecificStorage_Const[LayerIndex].IsConstant := True;
        FSpecificStorage_Const[LayerIndex].RealValue :=
          FConfinedStorage_Const[LayerIndex].RealValue
          / DisImporter.ConstLayerThickness[Layer];
      end
      else
      begin
        SetLength(FSpecificStorage[LayerIndex], DisImporter.NROW, DisImporter.NCOL);
        for RowIndex := 0 to DisImporter.NROW - 1 do
        begin
          for ColIndex := 0 to DisImporter.NCOL - 1 do
          begin
            if FConfinedStorage_Const[LayerIndex].IsConstant then
            begin
              ConfinedStorage := FConfinedStorage_Const[LayerIndex].RealValue;
            end
            else
            begin
              ConfinedStorage := FConfinedStorage[LayerIndex, RowIndex, ColIndex];
            end;

            if DisImporter.IsConstLayerThickness[Layer] then
            begin
              LayerThickness := DisImporter.ConstLayerThickness[Layer]
            end
            else
            begin
              LayerThickness :=
                DisImporter.VariableLayerThickness[Layer, RowIndex, ColIndex]
            end;

            FSpecificStorage[LayerIndex, RowIndex, ColIndex] :=
              ConfinedStorage/LayerThickness;
          end;
        end
      end;
    end;
  end;
end;

procedure TBcfImporter.ConvertTranToKx;
var
  LayerIndex: Integer;
  Layer: Integer;
  LayerGroup: TLayerGroup;
  DisImporter: TDisImporter;
  Trans: Double;
  RowIndex: Integer;
  ColIndex: Integer;
  LayerThickness: Double;
begin
  DisImporter := FBas.FDis;
  if FHY_Const = nil then
  begin
    SetLength(FHY_Const, NLAY);
    for LayerIndex := 0 to NLAY - 1 do
    begin
      FHY_Const[LayerIndex].IsConstant := False;
    end;
  end;
  if FHY = nil then
  begin
    SetLength(FHY, NLAY);
  end;
  for LayerIndex := 0 to NLAY - 1 do
  begin
    Layer := FModel.ModflowLayerToDataSetLayer(LayerIndex + 1);
    LayerGroup := FModel.LayerStructure[Layer + 1];
    if LayerGroup.AquiferType in [0,2] then
    begin
      if FTran_Const[LayerIndex].IsConstant and
        DisImporter.IsConstLayerThickness[Layer] then
      begin
        FHY_Const[LayerIndex].IsConstant := True;
        FHY_Const[LayerIndex].RealValue :=
          FTran_Const[LayerIndex].RealValue
          / DisImporter.ConstLayerThickness[Layer];
      end
      else
      begin
        FHY_Const[LayerIndex].IsConstant := False;
        SetLength(FHY[LayerIndex], DisImporter.NROW, DisImporter.NCOL);
        for RowIndex := 0 to DisImporter.NROW - 1 do
        begin
          for ColIndex := 0 to DisImporter.NCOL - 1 do
          begin
            if FTran_Const[LayerIndex].IsConstant then
            begin
              Trans := FTran_Const[LayerIndex].RealValue;
            end
            else
            begin
              Trans := FTran[LayerIndex, RowIndex, ColIndex];
            end;

            if DisImporter.IsConstLayerThickness[Layer] then
            begin
              LayerThickness := DisImporter.ConstLayerThickness[Layer]
            end
            else
            begin
              LayerThickness :=
                DisImporter.VariableLayerThickness[Layer, RowIndex, ColIndex]
            end;

            FHY[LayerIndex, RowIndex, ColIndex] := Trans/LayerThickness;
          end;
        end;
      end;
    end;
  end;
end;

constructor TBcfImporter.Create(Importer: TModflow2005Importer; Bas: TBasImporter);
begin
  inherited Create(Importer, 'BCF:');
  FBas := Bas;
  FIsSelected := False;
  FTransientModel := False;
end;

procedure TBcfImporter.ImportDataSets2And3;
var
  LayerIndex: Integer;
  Layer: Integer;
  LayerGroup: TLayerGroup;
begin
  Assert(Length(LAYCON) = Length(TRPY));
  for LayerIndex := 0 to Length(LAYCON) - 1 do
  begin
    Layer := FModel.ModflowLayerToDataSetLayer(LayerIndex + 1);
    LayerGroup := FModel.LayerStructure[Layer + 1];
    LayerGroup.AquiferType := LAYCON[LayerIndex] mod 10;
    LayerGroup.InterblockTransmissivityMethod := LAYCON[LayerIndex] div 10;
    LayerGroup.HorizontalAnisotropy := TRPY[LayerIndex];
  end;
end;

procedure TBcfImporter.ImportDataSet1;
begin
  FModel.ModflowOptions.HDry := HDRY;
  FModel.ModflowWettingOptions.WettingActive := IWDFLG <> 0;
  if FModel.ModflowWettingOptions.WettingActive then
  begin
    FModel.ModflowWettingOptions.WettingFactor := WETFCT;
    FModel.ModflowWettingOptions.WettingIterations := IWETIT;
    FModel.ModflowWettingOptions.WettingEquation := IHDWET;
  end;
end;

procedure TBcfImporter.ReadConstantArrays;
var
  ConstArray: TRealConstantRecordArray;
  Value: Double;
  Layer: Integer;
  ID: string;
  AquiferType: Integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  Dec(Layer);
  if ID = StrPRIMARYSTORAGECOEF then
  begin
    Assert(FTransientModel);
    AquiferType := LAYCON[Layer] mod 10;

    if AquiferType = 1 then
    begin
      InitializeContArray(FSpecificYield_Const);
      ConstArray := FSpecificYield_Const;
    end
    else
    begin
      InitializeContArray(FConfinedStorage_Const);
      ConstArray := FConfinedStorage_Const;
    end;
  end
  else if ID = StrTRANSMISALONGROWS then
  begin
    InitializeContArray(FTran_Const);
    ConstArray := FTran_Const;
  end
  else if ID = StrHYDCONDALONGROW then
  begin
    InitializeContArray(FHY_Const);
    ConstArray := FHY_Const;
  end
  else if ID = StrVERTHYDCONDTHICK then
  begin
    InitializeContArray(FVcont_Const);
    ConstArray := FVcont_Const;
  end
  else if ID = StrSECONDARYSTORAGECO then
  begin
    InitializeContArray(FSpecificYield_Const);
    ConstArray := FSpecificYield_Const;
  end
  else if ID = StrWETDRYPARAMETER then
  begin
    InitializeContArray(FWetDry_Const);
    ConstArray := FWetDry_Const;
  end
  else
  begin
    Assert(False);
  end;
  ConstArray[Layer].IsConstant := True;
  ConstArray[Layer].RealValue := Value;
end;

procedure TBcfImporter.ReadVariableArrays;
var
  ID: string;
  Layer: Integer;
  ConstArray: TRealConstantRecordArray;
  ThreeDArray: T3DDoubleArray;
  AquiferType: Integer;
  ArrayName: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  if ID = StrPRIMARYSTORAGECOEF then
  begin
    Assert(FTransientModel);
    AquiferType := LAYCON[Layer] mod 10;
    if AquiferType = 1 then
    begin
      InitializeContArray(FSpecificYield_Const);
      Initialize3DArray(FSpecificYield);
      ThreeDArray := FSpecificYield;
      ConstArray := FSpecificYield_Const;
      ArrayName := 'Primary Storage coefficient';
    end
    else
    begin
      InitializeContArray(FConfinedStorage_Const);
      Initialize3DArray(FConfinedStorage);
      ThreeDArray := FConfinedStorage;
      ConstArray := FConfinedStorage_Const;
      ArrayName := 'Confined Storage coefficient';
    end;
  end
  else if ID = StrTRANSMISALONGROWS then
  begin
    InitializeContArray(FTran_Const);
    Initialize3DArray(FTran);
    ThreeDArray := FTran;
    ConstArray := FTran_Const;
    ArrayName := 'Transmissivity';
  end
  else if ID = StrHYDCONDALONGROW then
  begin
    InitializeContArray(FHY_Const);
    Initialize3DArray(FHY);
    ThreeDArray := FHY;
    ConstArray := FHY_Const;
    ArrayName := 'Hydraulic Conductivity';
  end
  else if ID = StrVERTHYDCONDTHICK then
  begin
    InitializeContArray(FVcont_Const);
    Initialize3DArray(FVcont);
    ThreeDArray := FVcont;
    ConstArray := FVcont_Const;
    ArrayName := 'Vertical Conductance';
  end
  else if ID = StrSECONDARYSTORAGECO then
  begin
    Assert(FTransientModel);
    InitializeContArray(FSpecificYield_Const);
    Initialize3DArray(FSpecificYield);
    ThreeDArray := FSpecificYield;
    ConstArray := FSpecificYield_Const;
    ArrayName := 'Secondary Storage coefficient';
  end
  else if ID = StrWETDRYPARAMETER then
  begin
    InitializeContArray(FWetDry_Const);
    Initialize3DArray(FWetDry);
    ThreeDArray := FWetDry;
    ConstArray := FWetDry_Const;
    ArrayName := 'WetDry';
  end
  else
  begin
    Assert(False);
  end;
  if ThreeDArray[Layer] = nil then
  begin
    SetLength(ThreeDArray[Layer], FGrid.RowCount, FGrid.ColumnCount);
  end;
  Read2DRealArray(ThreeDArray[Layer], ArrayName);
  ConstArray[Layer].IsConstant := False;
end;

function TBcfImporter.ScreenObjectNameRoot: string;
begin
  result :=  '';
  Assert(False);
end;

procedure TBcfImporter.ReadConstantAnisotropy;
var
  TRPY_Const: Double;
  AName: string;
begin
  Readln(FImporter.FFile, AName);
  AName := Trim(AName);
  if AName = StrCOLUMNTOROWANISOT then
  begin
    Readln(FImporter.FFile, TRPY_Const);
    AssignConstant1DArray(TRPY, TRPY_Const);
    FImporter.UpdateProgress;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TBcfImporter.ReadVariableAnisotropy;
var
  AName: string;
begin
  Readln(FImporter.FFile, AName);
  AName := Trim(AName);
  if AName = StrCOLUMNTOROWANISOT then
  begin
    Read1DRealArray(TRPY);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TBcfImporter.Initialize3DArray(var ThreeDArray: T3DDoubleArray);
begin
  if ThreeDArray = nil then
  begin
    SetLength(ThreeDArray, NLAY);
  end;
end;

procedure TBcfImporter.InitializeContArray(
  var ConstArray: TRealConstantRecordArray);
var
  Index: Integer;
begin
  if ConstArray = nil then
  begin
    SetLength(ConstArray, NLay);
    InitializeConstArray(ConstArray);
    for Index := 0 to Length(ConstArray) - 1 do
    begin
      ConstArray[Index].IsConstant := True;
      ConstArray[Index].RealValue := 0;
    end;
  end;
end;

procedure TBcfImporter.ReadDataSet2;
var
  Index: Integer;
begin
  Readln(FImporter.FFile, NLAY);
  SetLength(LAYCON, NLAY);
  SetLength(TRPY, NLAY);
  for Index := 0 to NLAY - 1 do
  begin
    Read(FImporter.FFile, LAYCON[Index]);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TBcfImporter.ReadDataSet1;
//var
//  IBCFCB: Integer;
begin
  FIsSelected := True;
  Read(FImporter.FFile, DummyInteger); // IBCFCB
  Read(FImporter.FFile, HDRY);
  Read(FImporter.FFile, IWDFLG);
  Read(FImporter.FFile, WETFCT);
  Read(FImporter.FFile, IWETIT);
  Read(FImporter.FFile, IHDWET);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TBcfImporter.HandlePackage;
var
  BcfPackage: TModflowPackageSelection;
  PriorLayer: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
begin
  inherited;
  BcfPackage := FModel.ModflowPackages.BcfPackage;
  BcfPackage.IsSelected := FIsSelected;
  if FIsSelected then
  begin
    FModel.ModflowPackages.LpfPackage.IsSelected := False;
    FModel.ModflowPackages.HufPackage.IsSelected := False;
    FModel.ModflowPackages.UpwPackage.IsSelected := False;
    ImportDataSet1;
    ImportDataSets2And3;
    FModel.DataArrayManager.CreateInitialDataSets;

    ConvertConfinedStorageToSpecificStorage;

    CheckPositiveArrayValues(FConfinedStorage, FConfinedStorage_Const,
      StrConfinedStorageCoe, FBas);
    ImportDataSet(StrConfinedStorageCoe, StrConfinedStorageCoe,
      FConfinedStorage_Const, FConfinedStorage);

    ImportDataSet(rsSpecific_Storage, rsSpecific_Storage,
      FSpecificStorage_Const, FSpecificStorage);

    CheckPositiveArrayValues(FTran, FTran_Const, StrTransmissivity, FBas);
    ImportDataSet(StrTransmissivity, StrTransmissivity,
      FTran_Const, FTran);

    ConvertTranToKx;

    CheckPositiveArrayValues(FHY, FHY_Const, rsKx, FBas);
    ImportDataSet(rsKx, rsKx, FHY_Const, FHY);

    CheckPositiveArrayValues(FSpecificYield, FSpecificYield_Const,
      rsSpecificYield, FBas);
    ImportDataSet(rsSpecificYield, rsSpecificYield,
      FSpecificYield_Const, FSpecificYield);

    ImportDataSet(rsWetDry, rsWetDry, FWetDry_Const, FWetDry);
    if Length(FVcont_Const) > 1 then
    begin
      PriorLayer := Length(FVcont_Const)-2;
      Assert(FVcont_Const[Length(FVcont_Const)-1].IsConstant);
      if FVcont_Const[PriorLayer].IsConstant then
      begin
        FVcont_Const[Length(FVcont_Const)-1].RealValue
          := FVcont_Const[PriorLayer].RealValue
      end
      else
      begin
        FVcont_Const[Length(FVcont_Const)-1].IsConstant := False;
        SetLength(FVcont[PriorLayer+1], Length(FVcont[PriorLayer]),
          Length(FVcont[PriorLayer, 0]));
        for RowIndex := 0 to Length(FVcont[PriorLayer]) - 1 do
        begin
          for ColIndex := 0 to Length(FVcont[PriorLayer, 0]) - 1 do
          begin
            FVcont[PriorLayer+1, RowIndex, ColIndex]
              := FVcont[PriorLayer, RowIndex, ColIndex];
          end;
        end;
      end;
    end;

    CheckPositiveVcont(FVcont, FVcont_Const, StrVerticalConductance, FBas);
    ImportDataSet(StrVerticalConductance, StrVerticalConductance,
      FVcont_Const, FVcont);
  end;
end;

procedure TBcfImporter.ReadData(const ALabel: string);
var
  ISS: integer;
begin
  inherited;
  if ALabel = 'IBCFCB,HDRY,IWDFLG,WETFCT,IWETIT,IHDWET:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'ISS:' then
  begin
    Read(FImporter.FFile, ISS);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    FTransientModel := ISS = 0;
  end
  else if ALabel = 'LAYCON(I),I=1,NLAY:' then
  begin
    ReadDataSet2;
  end
  else if ALabel = StrConstant1DRealArray then
  begin
    ReadConstantAnisotropy;
  end
  else if ALabel = StrVariable1DRealArray then
  begin
    ReadVariableAnisotropy;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstantArrays;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableArrays;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TMnwiImporter }

constructor TMnwiImporter.Create(Importer: TModflow2005Importer;
  MnwImporter: TMnw2Importer);
begin
  inherited Create(Importer, 'MNWI');
  MnwImporter.FMnwiImporter := self;
  FMnwiArray := TMnwiArray.Create;
  FCurrentWell := -1;
  Wel1flag := 0;
  QSUMflag := 0;
  BYNDflag := 0;
end;

destructor TMnwiImporter.Destroy;
begin
  FMnwiArray.Free;
  inherited;
end;

function TMnwiImporter.GetWellByName(const AWellId: string): TMnwiItem;
begin
  result := FMnwiArray.GetWellByName(AWellId);
end;

procedure TMnwiImporter.HandlePackage;
begin
  if FImportedPackage then
  begin
    Exit;
  end;
  inherited;

end;

procedure TMnwiImporter.ReadData(const ALabel: string);
var
  MNWOBS: integer;
//  UNIT_Number: double;
//  CONCflag: double;
begin
  inherited;
  if ALabel = 'Wel1flag,QSUMflag,BYNDflag:' then
  begin
    Read(FImporter.FFile, Wel1flag);
    Read(FImporter.FFile, QSUMflag);
    Read(FImporter.FFile, BYNDflag);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'MNWOBS:' then
  begin
    Read(FImporter.FFile, MNWOBS);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
    FMnwiArray.ArrayLength := MNWOBS;
  end
  else if ALabel = 'WELLID UNIT QNDflag QBHflag CONCflag:' then
  begin
    Inc(FCurrentWell);
    Readln(FImporter.FFile, FMnwiArray[FCurrentWell].WellID);
    FMnwiArray[FCurrentWell].WellID := Trim(FMnwiArray[FCurrentWell].WellID);
    Read(FImporter.FFile, DummyDouble); // UNIT_Number
    Read(FImporter.FFile, FMnwiArray[FCurrentWell].QNDflag);
    Read(FImporter.FFile, FMnwiArray[FCurrentWell].QBHflag);
    Read(FImporter.FFile, DummyDouble); // CONCflag
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'WELLID UNIT QNDflag QBHflag:' then
  begin
    Inc(FCurrentWell);
    Readln(FImporter.FFile, FMnwiArray[FCurrentWell].WellID);
    FMnwiArray[FCurrentWell].WellID := Trim(FMnwiArray[FCurrentWell].WellID);
    Read(FImporter.FFile, DummyDouble); // UNIT_Number
    Read(FImporter.FFile, FMnwiArray[FCurrentWell].QNDflag);
    Read(FImporter.FFile, FMnwiArray[FCurrentWell].QBHflag);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else
  begin
    Assert(False)
  end;

end;

{ TMnwiArray }

function TMnwiArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMnwiItem;
end;

function TMnwiArray.GetItem(Index: integer): TMnwiItem;
begin
  result := TMnwiItem(Objects[Index]);
end;

function TMnwiArray.GetWellByName(const AWellId: string): TMnwiItem;
var
  Index: Integer;
begin
  result := nil;
  for Index := 0 to ArrayLength - 1 do
  begin
    if SameText(Items[Index].WellID, AWellId) then
    begin
      result := Items[Index];
      Exit;
    end;
  end;
end;

{ TSubImporter }

constructor TSubImporter.Create(Importer: TModflow2005Importer;
  NamImporter: TNamImporter);
begin
  inherited Create(Importer, 'SUB');
  FNamImporter := NamImporter;
  FDelayBeds := TSubLayerAssignments.Create;
  FNoDelayBeds := TSubLayerAssignments.Create;
  FMaterialZones := TMaterialZones.Create;
  FSubOutputs:= TSubOutputs.Create;
  FRnbIndex := -1;
  FNoDelayIndex := -1;
  FDelayIndex := -1;
end;

destructor TSubImporter.Destroy;
begin
  FSubOutputs.Free;
  FMaterialZones.Free;
  FNoDelayBeds.Free;
  FDelayBeds.Free;
  inherited;
end;

procedure TArrayImporter.GetTimeStepStartAndEndTimes(TimeStepEndLists: TList; TimeStepStartLists: TList);
var
  StepIndex: Integer;
  TimeStepEndTimes: TRealList;
  TimeStepStartTimes: TRealList;
  Time: Double;
  TimeStepLength: Double;
  StressPeriod: TModflowStressPeriod;
  PeriodIndex: Integer;
begin
  for PeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
  begin
    StressPeriod := FModel.ModflowStressPeriods[PeriodIndex];
    TimeStepStartTimes := TRealList.Create;
    TimeStepStartLists.Add(TimeStepStartTimes);
    TimeStepEndTimes := TRealList.Create;
    TimeStepEndLists.Add(TimeStepEndTimes);
    TimeStepLength := StressPeriod.LengthOfFirstTimeStep;
    Time := StressPeriod.StartTime;
    for StepIndex := 0 to StressPeriod.NumberOfSteps - 1 do
    begin
      TimeStepStartTimes.Add(Time);
      Time := Time + TimeStepLength;
      TimeStepEndTimes.Add(Time);
      TimeStepLength := TimeStepLength * StressPeriod.TimeStepMultiplier;
    end;
  end;
end;

procedure TSubImporter.ImportMaterialZone(DelayItem: TSubDelayBedLayerItem;
  Index: Integer; var ScreenObject: TScreenObject);
var
  VKDataArray: TDataArray;
  ElastSS: TDataArray;
  InelastSS: TDataArray;
  DataArrayName: string;
  ZoneNumber: Integer;
  ColIndex: Integer;
  RowIndex: Integer;
  ImportedValues: T2DDoubleArray;
  Zones: T2DIntArray;
//  DataArray: TDataArray;
  Zone: TMaterialZone;
begin
  VKDataArray := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.VerticalHydraulicConductivityDataArrayName);
  Assert(VKDataArray <> nil);

  ElastSS := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.ElasticSpecificStorageDataArrayName);
  Assert(ElastSS <> nil);

  InelastSS := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.InelasticSpecificStorageDataArrayName);
  Assert(InelastSS <> nil);
  if FConstNZ[Index].IsConstant then
  begin
    Zone := FMaterialZones[FConstNZ[Index].IntegerValue - 1];
    VKDataArray.Formula := FortranFloatToStr(Zone.VerticalHydraulicConductivity);
    ElastSS.Formula := FortranFloatToStr(Zone.ElasticSpecificStorage);
    InelastSS.Formula := FortranFloatToStr(Zone.InelasticSpecificStorage);
  end
  else
  begin
    Assert(FNZ <> nil);
    Zones := FNZ[Index];
    SetLength(ImportedValues, Length(Zones), Length(Zones[0]));
    for RowIndex := 0 to Length(Zones) - 1 do
    begin
      for ColIndex := 0 to Length(Zones[0]) - 1 do
      begin
        ZoneNumber := Zones[RowIndex, ColIndex];
        if (ZoneNumber < 1) or (ZoneNumber > FMaterialZones.ArrayLength) then
        begin
          ImportedValues[RowIndex, ColIndex] := 0;
        end
        else
        begin
          Zone := FMaterialZones[ZoneNumber-1];
          ImportedValues[RowIndex, ColIndex] :=
            Zone.VerticalHydraulicConductivity;
        end;
      end;
    end;
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + DelayItem.VerticalHydraulicConductivityDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, ImportedValues);
    VKDataArray.Formula := DataArrayName;

    for RowIndex := 0 to Length(Zones) - 1 do
    begin
      for ColIndex := 0 to Length(Zones[0]) - 1 do
      begin
        ZoneNumber := Zones[RowIndex, ColIndex];
        if (ZoneNumber < 1) or (ZoneNumber > FMaterialZones.ArrayLength) then
        begin
          ImportedValues[RowIndex, ColIndex] := 0;
        end
        else
        begin
          Zone := FMaterialZones[ZoneNumber-1];
          ImportedValues[RowIndex, ColIndex] := Zone.ElasticSpecificStorage;
        end;
      end;
    end;
    DataArrayName := 'Imported_'
      + DelayItem.ElasticSpecificStorageDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, ImportedValues);
    ElastSS.Formula := DataArrayName;

    for RowIndex := 0 to Length(Zones) - 1 do
    begin
      for ColIndex := 0 to Length(Zones[0]) - 1 do
      begin
        ZoneNumber := Zones[RowIndex, ColIndex];
        if (ZoneNumber < 1) or (ZoneNumber > FMaterialZones.ArrayLength) then
        begin
          ImportedValues[RowIndex, ColIndex] := 0;
        end
        else
        begin
          Zone := FMaterialZones[ZoneNumber-1];
          ImportedValues[RowIndex, ColIndex] := Zone.InelasticSpecificStorage;
        end;
      end;
    end;
    DataArrayName := 'Imported_'
      + DelayItem.InelasticSpecificStorageDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, ImportedValues);
    InelastSS.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportDZ(DelayItem: TSubDelayBedLayerItem;
  Index: Integer; var ScreenObject: TScreenObject);
var
  DataArrayName: string;
  DataArray: TDataArray;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.InterbedEquivalentThicknessDataArrayName);
  Assert(DataArray <> nil);
  if FConstDZ[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstDZ[Index].RealValue);
  end
  else
  begin
    Assert(FDZ <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + DelayItem.InterbedEquivalentThicknessDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FDZ[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportDCOM(DelayItem: TSubDelayBedLayerItem;
  Index: Integer; var ScreenObject: TScreenObject);
var
  DataArrayName: string;
  DataArray: TDataArray;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.InterbedStartingCompactionDataArrayName);
  Assert(DataArray <> nil);
  if FConstDCOM[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstDCOM[Index].RealValue);
  end
  else
  begin
    Assert(FDCOM <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + DelayItem.InterbedStartingCompactionDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FDCOM[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportDHC(DelayItem: TSubDelayBedLayerItem;
  Index: Integer; var ScreenObject: TScreenObject);
var
  DataArrayName: string;
  DataArray: TDataArray;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.InterbedPreconsolidationHeadDataArrayName);
  Assert(DataArray <> nil);
  if FConstDHC[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstDHC[Index].RealValue);
  end
  else
  begin
    Assert(FDHC <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + DelayItem.InterbedPreconsolidationHeadDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FDHC[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportDStart(DelayItem: TSubDelayBedLayerItem;
  Index: Integer; var ScreenObject: TScreenObject);
var
  DataArray: TDataArray;
  DataArrayName: string;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    DelayItem.InterbedStartingHeadDataArrayName);
  Assert(DataArray <> nil);
  if FConstDstart[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstDstart[Index].RealValue);
  end
  else
  begin
    Assert(FDstart <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_' + DelayItem.InterbedStartingHeadDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FDstart[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportRNB(DelayItem: TSubDelayBedLayerItem;
  Index: Integer; var ScreenObject: TScreenObject);
var
  DataArrayName: string;
  DataArray: TDataArray;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(DelayItem.EquivNumberDataArrayName);
  Assert(DataArray <> nil);
  if FConstRNB[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstRNB[Index].RealValue);
  end
  else
  begin
    Assert(FRNB <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_' + DelayItem.EquivNumberDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FRNB[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportCom(Index: Integer;
  NoDelayItem: TSubNoDelayBedLayerItem; var ScreenObject: TScreenObject);
var
  DataArray: TDataArray;
  DataArrayName: string;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    NoDelayItem.InitialCompactionDataArrayName);
  Assert(DataArray <> nil);
  if FConstCom[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstCom[Index].RealValue);
  end
  else
  begin
    Assert(FCom <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_' + NoDelayItem.InitialCompactionDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FCom[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportSfv(Index: Integer;
  NoDelayItem: TSubNoDelayBedLayerItem; var ScreenObject: TScreenObject);
var
  DataArray: TDataArray;
  DataArrayName: string;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    NoDelayItem.InelasticSkeletalStorageCoefficientDataArrayName);
  Assert(DataArray <> nil);
  if FConstSfv[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstSfv[Index].RealValue);
  end
  else
  begin
    Assert(FSfv <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + NoDelayItem.InelasticSkeletalStorageCoefficientDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FSfv[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportSfe(Index: Integer;
  NoDelayItem: TSubNoDelayBedLayerItem; var ScreenObject: TScreenObject);
var
  DataArray: TDataArray;
  DataArrayName: string;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    NoDelayItem.ElasticSkeletalStorageCoefficientDataArrayName);
  Assert(DataArray <> nil);
  if FConstSfe[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstSfe[Index].RealValue);
  end
  else
  begin
    Assert(FSfe <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + NoDelayItem.ElasticSkeletalStorageCoefficientDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FSfe[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportPreconsolidatonHead(Index: Integer;
  NoDelayItem: TSubNoDelayBedLayerItem; var ScreenObject: TScreenObject);
var
  DataArray: TDataArray;
  DataArrayName: string;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(
    NoDelayItem.PreconsolidationHeadDataArrayName);
  Assert(DataArray <> nil);
  if FConstHC[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(FConstHC[Index].RealValue);
  end
  else
  begin
    Assert(FHC <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_'
      + NoDelayItem.PreconsolidationHeadDataArrayName;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, FHC[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSubImporter.ImportPrintChoices(SubPackage: TSubPackageSelection);
var
  TimeStepEndTimes: TRealList;
  TimeStepStartTimes: TRealList;
  TimeStepEndLists: TList;
  TimeStepStartLists: TList;
  Defaults: array[0..12] of Boolean;
  Index: Integer;
  SubPrintItem: TSubPrintItem;
  SubOCItem: TSubOC;
  function GetBoolValue(OCIndex: integer): boolean;
  begin
    if SubOCItem.Ifl[OCIndex] < 0 then
    begin
      result := Defaults[OCIndex];
    end
    else if SubOCItem.Ifl[OCIndex] = 0 then
    begin
      result := False;
      Defaults[OCIndex] := result;
    end
    else
    begin
      result := True;
      Defaults[OCIndex] := result;
    end;
  end;
begin
  SubPackage.PrintChoices.Capacity := FSubOutputs.ArrayLength;
  for Index := 0 to 12 do
  begin
    Defaults[Index] := False;
  end;
  TimeStepStartLists := TObjectList.Create;
  TimeStepEndLists := TObjectList.Create;
  try
    GetTimeStepStartAndEndTimes(TimeStepEndLists, TimeStepStartLists);
    for Index := 0 to FSubOutputs.ArrayLength - 1 do
    begin
      SubOCItem := FSubOutputs[Index];
      SubPrintItem := SubPackage.PrintChoices.Add as TSubPrintItem;
      if SubOCItem.ISP1 < 1 then
      begin
        SubOCItem.ISP1 := 1;
      end;
      if SubOCItem.ISP1 > FModel.ModflowStressPeriods.Count then
      begin
        SubOCItem.ISP1 := FModel.ModflowStressPeriods.Count;
      end;
      if SubOCItem.ISP2 < 1 then
      begin
        SubOCItem.ISP2 := 1;
      end;
      if SubOCItem.ISP2 > FModel.ModflowStressPeriods.Count then
      begin
        SubOCItem.ISP2 := FModel.ModflowStressPeriods.Count;
      end;
      TimeStepStartTimes := TimeStepStartLists[SubOCItem.ISP1 - 1];
      TimeStepEndTimes := TimeStepEndLists[SubOCItem.ISP2 - 1];
      if SubOCItem.ITS1 < 1 then
      begin
        SubOCItem.ITS1 := 1;
      end;
      if SubOCItem.ITS1 > TimeStepStartTimes.Count then
      begin
        SubOCItem.ITS1 := TimeStepStartTimes.Count;
      end;
      if SubOCItem.ITS2 < 1 then
      begin
        SubOCItem.ITS2 := 1;
      end;
      if SubOCItem.ITS2 > TimeStepEndTimes.Count then
      begin
        SubOCItem.ITS2 := TimeStepEndTimes.Count;
      end;

      SubPrintItem.StartTime := TimeStepStartTimes[SubOCItem.ITS1 - 1];
      SubPrintItem.EndTime := TimeStepEndTimes[SubOCItem.ITS2 - 1];
      SubPrintItem.PrintSubsidence := GetBoolValue(0);
      SubPrintItem.SaveSubsidence := GetBoolValue(1);
      SubPrintItem.PrintCompactionByModelLayer := GetBoolValue(2);
      SubPrintItem.SaveCompactionByModelLayer := GetBoolValue(3);
      SubPrintItem.PrintCompactionByInterbedSystem := GetBoolValue(4);
      SubPrintItem.SaveCompactionByInterbedSystem := GetBoolValue(5);
      SubPrintItem.PrintVerticalDisplacement := GetBoolValue(6);
      SubPrintItem.SaveVerticalDisplacement := GetBoolValue(7);
      SubPrintItem.PrintCriticalHeadNoDelay := GetBoolValue(8);
      SubPrintItem.SaveCriticalHeadNoDelay := GetBoolValue(9);
      SubPrintItem.PrintCriticalHeadDelay := GetBoolValue(10);
      SubPrintItem.SaveCriticalHeadDelay := GetBoolValue(11);
      SubPrintItem.PrintDelayBudgets := GetBoolValue(12);
    end;
  finally
    TimeStepStartLists.Free;
    TimeStepEndLists.Free;
  end;
end;

function ConvertFormat(Ifm: integer): integer;
begin
  if Ifm = 0 then
  begin
    Ifm := 12;
  end;
  result := Abs(Ifm) -1;
end;

procedure TSubImporter.ImportPrintFormat(SubPackage: TSubPackageSelection);
begin
  SubPackage.PrintFormats.SubsidenceFormat
    := ConvertFormat(Ifm1);
  SubPackage.PrintFormats.CompactionByModelLayerFormat
    := ConvertFormat(Ifm2);
  SubPackage.PrintFormats.CompactionByInterbedSystemFormat
    := ConvertFormat(Ifm3);
  SubPackage.PrintFormats.VerticalDisplacementFormat
    := ConvertFormat(Ifm4);
  SubPackage.PrintFormats.NoDelayPreconsolidationHeadFormat
    := ConvertFormat(Ifm5);
  SubPackage.PrintFormats.DelayPreconsolidationHeadFormat
    := ConvertFormat(Ifm6);
end;

procedure TSubImporter.ImportDataSet1(SubPackage: TSubPackageSelection);
var
  FileName: string;
  Position: Integer;
begin
  SubPackage.NumberOfNodes := NN;
  SubPackage.AccelerationParameter1 := AC1;
  SubPackage.AccelerationParameter2 := AC2;
  SubPackage.MinIterations := ITMIN;
  SubPackage.SaveDelayRestart := IDSAVE > 0;
  if IDREST > 0 then
  begin
    Position := FNamImporter.FUnitNumbers.IndexOf(IDREST);
    Assert(Position >= 0);
    FileName := FNamImporter.FFileNames[Position];
    FileName := ExpandFileName(FileName);
    SubPackage.ReadDelayRestartFileName := FileName;
  end;
end;

procedure TSubImporter.ReadDataSet15;
//var
//  Iun6: Integer;
//  Iun5: Integer;
//  Iun4: Integer;
//  Iun3: Integer;
//  Iun2: Integer;
//  Iun1: Integer;
begin
  Read(FImporter.FFile, Ifm1);
  Read(FImporter.FFile, DummyInteger); // Iun1
  Read(FImporter.FFile, Ifm2);
  Read(FImporter.FFile, DummyInteger); // Iun2
  Read(FImporter.FFile, Ifm3);
  Read(FImporter.FFile, DummyInteger); // Iun3
  Read(FImporter.FFile, Ifm4);
  Read(FImporter.FFile, DummyInteger); // Iun4
  Read(FImporter.FFile, Ifm5);
  Read(FImporter.FFile, DummyInteger); // Iun5
  Read(FImporter.FFile, Ifm6);
  Read(FImporter.FFile, DummyInteger); // Iun6
end;

procedure TSubImporter.ReadVariableIntArrayForLayer;
var
//  Layer: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  ReadLn(FImporter.FFile, DummyInteger); // Layer
//  Dec(Layer);
  ID := Trim(ID);
  Assert(ID = 'MATERIAL ZONE INDICES');
  if FNZ = nil then
  begin
    SetLength(FNZ, FDelayBeds.ArrayLength);
  end;
  SetLength(FNZ[FDelayIndex], FModel.Grid.RowCount, FModel.Grid.ColumnCount);
  ReadVariable2DIntArray(FNZ[FDelayIndex]);
  FConstNZ[FDelayIndex].IsConstant := False;
end;

procedure TSubImporter.ReadConstIntArrayForLayer;
var
  IntegerConstant: Integer;
  ID: string;
//  Layer: integer;
begin
  ReadLn(FImporter.FFile, ID);
  Assert(Trim(ID) = 'MATERIAL ZONE INDICES');
  ReadLn(FImporter.FFile, DummyInteger); // Layer
//  Dec(Layer);
  ReadLn(FImporter.FFile, IntegerConstant);
  FConstNZ[FDelayIndex].IsConstant := True;
  FConstNZ[FDelayIndex].IntegerValue := IntegerConstant;
  FImporter.UpdateProgress;
end;

procedure TSubImporter.ReadDataSet9;
var
  Zone: TMaterialZone;
  Index: Integer;
begin
  for Index := 0 to FMaterialZones.ArrayLength - 1 do
  begin
    Zone := FMaterialZones[Index];
    Read(FImporter.FFile, Zone.VerticalHydraulicConductivity);
    Read(FImporter.FFile, Zone.ElasticSpecificStorage);
    Read(FImporter.FFile, Zone.InelasticSpecificStorage);
    Readln(FImporter.FFile);
  end;
  FImporter.UpdateProgress;
end;

procedure TSubImporter.ReadVariableRealArrayForLayer;
var
  ThreeDArray: T3DDoubleArray;
  Index: Integer;
//  Layer: Integer;
  ID: string;
  ConstArray: TRealConstantRecordArray;
  ArrayName: string;
begin
  Index := -1;
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, DummyInteger); // Layer
//  Dec(Layer);
  if ID = StrNUMBEROFBEDSINSY then
  begin
    Inc(FRnbIndex);
    ConstArray := FConstRNB;
    Index := FRnbIndex;
    if FRNB = nil then
    begin
      SetLength(FRNB, FDelayBeds.ArrayLength);
    end;
    ThreeDArray := FRNB;
    ArrayName := 'SUB, Number of beds in system';
  end
  else if ID = StrPRECONSOLIDATIONHEA then
  begin
    Inc(FNoDelayIndex);
    ConstArray := FConstHC;
    Index := FNoDelayIndex;
    if FHC = nil then
    begin
      SetLength(FHC, FNoDelayBeds.ArrayLength);
    end;
    ThreeDArray := FHC;
    ArrayName := 'SUB, Preconsolidation head';
  end
  else if ID = StrELASTICINTERBEDSTO then
  begin
    ConstArray := FConstSfe;
    Index := FNoDelayIndex;
    if FSfe = nil then
    begin
      SetLength(FSfe, FNoDelayBeds.ArrayLength);
    end;
    ThreeDArray := FSfe;
    ArrayName := 'SUB, Elastic interbed storage';
  end
  else if ID = StrVIRGININTERBEDSTOR then
  begin
    ConstArray := FConstSfv;
    Index := FNoDelayIndex;
    if FSfv = nil then
    begin
      SetLength(FSfv, FNoDelayBeds.ArrayLength);
    end;
    ThreeDArray := FSfv;
    ArrayName := 'SUB, Virgin interbed storage';
  end
  else if ID = StrSTARTINGCOMPACTION then
  begin
    ConstArray := FConstCom;
    Index := FNoDelayIndex;
    if FCom = nil then
    begin
      SetLength(FCom, FNoDelayBeds.ArrayLength);
    end;
    ThreeDArray := FCom;
    ArrayName := 'SUB, Starting compaction';
  end
  else if ID = StrDELAYSTARTINGHEAD then
  begin
    Inc(FDelayIndex);
    ConstArray := FConstDstart;
    Index := FDelayIndex;
    if FDstart = nil then
    begin
      SetLength(FDstart, FDelayBeds.ArrayLength);
    end;
    ThreeDArray := FDstart;
    ArrayName := 'SUB, Delay starting head';
  end
  else if ID = StrDELAYPRECOLSOLHEA then
  begin
    ConstArray := FConstDHC;
    Index := FDelayIndex;
    if FDHC = nil then
    begin
      SetLength(FDHC, FDelayBeds.ArrayLength);
    end;
    ThreeDArray := FDHC;
    ArrayName := 'SUB, Delay preconsolidation head';
  end
  else if ID = StrDELAYINITIALCOMPAC then
  begin
    ConstArray := FConstDCOM;
    Index := FDelayIndex;
    if FDCom = nil then
    begin
      SetLength(FDCom, FDelayBeds.ArrayLength);
    end;
    ThreeDArray := FDCom;
    ArrayName := 'SUB, Delay initial compaction';
  end
  else if ID = StrDELAYINTERBEDTHICK then
  begin
    ConstArray := FConstDZ;
    Index := FDelayIndex;
    if FDz = nil then
    begin
      SetLength(FDz, FDelayBeds.ArrayLength);
    end;
    ThreeDArray := FDz;
    ArrayName := 'SUB, Delay interbed thickness';
  end
  else
  begin
    Assert(False);
  end;
  if ThreeDArray[Index] = nil then
  begin
    SetLength(ThreeDArray[Index], FGrid.RowCount, FGrid.ColumnCount);
  end;
  Read2DRealArray(ThreeDArray[Index], ArrayName);
  ConstArray[Index].IsConstant := False;
end;

function TSubImporter.ScreenObjectNameRoot: string;
begin
  Result := '';
  Assert(False);
end;

procedure TSubImporter.ReadConstRealArrayForLayer;
var
  ConstArray: TRealConstantRecordArray;
  Index: Integer;
  ID: string;
//  Layer: Integer;
  Value: Double;
begin
  Index := -1;
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, DummyInteger); // Layer
  Readln(FImporter.FFile, Value);
//  Dec(Layer);
  if ID = StrNUMBEROFBEDSINSY then
  begin
    Inc(FRnbIndex);
    ConstArray := FConstRNB;
    Index := FRnbIndex;
  end
  else if ID = StrPRECONSOLIDATIONHEA then
  begin
    Inc(FNoDelayIndex);
    ConstArray := FConstHC;
    Index := FNoDelayIndex;
  end
  else if ID = StrELASTICINTERBEDSTO then
  begin
    ConstArray := FConstSfe;
    Index := FNoDelayIndex;
  end
  else if ID = StrVIRGININTERBEDSTOR then
  begin
    ConstArray := FConstSfv;
    Index := FNoDelayIndex;
  end
  else if ID = StrSTARTINGCOMPACTION then
  begin
    ConstArray := FConstCom;
    Index := FNoDelayIndex;
  end
  else if ID = StrDELAYSTARTINGHEAD then
  begin
    Inc(FDelayIndex);
    ConstArray := FConstDstart;
    Index := FDelayIndex;
  end
  else if ID = StrDELAYPRECOLSOLHEA then
  begin
    ConstArray := FConstDHC;
    Index := FDelayIndex;
  end
  else if ID = StrDELAYINITIALCOMPAC then
  begin
    ConstArray := FConstDCOM;
    Index := FDelayIndex;
  end
  else if ID = StrDELAYINTERBEDTHICK then
  begin
    ConstArray := FConstDZ;
    Index := FDelayIndex;
  end
  else
  begin
    Assert(False);
  end;
  ConstArray[Index].IsConstant := True;
  ConstArray[Index].RealValue := Value;
  FImporter.UpdateProgress;
end;

procedure TSubImporter.ReadDataSet3;
var
  Index: Integer;
  Item: TSubLayerAssignment;
begin
  for Index := 0 to FDelayBeds.ArrayLength - 1 do
  begin
    Item := FDelayBeds[Index];
    Read(FImporter.FFile, Item.Layer);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSubImporter.ReadDataSet2;
var
  Item: TSubLayerAssignment;
  Index: Integer;
begin
  for Index := 0 to FNoDelayBeds.ArrayLength - 1 do
  begin
    Item := FNoDelayBeds[Index];
    Read(FImporter.FFile, Item.Layer);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSubImporter.ReadDataSet1;
var
//  ISUBCB: Integer;
  ISUBOC: Integer;
  NNDB: Integer;
  NDB: Integer;
  NMZ: Integer;
begin
  Read(FImporter.FFile, DummyInteger); // ISUBCB
  Read(FImporter.FFile, ISUBOC);
  Read(FImporter.FFile, NNDB);
  Read(FImporter.FFile, NDB);
  Read(FImporter.FFile, NMZ);
  Read(FImporter.FFile, NN);
  Read(FImporter.FFile, AC1);
  Read(FImporter.FFile, AC2);
  Read(FImporter.FFile, ITMIN);
  Read(FImporter.FFile, IDSAVE);
  Read(FImporter.FFile, IDREST);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  if NNDB < 0 then
  begin
    NNDB := 0;
  end;
  if NDB < 0 then
  begin
    NDB := 0;
  end;
  if NMZ < 0 then
  begin
    NMZ := 0;
  end;
  if ISUBOC < 0 then
  begin
    ISUBOC := 0;
  end;
  FDelayBeds.ArrayLength := NDB;
  FNoDelayBeds.ArrayLength := NNDB;
  FMaterialZones.ArrayLength := NMZ;
  FSubOutputs.ArrayLength := ISUBOC;

  SetLength(FConstRNB, NDB);
  InitializeConstArray(FConstRNB);

  SetLength(FConstHC, NNDB);
  InitializeConstArray(FConstHC);
  SetLength(FConstSfe, NNDB);
  InitializeConstArray(FConstSfe);
  SetLength(FConstSfv, NNDB);
  InitializeConstArray(FConstSfv);
  SetLength(FConstCom, NNDB);
  InitializeConstArray(FConstCom);

  SetLength(FConstDstart, NDB);
  InitializeConstArray(FConstDstart);
  SetLength(FConstDHC, NDB);
  InitializeConstArray(FConstDHC);
  SetLength(FConstDCOM, NDB);
  InitializeConstArray(FConstDCOM);
  SetLength(FConstDZ, NDB);
  InitializeConstArray(FConstDZ);
  SetLength(FConstNZ, NDB);
  InitializeConstIntArray(FConstNZ);
end;

procedure TSubImporter.HandlePackage;
var
  SubPackage: TSubPackageSelection;
  Index: Integer;
  LayerItem: TSubLayerAssignment;
  Group: TLayerGroup;
  NoDelayItem: TSubNoDelayBedLayerItem;
  DelayItem: TSubDelayBedLayerItem;
  ScreenObject: TScreenObject;
begin
  inherited;
  SubPackage := FModel.ModflowPackages.SubPackage;
  SubPackage.IsSelected := True;
  ImportDataSet1(SubPackage);

  if FSubOutputs.ArrayLength > 0 then
  begin
    ImportPrintFormat(SubPackage);
    ImportPrintChoices(SubPackage);
  end;

  ScreenObject := nil;

  CheckVariableRealArrays(FConstRNB, FRNB);
  CheckVariableRealArrays(FConstHC, FHC);
  CheckVariableRealArrays(FConstSfe, FSfe);
  CheckVariableRealArrays(FConstSfv, FSfv);
  CheckVariableRealArrays(FConstCom, FCom);
  CheckVariableRealArrays(FConstDstart, FDstart);
  CheckVariableRealArrays(FConstDHC, FDHC);
  CheckVariableRealArrays(FConstDCOM, FDCOM);
  CheckVariableRealArrays(FConstDZ, FDZ);
  CheckVariableIntegerArrays(FConstNZ, FNZ);

  for Index := 0 to FNoDelayBeds.ArrayLength - 1 do
  begin
    LayerItem := FNoDelayBeds[Index];
    Group := FModel.LayerStructure[LayerItem.Layer];
    NoDelayItem := Group.SubNoDelayBedLayers.Add;
    NoDelayItem.Name := StrNDSys + IntToStr(Index + 1);
    ImportPreconsolidatonHead(Index, NoDelayItem, ScreenObject);
    ImportSfe(Index, NoDelayItem, ScreenObject);
    ImportSfv(Index, NoDelayItem, ScreenObject);
    ImportCom(Index, NoDelayItem, ScreenObject);
  end;

  for Index := 0 to FDelayBeds.ArrayLength - 1 do
  begin
    LayerItem := FDelayBeds[Index];
    Group := FModel.LayerStructure[LayerItem.Layer];
    DelayItem := Group.SubDelayBedLayers.Add;
    DelayItem.Name := 'D_Sys' + IntToStr(Index + 1);
    ImportRNB(DelayItem, Index, ScreenObject);
    ImportDStart(DelayItem, Index, ScreenObject);
    ImportDHC(DelayItem, Index, ScreenObject);
    ImportDCOM(DelayItem, Index, ScreenObject);
    ImportDZ(DelayItem, Index, ScreenObject);
    ImportMaterialZone(DelayItem, Index, ScreenObject);
  end;
end;

procedure TSubImporter.ReadData(const ALabel: string);
var
  Index: Integer;
  Item: TSubOC;
  OCIndex: Integer;
begin
  inherited;
  if ALabel = 'ISUBCB ISUBOC NNDB NDB NMZ NN AC1 AC2 ITMIN IDSAVE IDREST:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = '(LN(N),N=1,NNDB):' then
  begin
    ReadDataSet2;
  end
  else if ALabel = '(LDN(N),N=1,NDB):' then
  begin
    ReadDataSet3;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstRealArrayForLayer;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableRealArrayForLayer;
  end
  else if ALabel = '(DP(N,NP),NP=1,3):' then
  begin
    ReadDataSet9;
  end
  else if ALabel = StrConstant2DIntegerArrayForLayer then
  begin
    ReadConstIntArrayForLayer;
  end
  else if ALabel = StrVariable2DIntegerArrayForLayer then
  begin
    ReadVariableIntArrayForLayer;
  end
  else if ALabel =
    'Ifm1 Iun1 Ifm2 Iun2 Ifm3 Iun3 Ifm4 Iun4 Ifm5 Iun5 Ifm6 Iun6:' then
  begin
    ReadDataSet15;
  end
  else if ALabel = 'ISP1, ISP2, JTS1, JTS2, (IFL(II), II=1,13):' then
  begin
    for Index := 0 to FSubOutputs.ArrayLength - 1 do
    begin
      Item := FSubOutputs[Index];
      Read(FImporter.FFile, Item.ISP1);
      Read(FImporter.FFile, Item.ISP2);
      Read(FImporter.FFile, Item.ITS1);
      Read(FImporter.FFile, Item.ITS2);
      for OCIndex := 0 to Length(Item.Ifl)-1 do
      begin
        Read(FImporter.FFile, Item.Ifl[OCIndex]);
      end;
      ReadLn(FImporter.FFile);
    end;
    FImporter.UpdateProgress;
  end
  else
  begin
    Assert(False, Format('Unrecognized label %s', [ALabel]));
  end;

end;

{ TSubLayerAssignments }

function TSubLayerAssignments.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSubLayerAssignment;
end;

function TSubLayerAssignments.GetLayer(Index: integer): TSubLayerAssignment;
begin
  result := Objects[Index] as TSubLayerAssignment;
end;

{ TMaterialZones }

function TMaterialZones.ArrayMemberClass: TArrayMemberClass;
begin
  result := TMaterialZone;
end;

function TMaterialZones.GetZone(Index: integer): TMaterialZone;
begin
  result := Objects[Index] as TMaterialZone;
end;

{ TSubOutputs }

function TSubOutputs.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSubOC;
end;

function TSubOutputs.GetOC(Index: integer): TSubOC;
begin
  result := Objects[Index] as TSubOC;
end;

{ TNamImporter }

constructor TNamImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'NAM');
  FUnitNumbers := TIntegerList.Create;
  FFileNames := TStringList.Create;
end;

destructor TNamImporter.Destroy;
begin
  FFileNames.Free;
  FUnitNumbers.Free;
  inherited;
end;

procedure TNamImporter.ReadData(const ALabel: string);
var
  UnitNumber: integer;
  FileName: string;
begin
  inherited;
  if ALabel = 'OPENING:' then
  begin
    Read(FImporter.FFile, UnitNumber);
    Readln(FImporter.FFile, FileName);
    FUnitNumbers.Add(UnitNumber);
    FFileNames.Add(FileName);
  end;
  FImporter.UpdateProgress;
end;

{ TSwtImporter }

constructor TSwtImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'SWT');
  FInterBeds:= TSubLayerAssignments.Create;
end;

destructor TSwtImporter.Destroy;
begin
  FInterBeds.Free;
  inherited;
end;

procedure TSwtImporter.ImportPrintChoices;
var
  InnerIndex: Integer;
  OuterIndex: Integer;
  PrintChoices: TSwtPrintCollection;
  TimeStepStartLists: TList;
  TimeStepEndLists: TList;
  Index: Integer;
  SwtOCItem: TSwtPrintRecord;
  SwtPrintItem: TSwtPrintItem;
  TimeStepStartTimes: TRealList;
  TimeStepEndTimes: TRealList;
  function GetBoolValue(OCIndex: integer): boolean;
  begin
    if SwtOCItem.Ifl[OCIndex] < 0 then
    begin
      result := False;
      Assert(False);
    end
    else if SwtOCItem.Ifl[OCIndex] = 0 then
    begin
      result := False;
    end
    else
    begin
      result := True;
    end;
  end;
begin
  if Length(FSwtPrintRecordArray) > 0 then
  begin
    for InnerIndex := 0 to Length(FSwtPrintRecordArray[0].Ifl) - 1 do
    begin
      if FSwtPrintRecordArray[0].Ifl[InnerIndex] < 0 then
      begin
        FSwtPrintRecordArray[0].Ifl[InnerIndex] := 0;
      end;
    end;
  end;
  for OuterIndex := 1 to Length(FSwtPrintRecordArray) - 1 do
  begin
    for InnerIndex := 0 to Length(FSwtPrintRecordArray[OuterIndex].Ifl) - 1 do
    begin
      if FSwtPrintRecordArray[OuterIndex].Ifl[InnerIndex] < 0 then
      begin
        FSwtPrintRecordArray[OuterIndex].Ifl[InnerIndex] := FSwtPrintRecordArray[OuterIndex - 1].Ifl[InnerIndex];
      end;
    end;
  end;
  PrintChoices := FSwtPackage.PrintChoices;
  TimeStepStartLists := TObjectList.Create;
  TimeStepEndLists := TObjectList.Create;
  try
    GetTimeStepStartAndEndTimes(TimeStepEndLists, TimeStepStartLists);
    for Index := 0 to Length(FSwtPrintRecordArray) - 1 do
    begin
      SwtOCItem := FSwtPrintRecordArray[Index];
      SwtPrintItem := PrintChoices.Add as TSwtPrintItem;
      if SwtOCItem.ISP1 < 1 then
      begin
        SwtOCItem.ISP1 := 1;
      end;
      if SwtOCItem.ISP1 > FModel.ModflowStressPeriods.Count then
      begin
        SwtOCItem.ISP1 := FModel.ModflowStressPeriods.Count;
      end;
      if SwtOCItem.ISP2 < 1 then
      begin
        SwtOCItem.ISP2 := 1;
      end;
      if SwtOCItem.ISP2 > FModel.ModflowStressPeriods.Count then
      begin
        SwtOCItem.ISP2 := FModel.ModflowStressPeriods.Count;
      end;
      TimeStepStartTimes := TimeStepStartLists[SwtOCItem.ISP1 - 1];
      TimeStepEndTimes := TimeStepEndLists[SwtOCItem.ISP2 - 1];
      if SwtOCItem.ITS1 < 1 then
      begin
        SwtOCItem.ITS1 := 1;
      end;
      if SwtOCItem.ITS1 > TimeStepStartTimes.Count then
      begin
        SwtOCItem.ITS1 := TimeStepStartTimes.Count;
      end;
      if SwtOCItem.ITS2 < 1 then
      begin
        SwtOCItem.ITS2 := 1;
      end;
      if SwtOCItem.ITS2 > TimeStepEndTimes.Count then
      begin
        SwtOCItem.ITS2 := TimeStepEndTimes.Count;
      end;
      SwtPrintItem.StartTime := TimeStepStartTimes[SwtOCItem.ITS1 - 1];
      SwtPrintItem.EndTime := TimeStepEndTimes[SwtOCItem.ITS2 - 1];
      SwtPrintItem.PrintSubsidence := GetBoolValue(0);
      SwtPrintItem.SaveSubsidence := GetBoolValue(1);
      SwtPrintItem.PrintCompactionByModelLayer := GetBoolValue(2);
      SwtPrintItem.SaveCompactionByModelLayer := GetBoolValue(3);
      SwtPrintItem.PrintCompactionByInterbedSystem := GetBoolValue(4);
      SwtPrintItem.SaveCompactionByInterbedSystem := GetBoolValue(5);
      SwtPrintItem.PrintVerticalDisplacement := GetBoolValue(6);
      SwtPrintItem.SaveVerticalDisplacement := GetBoolValue(7);
      SwtPrintItem.PrintPreconsolidationStress := GetBoolValue(8);
      SwtPrintItem.SavePreconsolidationStress := GetBoolValue(9);
      SwtPrintItem.PrintDeltaPreconsolidationStress := GetBoolValue(10);
      SwtPrintItem.SaveDeltaPreconsolidationStress := GetBoolValue(11);
      SwtPrintItem.PrintGeostaticStress := GetBoolValue(12);
      SwtPrintItem.SaveGeostaticStress := GetBoolValue(13);
      SwtPrintItem.PrintDeltaGeostaticStress := GetBoolValue(14);
      SwtPrintItem.SaveDeltaGeostaticStress := GetBoolValue(15);
      SwtPrintItem.PrintEffectiveStress := GetBoolValue(16);
      SwtPrintItem.SaveEffectiveStress := GetBoolValue(17);
      SwtPrintItem.PrintDeltaEffectiveStress := GetBoolValue(18);
      SwtPrintItem.SaveDeltaEffectiveStress := GetBoolValue(19);
      SwtPrintItem.PrintVoidRatio := GetBoolValue(20);
      SwtPrintItem.SaveVoidRatio := GetBoolValue(21);
      SwtPrintItem.PrintThicknessCompressibleSediments := GetBoolValue(22);
      SwtPrintItem.SaveThicknessCompressibleSediments := GetBoolValue(23);
      SwtPrintItem.PrintLayerCenterElevation := GetBoolValue(24);
      SwtPrintItem.SaveLayerCenterElevation := GetBoolValue(25);
    end;
  finally
    TimeStepStartLists.Free;
    TimeStepEndLists.Free;
  end;
end;

procedure TSwtImporter.ImportInitialConditions;
begin
  if ISTPCS = 0 then
  begin
    ImportDataSet(StrInitialPreconsolida, StrInitialPreconsolida, FConstPcs, FPcs);
  end
  else
  begin
    ImportDataSet(StrInitialPreOffsets, StrInitialPreOffsets, FConstPcs, FPcs);
  end;
end;

procedure TSwtImporter.ImportDataSet16;
var
  PrintFormats: TSwtPrintFormats;
begin
  PrintFormats := FSwtPackage.PrintFormats;
  PrintFormats.SubsidenceFormat := ConvertFormat(Ifm[0]);
  PrintFormats.CompactionByModelLayerFormat := ConvertFormat(Ifm[1]);
  PrintFormats.CompactionByInterbedSystemFormat := ConvertFormat(Ifm[2]);
  PrintFormats.VerticalDisplacementFormat := ConvertFormat(Ifm[3]);
  PrintFormats.PreconsolidationStress := ConvertFormat(Ifm[4]);
  PrintFormats.DeltaPreconsolidationStress := ConvertFormat(Ifm[5]);
  PrintFormats.GeostaticStress := ConvertFormat(Ifm[6]);
  PrintFormats.DeltaGeostaticStress := ConvertFormat(Ifm[7]);
  PrintFormats.EffectiveStress := ConvertFormat(Ifm[8]);
  PrintFormats.DeltaEffectiveStress := ConvertFormat(Ifm[9]);
  PrintFormats.VoidRatio := ConvertFormat(Ifm[10]);
  PrintFormats.ThicknessCompressibleSediments := ConvertFormat(Ifm[11]);
  PrintFormats.LayerCenterElevation := ConvertFormat(Ifm[12]);
end;

procedure TSwtImporter.ImportDataSet3;
var
  InitialPrint: TSwtInitialPrint;
begin
  InitialPrint := FSwtPackage.InitialPrint;
  InitialPrint.PrintInitialLayerCenterElevations := IZCFL <> 0;
  InitialPrint.InitialLayerCenterElevationFormat := ConvertFormat(IZCFM);
  InitialPrint.PrintInitialGeostaticStress := IGLFL <> 0;
  InitialPrint.InitialGeostaticStressFormat := ConvertFormat(IGLFM);
  InitialPrint.PrintInitialEffectiveStress := IESTFL <> 0;
  InitialPrint.InitialEffectiveStressFormat := ConvertFormat(IESTFM);
  InitialPrint.PrintInitialPreconsolidationStress := IPCSFL <> 0;
  InitialPrint.InitialPreconsolidationStressFormat := ConvertFormat(IPCSFM);
  InitialPrint.PrintInitialEquivalentStorageProperties := ISTFL <> 0;
  InitialPrint.InitialEquivalentStoragePropertiesFormat := ConvertFormat(ISTFM);
end;

procedure TSwtImporter.ImportLayerData;
var
  Index: Integer;
  Layer: Integer;
  Group: TLayerGroup;
  WtItem: TSwtWaterTableItem;
  ScreenObject: TScreenObject;
begin
  ScreenObject := nil;
  for Index := 0 to FInterBeds.ArrayLength - 1 do
  begin
    Layer := FInterBeds[Index].Layer;
    Group := FModel.LayerStructure[Layer];
    WtItem := Group.WaterTableLayers.Add;
    WtItem.Name := 'WT_' + IntToStr(Index + 1);
    ImportTHICK(Index, WtItem, ScreenObject);
    if ICRCC <> 0 then
    begin
      ImportSSe(Index, WtItem, ScreenObject);
      ImportSSv(Index, WtItem, ScreenObject);
    end
    else
    begin
      ImportCr(Index, WtItem, ScreenObject);
      ImportCc(Index, WtItem, ScreenObject);
    end;
    ImportVOID(Index, WtItem, ScreenObject);
    ImportSUB(Index, WtItem, ScreenObject);
  end;
end;

procedure TSwtImporter.ImportDataSet1;
var
  CombinedOutput: Boolean;
  OuterIndex: Integer;
  InnerIndex: Integer;
begin
  if ITHK <= 0 then
  begin
    FSwtPackage.ThickResponse := trConstant;
  end
  else
  begin
    FSwtPackage.ThickResponse := trVariable;
  end;
  if IVOID < -0 then
  begin
    FSwtPackage.VoidRatioResponse := vrrConstant;
  end
  else
  begin
    FSwtPackage.VoidRatioResponse := vrrVariable;
  end;
  if ISTPCS <> 0 then
  begin
    FSwtPackage.PreconsolidationSource := pcOffsets;
  end
  else
  begin
    FSwtPackage.PreconsolidationSource := pcSpecified;
  end;
  if ICRCC <> 0 then
  begin
    FSwtPackage.CompressionSource := csSpecificStorage;
  end
  else
  begin
    FSwtPackage.CompressionSource := csCompressionReComp;
  end;
  CombinedOutput := True;
  for OuterIndex := 0 to Length(Iun) - 2 do
  begin
    if Iun[OuterIndex] <> 0 then
    begin
      for InnerIndex := OuterIndex + 1 to Length(Iun) - 1 do
      begin
        if Iun[InnerIndex] <> 0 then
        begin
          CombinedOutput := Iun[OuterIndex] = Iun[InnerIndex];
          if not CombinedOutput then
          begin
            break;
          end;
        end;
      end;
      break;
    end;
  end;
  if CombinedOutput then
  begin
    FSwtPackage.BinaryOutputChoice := sbocSingleFile;
  end
  else
  begin
    FSwtPackage.BinaryOutputChoice := sbocMultipleFiles;
  end;
end;

procedure TSwtImporter.ImportSse(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableInitialElasticSkeletalSpecificStorageDataArrayName,
    FConstSse, FSse);
end;

procedure TSwtImporter.ImportSsv(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableInitialInelasticSkeletalSpecificStorageDataArrayName,
    FConstSsv, FSsv);
end;

procedure TSwtImporter.ImportCr(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableRecompressionIndexDataArrayName,
    FConstCr, FCr);
end;

procedure TSwtImporter.ImportCc(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableCompressionIndexDataArrayName,
    FConstCc, FCc);
end;

procedure TSwtImporter.ImportVOID(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableInitialVoidRatioDataArrayName,
    FConstVoid, FVoid);
end;

procedure TSwtImporter.ImportSUB(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableInitialCompactionDataArrayName,
    FConstSub, FSub);
end;

procedure TSwtImporter.ImportLayerGroupData(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject; Const Name: string;
  const ConstArray: TRealConstantRecordArray; const ImportedData: T3DDoubleArray);
var
  DataArray: TDataArray;
  DataArrayName: string;
begin
  DataArray := FModel.DataArrayManager.GetDataSetByName(Name);
  Assert(DataArray <> nil);
  if ConstArray[Index].IsConstant then
  begin
    DataArray.Formula := FortranFloatToStr(ConstArray[Index].RealValue);
  end
  else
  begin
    Assert(ImportedData <> nil);
    if ScreenObject = nil then
    begin
      CreateOrRetrieveCellCenterScreenObject(ScreenObject);
    end;
    DataArrayName := 'Imported_' + Name;
    CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
      ImportedData[Index]);
    DataArray.Formula := DataArrayName;
  end;
end;

procedure TSwtImporter.ImportTHICK(Index: Integer; WtItem: TSwtWaterTableItem;
  var ScreenObject: TScreenObject);
begin
  ImportLayerGroupData(Index, WtItem, ScreenObject,
    WtItem.WaterTableCompressibleThicknessDataArrayName, FConstTHICK, FTHICK);
end;

procedure TSwtImporter.ReadDataSet17;
var
  Index: Integer;
begin
  Inc(FPrintIndex);
  Read(FImporter.FFile, FSwtPrintRecordArray[FPrintIndex].ISP1);
  Read(FImporter.FFile, FSwtPrintRecordArray[FPrintIndex].ISP2);
  Read(FImporter.FFile, FSwtPrintRecordArray[FPrintIndex].ITS1);
  Read(FImporter.FFile, FSwtPrintRecordArray[FPrintIndex].ITS2);
  for Index := 0 to Length(FSwtPrintRecordArray[FPrintIndex].Ifl) - 1 do
  begin
    Read(FImporter.FFile, FSwtPrintRecordArray[FPrintIndex].Ifl[Index]);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwtImporter.ReadDataSet16;
var
  Index: Integer;
begin
  for Index := 0 to Length(Ifm) - 1 do
  begin
    Read(FImporter.FFile, Ifm[Index]);
    Read(FImporter.FFile, Iun[Index]);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwtImporter.ReadMultiLayerVariableArrays(const ID: string);
var
  Index: Integer;
  ConstArray: TRealConstantRecordArray;
  ThreeDArray: T3DDoubleArray;
//  ArrayName: string;
begin
  Index := -1;
  if ID = StrSILTANDCLAYTHICKN then
  begin
    Inc(FThickIndex);
    ConstArray := FConstTHICK;
    Index := FThickIndex;
    if FTHICK = nil then
    begin
      SetLength(FTHICK, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FTHICK;
  end
  else if ID = StrELASTICSPECIFICSTO then
  begin
    Inc(FSseIndex);
    ConstArray := FConstSse;
    Index := FSseIndex;
    if FSse = nil then
    begin
      SetLength(FSse, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FSse;
  end
  else if ID = StrRECOMPRESSIONINDEX then
  begin
    Inc(FCrIndex);
    ConstArray := FConstCr;
    Index := FCrIndex;
    if FCr = nil then
    begin
      SetLength(FCr, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FCr;
  end
  else if ID = StrINELASSPECIFICSTO then
  begin
    Inc(FSsvIndex);
    ConstArray := FConstSsv;
    Index := FSsvIndex;
    if FSsv = nil then
    begin
      SetLength(FSsv, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FSsv;
  end
  else if ID = StrCOMPRESSIONINDEX then
  begin
    Inc(FCcIndex);
    ConstArray := FConstCc;
    Index := FCcIndex;
    if FCc = nil then
    begin
      SetLength(FCc, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FCc;
  end
  else if ID = StrVOIDRATIO then
  begin
    Inc(FVoidIndex);
    ConstArray := FConstVoid;
    Index := FVoidIndex;
    if FVoid = nil then
    begin
      SetLength(FVoid, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FVoid;
  end
  else if ID = StrSTARTINGCOMPACTION then
  begin
    Inc(FSubIndex);
    ConstArray := FConstSub;
    Index := FSubIndex;
    if FSub = nil then
    begin
      SetLength(FSub, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FSub;
  end
  else if ID = StrPRECONSOLSTRESS then
  begin
    Inc(FPCSIndex);
    ConstArray := FConstPCS;
    Index := FPCSIndex;
    if FPcs = nil then
    begin
      SetLength(FPcs, FInterBeds.ArrayLength);
    end;
    ThreeDArray := FPcs;
  end
  else
  begin
    Assert(False);
  end;
  if ThreeDArray[Index] = nil then
  begin
    SetLength(ThreeDArray[Index], FGrid.RowCount, FGrid.ColumnCount);
  end;
  Read2DRealArray(ThreeDArray[Index], ID);
  ConstArray[Index].IsConstant := False;
end;

procedure TSwtImporter.ReadMultilayerConstantArrays(Value: Double; const ID: string);
var
  ConstArray: TRealConstantRecordArray;
  Index: Integer;
begin
  Index := -1;
  if ID = StrSILTANDCLAYTHICKN then
  begin
    Inc(FThickIndex);
    ConstArray := FConstTHICK;
    Index := FThickIndex;
  end
  else if ID = StrELASTICSPECIFICSTO then
  begin
    Inc(FSseIndex);
    ConstArray := FConstSse;
    Index := FSseIndex;
  end
  else if ID = StrRECOMPRESSIONINDEX then
  begin
    Inc(FCrIndex);
    ConstArray := FConstCr;
    Index := FCrIndex;
  end
  else if ID = StrINELASSPECIFICSTO then
  begin
    Inc(FSsvIndex);
    ConstArray := FConstSsv;
    Index := FSsvIndex;
  end
  else if ID = StrCOMPRESSIONINDEX then
  begin
    Inc(FCcIndex);
    ConstArray := FConstCc;
    Index := FCcIndex;
  end
  else if ID = StrVOIDRATIO then
  begin
    Inc(FVoidIndex);
    ConstArray := FConstVoid;
    Index := FVoidIndex;
  end
  else if ID = StrSTARTINGCOMPACTION then
  begin
    Inc(FSubIndex);
    ConstArray := FConstSub;
    Index := FSubIndex;
  end
  else if ID = StrPRECONSOLSTRESS then
  begin
    Inc(FPCSIndex);
    ConstArray := FConstPCS;
    Index := FPCSIndex;
  end
  else
  begin
    Assert(False);
  end;
  ConstArray[Index].IsConstant := True;
  ConstArray[Index].RealValue := Value;
end;

procedure TSwtImporter.Read1LayerVariableDataSets(const ID: string);
var
  TwoDArray: T2DDoubleArray;
  ConstValue: TRealConstantRecord;
begin
  ConstValue.IsConstant := False;
  SetLength(TwoDArray, FGrid.RowCount, FGrid.ColumnCount);
  Read2DRealArray(TwoDArray, ID);
  if ID = StrMF_GEOSTATICSTRESS then
  begin
    GL0Const := ConstValue;
    GL0Variable := TwoDArray;
  end
  else if ID = StrMOISTSPECIFICGRAVI then
  begin
    SGMConst := ConstValue;
    SGMVariable := TwoDArray;
  end
  else if ID = StrSATSPECIFICGRAVIT then
  begin
    SGSConst := ConstValue;
    SGSVariable := TwoDArray;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TSwtImporter.Read1LayerConstDataSets(Value: Double; const ID: string);
begin
  if ID = StrMF_GEOSTATICSTRESS then
  begin
    GL0Const.IsConstant := True;
    GL0Const.RealValue := Value;
  end
  else if ID = StrMOISTSPECIFICGRAVI then
  begin
    SGMConst.IsConstant := True;
    SGMConst.RealValue := Value;
  end
  else if ID = StrSATSPECIFICGRAVIT then
  begin
    SGSConst.IsConstant := True;
    SGSConst.RealValue := Value;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TSwtImporter.ReadDataSet3;
begin
  Read(FImporter.FFile, IZCFL);
  Read(FImporter.FFile, IZCFM);
  Read(FImporter.FFile, IGLFL);
  Read(FImporter.FFile, IGLFM);
  Read(FImporter.FFile, IESTFL);
  Read(FImporter.FFile, IESTFM);
  Read(FImporter.FFile, IPCSFL);
  Read(FImporter.FFile, IPCSFM);
  Read(FImporter.FFile, ISTFL);
  Read(FImporter.FFile, ISTFM);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwtImporter.ReadVariableRealArrayForLayer;
var
  ID: string;
  Layer: integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  if (ID = StrMF_GEOSTATICSTRESS)
    or (ID = StrMOISTSPECIFICGRAVI)
    or (ID = StrSATSPECIFICGRAVIT) then
  begin
    Assert(Layer = 1);
    Read1LayerVariableDataSets(ID);
  end
  else
  begin
    ReadMultiLayerVariableArrays(ID);
  end;
end;

function TSwtImporter.ScreenObjectNameRoot: string;
begin
  result := '';
  Assert(False);
end;

procedure TSwtImporter.ReadDataSet2;
var
  Index: Integer;
  ALayer: Integer;
begin
  for Index := 0 to FInterBeds.ArrayLength - 1 do
  begin
    Read(FImporter.FFile, ALayer);
    FInterBeds[Index].Layer := ALayer;
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwtImporter.HandlePackage;
begin
  inherited;
  FSwtPackage := FModel.ModflowPackages.SwtPackage;
  FSwtPackage.IsSelected := True;

  ImportDataSet1;
  FModel.DataArrayManager.CreateInitialDataSets;

  ImportDataSet3;
  ImportLayerData;

  Import2DDataSet(StrGeostaticStress, StrGeostaticStress,
    GL0Const, GL0Variable);
  Import2DDataSet(StrSpecificGravityUns, StrSpecificGravityUns,
    SGMConst, SGMVariable);
  Import2DDataSet(StrSpecificGravitySat, StrSpecificGravitySat,
    SGSConst, SGSVariable);
  ImportInitialConditions;
  ImportDataSet16;
  ImportPrintChoices;


end;

procedure TSwtImporter.ReadDataSet1;
//var
//  ISWTCB: Integer;
begin
  Read(FImporter.FFile, DummyInteger); // ISWTCB
  Read(FImporter.FFile, ISWTOC);
  Read(FImporter.FFile, NSYSTM);
  Read(FImporter.FFile, ITHK);
  Read(FImporter.FFile, IVOID);
  Read(FImporter.FFile, ISTPCS);
  Read(FImporter.FFile, ICRCC);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;

  FInterBeds.ArrayLength := NSYSTM;

  SetLength(FConstTHICK, NSYSTM);
  FThickIndex := -1;

  if ICRCC <> 0 then
  begin
    SetLength(FConstSse, NSYSTM);
    SetLength(FConstSsv, NSYSTM);
  end
  else
  begin
    SetLength(FConstCr, NSYSTM);
    SetLength(FConstCc, NSYSTM);
  end;
  FSseIndex := -1;
  FCrIndex := -1;
  FSsvIndex := -1;
  FCcIndex := -1;

  SetLength(FConstVoid, NSYSTM);
  FVoidIndex := -1;

  SetLength(FConstSub, NSYSTM);
  FSubIndex := -1;

  SetLength(FConstPcs, NSYSTM);
  FPcsIndex := -1;

  SetLength(FSwtPrintRecordArray, ISWTOC);
  FPrintIndex := -1;
end;



procedure TSwtImporter.ReadConstRealArrayForLayer;
var
  ID: string;
  Value: double;
  Layer: integer;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Readln(FImporter.FFile, Value);
  FImporter.UpdateProgress;
  if (ID = StrMF_GEOSTATICSTRESS)
    or (ID = StrMOISTSPECIFICGRAVI)
    or (ID = StrSATSPECIFICGRAVIT) then
  begin
    Assert(Layer = 1);
    Read1LayerConstDataSets(Value, ID);
  end
  else
  begin
    ReadMultilayerConstantArrays(Value, ID);
  end;
end;

procedure TSwtImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'ISWTCB ISWTOC NSYSTM ITHK IVOID ISTPCS ICRCC:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = '(LNWT(N),N=1,NSYSTM):' then
  begin
    ReadDataSet2;
  end
  else if ALabel = 'IZCFL IZCFM IGLFL IGLFM IESTFL IESTFM IPCSFL IPCSFM ISTFL ISTFM:' then
  begin
    ReadDataSet3;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadConstRealArrayForLayer;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadVariableRealArrayForLayer;
  end
  else if ALabel = '(ISWOCF(N),ISWOCU(N),N=1,13):' then
  begin
    ReadDataSet16;
  end
  else if ALabel = 'ISP1,ISP2 , JTS1, JTS2 (IFL2(N),N=1,26):' then
  begin
    ReadDataSet17;
  end
  else
  begin
    Assert(False);
  end;
end;

{ THydmodImporter }

constructor THydmodImporter.Create(Importer: TModflow2005Importer;
  SfrImporter: TSfrImporter; SubImporter: TSubImporter);
begin
  inherited Create(Importer, 'HYD');
  FLocations := THydmodLocationArray.Create;
  FLocationIndex := -1;
  FSfrImporter := SfrImporter;
  FSubImporter := SubImporter;
end;

procedure THydmodImporter.ReadDataSet1;
var
  NHYDM: Integer;
//  IHYDMUN: Integer;
begin
  Read(FImporter.FFile, NHYDM);
  FLocations.ArrayLength := NHYDM;
  Read(FImporter.FFile, DummyInteger); // IHYDMUN
  Read(FImporter.FFile, HYDNOH);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

destructor THydmodImporter.Destroy;
begin
  FLocations.Free;
  inherited;
end;

procedure THydmodImporter.StoreCommonData(Z: Real; APoint: TPoint2D;
  Location: THydModLocation; Index: Integer; var HydModData: ModflowHydmodUnit.THydmodData);
var
  ScreenObject: TScreenObject;
begin
  ScreenObject := CreateScreenObject('ImportedHydmod' + IntToStr(Index + 1));
  ScreenObject.SetValuesOfEnclosedCells := False;
  ScreenObject.SetValuesOfIntersectedCells := True;
  ScreenObject.ElevationFormula := FortranFloatToStr(Z);
  APoint := FModel.Grid.RotateFromGridCoordinatesToRealWorldCoordinates(APoint);
  ScreenObject.AddPoint(APoint, True);
  ScreenObject.CreateHydmodData;
  HydModData := ScreenObject.ModflowHydmodData;
  HydModData.IsUsed := True;
  if Location.INTYP = 'C' then
  begin
    HydModData.AssignmentMethod := amCell;
  end
  else if Location.INTYP = 'I' then
  begin
    HydModData.AssignmentMethod := amInterpolate;
  end
  else
  begin
    Assert(False);
  end;
  HydModData.HydrographLabel := Location.HYDLBL;
end;

function THydmodImporter.GetObservationLocation(Location: THydModLocation): TPoint2D;
begin
  Assert((Location.PCKG = 'BAS') or (Location.PCKG = 'SUB'));
  result.x := Location.XL + FModel.Grid.ColumnPosition[0];
  result.y := Location.YL + FModel.Grid.RowPosition[FModel.Grid.RowCount];
end;

procedure THydmodImporter.HandlePackage;
var
  Index: Integer;
  Location: THydModLocation;
  APoint: TPoint2D;
  ACell: T2DTopCell;
  Z: Real;
  HydModData: ModflowHydmodUnit.THydmodData;
  LayerItem: TSubLayerAssignment;
  Group: TLayerGroup;
  Segment: integer;
  Reach: integer;
  ReachIndex: Integer;
  AReach: TSfrLocationObject;
  SelectedReach: TSfrLocationObject;
  Layer: Integer;
begin
//  inherited;
  if FImportedPackage then
  begin
    Exit;
  end;
  if (FLocationIndex < 0)
    or (FLocationIndex < FLocations.ArrayLength-1) then
  begin
    Exit;
  end;
  if (FModel.ModflowPackages.SfrPackage.IsSelected
    or (FSfrImporter.FReaches.ArrayLength > 0))
    and not FSfrImporter.FImportedPackage then
  begin
    Exit;
  end;
  if (FModel.ModflowPackages.SubPackage.IsSelected
    or (FSubImporter.FNoDelayBeds.ArrayLength > 0))
    and not FSubImporter.FImportedPackage then
  begin
    Exit;
  end;
  inherited;

  FHydmodPackage := FModel.ModflowPackages.HydmodPackage;
  FHydmodPackage.IsSelected := True;

  FHydmodPackage.HYDNOH := HYDNOH;

  for Index := 0 to FLocations.ArrayLength - 1 do
  begin
    Location := FLocations[Index];
    if Location.PCKG = 'IBS' then
    begin
      Continue;
    end
    else if Location.PCKG = 'STR' then
    begin
      Continue;
    end
    else if Location.PCKG = 'BAS' then
    begin
      APoint := GetObservationLocation(Location);
      ACell := FModel.Grid.TopContainingCell(APoint, eaBlocks, False);
      Layer := FModel.ModflowLayerToDataSetLayer(Location.KLAY);
      Z := FModel.Grid.LayerCenter(ACell.Col, ACell.Row,Layer);
      StoreCommonData(Z, APoint, Location, Index, HydModData);
      if Location.ARR = 'HD' then
      begin
        HydModData.Head := True;
      end
      else if Location.ARR = 'DD' then
      begin
        HydModData.Drawdown := True;
      end
      else
      begin
        Assert(False);
      end;
    end
    else if Location.PCKG = 'SUB' then
    begin
      APoint := GetObservationLocation(Location);
      ACell := FModel.Grid.TopContainingCell(APoint, eaBlocks, False);
      Z := FModel.Grid.LayerCenter(ACell.Col, ACell.Row,0);
      StoreCommonData(Z, APoint, Location, Index, HydModData);

      LayerItem := FSubImporter.FNoDelayBeds[Location.KLAY-1];
      Group := FModel.LayerStructure[LayerItem.Layer];
      HydModData.SubLayerGroup := Group.AquiferName;
      HydModData.SubNoDelayBed := StrNDSys + IntToStr(Location.KLAY);

      if Location.ARR = 'HC' then
      begin
        HydModData.SubPreconsolidationHead := True;
      end
      else if Location.ARR = 'CP' then
      begin
        HydModData.SubCompaction := True;
      end
      else if Location.ARR = 'SB' then
      begin
        HydModData.SubSubsidence := True;
      end
      else
      begin
        Assert(False);
      end;
    end
    else if Location.PCKG = 'SFR' then
    begin
      Segment := Round(Location.XL);
      Reach := Round(Location.YL);

      SelectedReach := nil;
      for ReachIndex := 0 to FSfrImporter.FReaches.ArrayLength - 1 do
      begin
        AReach := FSfrImporter.FReaches[ReachIndex];
        if (AReach.SegmentNumber = Segment)
          and (AReach.ReachNumber = Reach) then
        begin
          SelectedReach := AReach;
          break;
        end;
      end;
      Assert(SelectedReach <> nil);

      APoint := FModel.Grid.UnrotatedTwoDElementCenter(
        SelectedReach.Column-1, SelectedReach.Row-1);
      Layer := FModel.ModflowLayerToDataSetLayer(
        SelectedReach.Layer);
      Z := FModel.Grid.LayerCenter(
        SelectedReach.Column-1, SelectedReach.Row-1,Layer);
      StoreCommonData(Z, APoint, Location, Index, HydModData);

      if Location.ARR = 'ST' then
      begin
        HydModData.SfrStage := True;
      end
      else if Location.ARR = 'SI' then
      begin
        HydModData.SfrInFlow := True;
      end
      else if Location.ARR = 'SO' then
      begin
        HydModData.SfrOutFlow := True;
      end
      else if Location.ARR = 'SA' then
      begin
        HydModData.SfrAquiferExchange := True;
      end
      else
      begin
        Assert(False);
      end;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

procedure THydmodImporter.ReadData(const ALabel: string);
var
  PCKG: string;
  ARR: string;
  INTYP: string;
  HYDLBL: string;
begin
  inherited;
  if ALabel = 'NHYDM,IHYDMUN,HYDNOH:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'PCKG:' then
  begin
    Inc(FLocationIndex);
    if FLocations.ArrayLength <= FLocationIndex then
    begin
      FLocations.ArrayLength := FLocationIndex +1;
    end;
    Readln(FImporter.FFile, PCKG);
    FImporter.UpdateProgress;
    FLocations[FLocationIndex].PCKG := Trim(PCKG)
  end
  else if ALabel = 'ARR:' then
  begin
    Readln(FImporter.FFile, ARR);
    FImporter.UpdateProgress;
    FLocations[FLocationIndex].ARR := Trim(ARR)
  end
  else if ALabel = 'INTYP:' then
  begin
    Readln(FImporter.FFile, INTYP);
    FImporter.UpdateProgress;
    FLocations[FLocationIndex].INTYP := Trim(INTYP)
  end
  else if ALabel = 'KLAY XL YL:' then
  begin
    Read(FImporter.FFile, FLocations[FLocationIndex].KLAY);
    Read(FImporter.FFile, FLocations[FLocationIndex].XL);
    Read(FImporter.FFile, FLocations[FLocationIndex].YL);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'HYDLBL:' then
  begin
    Readln(FImporter.FFile, HYDLBL);
    FImporter.UpdateProgress;
    FLocations[FLocationIndex].HYDLBL := Trim(HYDLBL)
  end
  else
  begin
    Assert(False);
  end;
end;

{ THydmodLocationArray }

function THydmodLocationArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := THydModLocation;
end;

function THydmodLocationArray.GetLocations(Index: integer): THydModLocation;
begin
  result := Objects[Index] as THydModLocation;
end;

{ TPcgnImporter }

constructor TPcgnImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'PCGN:');
end;

procedure TPcgnImporter.HandlePackage;
var
  PcgnPackage: TPcgnSelection;
begin
  inherited;
  PcgnPackage := FModel.ModflowPackages.PcgnPackage;
  PcgnPackage.IsSelected := True;
  PcgnPackage.Comments := FComments;


  PcgnPackage.ITER_MO := ITER_MO;
  PcgnPackage.ITER_MI := ITER_MI;
  PcgnPackage.CLOSE_R.Value := CLOSE_R;
  PcgnPackage.CLOSE_H.Value := CLOSE_H;

  PcgnPackage.RELAX.Value := RELAX;
  if IFILL < 0 then
  begin
    IFILL := 0;
  end;
  if IFILL > 1 then
  begin
    IFILL := 1;
  end;
  PcgnPackage.IFILL := IFILL;
  PcgnPackage.UNIT_PC := UNIT_PC <> 0;
  PcgnPackage.UNIT_TS := UNIT_TS <> 0;

  if ITER_MO > 0 then
  begin
    if ADAMP < 0 then
    begin
      ADAMP := 0;
    end;
    if ADAMP > 2 then
    begin
      ADAMP := 2;
    end;
    PcgnPackage.ADAMP := TDamping(ADAMP);
    PcgnPackage.DAMP.Value := DAMP;
    PcgnPackage.DAMP_LB.Value := DAMP_LB;
    PcgnPackage.RATE_D.Value := RATE_D;
    PcgnPackage.CHGLIMIT.Value := CHGLIMIT;

    if ACNVG < 0 then
    begin
      ACNVG := 0;
    end;
    if ACNVG > 2 then
    begin
      ACNVG := 2;
    end;
    PcgnPackage.ACNVG := TConvergenceMode(ACNVG);
    PcgnPackage.CNVG_LB.Value := CNVG_LB;
    if MCNVG < 1 then
    begin
      MCNVG := 1;
    end;
    if MCNVG > 6 then
    begin
      MCNVG := 6;
    end;
    PcgnPackage.MCNVG := MCNVG;
    PcgnPackage.RATE_C.Value := RATE_C;
    if IPUNIT < -1 then
    begin
      IPUNIT := -1;
    end;
    if IPUNIT > 1 then
    begin
      IPUNIT := 1;
    end;
    Inc(IPUNIT);
    PcgnPackage.IPUNIT := TProgressReporting(IPUNIT);
  end;
end;

procedure TPcgnImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'ITER_MO, ITER_MI, CLOSE_R, CLOSE_H:' then
  begin
    Read(FImporter.FFile, ITER_MO);
    Read(FImporter.FFile, ITER_MI);
    Read(FImporter.FFile, CLOSE_R);
    Read(FImporter.FFile, CLOSE_H);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'RELAX, IFILL, UNIT_PC, UNIT_TS:' then
  begin
    Read(FImporter.FFile, RELAX);
    Read(FImporter.FFile, IFILL);
    Read(FImporter.FFile, UNIT_PC);
    Read(FImporter.FFile, UNIT_TS);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'ADAMP, DAMP, DAMP_LB, RATE_D, CHGLIMIT:' then
  begin
    Read(FImporter.FFile, ADAMP);
    Read(FImporter.FFile, DAMP);
    Read(FImporter.FFile, DAMP_LB);
    Read(FImporter.FFile, RATE_D);
    Read(FImporter.FFile, CHGLIMIT);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'ACNVG, CNVG_LB, MCNVG, RATE_C, IPUNIT:' then
  begin
    Read(FImporter.FFile, ACNVG);
    Read(FImporter.FFile, CNVG_LB);
    Read(FImporter.FFile, MCNVG);
    Read(FImporter.FFile, RATE_C);
    Read(FImporter.FFile, IPUNIT);
    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TUpwImporter }

procedure TUpwImporter.HandlePackage;
var
  UpwPackage: TUpwPackageSelection;
begin
  inherited;

  UpwPackage := FModel.ModflowPackages.UpwPackage;
  UpwPackage.IsSelected := FIsSelected;
  if FIsSelected then
  begin
    frmGoPhast.ModelSelection := msModflowNWT;
    FModel.ModflowPackages.HufPackage.IsSelected := False;
    FModel.ModflowPackages.BcfPackage.IsSelected := False;
    FModel.ModflowPackages.LpfPackage.IsSelected := False;
    UpwPackage.Comments := FComments;
    ImportDataSet1(UpwPackage);
    ImportDataSet2;
    ImportDataSet3;
    ImportHorizontalAnisotropy;
    ImportDataSet5;
//    ImportDataSet6;
//    ImportDataSet7;
    ImportLpfParameters;
    FModel.DataArrayManager.CreateInitialDataSets;

    ImportHorizontalHydraulicConductivity;
    ImportVerticalHydraulicConductivity;
    ImportSpecificStorage;
    ImportSpecificYield;
//    ImportWetDry;

    FModel.UpdateDataArrayParameterUsed;

  end;
end;

procedure TUpwImporter.ImportDataSet1(UpwPackage: TUpwPackageSelection);
begin
  FModel.ModflowOptions.HDry := HDRY;
//  LpfPackage.UseConstantCV := FComputeVkUsingCellThickness;
//  LpfPackage.UseSaturatedThickness := FComputeThicknessUsingStartingHead;
//  LpfPackage.UseCvCorrection := not FNoCvCorrection;
//  LpfPackage.UseVerticalFlowCorrection := not FNoVerticalFlowCorrection;
//  LpfPackage.UseStorageCoefficient := FStorageCoefficientChoice;
  UpwPackage.NoParCheck := FNoParameterCheck;
  if IPHDRY = 0 then
  begin
    UpwPackage.HDryPrintOption := hpoDontPrintHdry;
  end
  else
  begin
    UpwPackage.HDryPrintOption := hpoPrintHdry;
  end;
end;

function TUpwImporter.PackageLabel: string;
begin
  result := 'UPW:';
end;

procedure TUpwImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'IUPWCB, HDRY, NPUPW, IPHDRY:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'ISFAC, ICONCV, ITHFLG, NOCVCO, NOVFC, NOPCHK:' then
  begin
    ReadDataSet1Options;
  end
  else if ALabel = 'K,LAYTYPUPW(K),LAYAVG(K),CHANI(K),LAYVKAUPW(K),LAYWET(K):' then
  begin
    ReadDataSets2to6;
  end
  else if ALabel = 'PARNAM:' then
  begin
    ReadArrayParameter;
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadDataSets10to16Variable;
  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadDataSets10to16Constant;
  end
  else
  begin
    Assert(False);
  end

end;

procedure TUpwImporter.ReadDataSet1;
var
  NPLPF: Integer;
begin
  FIsSelected := True;
  Read(FImporter.FFile, ILPFCB);
  Read(FImporter.FFile, HDRY);
  Read(FImporter.FFile, NPLPF);
  Read(FImporter.FFile, IPHDRY);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  SetLength(FParameters, NPLPF);
  FNextParameterIndex := 0;
end;

function TUpwImporter.ScreenObjectNameRoot: string;
begin
  result := '';
  Assert(False);
end;

procedure TCustomFlowPackageImporter.ReadDataSets2to6;
var
  NLAY: integer;
  K: integer;
begin
  if (LAYTYP = nil) or (LAYAVG = nil) or (CHANI = nil) or (LAYVKA = nil) or
    (LAYWET = nil) then
  begin
    NLAY := FModel.ModflowLayerCount;
    if (LAYTYP = nil) then
    begin
      SetLength(LAYTYP, NLAY);
    end;
    if (LAYAVG = nil) then
    begin
      SetLength(LAYAVG, NLAY);
    end;
    if (CHANI = nil) then
    begin
      SetLength(CHANI, NLAY);
    end;
    if (LAYVKA = nil) then
    begin
      SetLength(LAYVKA, NLAY);
    end;
    if (LAYWET = nil) then
    begin
      SetLength(LAYWET, NLAY);
    end;
  end;
  Read(FImporter.FFile, K);
  Dec(K);
  Read(FImporter.FFile, LAYTYP[K]);
  Read(FImporter.FFile, LAYAVG[K]);
  Read(FImporter.FFile, CHANI[K]);
  Read(FImporter.FFile, LAYVKA[K]);
  Read(FImporter.FFile, LAYWET[K]);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TCustomFlowPackageImporter.ReadDataSets10to16Variable;
var
  ThreeDArray: T3DDoubleArray;
  Layer: integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  Dec(Layer);
  if ID = StrHydCondAlongRows then
  begin
    if FHk = nil then
    begin
      SetLength(FHk, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FHk;
  end
  else if ID = StrHorizAnisotropy then
  begin
    if FHorizontalAnisotropy = nil then
    begin
      SetLength(FHorizontalAnisotropy, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FHorizontalAnisotropy;
  end
  else if ID = StrVerticalHydCond then
  begin
    if FVerticalK = nil then
    begin
      SetLength(FVerticalK, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FVerticalK;
  end
  else if ID = StrHorizToVertAnis then
  begin
    if FHorizontalToVerticalAnisotropy = nil then
    begin
      SetLength(FHorizontalToVerticalAnisotropy, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FHorizontalToVerticalAnisotropy;
  end
  else if ID = StrQuasi3DVertHydCond then
  begin
    if FQuasiVerticalK = nil then
    begin
      SetLength(FQuasiVerticalK, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FQuasiVerticalK;
  end
  else if ID = StrSpecificStorage then
  begin
    if FSpecificStorage = nil then
    begin
      SetLength(FSpecificStorage, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FSpecificStorage;
  end
  else if ID = StrSpecificYield then
  begin
    if FSpecificYield = nil then
    begin
      SetLength(FSpecificYield, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FSpecificYield;
  end
  else if ID = StrWetDry then
  begin
    if FWetDry = nil then
    begin
      SetLength(FWetDry, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FWetDry;
  end
  else if ID = StrStorageCoef then
  begin
    if FStorageCoefficient = nil then
    begin
      SetLength(FStorageCoefficient, FModel.ModflowLayerCount);
    end;
    ThreeDArray := FStorageCoefficient;
  end
  else
  begin
    Assert(False);
  end;
  if ThreeDArray[Layer] = nil then
  begin
    SetLength(ThreeDArray[Layer], FGrid.RowCount, FGrid.ColumnCount);
  end;
  Read2DRealArray(ThreeDArray[Layer], ID);
end;

procedure TCustomFlowPackageImporter.ReadDataSets10to16Constant;
var
  ConstArray: TRealConstantRecordArray;
  Layer: integer;
  ID: string;
  Value: double;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  ReadLn(FImporter.FFile, Layer);
  ReadLn(FImporter.FFile, Value);
  Dec(Layer);
  if ID = StrHydCondAlongRows then
  begin
    if FHkConst = nil then
    begin
      SetLength(FHkConst, FModel.ModflowLayerCount);
      InitializeConstArray(FHkConst);
    end;
    ConstArray := FHkConst;
  end
  else if ID = StrHorizAnisotropy then
  begin
    if FHorizontalAnisotropyConst = nil then
    begin
      SetLength(FHorizontalAnisotropyConst, FModel.ModflowLayerCount);
      InitializeConstArray(FHorizontalAnisotropyConst);
    end;
    ConstArray := FHorizontalAnisotropyConst;
  end
  else if ID = StrVerticalHydCond then
  begin
    if FVerticalKConst = nil then
    begin
      SetLength(FVerticalKConst, FModel.ModflowLayerCount);
      InitializeConstArray(FVerticalKConst);
    end;
    ConstArray := FVerticalKConst;
  end
  else if ID = StrHorizToVertAnis then
  begin
    if FHorizontalToVerticalAnisotropyConst = nil then
    begin
      SetLength(FHorizontalToVerticalAnisotropyConst, FModel.ModflowLayerCount);
      InitializeConstArray(FHorizontalToVerticalAnisotropyConst);
    end;
    ConstArray := FHorizontalToVerticalAnisotropyConst;
  end
  else if ID = StrQuasi3DVertHydCond then
  begin
    if FQuasiVerticalKConst = nil then
    begin
      SetLength(FQuasiVerticalKConst, FModel.ModflowLayerCount);
      InitializeConstArray(FQuasiVerticalKConst);
    end;
    ConstArray := FQuasiVerticalKConst;
  end
  else if ID = StrSpecificStorage then
  begin
    if FSpecificStorageConst = nil then
    begin
      SetLength(FSpecificStorageConst, FModel.ModflowLayerCount);
      InitializeConstArray(FSpecificStorageConst);
    end;
    ConstArray := FSpecificStorageConst;
  end
  else if ID = StrSpecificYield then
  begin
    if FSpecificYieldConst = nil then
    begin
      SetLength(FSpecificYieldConst, FModel.ModflowLayerCount);
      InitializeConstArray(FSpecificYieldConst);
    end;
    ConstArray := FSpecificYieldConst;
  end
  else if ID = StrWetDry then
  begin
    if FWetDryConst = nil then
    begin
      SetLength(FWetDryConst, FModel.ModflowLayerCount);
      InitializeConstArray(FWetDryConst);
    end;
    ConstArray := FWetDryConst;
  end
  else if ID = StrStorageCoef then
  begin
    if FStorageCoefficientConst = nil then
    begin
      SetLength(FStorageCoefficientConst, FModel.ModflowLayerCount);
      InitializeConstArray(FStorageCoefficientConst);
    end;
    ConstArray := FStorageCoefficientConst;
  end
  else
  begin
    Assert(False);
  end;
  ConstArray[Layer].IsConstant := True;
  ConstArray[Layer].RealValue := Value;
  FImporter.UpdateProgress;
end;

procedure TCustomFlowPackageImporter.ImportDataSet2;
var
  LayerIndex: integer;
  Index: integer;
  LayerGroup: TLayerGroup;
begin
  // Data set 2.
  LayerIndex := -1;
  for Index := 1 to FModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FModel.LayerStructure.LayerGroups[Index];
    if LayerGroup.RunTimeSimulated then
    begin
      Inc(LayerIndex);
    end;
    if LayerIndex >= 0 then
    begin
      if LAYTYP[LayerIndex] > 0 then
      begin
        LayerGroup.AquiferType := 1;
      end
      else if LAYTYP[LayerIndex] = 0 then
      begin
        LayerGroup.AquiferType := 0;
      end
      else
      begin
        if FComputeThicknessUsingStartingHead then
        begin
          LayerGroup.AquiferType := 0;
        end
        else
        begin
          LayerGroup.AquiferType := 1;
        end;
      end;
    end;
  end;
  FModel.DataArrayManager.CreateInitialDataSets;
end;

procedure TCustomFlowPackageImporter.ImportDataSet3;
var
  LayerIndex: integer;
  Index: integer;
  LayerGroup: TLayerGroup;
begin
  // Data set 3.
  LayerIndex := -1;
  for Index := 1 to FModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FModel.LayerStructure.LayerGroups[Index];
    if LayerGroup.RunTimeSimulated then
    begin
      Inc(LayerIndex);
    end;
    Assert(LayerIndex >= 0);
    LayerGroup.InterblockTransmissivityMethod := LAYAVG[LayerIndex];
  end;
end;

procedure TCustomFlowPackageImporter.ImportHorizontalAnisotropy;
var
  DataArrayName: string;
  ScreenObject: TScreenObject;
  Value: double;
  LayerGroup: TLayerGroup;
  GroupIndex: integer;
  LayerIndex: integer;
  HorizontalAnisotropyFormula: string;
  DataArray: TDataArray;
  Index: integer;
  IsConstant: boolean;
  ConstantValue: double;
begin
  ScreenObject := nil;
  // Data sets 4 and 11.
  ConstantValue := CHANI[0];
  IsConstant := ConstantValue > 0;
  if IsConstant then
  begin
    for Index := 1 to Length(CHANI) - 1 do
    begin
      IsConstant := (CHANI[Index] = ConstantValue);
      if not IsConstant then
      begin
        break;
      end;
    end;
  end;
  if IsConstant then
  begin
    HorizontalAnisotropyFormula := FortranFloatToStr(ConstantValue);
  end
  else
  begin
    if FModel.LayerStructure.Count > 2 then
    begin
      HorizontalAnisotropyFormula := 'CaseR(' + LayerString + ', ';
    end
    else
    begin
      HorizontalAnisotropyFormula := '';
    end;
    LayerIndex := -1;
    for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
    begin
      LayerGroup := FModel.LayerStructure.LayerGroups[GroupIndex];
      if LayerGroup.RunTimeSimulated then
      begin
        Inc(LayerIndex);
      end;
      Assert(LayerIndex >= 0);
      Value := CHANI[LayerIndex];
      if Value > 0 then
      begin
        HorizontalAnisotropyFormula := HorizontalAnisotropyFormula +
          FortranFloatToStr(Value);
      end
      else if (FHorizontalAnisotropyConst <> nil) and FHorizontalAnisotropyConst
        [LayerIndex].IsConstant then
      begin
        HorizontalAnisotropyFormula := HorizontalAnisotropyFormula +
          FortranFloatToStr(FHorizontalAnisotropyConst[LayerIndex].RealValue);
      end
      else if (FHorizontalAnisotropy <> nil) and
        (FHorizontalAnisotropy[LayerIndex] <> nil) then
      begin
        if ScreenObject = nil then
        begin
          CreateOrRetrieveCellCenterScreenObject(ScreenObject);
        end;
        DataArrayName := 'Imported_Horizontal_Anisotropy_Layer_' +
          IntToStr(GroupIndex);
        CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
          FHorizontalAnisotropy[LayerIndex]);
        HorizontalAnisotropyFormula := HorizontalAnisotropyFormula +
          DataArrayName;
      end
      else
      begin
        HorizontalAnisotropyFormula := HorizontalAnisotropyFormula + '1';
      end;
      if GroupIndex < FModel.LayerStructure.Count - 1 then
      begin
        HorizontalAnisotropyFormula := HorizontalAnisotropyFormula + ', ';
      end;
    end;
    if FModel.LayerStructure.Count > 2 then
    begin
      HorizontalAnisotropyFormula := HorizontalAnisotropyFormula + ')';
    end
  end;
  DataArray := FModel.DataArrayManager.GetDataSetByName(rsHorizontalAnisotropy);
  DataArray.Formula := HorizontalAnisotropyFormula;
end;

procedure TCustomFlowPackageImporter.ImportDataSet5;
var
  LayerGroup: TLayerGroup;
  Index: integer;
  LayerIndex: integer;
begin
  // Data set 5.
  LayerIndex := -1;
  for Index := 1 to FModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FModel.LayerStructure.LayerGroups[Index];
    if LayerGroup.RunTimeSimulated then
    begin
      Inc(LayerIndex);
    end;
    Assert(LayerIndex >= 0);
    if LAYVKA[LayerIndex] = 0 then
    begin
      LayerGroup.VerticalHydraulicConductivityMethod := 0;
    end
    else
    begin
      LayerGroup.VerticalHydraulicConductivityMethod := 1;
    end;
  end;
end;

procedure TCustomFlowPackageImporter.ImportLpfParameters;
var
  ClusterIndex: integer;
  Cluster: TClusterRecord;
  MultName: string;
  MultDataArray: TDataArray;
  ZoneName: string;
  ZoneDataArray: TDataArray;
  MultFunctionList: TStringList;
  ZoneFunctionList: TStringList;
  LayerIndex: integer;
  ZoneFunction: string;
  ZoneIndex: integer;
  MultFunction: string;
  MultIndex: integer;
  Index: integer;
  Param: TModflowSteadyParameter;
  Instance: TInstanceRecord;
  MultUsed: boolean;
  ZoneUsed: boolean;
  IntList: TIntegerList;
begin
  for Index := 0 to Length(FParameters) - 1 do
  begin
    Param := FModel.ModflowSteadyParameters.Add as TModflowSteadyParameter;
    Param.ParameterName := FParameters[Index].PARNAM;
    Param.Value := FParameters[Index].Parval;
    if FParameters[Index].PARTYP = 'HK' then
    begin
      Param.ParameterType := ptLPF_HK;
    end
    else if FParameters[Index].PARTYP = 'HANI' then
    begin
      Param.ParameterType := ptLPF_HANI;
    end
    else if FParameters[Index].PARTYP = 'VK' then
    begin
      Param.ParameterType := ptLPF_VK;
    end
    else if FParameters[Index].PARTYP = 'VANI' then
    begin
      Param.ParameterType := ptLPF_VANI;
    end
    else if FParameters[Index].PARTYP = 'SS' then
    begin
      Param.ParameterType := ptLPF_SS;
    end
    else if FParameters[Index].PARTYP = 'SY' then
    begin
      Param.ParameterType := ptLPF_SY;
    end
    else if FParameters[Index].PARTYP = 'VKCB' then
    begin
      Param.ParameterType := ptLPF_VKCB;
    end
    else
    begin
      Assert(False);
    end;
    Assert(Length(FParameters[Index].Instances) = 1);
    Instance := FParameters[Index].Instances[0];
    MultUsed := False;
    ZoneUsed := False;
    IntList := TIntegerList.Create;
    try
      IntList.Sorted := True;
      for ClusterIndex := 0 to Length(Instance.Clusters) - 1 do
      begin
        Cluster := Instance.Clusters[ClusterIndex];
        IntList.AddUnique(Cluster.Layer);
        if not SameText(Cluster.MultiplierName, StrNone) then
        begin
          MultUsed := True;
        end;
        if not SameText(Cluster.ZoneName, StrAll) then
        begin
          ZoneUsed := True;
        end;
      end;
      if Param.ParameterType = ptLPF_VKCB then
      begin
        Param.UseMultiplier := MultUsed or
          (IntList.Count < FModel.ModflowConfiningBedCount);
      end
      else
      begin
        Param.UseMultiplier := MultUsed or
          (IntList.Count < FModel.ModflowLayerCount);
      end;
      if Param.UseMultiplier then
      begin
        MultName := Param.MultiplierName;
        MultDataArray := FModel.DataArrayManager.GetDataSetByName(MultName);
      end
      else
      begin
        MultDataArray := nil;
      end;
      if Param.ParameterType = ptLPF_VKCB then
      begin
        Param.UseZone := ZoneUsed or
          (IntList.Count < FModel.ModflowConfiningBedCount);
      end
      else
      begin
        Param.UseZone := ZoneUsed or (IntList.Count < FModel.ModflowLayerCount);
      end;
      if Param.UseZone then
      begin
        ZoneName := Param.ZoneName;
        ZoneDataArray := FModel.DataArrayManager.GetDataSetByName(ZoneName);
      end
      else
      begin
        ZoneDataArray := nil;
      end;
    finally
      IntList.Free;
    end;
    MultFunctionList := TStringList.Create;
    ZoneFunctionList := TStringList.Create;
    try
      for LayerIndex := 0 to FGrid.LayerCount - 1 do
      begin
//        MultFunctionList.Add('0');
        MultFunctionList.Add('');
//        ZoneFunctionList.Add('False');
        ZoneFunctionList.Add('');
      end;
      for ClusterIndex := 0 to Length(Instance.Clusters) - 1 do
      begin
        Cluster := Instance.Clusters[ClusterIndex];
        LayerIndex := FModel.ModflowLayerToDataSetLayer(Cluster.Layer);
        if Param.ParameterType = ptLPF_VKCB then
        begin
          Inc(LayerIndex);
        end;
        if SameText(Cluster.ZoneName, StrAll) then
        begin
          ZoneFunction := 'True';
//          ZoneFunctionList[LayerIndex] := 'True';
        end
        else
        begin
          ZoneFunction := '';
          for ZoneIndex := 0 to Length(Cluster.ZoneValues) - 1 do
          begin
            ZoneFunction := ZoneFunction + '(' + FixArrayName(Cluster.ZoneName)
              + ' = ' + IntToStr(Cluster.ZoneValues[ZoneIndex]) + ')';
            if ZoneIndex < Length(Cluster.ZoneValues) - 1 then
            begin
              ZoneFunction := ZoneFunction + ' or ';
            end;
          end;
        end;
        if ZoneFunctionList[LayerIndex] = '' then
        begin
          ZoneFunctionList[LayerIndex] := ZoneFunction;
        end
        else
        begin
          ZoneFunctionList[LayerIndex] := ZoneFunctionList[LayerIndex] + ' or ' + ZoneFunction;
        end;
        if MultFunctionList[LayerIndex] = '' then
        begin
          if SameText(Cluster.MultiplierName, StrNone) then
          begin
            if ZoneFunction = 'True' then
            begin
              MultFunctionList[LayerIndex] := '1';
            end
            else
            begin
              MultFunctionList[LayerIndex] := 'If(' + ZoneFunction + ',1 , 0)' ;
            end;
          end
          else
          begin
            if ZoneFunction = 'True' then
            begin
              MultFunctionList[LayerIndex] := FixArrayName(Cluster.MultiplierName);
            end
            else
            begin
              MultFunctionList[LayerIndex] := 'If(' + ZoneFunction + ', '
                + FixArrayName(Cluster.MultiplierName) + ', 0)' ;
            end;
          end;
        end
        else
        begin
          if SameText(Cluster.MultiplierName, StrNone)  then
          begin
            if ZoneFunction = 'True' then
            begin
              MultFunctionList[LayerIndex] := MultFunctionList[LayerIndex]
                + ' + 1'
            end
            else
            begin
              MultFunctionList[LayerIndex] := MultFunctionList[LayerIndex]
                + ' + ' + 'If(' + ZoneFunction + ',1 , 0)' ;
            end;
          end
          else
          begin
            if ZoneFunction = 'True' then
            begin
              MultFunctionList[LayerIndex] := MultFunctionList[LayerIndex]
                + ' + ' + FixArrayName(Cluster.MultiplierName);
            end
            else
            begin
              MultFunctionList[LayerIndex] := MultFunctionList[LayerIndex]
                + ' + ' + 'If(' + ZoneFunction + ', '
                + FixArrayName(Cluster.MultiplierName) + ', 0)' ;
            end;
          end;
        end;
      end;
      for LayerIndex := 0 to ZoneFunctionList.Count - 1 do
      begin
        if ZoneFunctionList[LayerIndex] = '' then
        begin
          ZoneFunctionList[LayerIndex] := 'False'
        end;
      end;
      for LayerIndex := 0 to MultFunctionList.Count - 1 do
      begin
        if MultFunctionList[LayerIndex] = '' then
        begin
          MultFunctionList[LayerIndex] := '0'
        end;
      end;
      if MultDataArray <> nil then
      begin
        if MultFunctionList.Count > 1 then
        begin
          MultFunction := 'CaseR(' + LayerString + ', ';
          for MultIndex := 0 to MultFunctionList.Count - 1 do
          begin
            MultFunction := MultFunction + MultFunctionList[MultIndex];
            if MultIndex < MultFunctionList.Count - 1 then
            begin
              MultFunction := MultFunction + ', ';
            end;
          end;
          MultFunction := MultFunction + ')';
          MultDataArray.Formula := MultFunction;
        end
        else
        begin
          MultDataArray.Formula := MultFunctionList[0];
        end;
      end;
      if ZoneDataArray <> nil then
      begin
        if ZoneFunctionList.Count = 1 then
        begin
          ZoneFunction := ZoneFunctionList[0];
        end
        else
        begin
          ZoneFunction := 'CaseB(' + LayerString + ', ';
          for ZoneIndex := 0 to ZoneFunctionList.Count - 1 do
          begin
            ZoneFunction := ZoneFunction + ZoneFunctionList[ZoneIndex];
            if ZoneIndex < ZoneFunctionList.Count - 1 then
            begin
              ZoneFunction := ZoneFunction + ', ';
            end;
          end;
          ZoneFunction := ZoneFunction + ')';
        end;
        ZoneDataArray.Formula := ZoneFunction;
      end;
    finally
      MultFunctionList.Free;
      ZoneFunctionList.Free;
    end;
  end;
end;

procedure TCustomFlowPackageImporter.ImportHorizontalHydraulicConductivity;
begin
  CheckPositiveArrayValues(FHk, FHkConst, rsKx, FBas);
  ImportDataSet('Kx', rsKx, FHkConst, FHk);
end;

procedure TCustomFlowPackageImporter.ImportVerticalHydraulicConductivity;
var
  ConstantValueK: double;
  IsConstantK: boolean;
  ConstantValueQuasiK: double;
  IsConstantQuasiK: boolean;
  IsConstant: boolean;
  DataArray: TDataArray;
  LayerIndex: integer;
  DataSetFormulaKz: string;
  GroupIndex: integer;
  Group: TLayerGroup;
  ScreenObject: TScreenObject;
  DataArrayName: string;
  Index: integer;
  AnisotropyFormulaKz: string;
  UseAnisotropy: boolean;
  UseAnisotropyInLayer: boolean;
begin
  ScreenObject := nil;
  if (FVerticalK <> nil) or (FVerticalKConst <> nil) or (FQuasiVerticalK <> nil)
    or (FQuasiVerticalKConst <> nil) or (FHorizontalToVerticalAnisotropy <> nil)
    or (FHorizontalToVerticalAnisotropyConst <> nil) then
  begin
    CheckVariableRealArrays(FVerticalKConst, FVerticalK);
    CheckVariableRealArrays(FQuasiVerticalKConst, FQuasiVerticalK);
    CheckVariableRealArrays(FHorizontalToVerticalAnisotropyConst,
      FHorizontalToVerticalAnisotropy);
    CheckRealConstArray(ConstantValueK, IsConstantK, FVerticalKConst);
    if FQuasiVerticalKConst = nil then
    begin
      IsConstant := IsConstantK;
    end
    else
    begin
      CheckRealConstArray(ConstantValueQuasiK, IsConstantQuasiK,
        FQuasiVerticalKConst);
      IsConstant := IsConstantK and IsConstantQuasiK and
        (ConstantValueK = ConstantValueQuasiK);
    end;
    if IsConstant then
    begin
      for Index := 0 to Length(LAYVKA) - 1 do
      begin
        IsConstant := LAYVKA[Index] = 0;
        if not IsConstant then
        begin
          break;
        end;
      end;
    end;
    if IsConstant then
    begin
      DataArray := FModel.DataArrayManager.GetDataSetByName(rsKz);
      DataArray.Formula := FortranFloatToStr(ConstantValueK);
    end
    else
    begin
      LayerIndex := -1;
      UseAnisotropy := False;
      if FModel.LayerStructure.Count > 2 then
      begin
        DataSetFormulaKz := 'CaseR(' + LayerString + ', ';
        AnisotropyFormulaKz := 'CaseR(' + LayerString + ', ';
      end
      else
      begin
        DataSetFormulaKz := '';
        AnisotropyFormulaKz := '';
      end;
      for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
      begin
        Group := FModel.LayerStructure.LayerGroups[GroupIndex];
        if Group.RunTimeSimulated then
        begin
          Inc(LayerIndex);
        end;
        Assert(LayerIndex >= 0);
        if Group.RunTimeSimulated then
        begin
          UseAnisotropyInLayer := LAYVKA[LayerIndex] <> 0;
          if UseAnisotropyInLayer then
          begin
            UseAnisotropy := True;
          end;
          if not UseAnisotropyInLayer and (FVerticalKConst <> nil) and
            FVerticalKConst[LayerIndex].IsConstant then
          begin
            AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
            DataSetFormulaKz := DataSetFormulaKz +
              FortranFloatToStr(FVerticalKConst[LayerIndex].RealValue);
          end
          else if UseAnisotropyInLayer and
            ((FHorizontalToVerticalAnisotropyConst <> nil) and
            (FHorizontalToVerticalAnisotropyConst[LayerIndex].IsConstant)) then
          begin
            DataSetFormulaKz := DataSetFormulaKz + '0';
            AnisotropyFormulaKz := AnisotropyFormulaKz +
              FortranFloatToStr(FHorizontalToVerticalAnisotropyConst[LayerIndex]
              .RealValue);
          end
          else
          begin
            if UseAnisotropyInLayer then
            begin
              if (FHorizontalToVerticalAnisotropy = nil) or
                (FHorizontalToVerticalAnisotropy[LayerIndex] = nil) then
              begin
                DataSetFormulaKz := DataSetFormulaKz + '0';
                AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
              end
              else
              begin
                if ScreenObject = nil then
                begin
                  CreateOrRetrieveCellCenterScreenObject(ScreenObject);
                end;
                DataArrayName := 'Imported_Vertical_Anisotropy_Layer_' +
                  IntToStr(GroupIndex);
                CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
                  FHorizontalToVerticalAnisotropy[LayerIndex]);
                DataSetFormulaKz := DataSetFormulaKz + '0';
                AnisotropyFormulaKz := AnisotropyFormulaKz + DataArrayName;
              end;
            end
            else
            begin
              if (FVerticalK = nil) or (FVerticalK[LayerIndex] = nil) then
              begin
                DataSetFormulaKz := DataSetFormulaKz + '0';
                AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
              end
              else
              begin
                if ScreenObject = nil then
                begin
                  CreateOrRetrieveCellCenterScreenObject(ScreenObject);
                end;
                Assert(FVerticalK <> nil);
                DataArrayName := 'Imported_Kz_Layer_' + IntToStr(GroupIndex);
                CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
                  FVerticalK[LayerIndex]);
                AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
                DataSetFormulaKz := DataSetFormulaKz + DataArrayName;
              end;
            end;
          end;
        end
        else
        begin
          if (FQuasiVerticalKConst <> nil) and FQuasiVerticalKConst[LayerIndex].IsConstant
          then
          begin
            AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
            DataSetFormulaKz := DataSetFormulaKz +
              FortranFloatToStr(FQuasiVerticalKConst[LayerIndex].RealValue);
          end
          else
          begin
            if (FQuasiVerticalK = nil) or (FQuasiVerticalK[LayerIndex] = nil)
            then
            begin
              DataSetFormulaKz := DataSetFormulaKz + '0';
              AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
            end
            else
            begin
              if ScreenObject = nil then
              begin
                CreateOrRetrieveCellCenterScreenObject(ScreenObject);
              end;
              DataArrayName := 'Imported_Kz_Layer_' + IntToStr(GroupIndex);
              CreateDataArrayAndAssignValues(ScreenObject, DataArrayName,
                FQuasiVerticalK[LayerIndex]);
              DataSetFormulaKz := DataSetFormulaKz + DataArrayName;
              AnisotropyFormulaKz := AnisotropyFormulaKz + '0';
            end;
          end;
        end;
        if GroupIndex < FModel.LayerStructure.Count - 1 then
        begin
          DataSetFormulaKz := DataSetFormulaKz + ', ';
          AnisotropyFormulaKz := AnisotropyFormulaKz + ', ';
        end;
      end;
      if FModel.LayerStructure.Count > 2 then
      begin
        DataSetFormulaKz := DataSetFormulaKz + ')';
        AnisotropyFormulaKz := AnisotropyFormulaKz + ')';
      end;
      DataArray := FModel.DataArrayManager.GetDataSetByName(rsKz);
      DataArray.Formula := DataSetFormulaKz;
      DataArray := FModel.DataArrayManager.GetDataSetByName(rsModflow_CBKz);
      if DataArray <> nil then
      begin
        DataArray.Formula := DataSetFormulaKz;
      end;
      if UseAnisotropy then
      begin
        DataArray := FModel.DataArrayManager.GetDataSetByName
          (rsVerticalAnisotropy);
        DataArray.Formula := AnisotropyFormulaKz;
      end;
    end;
  end;
end;

procedure TCustomFlowPackageImporter.ImportSpecificStorage;
var
  Suffix: string;
begin
  Suffix := '';
  if FStorageCoefficientChoice then
  begin
    Suffix := ' / ' + StrLayerHeight;
  end;
  CheckPositiveArrayValues(FSpecificStorage, FSpecificStorageConst,
    rsSpecific_Storage, FBas);
  ImportDataSet('Specific_Storage', rsSpecific_Storage, FSpecificStorageConst,
    FSpecificStorage, Suffix);
end;

procedure TCustomFlowPackageImporter.ImportSpecificYield;
begin
  CheckPositiveArrayValues(FSpecificYield, FSpecificYieldConst, rsSpecificYield, FBas);
  ImportDataSet('Specific_Yield', rsSpecificYield, FSpecificYieldConst,
    FSpecificYield);
end;

{ TNwtImporter }

constructor TNwtImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'DE4:');
end;

procedure TNwtImporter.ReadDataSet2A;
begin
  Read(FImporter.FFile, MAXITINNER);
  Read(FImporter.FFile, ILUMETHOD);
  Read(FImporter.FFile, LEVFILL);
  Read(FImporter.FFile, STOPTOL);
  Read(FImporter.FFile, MSDR);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TNwtImporter.ReadDataSet2B;
begin
  Read(FImporter.FFile, IACL);
  Read(FImporter.FFile, NORDER);
  Read(FImporter.FFile, LEVEL);
  Read(FImporter.FFile, NORTH);
  Read(FImporter.FFile, IREDSYS);
  Read(FImporter.FFile, RRCTOLS);
  Read(FImporter.FFile, IDROPTOL);
  Read(FImporter.FFile, EPSRNS);
  Read(FImporter.FFile, HCLOSEXMD);
  Read(FImporter.FFile, MXITERXMD);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TNwtImporter.ReadDataSet1D;
begin
  Read(FImporter.FFile, MAXBACKITER);
  Read(FImporter.FFile, BACKTOL);
  Read(FImporter.FFile, BACKREDUCE);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TNwtImporter.ReadDataSet1C;
begin
  Read(FImporter.FFile, DBDTHETA);
  Read(FImporter.FFile, DBDKAPPA);
  Read(FImporter.FFile, DBDGAMMA);
  Read(FImporter.FFile, MOMFACT);
  Read(FImporter.FFile, BACKFLAG);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TNwtImporter.ReadDataSet1A;
begin
  Read(FImporter.FFile, HEADTOL);
  Read(FImporter.FFile, FLUXTOL);
  Read(FImporter.FFile, MAXITEROUT);
  Read(FImporter.FFile, THICKFACT);
  Read(FImporter.FFile, LINMETH);
  Read(FImporter.FFile, IPRNWT);
  Read(FImporter.FFile, IBOTAV);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TNwtImporter.HandlePackage;
begin
  inherited;
  frmGoPhast.ModelSelection := msModflowNWT;
  FNWTPackage := FModel.ModflowPackages.NWTPackage;
  FNWTPackage.IsSelected := True;
  FNWTPackage.Comments := FComments;

  // data set 1.
  FNWTPackage.HeadTolerance.Value := HEADTOL;
  FNWTPackage.FluxTolerance.Value := FLUXTOL;
  FNWTPackage.MaxOuterIterations := MAXITEROUT;
  FNWTPackage.ThicknessFactor.Value := THICKFACT;

  FNWTPackage.SolverMethod := TNewtonSolverMethod(LINMETH-1);
  FNWTPackage.PrintFlag := IPRNWT;
  FNWTPackage.CorrectForCellBottom := IBOTAV;
  FNWTPackage.Option := FOption;

  if FOption = noSpecified then
  begin
    // data set 2.
    FNWTPackage.DBDTheta.Value := DBDTHETA;
    FNWTPackage.DBDKappa.Value := DBDKAPPA;
    FNWTPackage.DBDGamma.Value := DBDGAMMA;
    FNWTPackage.MomementumCoefficient.Value := MOMFACT;
    FNWTPackage.BackFlag := BACKFLAG;
    FNWTPackage.MaxBackIterations := MAXBACKITER;
    FNWTPackage.BackTol.Value := BACKTOL;
    FNWTPackage.BackReduce.Value := BACKREDUCE;
    if FNWTPackage.SolverMethod = nsmGmres then
    begin
      FNWTPackage.MaxIterInner := MAXITINNER;
      FNWTPackage.IluMethod := TNewtonIluMethod(ILUMETHOD-1);
      if FNWTPackage.IluMethod = nimDropTol then
      begin
        FNWTPackage.FillLimit := LEVFILL;
      end
      else
      begin
        Assert(FNWTPackage.IluMethod = nimKOrder);
        FNWTPackage.FillLevel := LEVFILL;
      end;
      FNWTPackage.StopTolerance.Value := STOPTOL;
      FNWTPackage.MaxGmresRestarts := MSDR;

{
  TNewtonIluMethod = (nimDropTol, nimKOrder);
  TNewtonAccelMethod = (namCongGrad, namOthoMin, namBiCgstab);
  TNewtonOrderingMethod = (nomRCM, nomMinimumOrdering);
  TNewtonApplyReducedPrecondition = (narpDontApply, narpApply);
  TNewtonUseDropTolerance = (nudtDontUse, nudtUse);

 }
    end
    else
    begin
      Assert(FNWTPackage.SolverMethod = nsmChiMD);
      FNWTPackage.AccelMethod := TNewtonAccelMethod(IACL);
      FNWTPackage.OrderingMethod := TNewtonOrderingMethod(NORDER);
      FNWTPackage.Level := LEVEL;
      FNWTPackage.NumberOfOrthogonalizations := NORTH;
      FNWTPackage.ApplyReducedPrecondition := TNewtonApplyReducedPrecondition(IREDSYS);
      FNWTPackage.ResidReducConv.Value := RRCTOLS;
      if IDROPTOL = 0 then
      begin
        FNWTPackage.UseDropTolerance := nudtDontUse
      end
      else
      begin
        FNWTPackage.UseDropTolerance := nudtUse
      end;
      FNWTPackage.DropTolerancePreconditioning.Value := EPSRNS;
      FNWTPackage.InnerHeadClosureCriterion.Value := HCLOSEXMD;
      FNWTPackage.MaxInnerIterations := MXITERXMD;
      FNWTPackage.ContinueNWT := FContinueNWT
    end;
  end;
end;

procedure TNwtImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'toldum,ftoldum,Mxiter,Thickdum,Linmeth,IPRNWT,IBOTAV:' then
  begin
    ReadDataSet1A;
  end
  else if ALabel = 'SIMPLE:' then
  begin
    FOption := noSimple;
//    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'MODERATE:' then
  begin
    FOption := noModerate;
//    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'COMPLEX:' then
  begin
    FOption := noComplex;
//    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'SPECIFIED:' then
  begin
    FOption := noSpecified;
//    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'CONTINUE:' then
  begin
    FContinueNWT := True;
//    ReadLn(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'thetadum,akappadum,gammadum,amomentdum,Btrack:' then
  begin
    ReadDataSet1C;
  end
  else if ALabel = 'Numtrack,Btoldum,Breducdum:' then
  begin
    ReadDataSet1D;
  end
  else if ALabel = 'IACL,NORDER,LEVEL,NORTH,IREDSYS,RRCTOLS,IDROPTOL,EPSRNS,HCLOSEXMDDUM,MXITERXMD:' then
  begin
    ReadDataSet2B;
  end
  else if ALabel = 'MAXITINNER,ILUMETHOD,LEVFILL,STOPTOL,MSDR:' then
  begin
    ReadDataSet2A;
  end
  else
  begin
    Assert(False, Format('Unrecognized label %s', [ALabel]));
  end;

end;

{ TStrImporter }

constructor TStrImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'STR:');
  FObsImporter := nil;
  FParameters := TStrParamArray.Create;
  FStressPeriods := TStrStressPeriodArray.Create;
  FChannelCharacteristicsStressPeriodArray := TChannelCharacteristicsStressPeriodArray.Create;
  FTributariesStressPeriodArray := TTributariesStressPeriodArray.Create;
  FDiversionStressPeriodArray := TDiversionStressPeriodArray.Create;
  FParamInstanceStressPeriodArray := TParamInstanceStressPeriodArray.Create;
  FScreenObjectsInAllStressPeriod := TObjectList<TList<TScreenObject>>.Create;
end;

destructor TStrImporter.Destroy;
begin
  FScreenObjectsInAllStressPeriod.Free;
  FParamInstanceStressPeriodArray.Free;
  FDiversionStressPeriodArray.Free;
  FTributariesStressPeriodArray.Free;
  FChannelCharacteristicsStressPeriodArray.Free;
  FStressPeriods.Free;
  FParameters.Free;
  inherited;
end;

procedure TStrImporter.SetLengthAndTimeUnit;
Const
  MaxLengthUnit = 3;
  MaxTimeUnit = 5;
var
  TimeUnit: Integer;
  LengthIndex: Integer;
  MinDifference: Double;
  Difference: Double;
  LengthUnit: Integer;
  TimeIndex: Integer;
begin
  if FStrPackage.CalculateStage then
  begin
    if FModel.ModflowOptions.LengthUnit = 0 then
    begin
      if FModel.ModflowOptions.TimeUnit = 0 then
      begin
        LengthUnit := 1;
        FModel.ModflowOptions.LengthUnit := LengthUnit;
        TimeUnit := 1;
        FModel.ModflowOptions.TimeUnit := TimeUnit;
        MinDifference := Abs(TStrWriter.ComputeStreamConstant(FModel) - AConst);
        for LengthIndex := 1 to MaxLengthUnit do
        begin
          FModel.ModflowOptions.LengthUnit := LengthIndex;
          for TimeIndex := 1 to MaxTimeUnit do
          begin
            FModel.ModflowOptions.TimeUnit := TimeIndex;
            Difference := Abs(TStrWriter.ComputeStreamConstant(FModel) - AConst);
            if Difference < MinDifference then
            begin
              LengthUnit := LengthIndex;
              TimeUnit := TimeIndex;
            end;
          end;
        end;
        FModel.ModflowOptions.LengthUnit := LengthUnit;
        FModel.ModflowOptions.TimeUnit := TimeUnit;
      end
      else
      begin
        LengthUnit := 1;
        FModel.ModflowOptions.LengthUnit := LengthUnit;
        MinDifference := Abs(TStrWriter.ComputeStreamConstant(FModel) - AConst);
        for LengthIndex := 2 to MaxLengthUnit do
        begin
          FModel.ModflowOptions.LengthUnit := LengthIndex;
          Difference := Abs(TStrWriter.ComputeStreamConstant(FModel) - AConst);
          if Difference < MinDifference then
          begin
            LengthUnit := LengthIndex;
          end;
        end;
        FModel.ModflowOptions.LengthUnit := LengthUnit;
      end;
    end
    else if FModel.ModflowOptions.TimeUnit = 0 then
    begin
      TimeUnit := 1;
      FModel.ModflowOptions.TimeUnit := TimeUnit;
      MinDifference := Abs(TStrWriter.ComputeStreamConstant(FModel) - AConst);
      for TimeIndex := 2 to MaxTimeUnit do
      begin
        FModel.ModflowOptions.TimeUnit := TimeIndex;
        Difference := Abs(TStrWriter.ComputeStreamConstant(FModel) - AConst);
        if Difference < MinDifference then
        begin
          TimeUnit := TimeIndex;
        end;
      end;
      FModel.ModflowOptions.TimeUnit := TimeUnit;
    end;
  end;
end;

procedure TStrImporter.ReadDataSet7B;
var
  Iname: string;
  Item: TParamInstance;
begin
  Readln(FImporter.FFile, Iname);
  Item := FParamInstanceStressPeriodArray[FCurrentStressPeriod][FParamIndex];
  Item.InstanceName := UpperCase(Trim(Iname));
  FImporter.UpdateProgress;
end;

procedure TStrImporter.ReadDataSet7A;
var
  Pname: string;
  Item: TParamInstance;
begin
  Inc(FParamIndex);
  Readln(FImporter.FFile, Pname);
  Item := FParamInstanceStressPeriodArray[FCurrentStressPeriod][FParamIndex];
  Item.ParamName := UpperCase(Trim(Pname));
  Item.InstanceName := '';
  FImporter.UpdateProgress;
end;

procedure TStrImporter.ReadDataSet10;
var
  Iupseg: Integer;
  Item: TDiversion;
begin
  Inc(FSegmentDiversionIndex);
  Item := FDiversionStressPeriodArray[FCurrentStressPeriod][FSegmentDiversionIndex];
  Read(FImporter.FFile, Iupseg);
  Item.Iupseg := Iupseg;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TStrImporter.ReadDataSet9;
var
  Itrib: Integer;
  Item: TTributaries;
  TribIndex: Integer;
begin
  Inc(FSegmentTributaryIndex);
  Item := FTributariesStressPeriodArray
    [FCurrentStressPeriod][FSegmentTributaryIndex];
  SetLength(Item.Itrib, NTRIB);
  for TribIndex := 0 to NTRIB - 1 do
  begin
    Read(FImporter.FFile, Itrib);
    Item.Itrib[TribIndex] := Itrib;
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TStrImporter.ReadDataSet8;
var
  Item: TChannelCharacteristics;
  Slope: Double;
  Rough: Double;
  Width: Double;
begin
  Inc(FReachChanelIndex);
  Read(FImporter.FFile, Width);
  Read(FImporter.FFile, Slope);
  Read(FImporter.FFile, Rough);
  Readln(FImporter.FFile);
  Item := FChannelCharacteristicsStressPeriodArray
    [FCurrentStressPeriod][FReachChanelIndex];
  Item.Width := Width;
  Item.Slope := Slope;
  Item.Roughness := Rough;
  FImporter.UpdateProgress;
end;

procedure TStrImporter.AssignReach(ReachObject: TStrLocationObject);
var
  Stop: Double;
  Reach: Integer;
  Sbot: Double;
  Layer: Integer;
  Column: Integer;
  Segment: Integer;
  Row: Integer;
  Cond: Double;
  Stage: Double;
  Flow: Double;
begin
  Read(FImporter.FFile, Layer);
  Read(FImporter.FFile, Row);
  Read(FImporter.FFile, Column);
  Read(FImporter.FFile, Segment);
  Read(FImporter.FFile, Reach);
  Read(FImporter.FFile, Flow);
  Read(FImporter.FFile, Stage);
  Read(FImporter.FFile, Cond);
  Read(FImporter.FFile, Sbot);
  Read(FImporter.FFile, Stop);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  ReachObject.Layer := Layer;
  ReachObject.Row := Row;
  ReachObject.Column := Column;
  ReachObject.SegmentNumber := Segment;
  ReachObject.ReachNumber := Reach;
  ReachObject.Flow := Flow;
  ReachObject.Stage := Stage;
  ReachObject.Condfact := Cond;
  ReachObject.ReachNumber := Reach;
  ReachObject.Sbot := Sbot;
  ReachObject.Stop := Stop;
end;

{$HINTS OFF}
procedure TStrImporter.ReadDataSet5;
var
  IPTFLG: Integer;
  IRDFLG: Integer;
begin
  Inc(FCurrentStressPeriod);
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, IRDFLG);
  Read(FImporter.FFile, IPTFLG);
  Readln(FImporter.FFile);
  InitializeCurrentStressPeriod;
  FImporter.UpdateProgress;
end;
{$HINTS ON}

function TStrImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := ScreenObject.ModflowStrBoundary;
end;

procedure TStrImporter.HandlePackage;
var
  StressPeriodIndex: Integer;
  StartTime: Double;
  EndTime: Double;
  StressPeriod: TStrStressPeriod;
  SP: TListStressPeriod;
  AReach: TStrLocationObject;
  Segments: TSegmentListList;
  PriorSegment: Integer;
  ReachList: TReachList;
  UndoCreateScreenObject: TCustomUndo;
  ScreenObject: TScreenObject;
  ImportedElevations: TValueArrayStorage;
  Boundary: TStrLocationObject;
  SegmentList: TSegmentList;
  StageItem: TValueArrayItem;
  CondItem: TValueArrayItem;
  SbotItem: TValueArrayItem;
  StopItem: TValueArrayItem;
  WidthItem: TValueArrayItem;
  SlopeItem: TValueArrayItem;
  RoughnessItem: TValueArrayItem;
  PriorStageItem: TValueArrayItem;
  PriorCondItem: TValueArrayItem;
  PriorSbotItem: TValueArrayItem;
  PriorStopItem: TValueArrayItem;
  PriorWidthItem: TValueArrayItem;
  PriorSlopeItem: TValueArrayItem;
  PriorRoughnessItem: TValueArrayItem;
  StrBoundary: TStrBoundary;
  StrItem: TStrItem;
  Flow: double;
  ChannelReachIndex: integer;
  SegmentsNumbers: TListOfTIntegerList;
  SegNumb: TGenericIntegerList;
  ChannelCharacteristics: TChannelCharacteristics;
  ChannelCharStart: Integer;
  ScreenObjectsInStressPeriod: TList<TScreenObject>;
  Tribs: TTributaries;
  TributaryObject: TScreenObject;
  OtherStrItem: TStrItem;
  Diversion: TDiversion;
  DiversionObject: TScreenObject;
  ParamIndex: Integer;
  AParam: TParamInstance;
  StrInstance: TStrInstanceObject;
  ReachIndex: Integer;
  ObjectIndex: Integer;
  StartTimes: TList<double>;
  InvalidTribIndexes: TGenericIntegerList;
  InvalidBoundaryNumbers: TGenericIntegerList;
  InvalidTribObjects: TList<TStrItem>;
//  ErrorFound: boolean;
  procedure AddSegment;
  var
    SegmentListIndex: Integer;
    ASegmentList: TSegmentList;
  begin
    if ReachList.SegmentNumber-1 >= Segments.Count then
    begin
      ASegmentList := TSegmentList.Create;
      Segments.Add(ASegmentList);
      ASegmentList.Add(ReachList);
      Exit;
    end
    else
    begin
      ASegmentList := Segments[ReachList.SegmentNumber-1];
      if ASegmentList[0].LocationsMatch(ReachList) then
      begin
        ASegmentList.Add(ReachList);
        Exit;
      end;
    end;
    for SegmentListIndex := 0 to Segments.Count - 1 do
    begin
      ASegmentList := Segments[SegmentListIndex];
      if ASegmentList[0].LocationsMatch(ReachList) then
      begin
        ASegmentList.Add(ReachList);
        Exit;
      end;
    end;
    ASegmentList := TSegmentList.Create;
    Segments.Add(ASegmentList);
    ASegmentList.Add(ReachList);
  end;
  function GetInstance(AParam: TParamInstance): TStrInstanceObject;
  var
    ParamIndex: integer;
    InstanceIndex: Integer;
  begin
    result := nil;
    for ParamIndex := 0 to FParameters.ArrayLength - 1 do
    begin
      if CompareText(FParameters[ParamIndex].PARNAM, AParam.ParamName) = 0 then
      begin
        for InstanceIndex := 0 to FParameters[ParamIndex].ArrayLength - 1 do
        begin
          if CompareText(FParameters[ParamIndex].
            Instances[InstanceIndex].Name, AParam.InstanceName) = 0 then
          begin
            result := FParameters[ParamIndex].Instances[InstanceIndex]
              as TStrInstanceObject;
            Exit;
          end;
        end;
      end;
    end;
  end;
  procedure CreateObjects;
  var
    ScreenObjectIndex: Integer;
    Index: Integer;
    StressPeriodIndex: Integer;
    ReachIndex: Integer;
    TribIndex: Integer;
    ParamItem: TModflowParamItem;
    PriorBoundary: TStrLocationObject;
    NeighborPoints: Boolean;
    APoint: TPoint2D;
    Grid: TModflowGrid;
    PriorPoint: TPoint2D;
    PointIndex: Integer;
    SectionLength: double;
    TributaryNumber: integer;
    SegmentNumber: Integer;
    ScreenObjects: TList<TScreenObject>;
    STime: Double;
    SIndex: Integer;
    StressPeriod: integer;
    StrItems: TStrItemList;
    StrItemLists: TStrItemLists;
    InvalidPos: Integer;
    MaxZeros: integer;
    NotZeros: integer;
    Zeros: string;
    ZeroIndex: Integer;
  begin
    Grid := frmGoPhast.PhastModel.ModflowGrid;
    UndoCreateScreenObject := nil;
    ChannelReachIndex := -1;
    ScreenObjects := TList<TScreenObject>.Create;
    StrItemLists := TStrItemLists.Create;
    // loop over segments in all stress periods
    try
      MaxZeros := Trunc(Log10(Segments.Count));
      for ScreenObjectIndex := 0 to Segments.Count - 1 do
      begin
        StrItems := TStrItemList.Create;
        StrItemLists.Add(StrItems);
        SegmentList := Segments[ScreenObjectIndex];
        ReachList := SegmentList[0];
        SegmentNumber := ReachList[0].SegmentNumber;
        StressPeriod :=  ReachList.StressPeriod;

        ScreenObject := TScreenObject.CreateWithViewDirection(FModel, vdTop,
          UndoCreateScreenObject, False);
        ScreenObject.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);
        ScreenObjects.Add(ScreenObject);

        NotZeros := Trunc(Log10(ObjectIndex));
        Zeros := '';
        if NotZeros < MaxZeros then
        begin
          for ZeroIndex := NotZeros to MaxZeros - 1 do
          begin
            Zeros := Zeros + '0';
          end;
        end;

        ScreenObject.Name := 'Str_Segment_' + Zeros + IntToStr(ObjectIndex);
        Inc(ObjectIndex);
        FModel.AddScreenObject(ScreenObject);
        ScreenObject.ElevationCount := ecOne;
        ScreenObject.SetValuesOfIntersectedCells := True;
        ScreenObject.EvaluatedAt := eaBlocks;
        ScreenObject.Visible := False;
        ScreenObject.Capacity := ReachList.Count;

        ImportedElevations := ScreenObject.ImportedSectionElevations;
        ImportedElevations.DataType := rdtDouble;
        ImportedElevations.Count := ReachList.Count;
        PriorBoundary := nil;
        for Index := 0 to ReachList.Count - 1 do
        begin
          Boundary := ReachList[Index];
          NeighborPoints := False;
          if PriorBoundary <> nil then
          begin
            if Max(Abs(PriorBoundary.Row - Boundary.Row),
              Abs(PriorBoundary.Column - Boundary.Column)) = 1 then
            begin
              NeighborPoints := True;
            end;
          end;

          if NeighborPoints then
          begin
            if (Boundary.Row <> PriorBoundary.Row) then
            begin
              if (Boundary.Column <> PriorBoundary.Column) then
              begin
                APoint := FImporter.CornerPoints[Min(Boundary.Row, PriorBoundary.Row),
                  Min(Boundary.Column, PriorBoundary.Column)]
              end
              else
              begin
                APoint := Grid.TwoDRowEdgeCenter(Boundary.Column-1,
                  Min(Boundary.Row, PriorBoundary.Row));
              end;
            end
            else
            begin
              Assert((Boundary.Column <> PriorBoundary.Column));
              APoint := Grid.TwoDColumnEdgeCenter(Min(Boundary.Column, PriorBoundary.Column),
                Boundary.Row-1);
            end;
            ScreenObject.AddPoint(APoint, False);
            ScreenObject.AddPoint(APoint, True);
            ScreenObject.AddPoint(FImporter.CenterPoints[Boundary.Row - 1,
              Boundary.Column - 1], False);
          end
          else
          begin
            ScreenObject.AddPoint(FImporter.CenterPoints[Boundary.Row - 1,
              Boundary.Column - 1], True);
          end;

          ImportedElevations.RealValues[Index] :=
            FGrid.LayerCenter(Boundary.Column - 1, Boundary.Row - 1,
            FModel.ModflowLayerToDataSetLayer(Boundary.Layer));
          PriorBoundary := Boundary;
        end;
        ScreenObject.ElevationFormula := rsObjectImportedValuesR
          + '("' + StrImportedElevations + '")';
        ImportedElevations.CacheData;
        ScreenObject.SectionStarts.CacheData;

        ScreenObject.CreateStrBoundary;
        StrBoundary := ScreenObject.ModflowStrBoundary;
        StrBoundary.SegmentNumber := ScreenObjectIndex + 1;
        ScreenObject.Comment := Format(StrOriginalSegmentNum,
          [SegmentNumber, StressPeriod+1]);

        for StressPeriodIndex := 0 to SegmentList.Count - 1 do
        begin
          ReachList := SegmentList[StressPeriodIndex];
          STime := FModel.ModflowStressPeriods[ReachList.StressPeriod].StartTime;
          SIndex := StartTimes.IndexOf(STime);
          Assert(SIndex >= 0);
          ScreenObjectsInStressPeriod :=
            FScreenObjectsInAllStressPeriod[SIndex];
          while ScreenObjectsInStressPeriod.Count < SegmentNumber do
          begin
            ScreenObjectsInStressPeriod.Add(nil);
          end;
          ScreenObjectsInStressPeriod[SegmentNumber-1] := ScreenObject;
        end;
//
        PriorStageItem := nil;
        PriorCondItem := nil;
        PriorSbotItem := nil;
        PriorStopItem := nil;
        PriorWidthItem := nil;
        PriorSlopeItem := nil;
        PriorRoughnessItem := nil;

        for StressPeriodIndex := 0 to SegmentList.Count - 1 do
        begin
          ReachList := SegmentList[StressPeriodIndex];

          StageItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
          CondItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
          SbotItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
          StopItem := ScreenObject.ImportedValues.Add as TValueArrayItem;

          StageItem.Name := 'Stage_SP_' + IntToStr(ReachList.StressPeriod+1);
          CondItem.Name := 'Cond_SP_' + IntToStr(ReachList.StressPeriod+1);
          SbotItem.Name := 'Sbot_SP_' + IntToStr(ReachList.StressPeriod+1);
          StopItem.Name := 'Stop_SP_' + IntToStr(ReachList.StressPeriod+1);

          StageItem.Values.DataType := rdtDouble;
          CondItem.Values.DataType := rdtDouble;
          SbotItem.Values.DataType := rdtDouble;
          StopItem.Values.DataType := rdtDouble;

          StageItem.Values.Count := ReachList.Count;
          CondItem.Values.Count := ReachList.Count;
          SbotItem.Values.Count := ReachList.Count;
          StopItem.Values.Count := ReachList.Count;

          WidthItem := nil;
          SlopeItem := nil;
          RoughnessItem := nil;
          if ICALC > 0 then
          begin
            WidthItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
            SlopeItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
            RoughnessItem := ScreenObject.ImportedValues.Add as TValueArrayItem;

            WidthItem.Name := 'Width_SP_' + IntToStr(ReachList.StressPeriod+1);
            SlopeItem.Name := 'Slope_SP_' + IntToStr(ReachList.StressPeriod+1);
            RoughnessItem.Name :=
              'Roughness_SP_' + IntToStr(ReachList.StressPeriod+1);

            WidthItem.Values.DataType := rdtDouble;
            SlopeItem.Values.DataType := rdtDouble;
            RoughnessItem.Values.DataType := rdtDouble;

            WidthItem.Values.Count := ReachList.Count;
            SlopeItem.Values.Count := ReachList.Count;
            RoughnessItem.Values.Count := ReachList.Count;
          end;

          Flow := 0;

          ChannelCharStart := 0;
          if ICALC > 0 then
          begin
            ChannelCharStart :=
              SegmentsNumbers[StressPeriodIndex][ReachList.SegmentNumber-1];
          end;

          for ReachIndex := 0 to ReachList.Count - 1 do
          begin
            AReach := ReachList[ReachIndex];
            if ReachIndex = 0 then
            begin
              Flow := AReach.Flow;
            end;
            StageItem.Values.RealValues[ReachIndex] := AReach.Stage;

            if ScreenObject.SectionLength[ReachIndex] = 1 then
            begin
              CondItem.Values.RealValues[ReachIndex] := AReach.Condfact;
            end
            else
            begin
              SectionLength := 0;
              PriorPoint := ScreenObject.Points[ScreenObject.SectionStart[ReachIndex]];
              for PointIndex := ScreenObject.SectionStart[ReachIndex]+1
                to ScreenObject.SectionEnd[ReachIndex] do
              begin
                APoint := ScreenObject.Points[PointIndex];
                SectionLength := SectionLength + Distance(PriorPoint,APoint);
                PriorPoint := APoint;
              end;
              CondItem.Values.RealValues[ReachIndex] := AReach.Condfact / SectionLength;
            end;

            SbotItem.Values.RealValues[ReachIndex] := AReach.Sbot;
            StopItem.Values.RealValues[ReachIndex] := AReach.Stop;

            if ICALC > 0 then
            begin
              ChannelCharacteristics :=
                FChannelCharacteristicsStressPeriodArray[StressPeriodIndex]
                [ReachIndex + ChannelCharStart];
              WidthItem.Values.RealValues[ReachIndex] :=
                ChannelCharacteristics.Width;
              SlopeItem.Values.RealValues[ReachIndex] :=
                ChannelCharacteristics.Slope;
              RoughnessItem.Values.RealValues[ReachIndex] :=
                ChannelCharacteristics.Roughness;
            end;
          end;

          if ReachList.ParameterName = '' then
          begin
            StrItem := StrBoundary.Values.Add as TStrItem;
          end
          else
          begin
            if StrBoundary.Parameters.Count = 0 then
            begin
              ParamItem := StrBoundary.Parameters.Add;
              ParamItem.Param.ParamName := ReachList.ParameterName;
            end
            else
            begin
              ParamItem := StrBoundary.Parameters[0];
            end;
            StrItem := ParamItem.Param.Add as TStrItem;
          end;
          StrItems.Add(StrItem);


          StrItem.StartTime := ReachList.StartTime;
          StrItem.EndTime := ReachList.EndTime;

          if StageItem.Values.UniformValues then
          begin
            StrItem.Stage := FortranFloatToStr(StageItem.Values.RealValues[0]);
            StageItem.Free;
          end
          else
          begin
            if PriorStageItem <> nil then
            begin
              if StageItem.Values.IsSame(PriorStageItem.Values) then
              begin
                StageItem.Free;
                StageItem := PriorStageItem;
              end;
            end;
            StrItem.Stage := rsObjectImportedValuesR
              + '("' + StageItem.Name + '")';
            PriorStageItem := StageItem;
          end;

          if CondItem.Values.UniformValues then
          begin
            StrItem.Conductance := FortranFloatToStr(CondItem.Values.RealValues[0]);
            CondItem.Free;
          end
          else
          begin
            if PriorCondItem <> nil then
            begin
              if CondItem.Values.IsSame(PriorCondItem.Values) then
              begin
                CondItem.Free;
                CondItem := PriorCondItem;
              end;
            end;
            StrItem.Conductance := rsObjectImportedValuesR
              + '("' + CondItem.Name + '")';
            PriorCondItem := CondItem;
          end;

          if StopItem.Values.UniformValues then
          begin
            StrItem.BedTop := FortranFloatToStr(StopItem.Values.RealValues[0]);
            StopItem.Free;
          end
          else
          begin
            if PriorStopItem <> nil then
            begin
              if StopItem.Values.IsSame(PriorStopItem.Values) then
              begin
                StopItem.Free;
                StopItem := PriorStopItem;
              end;
            end;
            StrItem.BedTop := rsObjectImportedValuesR
              + '("' + StopItem.Name + '")';
            PriorStopItem := StopItem;
          end;

          if SbotItem.Values.UniformValues then
          begin
            StrItem.BedBottom := FortranFloatToStr(SbotItem.Values.RealValues[0]);
            SbotItem.Free;
          end
          else
          begin
            if PriorSbotItem <> nil then
            begin
              if SbotItem.Values.IsSame(PriorSbotItem.Values) then
              begin
                SbotItem.Free;
                SbotItem := PriorSbotItem;
              end;
            end;
            StrItem.BedBottom := rsObjectImportedValuesR
              + '("' + SbotItem.Name + '")';
            PriorSbotItem := SbotItem;
          end;

          // Flow only applies to the first reach.
          StrItem.Flow := FortranFloatToStr(Flow);

          if ICALC > 0 then
          begin
            if WidthItem.Values.UniformValues then
            begin
              StrItem.Width := FortranFloatToStr(WidthItem.Values.RealValues[0]);
              WidthItem.Free;
            end
            else
            begin
              if PriorWidthItem <> nil then
              begin
                if WidthItem.Values.IsSame(PriorWidthItem.Values) then
                begin
                  WidthItem.Free;
                  WidthItem := PriorWidthItem;
                end;
              end;
              StrItem.Width := rsObjectImportedValuesR
                + '("' + WidthItem.Name + '")';
              PriorWidthItem := WidthItem;
            end;

            if SlopeItem.Values.UniformValues then
            begin
              StrItem.Slope := FortranFloatToStr(SlopeItem.Values.RealValues[0]);
              SlopeItem.Free;
            end
            else
            begin
              if PriorSlopeItem <> nil then
              begin
                if SlopeItem.Values.IsSame(PriorSlopeItem.Values) then
                begin
                  SlopeItem.Free;
                  SlopeItem := PriorSlopeItem;
                end;
              end;
              StrItem.Slope := rsObjectImportedValuesR
                + '("' + SlopeItem.Name + '")';
              PriorSlopeItem := SlopeItem;
            end;

            if RoughnessItem.Values.UniformValues then
            begin
              StrItem.Roughness := FortranFloatToStr(RoughnessItem.Values.RealValues[0]);
              RoughnessItem.Free;
            end
            else
            begin
              if PriorRoughnessItem <> nil then
              begin
                if RoughnessItem.Values.IsSame(PriorRoughnessItem.Values) then
                begin
                  RoughnessItem.Free;
                  RoughnessItem := PriorRoughnessItem;
                end;
              end;
              StrItem.Roughness := rsObjectImportedValuesR
                + '("' + RoughnessItem.Name + '")';
              PriorRoughnessItem := RoughnessItem;
            end;
          end;
        end;

      end;

        // loop over stress periods.
      for ScreenObjectIndex := 0 to Segments.Count - 1 do
      begin
        StrItems := StrItemLists[ScreenObjectIndex];

        ScreenObject := ScreenObjects[ScreenObjectIndex];
        StrBoundary := ScreenObject.ModflowStrBoundary;
        SegmentList := Segments[ScreenObjectIndex];
        for StressPeriodIndex := 0 to SegmentList.Count - 1 do
        begin
          StrItem := StrItems[StressPeriodIndex];
          ReachList := SegmentList[StressPeriodIndex];
          if NTRIB > 0 then
          begin
            STime := FModel.ModflowStressPeriods[ReachList.StressPeriod].StartTime;
            SIndex := StartTimes.IndexOf(STime);
            Assert(SIndex >= 0);
            ScreenObjectsInStressPeriod :=
              FScreenObjectsInAllStressPeriod[SIndex];
            Tribs := FTributariesStressPeriodArray
              [SIndex][ReachList.SegmentNumber-1];
            for TribIndex := 0 to Length(Tribs.Itrib) - 1 do
            begin
              if Tribs.Itrib[TribIndex] > 0 then
              begin
                TributaryNumber := Tribs.Itrib[TribIndex];
                if TributaryNumber-1 < ScreenObjectIndex then
                begin
                  TributaryObject := ScreenObjectsInStressPeriod
                    [TributaryNumber-1];
                  Assert(TributaryObject <> nil);
                end
                else
                begin
  //                ErrorFound := True;
                  frmErrorsAndWarnings.AddError(frmGoPhast.PhastModel,
                    StrInvalidStreamTribu,
                    Format(Str0d1d2d, [ScreenObjectIndex+1, TributaryNumber,
                    StressPeriodIndex+1]));
                  TributaryObject := nil;
                  InvalidTribObjects.Add(StrItem);
                  InvalidTribIndexes.Add(TributaryNumber);
                  InvalidBoundaryNumbers.Add(StrBoundary.SegmentNumber);
                end;
                if TributaryObject <> nil then
                begin
                  if NP = 0 then
                  begin
                    OtherStrItem := TributaryObject.ModflowStrBoundary.
                      Values.GetItemByStartTime(STime) as TStrItem;
//                    OtherStrItem := TributaryObject.ModflowStrBoundary.
//                      Values[StrBoundary.Values.Count-1] as TStrItem;
                  end
                  else
                  begin
                    OtherStrItem := TributaryObject.ModflowStrBoundary.
                      Parameters[0].Param.GetItemByStartTime(STime) as TStrItem;
//                      [StrBoundary.Parameters[0].Param.Count-1] as TStrItem;
                  end;
                  Assert(OtherStrItem <> nil);
                  OtherStrItem.OutflowSegment := StrBoundary.SegmentNumber;
                end;
              end
              else
              begin
                break;
              end;
            end;

            InvalidPos := InvalidTribIndexes.IndexOf(ScreenObjectIndex+1);
            if InvalidPos >= 0 then
            begin
              TributaryObject := ScreenObjectsInStressPeriod[ScreenObjectIndex];
              StrItem := InvalidTribObjects[InvalidPos];

              if NP = 0 then
              begin
                OtherStrItem := TributaryObject.ModflowStrBoundary.
                  Values.GetItemByStartTime(STime) as TStrItem;
//                    OtherStrItem := TributaryObject.ModflowStrBoundary.
//                      Values[StrBoundary.Values.Count-1] as TStrItem;
              end
              else
              begin
                OtherStrItem := TributaryObject.ModflowStrBoundary.
                  Parameters[0].Param.GetItemByStartTime(STime) as TStrItem;
//                      [StrBoundary.Parameters[0].Param.Count-1] as TStrItem;
              end;
              Assert(OtherStrItem <> nil);
              OtherStrItem.OutflowSegment := InvalidBoundaryNumbers[InvalidPos];

              InvalidTribObjects.Delete(InvalidPos);
              InvalidTribIndexes.Delete(InvalidPos);
              InvalidBoundaryNumbers.Delete(InvalidPos);
            end;
          end;

          if NDIV > 0 then
          begin
            Diversion := FDiversionStressPeriodArray
              [StressPeriodIndex][ReachList.SegmentNumber-1];
            if Diversion.Iupseg > 0 then
            begin
              DiversionObject := ScreenObjectsInStressPeriod[Diversion.Iupseg-1];
              StrItem.DiversionSegment :=
                DiversionObject.ModflowStrBoundary.SegmentNumber;
            end;
          end;
        end;
      end
    finally
      ScreenObjects.Free;
      StrItemLists.Free;
    end;
  end;
  function SetStartAndEndTime: boolean;
  var
    InnerIndex: integer;
    PriorSegNumbers: TGenericIntegerList;
  begin
    // initialize the start and end times for when the boundary will be
    // applied.
    result := True;
    StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
    EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
    StressPeriod := FStressPeriods[StressPeriodIndex] as TStrStressPeriod;
    SegNumb := TGenericIntegerList.Create;
    SegmentsNumbers.Add(SegNumb);
    FScreenObjectsInAllStressPeriod.Add(TList<TScreenObject>.Create);
    if StressPeriod.Reuse then
    begin
      PriorSegNumbers := SegmentsNumbers[SegmentsNumbers.Count-2];
      SegNumb.AddRange(PriorSegNumbers);
      Result := False;
      Exit;
    end
    else
    begin
      // Update the endtime if the boundaries from the current
      // stress period will be reused in subsequent stress periods.
      for InnerIndex := StressPeriodIndex + 1 to
        FStressPeriods.ArrayLength - 1 do
      begin
        SP := FStressPeriods[InnerIndex];
        if SP.Reuse then
        begin
          EndTime := FModel.ModflowStressPeriods[InnerIndex].EndTime;
        end
        else
        begin
          break;
        end;
      end;
    end;
  end;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FStressPeriods.ArrayLength -1) then
  begin
    Exit;
  end;
  frmErrorsAndWarnings.RemoveErrorGroup(frmGoPhast.PhastModel, StrInvalidStreamTribu);
  inherited;
  FStrPackage := FModel.ModflowPackages.StrPackage;
  FStrPackage.IsSelected := True;
  FStrPackage.Comments := FComments;

  FStrPackage.CalculateStage := ICALC > 0;
  SetLengthAndTimeUnit;

  ObjectIndex := 1;
  SegmentsNumbers := TListOfTIntegerList.Create;
  Segments := TSegmentListList.Create;
  StartTimes := TList<double>.Create;
  InvalidTribIndexes := TGenericIntegerList.Create;
  InvalidTribObjects := TList<TStrItem>.Create;
  InvalidBoundaryNumbers := TGenericIntegerList.Create;
  try
    if NP = 0 then
    {$REGION 'MyRegion'}
    begin
      // loop over stress periods
      for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
      begin
        if not SetStartAndEndTime then
        begin
          Continue;
        end;
        StartTimes.Add(StartTime);

        ReachList := nil;
        PriorSegment := 0;
        // loop over reaches in stress period.
        for ReachIndex := 0 to StressPeriod.ArrayLength - 1 do
        begin
          AReach := StressPeriod[ReachIndex];
          if AReach.SegmentNumber <> PriorSegment then
          begin
            // New segment
            if ReachList <> nil then
            begin
              AddSegment;
            end;
            SegNumb.Add(ReachIndex);
            ReachList := TReachList.Create;
            ReachList.StartTime := StartTime;
            ReachList.EndTime := EndTime;
            ReachList.StressPeriod := StressPeriodIndex;
            PriorSegment := AReach.SegmentNumber;
          end;
          ReachList.Add(AReach);
        end;
        // add the final segment
        AddSegment;
      end;

      CreateObjects;
    end
    {$ENDREGION}
    else
    begin
      CreateParameters;

      for StressPeriodIndex := 0 to FStressPeriods.ArrayLength - 1 do
      begin
        if not SetStartAndEndTime then
        begin
          Continue;
        end;
        StartTimes.Add(StartTime);
//        // initialize the start and end times for when the boundary will be
//        // applied.
//        StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
//        EndTime := FModel.ModflowStressPeriods[StressPeriodIndex].EndTime;
//        StressPeriod := FStressPeriods[StressPeriodIndex] as TStrStressPeriod;
//        SegNumb := TGenericIntegerList.Create;
//        SegmentsNumbers.Add(SegNumb);
//        ScreenObjectsInAllStressPeriod.Add(TList<TScreenObject>.Create);
//        if StressPeriod.Reuse then
//        begin
//          Continue;
//        end
//        else
//        begin
//          // Update the endtime if the boundaries from the current
//          // stress period will be reused in subsequent stress periods.
//          for InnerIndex := StressPeriodIndex + 1 to
//            FStressPeriods.ArrayLength - 1 do
//          begin
//            SP := FStressPeriods[InnerIndex];
//            if SP.Reuse then
//            begin
//              EndTime := FModel.ModflowStressPeriods[InnerIndex].EndTime;
//            end
//            else
//            begin
//              break;
//            end;
//          end;
//        end;

        // loop over parameters and instances for current stress period.
        for ParamIndex := 0 to
          FParamInstanceStressPeriodArray[StressPeriodIndex].ArrayLength - 1 do
        begin
          AParam := FParamInstanceStressPeriodArray
            [StressPeriodIndex][ParamIndex];
          StrInstance := GetInstance(AParam);


          ReachList := nil;
          PriorSegment := 0;
          // loop over reaches in stress period.
          for ReachIndex := 0 to StrInstance.ArrayLength - 1 do
          begin
            AReach := StrInstance[ReachIndex];
            AReach.ParameterName := AParam.ParamName;
            AReach.InstanceName := AParam.InstanceName;
            if AReach.SegmentNumber <> PriorSegment then
            begin
              // New segment
              if ReachList <> nil then
              begin
                AddSegment;
              end;
              SegNumb.Add(ReachIndex);
              ReachList := TReachList.Create;
              ReachList.StartTime := StartTime;
              ReachList.EndTime := EndTime;
              ReachList.StressPeriod := StressPeriodIndex;
              PriorSegment := AReach.SegmentNumber;
            end;
            ReachList.Add(AReach);
          end;
          // add the final segment
          AddSegment;


        end;
      end;

      CreateObjects;
    end;
  finally
    SegmentsNumbers.Free;
    Segments.Free;
    StartTimes.Free;
    InvalidTribIndexes.Free;
    InvalidTribObjects.Free;
    InvalidBoundaryNumbers.Free;
  end;
  if FObsImporter <> nil then
  begin
    FObsImporter.HandlePackage;
  end;
  frmGoPhast.EnableLinkStreams;
end;

procedure TStrImporter.InitializeCurrentStressPeriod;
begin
  inherited;
  FReachIndex := -1;
  FReachChanelIndex := -1;
  FSegmentTributaryIndex := -1;
  FSegmentDiversionIndex := -1;
  FParamIndex := -1;
  if ICALC > 0 then
  begin
    FChannelCharacteristicsStressPeriodArray
      [FCurrentStressPeriod].ArrayLength := MXACTS;
  end;
  if NTRIB > 0 then
  begin
    FTributariesStressPeriodArray[FCurrentStressPeriod].ArrayLength := NSS;
  end;
  if NDIV > 0 then
  begin
    FDiversionStressPeriodArray[FCurrentStressPeriod].ArrayLength := NSS;
  end;
  if NP > 0 then
  begin
    FParamInstanceStressPeriodArray[FCurrentStressPeriod].ArrayLength := Max(ITMP,0)
  end;
end;

procedure TStrImporter.InitializeStressPeriods;
begin
  inherited;
  if ICALC > 0 then
  begin
    FChannelCharacteristicsStressPeriodArray.ArrayLength :=
      FModel.ModflowStressPeriods.Count;
  end;
  if NTRIB > 0 then
  begin
    FTributariesStressPeriodArray.ArrayLength :=
      FModel.ModflowStressPeriods.Count;
  end;
  if NDIV > 0 then
  begin
    FDiversionStressPeriodArray.ArrayLength :=
      FModel.ModflowStressPeriods.Count;
  end;
  if NP > 0 then
  begin
    FParamInstanceStressPeriodArray.ArrayLength :=
      FModel.ModflowStressPeriods.Count;
  end;
end;

procedure TStrImporter.ReadReach;
var
  SP: TListStressPeriod;
  ReachObject: TStrLocationObject;
  NLIST: integer;
  ReachIndex: Integer;
begin
  SP := FStressPeriods[FCurrentStressPeriod];// as TStrStressPeriodArray;
  Readln(FImporter.FFile, NLIST);
  for ReachIndex := 0 to NLIST-1 do
  begin
    ReachObject := SP[ReachIndex] as TStrLocationObject;

    AssignReach(ReachObject);
  end;
end;

procedure TStrImporter.ReadInstance;
var
  StrInstance: TStrInstanceObject;
  ReachObject: TStrLocationObject;
  NLIST: integer;
  ReachIndex: Integer;
begin
  StrInstance := FParameters[CurrentParameter].
    Instances[CurrentInstance] as TStrInstanceObject;
  Readln(FImporter.FFile, NLIST);
  for ReachIndex := 0 to NLIST-1 do
  begin
    ReachObject := StrInstance[ReachIndex] as TStrLocationObject;

    AssignReach(ReachObject);
  end;
  Inc(CurrentInstance);
//
//
//  Inc(FReachIndex);
end;

procedure TStrImporter.ReadParameterType;
var
  PARTYP: string;
begin
  Readln(FImporter.FFile, PARTYP);
  FImporter.UpdateProgress;
  PARTYP := Trim(PARTYP);
  PARTYP := UpperCase(PARTYP);
  Assert(PARTYP = 'STR');
  FParameters[CurrentParameter].PARTYP := PARTYP;
end;

{$HINTS OFF}
procedure TStrImporter.ReadDataSet2;
var
  ISTCB2: Integer;
  ISTCB1: Integer;
begin
  Read(FImporter.FFile, MXACTS);
  Read(FImporter.FFile, NSS);
  Read(FImporter.FFile, NTRIB);
  Read(FImporter.FFile, NDIV);
  Read(FImporter.FFile, ICALC);
  Read(FImporter.FFile, ACONST);
  Read(FImporter.FFile, ISTCB1);
  Read(FImporter.FFile, ISTCB2);
  ReadLn(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

function TStrImporter.ParameterType: TParameterType;
begin
  result := ptSTR;
end;

procedure TStrImporter.ReadData(const ALabel: string);
begin
  if FCurrentStressPeriod = -1 then
  begin
    if ALabel = 'NP,MXL:' then
    begin
      ReadDataSet1;
    end
    else if ALabel = 'MXACTS,NSS,NTRIB,NDIV,ICALC,CONST,ISTCB1,ISTCB2:' then
    begin
      ReadDataSet2;
    end
    else if ALabel = 'PARNAM:' then
    begin
      ReadParameterName;
    end
    else if ALabel = 'PARTYP:' then
    begin
      ReadParameterType;
    end
    else if ALabel = 'Parval,NLST:' then
    begin
      ReadParameterValueAndLocationCount;
      FReachIndex := -1;
    end
    else if ALabel = 'INSTANCES:' then
    begin
//       do nothing
    end
    else if ALabel = 'NUMINST:' then
    begin
      ReadNumberOfInstances;
    end
    else if ALabel = 'INAME(ILOC):' then
    begin
      ReadInstanceName;
      FReachIndex := -1;
    end
    else if ALabel = 'K,I,J,ISTRM(4,II),ISTRM(5,II),STRM:' then
    begin
      ReadInstance;
    end
    else if ALabel = 'ITMP,IRDFLG,IPTFLG:' then
    begin
      InitializeStressPeriods;
      ReadDataSet5;
    end
    else
    begin
      Assert(False);
    end;
  end
  else
  begin
    if ALabel = 'ITMP,IRDFLG,IPTFLG:' then
    begin
      ReadDataSet5;
    end
    else if ALabel = 'Width Slope Rough:' then
    begin
      ReadDataSet8;
    end
    else if ALabel = '(ITRBAR(IK,JK),JK=1,NTRIB):' then
    begin
      ReadDataSet9;
    end
    else if ALabel = 'IDIVAR(IK):' then
    begin
      ReadDataSet10;
    end
    else if ALabel = 'K,I,J,ISTRM(4,II),ISTRM(5,II),STRM:' then
    begin
      ReadReach;
    end
    else if ALabel = 'Pname:' then
    begin
      ReadDataSet7A;
    end
    else if ALabel = 'Iname:' then
    begin
      ReadDataSet7B;
    end
    else
    begin
      Assert(False);
    end;
  end;
end;

function TStrImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Str'
end;

procedure TStrImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
begin
  Assert(False);
end;

{ TStrReaches }

function TStrReaches.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStrLocationObject;
end;

function TStrReaches.GetReach(Index: integer): TStrLocationObject;
begin
  result := Objects[Index] as TStrLocationObject;
end;

{ TStrParamArray }

function TStrParamArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStrParameterObject;
end;

{ TStrStressPeriod }

function TStrStressPeriod.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStrLocationObject;
end;

function TStrStressPeriod.GetItem(Index: Integer): TStrLocationObject;
begin
  result := Objects[Index] as TStrLocationObject;
end;

{ TStrParameterObject }

function TStrParameterObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStrInstanceObject;
end;

{ TStrInstanceObject }

function TStrInstanceObject.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStrLocationObject;
end;

function TStrInstanceObject.GetReach(Index: integer): TStrLocationObject;
begin
  result := Objects[Index] as TStrLocationObject;
end;

{ TStrStressPeriodArray }

function TStrStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStrStressPeriod;
end;

{ TChannelCharacteristicsArray }

function TChannelCharacteristicsArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChannelCharacteristics;
end;

function TChannelCharacteristicsArray.GetItem(
  Index: Integer): TChannelCharacteristics;
begin
  result := Objects[Index] as TChannelCharacteristics;
end;

{ TTributariesArray }

function TTributariesArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TTributaries;
end;

function TTributariesArray.GetItem(Index: Integer): TTributaries;
begin
  result := Objects[Index] as TTributaries;
end;

{ TChannelCharacteristicsStressPeriodArray }

function TChannelCharacteristicsStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TChannelCharacteristicsArray;
end;

function TChannelCharacteristicsStressPeriodArray.GetItem(
  Index: Integer): TChannelCharacteristicsArray;
begin
  result := Objects[Index] as TChannelCharacteristicsArray
end;

{ TTributariesStressPeriodArray }

function TTributariesStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TTributariesArray;
end;

function TTributariesStressPeriodArray.GetItem(
  Index: Integer): TTributariesArray;
begin
  result := Objects[Index] as TTributariesArray
end;

{ TDiversionArray }

function TDiversionArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDiversion;
end;

function TDiversionArray.GetItem(Index: Integer): TDiversion;
begin
  Result := Objects[Index] as TDiversion;
end;

{ TDiversionStressPeriodArray }

function TDiversionStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TDiversionArray;
end;

function TDiversionStressPeriodArray.GetItem(Index: Integer): TDiversionArray;
begin
  result := Objects[Index] as TDiversionArray
end;

{ TParamInstanceArray }

function TParamInstanceArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TParamInstance;
end;

function TParamInstanceArray.GetItem(Index: Integer): TParamInstance;
begin
  result := Objects[Index] as TParamInstance;
end;

{ TParamInstanceStressPeriodArray }

function TParamInstanceStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TParamInstanceArray;
end;

function TParamInstanceStressPeriodArray.GetItem(
  Index: Integer): TParamInstanceArray;
begin
  result := Objects[Index] as TParamInstanceArray;
end;

{ TReachList }

function TReachList.LocationsMatch(ReachList: TReachList): boolean;
var
  ReachIndex: Integer;
begin
  Result := (Count = ReachList.Count) and not (StressPeriod = ReachList.StressPeriod);
  if result then
  begin
    for ReachIndex := 0 to Count - 1 do
    begin
      result := Items[ReachIndex].LocationsMatch(ReachList.Items[ReachIndex]);
      if not Result then
      begin
        Exit;
      end;
    end;
  end;
end;

function TReachList.ParameterName: string;
begin
  if Count > 0 then
  begin
    result := Items[0].ParameterName;
  end
  else
  begin
    result := '';
  end;
end;

function TReachList.SegmentNumber: integer;
begin
  if Count > 0 then
  begin
    result := Items[0].SegmentNumber;
  end
  else
  begin
    result := 0;
  end;
end;

{ TStrLocationObject }

constructor TStrLocationObject.Create;
begin
  inherited;
  ParameterName := '';
  InstanceName := '';
end;

function TStrLocationObject.LocationsMatch(AReach: TStrLocationObject): Boolean;
begin
  result := (Row = AReach.Row) and (Column = AReach.Column)
    and (Layer = AReach.Layer) and (SegmentNumber = AReach.SegmentNumber)
    and (ParameterName = AReach.ParameterName);
end;

{ TStrObsImporter }

constructor TStrObsImporter.Create(Importer: TModflow2005Importer;
  StrImporter: TStrImporter);
begin
  inherited Create(Importer, 'STOB');
  FStrImporter := StrImporter;
  FStrImporter.FObsImporter := self;
  FDataSet1Label := 'NQST, NQCST, NQTST, IUSTOBSV:';
  FDataSet2Label := 'TOMULTST:';
  FDataSet3Label := 'NQOBST(IQ), NQCLST(IQ):';
  FDataSet4Label := 'OBSNAM(J),IREFSP,TOFFSET,FLWOBS(J):';
  // segment and reach
  FDataSet5Label := '(QCELL(I,L),I=1,2),QCELL(4,L):';
  FObsPrefix := 'STOB';
end;

procedure TStrObsImporter.HandlePackage;
const
  FactorName = ' Factor';
var
  ObsGroupIndex: Integer;
  AGroup: TObservationGroup;
  CellIndex: Integer;
  AReach: TFlowObservationLocation;
  ObsGroup: TFluxObservationGroup;
  AScreenObject: TScreenObject;
  ScreenObjects: TList<TScreenObject>;
  FactorItem: TValueArrayItem;
  ObsFactor: TObservationFactor;
  procedure InitializeFactorItem;
  var
    ValueIndex: Integer;
  begin
    ObsGroup.AddObject(AScreenObject);

    FactorItem := AScreenObject.ImportedValues.Add as TValueArrayItem;
    FactorItem.Name := ObsGroup.ObservationName + FactorName;
    FactorItem.Values.DataType := rdtDouble;
    FactorItem.Values.Count := AScreenObject.SectionCount;
    for ValueIndex := 0 to FactorItem.Values.Count - 1 do
    begin
      FactorItem.Values.RealValues[ValueIndex] := 0;
    end;

    ObsFactor := ObsGroup.ObservationFactors.Items[
      ObsGroup.ObservationFactors.Count-1];
    Assert(ObsFactor.ScreenObject = AScreenObject);
    ObsFactor.Factor := rsObjectImportedValuesR
      + '("' + FactorItem.Name + '")';
  end;
begin
  if FStrImporter.ImportedPackage then
  begin
    inherited;
    CreateObservationGroups;

    Assert(FObservations.ArrayLength = FFlowObsGroups.Count);

    ScreenObjects := TList<TScreenObject>.Create;
    try
      for ObsGroupIndex := 0 to FObservations.ArrayLength - 1 do
      begin
        AGroup := FObservations[ObsGroupIndex];
        ObsGroup := FFlowObsGroups[ObsGroupIndex];

        for CellIndex := 0 to AGroup.FCells.ArrayLength - 1 do
        begin
          AReach := AGroup.FCells[CellIndex];

          // For STOB, AReach.ROW is the segment number.
          AScreenObject := FStrImporter.FScreenObjectsInAllStressPeriod[0][AReach.ROW-1];
          if ScreenObjects.IndexOf(AScreenObject) < 0 then
          begin
            ScreenObjects.Add(AScreenObject);
            InitializeFactorItem;
          end
          else
          begin
            FactorItem := AScreenObject.ImportedValues.
              ValueItemByName(ObsGroup.ObservationName + FactorName);
            if FactorItem = nil then
            begin
              InitializeFactorItem
            end;
          end;
          // For STOB, AReach.COLUMN is the reach number.
          FactorItem.Values.RealValues[AReach.COLUMN-1] := AReach.FACTOR;
        end;
      end;
    finally
      ScreenObjects.Free;
    end;

    FModel.ModflowPackages.StobPackage.IsSelected := FIsActive;
    FModel.StreamObservations := FFlowObsGroups;
    frmGoPhast.EnableManageFlowObservations;
  end;
end;

procedure TStrObsImporter.ReadDataSet5;
var
  CurrentLoc: TFlowObservationLocation;
  RowReal: double;
  ColReal: double;
begin
  Inc(FCurrentLocationIndex);
  // Row and Column represent segment and reach respectively.
  CurrentLoc := FCurrentGroup.FCells[FCurrentLocationIndex];
  Readln(FImporter.FFile,  RowReal,
    ColReal, CurrentLoc.FACTOR);
  // segment number
  CurrentLoc.ROW := Round(RowReal);
  // reach number
  CurrentLoc.COLUMN := Round(ColReal);
  FImporter.UpdateProgress;
  if NQCL < 0 then
  begin
    CurrentLoc.FACTOR := 1;
  end;
end;

{ TClusterRecord }

function TClusterRecord.GetMultiplierName: string;
begin
  Result := Copy(FMultiplierName, 1, 10);
end;

function TClusterRecord.GetZoneName: string;
begin
  Result := Copy(FZoneName, 1, 10);
end;

{ TFhbImporter }

constructor TFhbImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'FHB');
  FFlowCells := TFhbCellArray.Create;
  FHeadCells := TFhbCellArray.Create;
end;


destructor TFhbImporter.Destroy;
begin
  FHeadCells.Free;
  FFlowCells.Free;
  inherited;
end;

function TFhbImporter.GetBoundary(
  ScreenObject: TScreenObject): TModflowParamBoundary;
begin
  result := nil;
  Assert(False);
end;

procedure TFhbImporter.HandlePackage;
var
  CellIndex: Integer;
  ACell: TFhbCell;
  AList: TList;
  ScreenObjectIndex: integer;
  ScreenObject: TScreenObject;
  LayerIndex: Integer;
  FlowBoundary: TFhbFlowBoundary;
  TimeIndex: Integer;
  AnItem: TFhbItem;
  Values: TValueArrayStorage;
  ValueItem: TValueArrayItem;
  HeadBoundary: TFhbHeadBoundary;
begin
  if FImportedPackage then
  begin
    Exit;
  end;
  inherited;

  FFhbPackage := FModel.ModflowPackages.FhbPackage;
  FFhbPackage.IsSelected := True;

  ScreenObjectIndex := 0;
  AList := TList.Create;
  try
    for LayerIndex := 1 to FModel.ModflowLayerCount do
    begin
      for CellIndex := 0 to FFlowCells.ArrayLength - 1 do
      begin
        ACell := FFlowCells[CellIndex];
        if ACell.Layer = LayerIndex then
        begin
          AList.Add(ACell);
        end;
      end;
      if AList.Count > 0 then
      begin
        ScreenObject := CreateScreenObject(AList, ScreenObjectIndex,
          LayerIndex, -1, otPoint);
        if ScreenObject <> nil then
        begin
          ScreenObject.CreateFhbFlowBoundary;
          FlowBoundary := ScreenObject.ModflowFhbFlowBoundary;
          for TimeIndex := 0 to Length(BDTIM) - 1 do
          begin
            AnItem := FlowBoundary.Values.Add as TFhbItem;
            AnItem.StartTime := BDTIM[TimeIndex];
            if TimeIndex+1 < Length(BDTIM) then
            begin
              AnItem.EndTime := BDTIM[TimeIndex+1];
            end
            else
            begin
              AnItem.EndTime := FModel.ModflowStressPeriods.Last.EndTime;
            end;
          end;
          if AList.Count = 1 then
          begin
            ACell := AList[0];
            Assert(Length(ACell.Values) = Length(BDTIM));
            for TimeIndex := 0 to Length(BDTIM) - 1 do
            begin
              AnItem := FlowBoundary.Values[TimeIndex] as TFhbItem;
              AnItem.BoundaryValue := FortranFloatToStr(ACell.Values[TimeIndex]);
            end;
          end
          else
          begin
            for TimeIndex := 0 to Length(BDTIM) - 1 do
            begin
              ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
              Values := ValueItem.Values;
              Values.DataType := rdtDouble;
              Values.Count := AList.Count;
              ValueItem.Name := 'FHB_Flow_Values' + IntToStr(TimeIndex+1);
            end;

            for CellIndex := 0 to AList.Count - 1 do
            begin
              ACell := AList[CellIndex];
              Assert(Length(ACell.Values) = Length(BDTIM));
              for TimeIndex := 0 to Length(BDTIM) - 1 do
              begin
                Values := ScreenObject.ImportedValues[TimeIndex].Values;
                Values.RealValues[CellIndex] := ACell.Values[TimeIndex];
              end;
            end;

            for TimeIndex := Length(BDTIM) - 1 downto 0 do
            begin
              ValueItem := ScreenObject.ImportedValues[TimeIndex];
              Values := ValueItem.Values;
              AnItem := FlowBoundary.Values[TimeIndex] as TFhbItem;
              if Values.UniformValues then
              begin
                AnItem.BoundaryValue := FortranFloatToStr(Values.RealValues[0]);
                ScreenObject.ImportedValues.Delete(TimeIndex);
              end
              else
              begin
                AnItem.BoundaryValue := rsObjectImportedValuesR
                  + '("' + ValueItem.Name + '")';
              end;
            end;
          end;
        end;

        AList.Clear;
      end;
    end;

    for LayerIndex := 1 to FModel.ModflowLayerCount do
    begin
      for CellIndex := 0 to FHeadCells.ArrayLength - 1 do
      begin
        ACell := FHeadCells[CellIndex];
        if ACell.Layer = LayerIndex then
        begin
          AList.Add(ACell);
        end;
      end;
      if AList.Count > 0 then
      begin
        ScreenObject := CreateScreenObject(AList, ScreenObjectIndex,
          LayerIndex, -1, otPoint);
        if ScreenObject <> nil then
        begin
          ScreenObject.CreateFhbHeadBoundary;
          HeadBoundary := ScreenObject.ModflowFhbHeadBoundary;
          for TimeIndex := 0 to Length(BDTIM) - 1 do
          begin
            AnItem := HeadBoundary.Values.Add as TFhbItem;
            AnItem.StartTime := BDTIM[TimeIndex];
            if TimeIndex+1 < Length(BDTIM) then
            begin
              AnItem.EndTime := BDTIM[TimeIndex+1];
            end
            else
            begin
              AnItem.EndTime := FModel.ModflowStressPeriods.Last.EndTime;
            end;
          end;
          if AList.Count = 1 then
          begin
            ACell := AList[0];
            Assert(Length(ACell.Values) = Length(BDTIM));
            for TimeIndex := 0 to Length(BDTIM) - 1 do
            begin
              AnItem := HeadBoundary.Values[TimeIndex] as TFhbItem;
              AnItem.BoundaryValue := FortranFloatToStr(ACell.Values[TimeIndex]);
            end;
          end
          else
          begin
            for TimeIndex := 0 to Length(BDTIM) - 1 do
            begin
              ValueItem := ScreenObject.ImportedValues.Add as TValueArrayItem;
              Values := ValueItem.Values;
              Values.DataType := rdtDouble;
              Values.Count := AList.Count;
              ValueItem.Name := 'FHB_Head_Values' + IntToStr(TimeIndex+1);
            end;

            for CellIndex := 0 to AList.Count - 1 do
            begin
              ACell := AList[CellIndex];
              Assert(Length(ACell.Values) = Length(BDTIM));
              for TimeIndex := 0 to Length(BDTIM) - 1 do
              begin
                Values := ScreenObject.ImportedValues[TimeIndex].Values;
                Values.RealValues[CellIndex] := ACell.Values[TimeIndex];
              end;
            end;

            for TimeIndex := Length(BDTIM) - 1 downto 0 do
            begin
              ValueItem := ScreenObject.ImportedValues[TimeIndex];
              Values := ValueItem.Values;
              AnItem := HeadBoundary.Values[TimeIndex] as TFhbItem;
              if Values.UniformValues then
              begin
                AnItem.BoundaryValue := FortranFloatToStr(Values.RealValues[0]);
                ScreenObject.ImportedValues.Delete(TimeIndex);
              end
              else
              begin
                AnItem.BoundaryValue := rsObjectImportedValuesR
                  + '("' + ValueItem.Name + '")';
              end;
            end;
          end;
        end;

        AList.Clear;
      end;
    end;

  finally
    AList.Free;
  end;

  FModel.FixFhbItems;
end;

function TFhbImporter.ParameterType: TParameterType;
begin
  result := ptUndefined;
  Assert(False);
end;

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet7b;
var
  TimeIndex: Integer;
  IAUX: Integer;
  Cell: TFhbCell;
begin
  // Data Set 7b
  Cell := FHeadCells[FHeadCellIndex];
  Read(FImporter.FFile, Cell.Layer);
  Read(FImporter.FFile, Cell.Row);
  Read(FImporter.FFile, Cell.Column);
  Read(FImporter.FFile, IAUX);
  Readln(FImporter.FFile);
  for TimeIndex := 0 to NBDTIM - 1 do
  begin
    Read(FImporter.FFile, Cell.Values[TimeIndex]);
  end;
  Readln(FImporter.FFile);
  Inc(FHeadCellIndex);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

function TFhbImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Fhb';
end;

procedure TFhbImporter.SetItemValues(Item: TCustomModflowBoundaryItem;
  Boundaries: TList; EndTime, StartTime: Double; ScreenObject: TScreenObject;
  const ParamName: string);
begin
  Assert(False);
end;

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet7a;
var
  IFHBUN: Integer;
  IFHBPT: Integer;
begin
  // Data Set 7a
  Read(FImporter.FFile, IFHBUN);
  Read(FImporter.FFile, IFHBPT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet5b;
var
  TimeIndex: Integer;
  IAUX: Integer;
  Cell: TFhbCell;
begin
  // Data Set 5b
  Cell := FFlowCells[FFlowCellIndex];
  Read(FImporter.FFile, Cell.Layer);
  Read(FImporter.FFile, Cell.Row);
  Read(FImporter.FFile, Cell.Column);
  Read(FImporter.FFile, IAUX);
  Readln(FImporter.FFile);
  for TimeIndex := 0 to NBDTIM - 1 do
  begin
    Read(FImporter.FFile, Cell.Values[TimeIndex]);
  end;
  Readln(FImporter.FFile);
  Inc(FFlowCellIndex);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet5a;
var
  IFHBUN: Integer;
  IFHBPT: Integer;
begin
  // Data Set 5a
  Read(FImporter.FFile, IFHBUN);
  Read(FImporter.FFile, IFHBPT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

procedure TFhbImporter.ReadDataSet4b;
var
  TimeIndex: Integer;
begin
  // Data Set 4b
  SetLength(BDTIM, NBDTIM);
  for TimeIndex := 0 to NBDTIM - 1 do
  begin
    Read(FImporter.FFile, BDTIM[TimeIndex]);
  end;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet4a;
var
  IFHBUN: Integer;
  IFHBPT: Integer;
begin
  // Data Set 4a
  Read(FImporter.FFile, IFHBUN);
  Read(FImporter.FFile, IFHBPT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet3Weight;
var
  FHBXWT: Double;
begin
  // Data Set 3 weight
  Read(FImporter.FFile, FHBXWT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

procedure TFhbImporter.ReadDataSet3Name;
var
  FHBXNM: string;
begin
  // Data Set 3 variable name
  Readln(FImporter.FFile, FHBXNM);
  FImporter.UpdateProgress;
end;

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet2Weight;
var
  FHBXWT: Double;
begin
  // Data Set 2 weight
  Read(FImporter.FFile, FHBXWT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

procedure TFhbImporter.ReadDataSet2Name;
var
  FHBXNM: string;
begin
  // Data Set 2 variable name
  Readln(FImporter.FFile, FHBXNM);
  FImporter.UpdateProgress;
end;

{$HINTS OFF}
procedure TFhbImporter.ReadDataSet1;
var
  NHED: Integer;
  NFLW: Integer;
  NFHBX1: Integer;
  IFHBSS: Integer;
  IFHBCB: Integer;
  NFHBX2: Integer;
  CellIndex: Integer;
begin
  // Data Set 1
  Read(FImporter.FFile, NBDTIM);
  Read(FImporter.FFile, NFLW);
  Read(FImporter.FFile, NHED);
  Read(FImporter.FFile, IFHBSS);
  Read(FImporter.FFile, IFHBCB);
  Read(FImporter.FFile, NFHBX1);
  Read(FImporter.FFile, NFHBX2);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FFlowCells.ArrayLength := NFLW;
  FHeadCells.ArrayLength := NHED;
  for CellIndex := 0 to FFlowCells.ArrayLength - 1 do
  begin
    SetLength(FFlowCells.Cells[CellIndex].Values, NBDTIM);
  end;
  for CellIndex := 0 to FHeadCells.ArrayLength - 1 do
  begin
    SetLength(FHeadCells.Cells[CellIndex].Values, NBDTIM);
  end;
end;
{$HINTS ON}

procedure TFhbImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'NBDTIM,NFLW,NHED,IFHBSS,IFHBCB,NFHBX1,NFHBX2:' then
  begin
    ReadDataSet1;
//    FParameters.ArrayLength := NP;
  end
  else if ALabel = 'FHBXNM(NX):' then
  begin
    ReadDataSet2Name;
  end
  else if ALabel = 'FHBXWT(NX):' then
  begin
    ReadDataSet2Weight;
  end
  else if ALabel = 'FHBXNM(5+NX):' then
  begin
    ReadDataSet3Name;
  end
  else if ALabel = 'FHBXWT(5+NX):' then
  begin
    ReadDataSet3Weight;
  end
  else if ALabel = 'IFHBUN,IFHBPT:' then
  begin
    ReadDataSet4a;
  end
  else if ALabel = '(BDTIM(L),L=1,NBDTIM):' then
  begin
    ReadDataSet4b;
  end
  else if ALabel = 'IFHBUN,IFHBPT1:' then
  begin
    ReadDataSet5a;
  end
  else if ALabel = '(IFLLOC(I,N),I=1,4),(FLWRAT(L,N),L=1,NBDTIM):' then
  begin
    ReadDataSet5b;
  end
  else if ALabel = 'IFHBUN,IFHBPT3:' then
  begin
    ReadDataSet7a;
  end
  else if ALabel = '(IHDLOC(I,N),I=1,4),(SBHED(L,N),L=1,NBDTIM):' then
  begin
    ReadDataSet7b;
  end
  else
  begin
    Assert(False);
  end;
end;

{ TFhbCellArray }

function TFhbCellArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TFhbCell;
end;

function TFhbCellArray.GetCell(Index: Integer): TFhbCell;
begin
  result := Objects[Index] as TFhbCell;
end;

{ TSwiObsArray }

function TSwiObsArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwiObs;
end;

function TSwiObsArray.GetCell(Index: Integer): TSwiObs;
begin
  result := Objects[Index] as TSwiObs;
end;

{ TSwiImporter }

constructor TSwiImporter.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'SWI2');
  IObs := -1;
  FObservations := TSwiObsArray.Create;
end;

destructor TSwiImporter.Destroy;
begin
  FObservations.Free;
  inherited;
end;

procedure TSwiImporter.ImportPackageData(SwiPackage: TSwiPackage);
var
  ZoneIndex: Integer;
begin
  SwiPackage.NumberOfSurfaces := NSRF;
  Assert(ISTRAT in [0, 1]);
  SwiPackage.DensityChoice := TDensityChoice(ISTRAT);
  SwiPackage.SaveZeta := ISWIZT > 0;
  if ISWIOBS > 0 then
  begin
    SwiPackage.ObsChoice := socAscii;
  end
  else if ISWIOBS < 0 then
  begin
    SwiPackage.ObsChoice := socBinary;
  end
  else
  begin
    if NOBS > 0 then
    begin
      SwiPackage.ObsChoice := socAscii;
    end
    else
    begin
      SwiPackage.ObsChoice := socNone;
    end;
  end;
  SwiPackage.Adaptive := iadptflg > 0;
  Assert(NSOLVER in [1, 2]);
  SwiPackage.Solver := TSwiSolver(NSOLVER - 1);
  SwiPackage.SolverPrintoutInterval := IPRSOL;
  Assert(MUTSOL in [0..3]);
  SwiPackage.SolverPrintChoice := TSwiSolverPrintChoice(MUTSOL);
  if SwiPackage.Solver = ssPCG then
  begin
    SwiPackage.MXITER := MXITER;
    SwiPackage.ITER1 := ITER1;
    Assert(NPCOND in [1, 2]);
    SwiPackage.NPCOND := TPcgMethod(NPCOND - 1);
    SwiPackage.ZCLOSE.Value := ZCLOSE;
    SwiPackage.RCLOSE.Value := RCLOSE;
    SwiPackage.RELAX.Value := RELAX;
    if NBPOL = 2 then
    begin
      SwiPackage.NBPOL := peeDontEstimate;
    end
    else
    begin
      SwiPackage.NBPOL := peeEstimate;
    end;
    SwiPackage.DAMP.Value := DAMP;
    SwiPackage.DAMPT.Value := DAMPT;
  end;
  SwiPackage.ToeSlope.Value := TOESLOPE;
  SwiPackage.TipSlope.Value := TIPSLOPE;
  SwiPackage.Alpha.Value := ALPHA;
  SwiPackage.Beta.Value := BETA;
  if SwiPackage.Adaptive then
  begin
    SwiPackage.MaxAdaptiveTimeSteps := NADPTMX;
    SwiPackage.MinAdaptiveTimeSteps := NADPTMN;
    SwiPackage.AdaptiveFactor.Value := ADPTFCT;
  end;
  SwiPackage.ZoneDimensionlessDensities.Clear;
  for ZoneIndex := 0 to Length(NU) - 1 do
  begin
    SwiPackage.ZoneDimensionlessDensities.Add.Value := NU[ZoneIndex];
  end;
end;

procedure TSwiImporter.ImportISOURCE;
var
  DataArrayName: string;
  ScreenObject: TScreenObject;
  ConstantValue: Integer;
  Index: Integer;
  LayerIndex: Integer;
  DataArray: TDataArray;
  Group: TLayerGroup;
  IsConstant: Boolean;
  ActiveFormula: string;
  Interpolator: TNearestPoint2DInterpolator;
  GroupIndex: Integer;
begin
  CheckVariableIntegerArrays(ISOURCE_Const, ISOURCE);
  ScreenObject := nil;
  IsConstant := True;
  ConstantValue := ISOURCE_Const[0].IntegerValue;
  for Index := 0 to Length(ISOURCE_Const) - 1 do
  begin
    IsConstant := ISOURCE_Const[Index].IsConstant
      and (ISOURCE_Const[Index].IntegerValue = ConstantValue);
    if not IsConstant then
    begin
      break;
    end;
  end;
  if IsConstant then
  begin
    DataArray := FModel.DataArrayManager.GetDataSetByName(KSourceFluidDensityZone);
    DataArray.Formula := IntToStr(ConstantValue);
  end
  else
  begin
    LayerIndex := -1;
    if FModel.LayerStructure.Count > 2 then
    begin
      ActiveFormula := 'CaseI(' + LayerString + ', ';
    end
    else
    begin
      ActiveFormula := '';
    end;
    for GroupIndex := 1 to FModel.LayerStructure.Count - 1 do
    begin
      Group := FModel.LayerStructure.LayerGroups[GroupIndex];
      if Group.RunTimeSimulated then
      begin
        Inc(LayerIndex);
        if ISOURCE_Const[LayerIndex].IsConstant then
        begin
          ActiveFormula := ActiveFormula
            + IntToStr(ISOURCE_Const[LayerIndex].IntegerValue);
        end
        else
        begin
          if ScreenObject = nil then
          begin
            CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          end;
          DataArrayName := 'Imported_ISOURCE_Layer_' + IntToStr(GroupIndex);
          DataArray := FModel.DataArrayManager.GetDataSetByName(DataArrayName);
          if DataArray = nil then
          begin
            DataArray := FModel.DataArrayManager.CreateNewDataArray(
              TDataArray, DataArrayName, '0', DataArrayName, [dcType], rdtInteger,
              eaBlocks, dsoTop, '');
            DataArray.Comment := Format(StrImportedFromExisti, [DateTimeToStr(Now)]);
            DataArray.UpdateDimensions(
              FGrid.LayerCount, FGrid.RowCount, FGrid.ColumnCount);
            Interpolator := TNearestPoint2DInterpolator.Create(nil);
            try
              DataArray.TwoDInterpolator := Interpolator;
            finally
              Interpolator.Free;
            end;
          end;
          AssignIntegerValuesToCellCenters(DataArray, ScreenObject,
            ISOURCE[LayerIndex]);
          ActiveFormula := ActiveFormula + DataArrayName;
        end;
      end
      else
      begin
        ActiveFormula := ActiveFormula + '0';
      end;
      if GroupIndex < FModel.LayerStructure.Count - 1 then
      begin
        ActiveFormula := ActiveFormula + ', ';
      end;
    end;
    if FModel.LayerStructure.Count > 2 then
    begin
      ActiveFormula := ActiveFormula + ')';
    end;
    DataArray := FModel.DataArrayManager.GetDataSetByName(KSourceFluidDensityZone);
    DataArray.Formula := ActiveFormula;
  end;
end;

procedure TSwiImporter.HandlePackage;
var
  SwiPackage: TSwiPackage;
  ZetaIndex: Integer;
  ListOfLists: TList;
  LayerIndex: Integer;
  AList: TList;
  ObsIndex: Integer;
  AnObs: TSwiObs;
  ScreenObjectIndex: integer;
  AScreenObject: TScreenObject;
  ObsArray: TDataArray;
  FormulaPosition: Integer;
  ValueItem: TValueArrayItem;
begin
  inherited;
  SwiPackage := FModel.ModflowPackages.SwiPackage;
  SwiPackage.IsSelected := True;

  ImportPackageData(SwiPackage);

  FModel.DataArrayManager.CreateInitialDataSets;


  for ZetaIndex := 1 to NSRF do
  begin
    ImportDataSet('ZETA' + IntToStr(ZetaIndex),
      KActive_Surface_Elevation + IntToStr(ZetaIndex),
      ZETA_const[ZetaIndex-1], ZETA[ZetaIndex-1]);
  end;

  ImportDataSet('SSZ', KEffectivePorosity, SSZ_Const, SSZ);

  ImportISOURCE;

  //    FObservations: TSwiObsArray;


  if NOBS > 0 then
  begin
    ObsArray := FModel.DataArrayManager.GetDataSetByName(KSWI_Observation_Name);

    ScreenObjectIndex := 0;
    ListOfLists := TObjectList.Create;
    try
      for LayerIndex := 0 to FModel.ModflowLayerCount - 1 do
      begin
        AList := TList.Create;
        ListOfLists.Add(AList);
      end;
      for ObsIndex := 0 to FObservations.ArrayLength - 1 do
      begin
        AnObs := FObservations[ObsIndex];
        AList := ListOfLists[AnObs.Layer-1];
        AList.Add(AnObs);
      end;
      for LayerIndex := 0 to ListOfLists.Count - 1 do
      begin
        AList := ListOfLists[LayerIndex];
        if AList.Count > 0 then
        begin
          AScreenObject := CreateScreenObject(AList, ScreenObjectIndex,
            LayerIndex+1, -1, otPoint);
          if AScreenObject <> nil then
          begin
            FormulaPosition :=  AScreenObject.AddDataSet(ObsArray);
            if AList.Count > 1 then
            begin
              ValueItem := AScreenObject.ImportedValues.Add as TValueArrayItem;
              ValueItem.Name := 'Imported_SWI_Observatations';
              ValueItem.Values.DataType := rdtString;
              ValueItem.Values.Count := AList.Count;
              for ObsIndex := 0 to AList.Count - 1 do
              begin
                AnObs := AList[ObsIndex];
                ValueItem.Values.StringValues[ObsIndex] :=
                  '"' + AnObs.OBSNAM + '"';
              end;
              AScreenObject.DataSetFormulas[FormulaPosition] :=
                rsObjectImportedValuesT
                    + '("' + 'Imported_SWI_Observatations' + '")';
            end
            else
            begin
              AnObs := AList[0];
              AScreenObject.DataSetFormulas[FormulaPosition] :=
               '"' + AnObs.OBSNAM + '"';
            end;
          end;
        end;
      end;
    finally
      ListOfLists.Free
    end;
  end;
end;

{$HINTS OFF}
procedure TSwiImporter.ReadData(const ALabel: string);
var
  NZONES: integer;
  AName: string;
  AValue: double;
  Index: Integer;
  ZetaLength: Integer;
  ZetaNumString: string;
  ZetaIndex: Integer;
  ID: string;
  Layer: integer;
  ThreeDArray: T3DDoubleArray;
  ConstArray: TRealConstantRecordArray;
  Value: double;
  IntegerConstant: integer;
  OBSNAM: string;
begin
  inherited;
  if ALabel = 'iadptflg:' then
  begin
    Read(FImporter.FFile, iadptflg);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'NSRF, NZONES, ISTRAT, NOBS, ISWIZT, ISWICB, ISWIOBS:' then
  begin
    Read(FImporter.FFile, NSRF);
    Read(FImporter.FFile, NZONES);
    Read(FImporter.FFile, ISTRAT);
    Read(FImporter.FFile, NOBS);
    Read(FImporter.FFile, ISWIZT);
    Read(FImporter.FFile, ISWIBD);
    Read(FImporter.FFile, ISWIOBS);
    Readln(FImporter.FFile);
    case ISTRAT of
      0:
        begin
          SetLength(NU, NSRF+2);
        end;
      1:
        begin
          SetLength(NU, NSRF+1);
        end;
      else
        Assert(False);
    end;
    FObservations.ArrayLength := NOBS;
    SetLength(ZETA, NSRF);
    SetLength(ZETA_const, NSRF);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'NSOLVER,IPRSOL,MUTSOL:' then
  begin
    Read(FImporter.FFile, NSOLVER);
    Read(FImporter.FFile, IPRSOL);
    Read(FImporter.FFile, MUTSOL);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'MXITER, ITER1,NPCOND,ZCLOSE, RCLOSE,RELAX, NBPOL,DAMP, DAMPT:' then
  begin
    Read(FImporter.FFile, MXITER);
    Read(FImporter.FFile, ITER1);
    Read(FImporter.FFile, NPCOND);
    Read(FImporter.FFile, ZCLOSE);
    Read(FImporter.FFile, RCLOSE);
    Read(FImporter.FFile, RELAX);
    Read(FImporter.FFile, NBPOL);
    Read(FImporter.FFile, DAMP);
    Read(FImporter.FFile, DAMPT);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'TOESLOPE, TIPSLOPE, ALPHA, BETA:' then
  begin
    Read(FImporter.FFile, TOESLOPE);
    Read(FImporter.FFile, TIPSLOPE);
    Read(FImporter.FFile, ALPHA);
    Read(FImporter.FFile, BETA);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'NADPTMN,NADPTMX,ADPTFCT:' then
  begin
    Read(FImporter.FFile, NADPTMN);
    Read(FImporter.FFile, NADPTMX);
    Read(FImporter.FFile, ADPTFCT);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = StrConstant1DRealArray then
  begin
    Readln(FImporter.FFile, AName);
    AName := Trim(AName);
    Assert((AName = 'NUZONE') or (AName = 'NUSRF'));
    Read(FImporter.FFile, AValue);
    Readln(FImporter.FFile);
    for Index := 0 to Length(NU) - 1 do
    begin
      NU[Index] := AValue;
    end;
  end
  else if ALabel = StrVariable1DRealArray then
  begin
    Readln(FImporter.FFile, AName);
    AName := Trim(AName);
    Assert((AName = 'NUZONE') or (AName = 'NUSRF'));
    Read1DRealArray(NU);
  end
  else if ALabel = StrVariable2DRealArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    ReadLn(FImporter.FFile, Layer);
    Dec(Layer);

    if Pos('ZETA SURFACE', ID) > 0 then
    begin
      ZetaLength := Length('ZETA SURFACE');
      ZetaNumString := AnsiMidStr(ID,ZetaLength+1, Length(ALabel) - ZetaLength -1);
      ZetaIndex := StrToInt(Trim(ZetaNumString)) -1;

      if ZETA[ZetaIndex] = nil then
      begin
        SetLength(ZETA[ZetaIndex], FModel.ModflowLayerCount);
      end;
      ThreeDArray := ZETA[ZetaIndex];

//      ReadDataSets10to16Variable;
    end
    else if ID = 'SSZ' then
    begin
      if SSZ = nil then
      begin
        SetLength(SSZ, FModel.ModflowLayerCount);
      end;
      ThreeDArray := SSZ;
    end
    else
    begin
      Assert(False);
    end;

    if ThreeDArray[Layer] = nil then
    begin
      SetLength(ThreeDArray[Layer], FGrid.RowCount, FGrid.ColumnCount);
    end;
    Read2DRealArray(ThreeDArray[Layer], ID);

  end
  else if ALabel = StrConstant2DRealArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    ID := Trim(ID);
    ReadLn(FImporter.FFile, Layer);
    ReadLn(FImporter.FFile, Value);
    Dec(Layer);

    if Pos('ZETA SURFACE', ID) > 0 then
    begin
      ZetaLength := Length('ZETA SURFACE');
      ZetaNumString := AnsiMidStr(ID,ZetaLength+1, Length(ALabel) - ZetaLength -1);
      ZetaIndex := StrToInt(Trim(ZetaNumString)) -1;

      if ZETA_const[ZetaIndex] = nil then
      begin
        SetLength(ZETA_const[ZetaIndex], FModel.ModflowLayerCount);
        InitializeConstArray(ZETA_const[ZetaIndex]);
      end;
      ConstArray := ZETA_const[ZetaIndex];
    end
    else if ID = 'SSZ' then
    begin
      if SSZ_Const = nil then
      begin
        SetLength(SSZ_Const, FModel.ModflowLayerCount);
        InitializeConstArray(SSZ_Const);
      end;
      ConstArray := SSZ_Const;
    end
    else
    begin
      Assert(False);
    end;

    ConstArray[Layer].IsConstant := True;
    ConstArray[Layer].RealValue := Value;
    FImporter.UpdateProgress;
  end
  else if ALabel = StrVariable2DIntegerArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    Assert(Trim(ID) = 'IZONENR');
    ReadLn(FImporter.FFile, Layer);
    Dec(Layer);
    if ISOURCE = nil then
    begin
      SetLength(ISOURCE, FModel.ModflowLayerCount);
    end;
    if ISOURCE[Layer] = nil then
    begin
      SetLength(ISOURCE[Layer], FGrid.RowCount, FGrid.ColumnCount);
    end;
    ReadVariable2DIntArray(ISOURCE[Layer]);
  end
  else if ALabel = StrConstant2DIntegerArrayForLayer then
  begin
    ReadLn(FImporter.FFile, ID);
    Assert(Trim(ID) = 'IZONENR');
    ReadLn(FImporter.FFile, Layer);
    Dec(Layer);
    ReadLn(FImporter.FFile, IntegerConstant);

    if ISOURCE_Const = nil then
    begin
      SetLength(ISOURCE_Const, FModel.ModflowLayerCount);
      InitializeConstIntArray(ISOURCE_Const);
    end;

    ISOURCE_Const[Layer].IsConstant := True;
    ISOURCE_Const[Layer].IntegerValue := IntegerConstant;
    FImporter.UpdateProgress;
  end
  else if ALabel = 'OBSNAM:' then
  begin
    Inc(IObs);
    ReadLn(FImporter.FFile, OBSNAM);
    FObservations[IObs].OBSNAM := Trim(OBSNAM);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'KLAY, IROW, JCOL:' then
  begin
    Read(FImporter.FFile, FObservations[IObs].Layer);
    Read(FImporter.FFile, FObservations[IObs].Row);
    Read(FImporter.FFile, FObservations[IObs].Column);
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else
  begin
    Assert(False);
  end;
//  Read(FImporter.FFile, NBDTIM);
//  Read(FImporter.FFile, NFLW);
//  Read(FImporter.FFile, NHED);
//  Read(FImporter.FFile, IFHBSS);
//  Read(FImporter.FFile, IFHBCB);
//  Read(FImporter.FFile, NFHBX1);
//  Read(FImporter.FFile, NFHBX2);
//  Readln(FImporter.FFile);
//  FImporter.UpdateProgress;
//  FFlowCells.ArrayLength := NFLW;
//  FHeadCells.ArrayLength := NHED;
//  for CellIndex := 0 to FFlowCells.ArrayLength - 1 do
//  begin
//    SetLength(FFlowCells.Cells[CellIndex].Values, NBDTIM);
//  end;
//  for CellIndex := 0 to FHeadCells.ArrayLength - 1 do
//  begin
//    SetLength(FHeadCells.Cells[CellIndex].Values, NBDTIM);
//  end;
end;
{$HINTS ON}

function TSwiImporter.ScreenObjectNameRoot: string;
begin
  result := 'SWI_Observation';
end;

function TPackageImporter.AddBoundaryPoints(List: TList; Index: integer;
  ObjectType: TObjectType; var AScreenObject: TScreenObject): Boolean;
var
  Boundary: TLocation;
begin
  Boundary := List[Index];
  if FImporter.FImportParameters.Outline <> nil then
  begin
    result := FImporter.FImportParameters.Outline.PointInside(
      FImporter.CenterPoints[Boundary.Row - 1, Boundary.Column - 1]);
  end
  else
  begin
    result := True;
  end;

  if result then
  begin
    case ObjectType of
      otPoint:
        begin
          AScreenObject.AddPoint(FImporter.CenterPoints[Boundary.Row - 1,
            Boundary.Column - 1], True);
        end;
      otPolygon:
        begin
          AScreenObject.AddPoint(FImporter.CornerPoints[Boundary.Row - 1,
            Boundary.Column - 1], True);
          AScreenObject.AddPoint(FImporter.CornerPoints[Boundary.Row - 1,
            Boundary.Column], False);
          AScreenObject.AddPoint(FImporter.CornerPoints[Boundary.Row,
            Boundary.Column], False);
          AScreenObject.AddPoint(FImporter.CornerPoints[Boundary.Row,
            Boundary.Column - 1], False);
          AScreenObject.AddPoint(FImporter.CornerPoints[Boundary.Row - 1,
            Boundary.Column - 1], False);
        end;
    else
      Assert(False);
    end;
  end;
end;

function TObjectImporter.CreateScreenObject(List: TList;
  var ScreenObjectIndex: integer; LayerIndex, StressPeriodIndex: integer;
  ObjectType: TObjectType): TScreenObject;
var
  UndoCreateScreenObject: TCustomUndo;
  Index: integer;
  Boundary: TLocation;
  ImportedElevations: TValueArrayStorage;
  MaxStressPeriodString: string;
  LayerString: string;
  MaxLayerString: string;
begin
  if StressPeriodIndex < 0 then
  begin
    StressPeriodString := '';
  end
  else
  begin
    StressPeriodString := IntToStr(StressPeriodIndex + 1);
    MaxStressPeriodString := IntToStr(FModel.ModflowStressPeriods.Count);
    while Length(StressPeriodString) < Length(MaxStressPeriodString) do
    begin
      StressPeriodString := '0' + StressPeriodString;
    end;
    StressPeriodString := '_StressPeriod_' + StressPeriodString;
  end;
  if LayerIndex >= 1 then
  begin
    LayerString := IntToStr(FModel.LayerStructure.ModflowLayerToDataSetLayer
      (LayerIndex) + 1);
    MaxLayerString := IntToStr(FGrid.LayerCount);
    while Length(LayerString) < Length(MaxLayerString) do
    begin
      LayerString := '0' + LayerString;
    end;
    LayerString := '_Layer_' + LayerString;
  end
  else
  begin
    LayerString := '';
  end;
  result := TScreenObject.CreateWithViewDirection(FModel, vdTop,
    UndoCreateScreenObject, False);
  result.Comment := 'Imported from ' + NameFile +' on ' + DateTimeToStr(Now);
  Inc(ScreenObjectIndex);
  result.Name := ScreenObjectNameRoot + StressPeriodString +
    LayerString + '_' + IntToStr(ScreenObjectIndex);
  result.ElevationCount := ecOne;
  case ObjectType of
    otPoint:
      result.SetValuesOfIntersectedCells := True;
    otLine, otPolygon:
      result.SetValuesOfEnclosedCells := True;
  else
    Assert(False);
  end;
  result.EvaluatedAt := eaBlocks;
  result.Visible := False;
  result.Capacity := List.Count;
  ImportedElevations := result.ImportedSectionElevations;
  ImportedElevations.DataType := rdtDouble;
  ImportedElevations.Count := List.Count;
  for Index := 0 to List.Count - 1 do
  begin
    if AddBoundaryPoints(List, Index, ObjectType, result) then
    begin
      Boundary := List[Index];
      if Boundary.Layer >= 1 then
      begin
        ImportedElevations.RealValues[Index] :=
          FGrid.NearLayerTop(ZeroBasedID(FModel.ModflowLayerToDataSetLayer(Boundary.Layer),
          Boundary.Row - 1, Boundary.Column - 1));
      end
      else
      begin
        ImportedElevations.RealValues[Index] :=
          FGrid.NearLayerTop(ZeroBasedID(0, Boundary.Row - 1, Boundary.Column - 1));
      end;
    end;
  end;
  ImportedElevations.Count := result.SectionCount;
  result.ElevationFormula := rsObjectImportedValuesR + '("' +
    StrImportedElevations + '")';
  ImportedElevations.CacheData;
  result.SectionStarts.CacheData;
  if result.Count > 0 then
  begin
    FModel.AddScreenObject(result);
  end
  else
  begin
    FreeAndNil(result);
  end;
end;

{ TSwrImporter }

constructor TSwrImporter.Create(Importer: TModflow2005Importer;
  const NameFile: string);
begin
  inherited Create(Importer, 'SWR');
  FNameFile := NameFile;

  FReachArray := TSwrReachArray.Create;
  FTabFiles := TSwrTabFileArray.Create;
  FObsArray := TSwrObsArray.Create;
  FGeomArray := TSwrGeomArray.Create;
  FStructures := TStructureArray.Create;
  FCurrentStressPeriod := -1;

  DMAXRAI := KMaxRainfallForStepAdjustment;
  DMAXSTG := KMaxStageChangePerStep;
  IPC := Ord(KPreconditioner);
  NLEVELS := KMaxLevels;
  DROPTOL := KDropThreshold;
  PTOLR := KAlternativeFlowTolerance;
end;

destructor TSwrImporter.Destroy;
begin
  FStructures.Free;
  FGeomArray.Free;
  FObsArray.Free;
  FTabFiles.Free;
  FReachArray.Free;
  inherited;
end;

procedure TSwrImporter.ImportObservations;
var
  ObsIndex: Integer;
  SwrObs: TSwrObs;
  ObsItem: TSwrObsItem;
  Observations: TSwrObsCollection;
  ObservationReach: Integer;
//  StructurePosition: Integer;
  StructureIndex: Integer;
  AStructure: TStructure;
  StructureCount: integer;
  procedure AddObservation;
  begin
    ObsItem := Observations.Add;
    if SwrObs.COBSTYPE = 'STRUCTURE' then
    begin
      ObsItem.ObsName := SwrObs.COBSNAME + IntToStr(StructureCount);
    end
    else
    begin
      ObsItem.ObsName := SwrObs.COBSNAME;
    end;
    if SwrObs.COBSTYPE = 'STAGE' then
    begin
      ObsItem.ObsType := sotStage;
    end
    else if SwrObs.COBSTYPE = 'DEPTH' then
    begin
      ObsItem.ObsType := sotDepth;
    end
    else if SwrObs.COBSTYPE = 'RBOTTOM' then
    begin
      ObsItem.ObsType := sotBottom;
    end
    else if SwrObs.COBSTYPE = 'FLOW' then
    begin
      ObsItem.ObsType := sotFlow;
    end
    else if SwrObs.COBSTYPE = 'STRUCTURE' then
    begin
      ObsItem.ObsType := sotStructure;
    end
    else if SwrObs.COBSTYPE = 'BASEFLOW' then
    begin
      ObsItem.ObsType := sotBaseFlow;
    end;
    ObsItem.ObservationReach := SwrObs.IOBSLOC;
    ObsItem.ConnectedReachOrStructure := SwrObs.IOBSLOC2;
    ObsItem.ObservationLayer := SwrObs.IOBSLAY;
    if ObsItem.ObsType = sotStructure then
    begin
      ObsItem.StructureName := AStructure.Name;
    end;
  end;
begin
  Observations := FModel.SwrObservations;
  Observations.Capacity := FObsArray.ArrayLength;
  for ObsIndex := 0 to FObsArray.ArrayLength - 1 do
  begin
  SwrObs := FObsArray[ObsIndex];
    if SwrObs.COBSTYPE = 'STRUCTURE' then
    begin
      ObservationReach := SwrObs.IOBSLOC;
//      StructurePosition := SwrObs.IOBSLOC2;
      StructureCount := 0;
      for StructureIndex := 0 to FModel.SwrStructures.Count - 1 do
      begin
        AStructure := FModel.SwrStructures[StructureIndex];
        if AStructure.Reach = ObservationReach then
        begin
          Inc(StructureCount);
          AddObservation;
        end;
      end;
    end
    else
    begin
      AddObservation;
    end;
  end;
end;

procedure TSwrImporter.ImportStructures;
var
  TabFile: TSwrTabFile;
  Structures: TStructureCollection;
  TableItem: TStructureDischargeItem;
  PriorIndex: Integer;
  SwrTableItem: TSwrStructureTableItem;
  AStructArray: TStructureStressPeriodArray;
  StressPeriodIndex: Integer;
  PriorCount: Integer;
  TabIndex: Integer;
  StructureList: Generics.Collections.TList<TSwrStructure>;
  StructureIndex: Integer;
  PriorItem: TSwrStructure;
  EndTime: Double;
  TimeItem: TStructureTimeItem;
  PriorEndTime: Double;
  AStruct: TStructure;
  StressPeriod: TModflowStressPeriod;
  ATable: TStructureDischargeCollection;
  StructIndex: Integer;
  TableItemIndex: Integer;
  AStructItem: TSwrStructure;
begin
  Structures := FModel.SwrStructures;
  StructureList := TList<TSwrStructure>.Create;
  try
    for StressPeriodIndex := 0 to Length(FStructureChanged) - 1 do
    begin
      StressPeriod := FModel.ModflowStressPeriods[StressPeriodIndex];
      if StressPeriodIndex < FStructures.ArrayLength then
      begin
        if FStructureChanged[StressPeriodIndex] then
        begin
          AStructArray := FStructures[StressPeriodIndex];
          PriorCount := StructureList.Count;
          for StructIndex := 0 to AStructArray.ArrayLength - 1 do
          begin
            AStructItem := AStructArray[StructIndex];
            for PriorIndex := 0 to PriorCount - 1 do
            begin
              PriorItem := StructureList[PriorIndex];
              if PriorItem.IsSame(AStructItem) then
              begin
                AStructItem.FStrucItem := PriorItem.FStrucItem;
                break;
              end;
            end;
            if AStructItem.FStrucItem <> nil then
            begin
              Continue;
            end;
            AStructItem.FStrucItem := Structures.Add;
            AStructItem.FStrucItem.Name := 'Structure' + IntToStr(Structures.Count);
            AStructItem.FStrucItem.Reach := AStructItem.ISTRRCH + 1;
            AStructItem.FStrucItem.ConnectedReach := AStructItem.ISTRCONN;
            if AStructItem.ISTRDIR < 0 then
            begin
              AStructItem.FStrucItem.StructureRestrictions := srRestrictFromConnected;
            end
            else if AStructItem.ISTRDIR > 0 then
            begin
              AStructItem.FStrucItem.StructureRestrictions := srRestrictToConnected;
            end
            else
            begin
              AStructItem.FStrucItem.StructureRestrictions := srBidirectional;
            end;
            if AStructItem.ISTRTYPE < 0 then
            begin
              Assert(AStructItem.ISTRTYPE = -2);
              AStructItem.FStrucItem.StructureType := sstUncontrolledZeroDepth;
            end
            else
            begin
              Assert(AStructItem.ISTRTYPE in [0..12]);
              AStructItem.FStrucItem.StructureType := TSwrStructureType(AStructItem.ISTRTYPE + 1);
            end;
            AStructItem.FStrucItem.WeirDischargeCoefficient := AStructItem.STRCD;
            AStructItem.FStrucItem.OrificeDischargeCoefficient := AStructItem.STRCD2;
            AStructItem.FStrucItem.SubmergenceExponent := AStructItem.STRCD3;
            AStructItem.FStrucItem.InvertElevation := AStructItem.STRINV;
            AStructItem.FStrucItem.DownstreamInvertElevation := AStructItem.STRINV2;
            AStructItem.FStrucItem.Width := Abs(AStructItem.STRWID);
            if AStructItem.STRWID >= 0 then
            begin
              AStructItem.FStrucItem.CulvertType := ctCircular;
            end
            else
            begin
              AStructItem.FStrucItem.CulvertType := ctRectangular;
            end;
            AStructItem.FStrucItem.CulvertRise := Abs(AStructItem.STRWID2);
            if AStructItem.FStrucItem.StructureType in [sstUncontrolledZeroDepth, sstUncontrolledCriticalDepth] then
            begin
              AStructItem.FStrucItem.SpecifyCulvertLengths := (AStructItem.STRLEN > 0) or (AStructItem.STRLEN2 > 0);
            end
            else
            begin
              AStructItem.FStrucItem.SpecifyCulvertLengths := False;
            end;
            AStructItem.FStrucItem.CulvertLength := AStructItem.STRLEN;
            AStructItem.FStrucItem.DownstreamCulvertLength := AStructItem.STRLEN2;
            AStructItem.FStrucItem.CulvertRoughness := AStructItem.STRMAN;
            if AStructItem.ISTRTAB_Discharge > 0 then
            begin
              AStructItem.FStrucItem.InitialFlowRateMethod := smTabFile;
              for TabIndex := 0 to FTabFiles.ArrayLength - 1 do
              begin
                TabFile := FTabFiles[TabIndex];
                if AStructItem.ISTRTAB_Discharge = TabFile.ITAB then
                begin
                  AStructItem.FStrucItem.FullInitialFlowRateTabFile := TabFile.TabItem.FullTabFileName;
                  break;
                end;
              end;
            end
            else
            begin
              AStructItem.FStrucItem.InitialFlowRateMethod := smValue;
              AStructItem.FStrucItem.InitialFlowRateOrGateOpening := AStructItem.STRVAL;
            end;
            AStructItem.FStrucItem.SfrSegment := AStructItem.ISFRSEG;
            AStructItem.FStrucItem.SfrReach := AStructItem.ISFRRCH;
            if AStructItem.CSTROTYP = 'STAGE' then
            begin
              AStructItem.FStrucItem.ControlType := ctStage;
            end
            else if AStructItem.CSTROTYP = 'FLOW' then
            begin
              AStructItem.FStrucItem.ControlType := ctFlow;
            end;
            AStructItem.FStrucItem.ControlReach := AStructItem.ISTRORCH;
            AStructItem.FStrucItem.ConnectedControlReach := AStructItem.ISTROQCON;
            if AStructItem.CSTROLO = 'GE' then
            begin
              AStructItem.FStrucItem.ControlOperated := coGreaterEqual;
            end
            else if AStructItem.CSTROLO = 'LT' then
            begin
              AStructItem.FStrucItem.ControlOperated := coLessThan;
            end;
            if AStructItem.ISTRTAB_Control > 0 then
            begin
              AStructItem.FStrucItem.CriticalMethod := smTabFile;
              for TabIndex := 0 to FTabFiles.ArrayLength - 1 do
              begin
                TabFile := FTabFiles[TabIndex];
                if AStructItem.ISTRTAB_Control = TabFile.ITAB then
                begin
                  AStructItem.FStrucItem.CriticalTabFileName := TabFile.TabItem.FullTabFileName;
                  break;
                end;
              end;
            end
            else
            begin
              AStructItem.FStrucItem.CriticalMethod := smValue;
              AStructItem.FStrucItem.CriticalValue := AStructItem.STRCRIT;
            end;
            AStructItem.FStrucItem.ControlOffsetCriterion := AStructItem.STRCRITC;
            AStructItem.FStrucItem.StartingControlRate := AStructItem.STRRT;
            AStructItem.FStrucItem.MaximumControlRate := AStructItem.STRMAX;
            if AStructItem.ISTRTAB_Gate > 0 then
            begin
              for TabIndex := 0 to FTabFiles.ArrayLength - 1 do
              begin
                TabFile := FTabFiles[TabIndex];
                if AStructItem.ISTRTAB_Gate = TabFile.ITAB then
                begin
                  AStructItem.FStrucItem.DischargeTabFile := TabFile.TabItem.FullTabFileName;
                  break;
                end;
              end;
            end;
            ATable := AStructItem.FStrucItem.Table;
            ATable.Capacity := AStructItem.FTable.ArrayLength;
            for TableItemIndex := 0 to AStructItem.FTable.ArrayLength - 1 do
            begin
              TableItem := ATable.Add;
              SwrTableItem := AStructItem.FTable[TableItemIndex];
              TableItem.Discharge := SwrTableItem.STRQ;
              TableItem.Elev := SwrTableItem.STRELEV;
            end;
            if (AStructItem.FStrucItem.Times.Count = 0) and (StressPeriodIndex > 0) then
            begin
              TimeItem := AStructItem.FStrucItem.Times.Add;
              TimeItem.StartTime := FModel.ModflowStressPeriods.First.StartTime;
              TimeItem.EndTime := StressPeriod.StartTime;
              TimeItem.Used := False;
            end;
            TimeItem := AStructItem.FStrucItem.Times.Add;
            TimeItem.StartTime := StressPeriod.StartTime;
            TimeItem.EndTime := StressPeriod.EndTime;
            TimeItem.Used := True;
          end;
          for StructureIndex := 0 to Structures.Count - 1 do
          begin
            AStruct := Structures[StructureIndex];
            TimeItem := AStruct.Times.Last;
            if TimeItem.EndTime <> StressPeriod.EndTime then
            begin
              if TimeItem.Used then
              begin
                PriorEndTime := TimeItem.EndTime;
                TimeItem := AStruct.Times.Add;
                TimeItem.StartTime := PriorEndTime;
                TimeItem.EndTime := StressPeriod.EndTime;
                TimeItem.Used := False;
              end
              else
              begin
                TimeItem.EndTime := StressPeriod.EndTime;
              end;
            end;
          end;
        end
        else
        begin
          for StructureIndex := 0 to Structures.Count - 1 do
          begin
            AStruct := Structures[StructureIndex];
            TimeItem := AStruct.Times.Last;
            TimeItem.EndTime := StressPeriod.EndTime;
          end;
        end;
      end
      else
      begin
        EndTime := FModel.ModflowStressPeriods.Last.EndTime;
        for StructureIndex := 0 to Structures.Count - 1 do
        begin
          AStruct := Structures[StructureIndex];
          TimeItem := AStruct.Times.Last;
          TimeItem.EndTime := EndTime;
        end;
        break;
      end;
    end;
  finally
    StructureList.Free;
  end;
end;

procedure TSwrImporter.InitializeStructureChanged;
var
  StressPeriodIndex: Integer;
begin
  if Length(FStructureChanged) = 0 then
  begin
    SetLength(FStructureChanged, FModel.ModflowStressPeriods.Count);
    for StressPeriodIndex := 0 to Length(FStructureChanged) - 1 do
    begin
      FStructureChanged[StressPeriodIndex] := False;
    end;
  end;
end;

procedure TSwrImporter.ImportTabFiles;
var
  TabFile: TSwrTabFile;
  Splitter: TStringList;
  TabFiles: TTabFileCollection;
  NameFileItems: TNameFileItemList;
  TabFileIndex: Integer;
  LineIndex: Integer;
  TabIndex: Integer;
  TabItem: TTabFileItem;
  NameItem: TNameFileItem;
  ReachIndex: Integer;
  FileType: string;
  NameFile: TStringList;
begin
  if FTabFiles.ArrayLength > 0 then
  begin
    NameFileItems := TNameFileItemList.Create;
    try
      NameFile := TStringList.Create;
      Splitter := TStringList.Create;
      try
        Splitter.Delimiter := ' ';
        Assert(FileExists(FNameFile));
        SetCurrentDir(ExtractFileDir(FNameFile));
        NameFile.LoadFromFile(FNameFile);
        for LineIndex := 0 to NameFile.Count - 1 do
        begin
          if (Length(NameFile[LineIndex]) > 0) and (NameFile[LineIndex][1] <> '#') then
          begin
            Splitter.DelimitedText := NameFile[LineIndex];
            FileType := UpperCase(Splitter[0]);
            if (FileType = StrData) or (FileType = StrDATABINARY) then
            begin
              NameItem := TNameFileItem.Create;
              NameFileItems.Add(NameItem);
              NameItem.FileName := ExpandFileName(Splitter[2]);
              NameItem.UnitNumber := StrToInt(Splitter[1]);
            end;
          end;
        end;
      finally
        Splitter.Free;
        NameFile.Free;
      end;
      TabFiles := FModel.SwrTabFiles;
      TabFiles.Capacity := FTabFiles.ArrayLength;
      for TabFileIndex := 0 to FTabFiles.ArrayLength - 1 do
      begin
        TabItem := TabFiles.Add;
        TabFile := FTabFiles[TabFileIndex];
        TabFile.TabItem := TabItem;
        if TabFile.CTABTYPE = 'RAIN' then
        begin
          TabItem.TabType := ttRain;
        end
        else if TabFile.CTABTYPE = 'EVAP' then
        begin
          TabItem.TabType := ttEvap;
        end
        else if TabFile.CTABTYPE = 'LATFLOW' then
        begin
          TabItem.TabType := ttLatFlow;
        end
        else if TabFile.CTABTYPE = 'STAGE' then
        begin
          TabItem.TabType := ttStage;
        end
        else if TabFile.CTABTYPE = 'STRUCTURE' then
        begin
          TabItem.TabType := ttStructure;
        end
        else if TabFile.CTABTYPE = 'TIME' then
        begin
          TabItem.TabType := ttTime;
        end
        else
        begin
          Assert(False);
        end;
        if TabFile.ITABUNIT > 0 then
        begin
          TabItem.TabFormat := tfText;
        end
        else
        begin
          TabItem.TabFormat := tfBinary;
        end;
        for TabIndex := 0 to NameFileItems.Count - 1 do
        begin
          if Abs(TabFile.ITABUNIT) = NameFileItems[TabIndex].UnitNumber then
          begin
            TabItem.TabFileName := NameFileItems[TabIndex].FileName;
            break;
          end;
        end;
        Assert(TabItem.TabFileName <> '');
        if TabFile.CINTP = 'NONE' then
        begin
          TabItem.InterpolationMethod := imNone;
        end
        else if TabFile.CINTP = 'AVERAGE' then
        begin
          TabItem.InterpolationMethod := imAverage;
        end
        else if TabFile.CINTP = 'INTERPOLATE' then
        begin
          TabItem.InterpolationMethod := imInterpolate;
        end
        else
        begin
          Assert(False);
        end;
        if TabFile.CTABRCH = 'ALL' then
        begin
          TabItem.ReachSelectionMethod := rsmAll;
        end
        else if not (TabItem.TabType in [ttStructure, ttTime]) then
        begin
          if Length(TabFile.ITABRCH) > 1 then
          begin
            TabItem.ReachSelectionMethod := rsmReaches;
            TabItem.Reaches.Capacity := Length(TabFile.ITABRCH);
            for ReachIndex := 0 to Length(TabFile.ITABRCH) - 1 do
            begin
              TabItem.Reaches.Add.Value := TabFile.ITABRCH[ReachIndex]+1;
            end;
          end
          else
          begin
            TabItem.ReachSelectionMethod := rsmValue;
            TabItem.Value := TabFile.ITABRCH[0]+1;
          end;
        end;
      end;
    finally
      NameFileItems.Free;
    end;
  end;
end;

procedure TSwrImporter.ImportDirectRunoffArrays(AScreenObject: TScreenObject);
var
  CurrentMultiplierArray: T2DDoubleArray;
  MapDataArrayName: string;
  CurrentMapConstant: Integer;
  RunoffItem: TSwrDirectRunoffItem;
  DataArrayName: string;
  ConstantMultiplier: Double;
  ConstantValue: Double;
  StartTime: Double;
  ImportArray: T2DDoubleArray;
  CellCenterScreenObject: TScreenObject;
  DirectRunoffCollection: TSwrDirectRunoffCollection;
  ImportValues: Boolean;
  Index1: Integer;
  Index2: Integer;
  MapFormula: string;
  UseConstantValue: Boolean;
  StressPeriodIndex: Integer;
  UseConstantMultiplier: Boolean;
  CurrentValueArray: T2DDoubleArray;
  CurrentMap: T2DIntArray;
  DirRunoffBound: TSwrDirectRunoffBoundary;
begin
  if (Length(FRunoffMap) > 0) or (Length(FRunoffMap_Const) > 0) then
  begin
    if AScreenObject = nil then
    begin
      AScreenObject := CreateScreenObjectAroundGrid('SWR_Boundary');
      AScreenObject.ElevationCount := ecZero;
    end;
    AScreenObject.CreateSwrDirectRunoffBoundary;
    DirRunoffBound := AScreenObject.ModflowSwrDirectRunoff;
    DirectRunoffCollection := DirRunoffBound.Values as TSwrDirectRunoffCollection;
    DirectRunoffCollection.Capacity := FModel.ModflowStressPeriods.Count;
    CurrentMap := nil;
    CurrentMultiplierArray := nil;
    CurrentValueArray := nil;
    ConstantMultiplier := 1;
    UseConstantMultiplier := True;
    RunoffItem := nil;
    ConstantValue := 0;
    UseConstantValue := True;
    for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
    begin
      ImportValues := False;
      if (StressPeriodIndex < Length(FRunoffMap))
        and (Length(FRunoffMap[StressPeriodIndex]) > 0) then
      begin
        CurrentMap := FRunoffMap[StressPeriodIndex];
        ImportValues := True;
        MapDataArrayName := 'Imported_SWR_Direct_RunnoffMap'
          + GetStressPeriodString(StressPeriodIndex);
        CreateOrRetrieveCellCenterScreenObject(CellCenterScreenObject);
        CreateDataArrayAndAssignValues(CellCenterScreenObject,
          MapDataArrayName, CurrentMap);
        MapFormula := MapDataArrayName;
      end
      else if (StressPeriodIndex < Length(FRunoffMap_Const))
        and FRunoffMap_Const[StressPeriodIndex].IsConstant then
      begin
        CurrentMapConstant := FRunoffMap_Const[StressPeriodIndex].IntegerValue;
        MapFormula := IntToStr(CurrentMapConstant);
        ImportValues := True;
      end;
      if (StressPeriodIndex < Length(FRunoffMultiplier))
        and (Length(FRunoffMultiplier[StressPeriodIndex]) > 0) then
      begin
        CurrentMultiplierArray := FRunoffMultiplier[StressPeriodIndex];
        UseConstantMultiplier := False;
        ImportValues := True;
      end
      else if (StressPeriodIndex < Length(FRunoffMultiplier_Const))
        and FRunoffMultiplier_Const[StressPeriodIndex].IsConstant then
      begin
        ConstantMultiplier :=
          FRunoffMultiplier_Const[StressPeriodIndex].RealValue;
        UseConstantMultiplier := True;
        ImportValues := True;
      end;
      if (StressPeriodIndex < Length(FRunoffValue))
        and (Length(FRunoffValue[StressPeriodIndex]) > 0) then
      begin
        CurrentValueArray := FRunoffValue[StressPeriodIndex];
        UseConstantValue := False;
        ImportValues := True;
      end
      else if (StressPeriodIndex < Length(FRunoffValue_Const))
        and FRunoffValue_Const[StressPeriodIndex].IsConstant then
      begin
        ConstantValue := FRunoffValue_Const[StressPeriodIndex].RealValue;
        UseConstantValue := True;
        ImportValues := True;
      end;
      if ImportValues then
      begin
        StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
        if RunoffItem <> nil then
        begin
          RunoffItem.EndTime := StartTime;
        end;
        RunoffItem := DirectRunoffCollection.Add as TSwrDirectRunoffItem;
        RunoffItem.StartTime := StartTime;
        RunoffItem.Reach := MapFormula;
        if UseConstantMultiplier and UseConstantValue then
        begin
          RunoffItem.Runoff :=
            FortranFloatToStr(ConstantMultiplier * ConstantValue);
          ImportArray := nil;
        end
        else if UseConstantMultiplier then
        begin
          if ConstantMultiplier = 0 then
          begin
            ImportArray := nil;
            RunoffItem.Runoff := '0';
          end
          else
          begin
            ImportArray := CurrentValueArray;
            if ConstantMultiplier <> 1 then
            begin
              SetLength(ImportArray, Length(ImportArray),
                Length(ImportArray[0]));
              for Index1 := 0 to Length(ImportArray) - 1 do
              begin
                for Index2 := 0 to Length(ImportArray[0]) - 1 do
                begin
                  ImportArray[Index1, Index2] :=
                    ImportArray[Index1, Index2] * ConstantMultiplier;
                end;
              end;
            end;
          end;
        end
        else if UseConstantValue then
        begin
          if ConstantValue = 0 then
          begin
            ImportArray := nil;
            RunoffItem.Runoff := '0';
          end
          else
          begin
            ImportArray := CurrentMultiplierArray;
            if ConstantValue <> 1 then
            begin
              SetLength(ImportArray,
                Length(ImportArray), Length(ImportArray[0]));
              for Index1 := 0 to Length(ImportArray) - 1 do
              begin
                for Index2 := 0 to Length(ImportArray[0]) - 1 do
                begin
                  ImportArray[Index1, Index2] :=
                    ImportArray[Index1, Index2] * ConstantValue;
                end;
              end;
            end;
          end;
        end
        else
        begin
          ImportArray := CurrentValueArray;
          SetLength(ImportArray, Length(ImportArray), Length(ImportArray[0]));
          for Index1 := 0 to Length(ImportArray) - 1 do
          begin
            for Index2 := 0 to Length(ImportArray[0]) - 1 do
            begin
              ImportArray[Index1, Index2] :=
                ImportArray[Index1, Index2] *
                CurrentMultiplierArray[Index1, Index2];
            end;
          end;
        end;
        if ImportArray <> nil then
        begin
          DataArrayName := 'Imported_SWR_Direct_Runoff_'
            + GetStressPeriodString(StressPeriodIndex);
          CreateOrRetrieveCellCenterScreenObject(CellCenterScreenObject);
          CreateDataArrayAndAssignValues(CellCenterScreenObject,
            DataArrayName, ImportArray);
          RunoffItem.Runoff := DataArrayName;
        end;
      end;
    end;
    if RunoffItem <> nil then
    begin
      RunoffItem.EndTime := FModel.ModflowStressPeriods.Last.EndTime;
    end;
  end;
end;

procedure TSwrImporter.ImportStageArray(var AScreenObject: TScreenObject);
var
  StageBoundary: TSwrStageBoundary;
  Reuse: TBooleanArray;
  ImportedConstData: TRealConstantRecordArray;
  ImportedData: T3DDoubleArray;
  Root: string;
  SwrCollection: TCustomSwrListCollection;
begin
  if (Length(FStage) > 0) or (Length(FStage_Const) > 0) then
  begin
    FSwrPackage.StageSpecification := smArray;

    ImportedData := FStage;
    ImportedConstData := FStage_Const;
    InitializeReuseArray(Reuse, ImportedData, ImportedConstData);
    if AScreenObject = nil then
    begin
      AScreenObject := CreateScreenObjectAroundGrid('SWR_Boundary');
      AScreenObject.ElevationCount := ecZero;
    end;
    AScreenObject.CreateSwrStageBoundary;
    StageBoundary := AScreenObject.ModflowSwrStage;
    SwrCollection := StageBoundary.Values as TCustomSwrListCollection;
    Root := 'Imported_SWR_Stage_';
    ImportSwrTransientArrays(Root, Reuse, ImportedData, SwrCollection,
      ImportedConstData);
  end;
end;

procedure TSwrImporter.ImportLateralFlowArray(var AScreenObject: TScreenObject);
var
  ImportedData: T3DDoubleArray;
  Root: string;
  ImportedConstData: TRealConstantRecordArray;
  SwrCollection: TCustomSwrListCollection;
  LatInflowBoundary: TSwrLatInflowBoundary;
  Reuse: TBooleanArray;
begin
  if (Length(FLatFlow) > 0) or (Length(FLatFlow_Const) > 0) then
  begin
    FSwrPackage.LateralInflowSpecification := smArray;

    ImportedData := FLatFlow;
    ImportedConstData := FLatFlow_Const;
    InitializeReuseArray(Reuse, ImportedData, ImportedConstData);
    if AScreenObject = nil then
    begin
      AScreenObject := CreateScreenObjectAroundGrid('SWR_Boundary');
      AScreenObject.ElevationCount := ecZero;
    end;
    AScreenObject.CreateSwrLatInflowBoundary;
    LatInflowBoundary := AScreenObject.ModflowSwrLatInflow;
    SwrCollection := LatInflowBoundary.Values as TCustomSwrListCollection;
    Root := 'Imported_SWR_Lateral_Inflow_';
    ImportSwrTransientArrays(Root, Reuse, ImportedData, SwrCollection,
      ImportedConstData);
  end;
end;

procedure TSwrImporter.ImportEvapArray(var AScreenObject: TScreenObject);
var
  SwrCollection: TCustomSwrListCollection;
  ImportedConstData: TRealConstantRecordArray;
  ImportedData: T3DDoubleArray;
  Root: string;
  EvapBoundary: TSwrEvapBoundary;
  Reuse: TBooleanArray;
begin
  if (Length(FEvap) > 0) or (Length(FEvap_Const) > 0) then
  begin
    FSwrPackage.EvapSpecification := smArray;

    ImportedData := FEvap;
    ImportedConstData := FEvap_Const;
    InitializeReuseArray(Reuse, ImportedData, ImportedConstData);
    if AScreenObject = nil then
    begin
      AScreenObject := CreateScreenObjectAroundGrid('SWR_Boundary');
      AScreenObject.ElevationCount := ecZero;
    end;
    AScreenObject.CreateSwrEvapBoundary;
    EvapBoundary := AScreenObject.ModflowSwrEvap;
    SwrCollection := EvapBoundary.Values as TCustomSwrListCollection;
    Root := 'Imported_SWR_Evap_';
    ImportSwrTransientArrays(Root, Reuse, ImportedData, SwrCollection,
      ImportedConstData);
  end;
end;

procedure TSwrImporter.ImportRainArray(var AScreenObject: TScreenObject);
var
  ImportedConstData: TRealConstantRecordArray;
  Root: string;
  RainBoundary: TSwrRainBoundary;
  ImportedData: T3DDoubleArray;
  SwrCollection: TCustomSwrListCollection;
  Reuse: TBooleanArray;
begin
  if (Length(FRain) > 0) or (Length(FRain_Const) > 0) then
  begin
    FSwrPackage.RainSpecification := smArray;

    ImportedData := FRain;
    ImportedConstData := FRain_Const;
    InitializeReuseArray(Reuse, ImportedData, ImportedConstData);
    AScreenObject := CreateScreenObjectAroundGrid('SWR_Boundary');
    AScreenObject.ElevationCount := ecZero;
    AScreenObject.CreateSwrRainBoundary;
    RainBoundary := AScreenObject.ModflowSwrRain;
    SwrCollection := RainBoundary.Values as TCustomSwrListCollection;
    Root := 'Imported_SWR_Rain_';
    ImportSwrTransientArrays(Root, Reuse, ImportedData, SwrCollection,
      ImportedConstData);
  end;
end;

procedure TSwrImporter.ImportSwrTransientArrays(const Root: string; 
  Reuse: TBooleanArray; ImportedData: T3DDoubleArray; 
  SwrCollection: TCustomSwrListCollection; 
  ImportedConstData: TRealConstantRecordArray);
var
  DataArrayName: string;
  Index1: Integer;
  StressPeriodIndex: Integer;
  SwrItem: TCustomSwrBoundaryItem;
  StartTime: Double;
  Index2: Integer;
  ScreenObject: TScreenObject;
  Uniform: Boolean;
  TwoDArray: T2DDoubleArray;
  AValue: Double;
begin
  SwrCollection.Capacity := FModel.ModflowStressPeriods.Count;
  SwrItem := nil;
  for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
  begin
    if not Reuse[StressPeriodIndex] then
    begin
      StartTime := FModel.ModflowStressPeriods[StressPeriodIndex].StartTime;
      if SwrItem <> nil then
      begin
        SwrItem.EndTime := StartTime;
      end;
      SwrItem := SwrCollection.Add as TCustomSwrBoundaryItem;
      SwrItem.StartTime := StartTime;
      if (StressPeriodIndex < Length(ImportedConstData)) and ImportedConstData[StressPeriodIndex].IsConstant then
      begin
        SwrItem.SwrValue := FortranFloatToStr(ImportedConstData[StressPeriodIndex].RealValue);
      end
      else
      begin
        TwoDArray := ImportedData[StressPeriodIndex];
        AValue := TwoDArray[0, 0];
        Uniform := True;
        for Index1 := 0 to length(TwoDArray) - 1 do
        begin
          for Index2 := 0 to length(TwoDArray[Index1]) - 1 do
          begin
            Uniform := AValue = TwoDArray[Index1, Index2];
            if not Uniform then
            begin
              break;
            end;
          end;
        end;
        if Uniform then
        begin
          SwrItem.SwrValue := FortranFloatToStr(AValue);
        end
        else
        begin
          DataArrayName := Root + GetStressPeriodString(StressPeriodIndex);
          CreateOrRetrieveCellCenterScreenObject(ScreenObject);
          CreateDataArrayAndAssignValues(ScreenObject, DataArrayName, TwoDArray);
          SwrItem.SwrValue := DataArrayName;
        end;
      end;
    end;
  end;
  if SwrItem <> nil then
  begin
    SwrItem.EndTime := FModel.ModflowStressPeriods.Last.EndTime;
  end;
end;

procedure TSwrImporter.InitializeReuseArray(var Reuse: TBooleanArray; 
  ImportedData: T3DDoubleArray; ImportedConstData: TRealConstantRecordArray);
var
  StressPeriodIndex: Integer;
begin
  SetLength(Reuse, FModel.ModflowStressPeriods.Count);
  for StressPeriodIndex := 0 to FModel.ModflowStressPeriods.Count - 1 do
  begin
    Reuse[StressPeriodIndex] := True;
    if StressPeriodIndex < Length(ImportedData) then
    begin
      if Length(ImportedData[StressPeriodIndex]) > 0 then
      begin
        Reuse[StressPeriodIndex] := False;
      end;
    end;
    if StressPeriodIndex < Length(ImportedConstData) then
    begin
      if ImportedConstData[StressPeriodIndex].IsConstant then
      begin
        Reuse[StressPeriodIndex] := False;
      end;
    end;
  end;
end;

procedure TSwrImporter.ImportReachGeom;
var
  GeomList: Generics.Collections.TList<TSwrGeomItem>;
  XSecItem: TReachCrossSectionItem;
  ItemIndex: Integer;
  AGeomItem: TSwrGeomItem;
  TableItem: TSwrGeomTableItem;
  CrossSecItem: TSwrGeomCrossSectionPoint;
  GeomIndex: Integer;
  StressPeriodIndex: Integer;
  PriorCount: Integer;
  TabItem: TReachTableItem;
  PriorIndex: Integer;
  AGeomArray: TSwrGeomStressPeriodArray;
  PriorItem: TSwrGeomItem;
  ReachGeometry: TReachGeometryCollection;
begin
  ReachGeometry := FModel.SwrReachGeometry;
  GeomList := TList<TSwrGeomItem>.Create;
  try
    for StressPeriodIndex := 0 to FGeomArray.ArrayLength - 1 do
    begin
      AGeomArray := FGeomArray[StressPeriodIndex];
      PriorCount := GeomList.Count;
      for GeomIndex := 0 to AGeomArray.ArrayLength - 1 do
      begin
        AGeomItem := AGeomArray[GeomIndex];
        for PriorIndex := 0 to PriorCount - 1 do
        begin
          PriorItem := GeomList[PriorIndex];
          if PriorItem.IsSame(AGeomItem) then
          begin
            AGeomItem.FGeomItem := PriorItem.FGeomItem;
            break;
          end;
        end;
        if AGeomItem.FGeomItem <> nil then
        begin
          Continue;
        end;
        AGeomItem.FGeomItem := ReachGeometry.Add;
        AGeomItem.FGeomItem.Name := 'Geom' + IntToStr(ReachGeometry.Count);
        AGeomItem.FGeomItem.GeometryType :=
          TGeometryType(AGeomItem.IGEOTYPE - 1);
        AGeomItem.FGeomItem.ConductanceMethod :=
          TConductanceMethod(AGeomItem.IGCNDOP);
        AGeomItem.FGeomItem.Roughness := AGeomItem.GMANNING;
        AGeomItem.FGeomItem.Width := AGeomItem.GWIDTH;
        AGeomItem.FGeomItem.BottomElevation := AGeomItem.GBELEV;
        AGeomItem.FGeomItem.SideSlope := AGeomItem.GSSLOPE;
        AGeomItem.FGeomItem.Conductance := AGeomItem.GCND;
        AGeomItem.FGeomItem.Leakance := AGeomItem.GLK;
        AGeomItem.FGeomItem.CenterDistance := AGeomItem.GCNDLN;
        AGeomItem.FGeomItem.ExtinctionDepth := AGeomItem.GETEXTD;

        AGeomItem.FGeomItem.CrossSection.Capacity :=
          AGeomItem.FCrossSection.ArrayLength;
        for ItemIndex := 0 to AGeomItem.FCrossSection.ArrayLength - 1 do
        begin
          CrossSecItem := AGeomItem.FCrossSection[ItemIndex];
          XSecItem := AGeomItem.FGeomItem.CrossSection.Add;
          XSecItem.X := CrossSecItem.XB;
          XSecItem.Elev := CrossSecItem.ELEVB;
        end;

        AGeomItem.FGeomItem.Table.Capacity := AGeomItem.FTable.ArrayLength;
        for ItemIndex := 0 to AGeomItem.FTable.ArrayLength - 1 do
        begin
          TableItem := AGeomItem.FTable[ItemIndex];
          TabItem := AGeomItem.FGeomItem.Table.Add;
          TabItem.Elevation := TableItem.ELEV;
          TabItem.Volume := TableItem.VOL;
          TabItem.WettedPerimeter := TableItem.WETPER;
          TabItem.SurfaceArea := TableItem.SAREA;
          TabItem.CrossSectionArea := TableItem.XAREA;
        end;
      end;
    end;
  finally
    GeomList.Free;
  end;
end;

procedure TSwrImporter.SetPackageData;
begin
  FSwrPackage.OnlyUseSWR := ISWRONLY > 0;
  FSwrPackage.ContinueDespiteNonConvergence := USE_NONCONVERGENCE_CONTINUE;
  FSwrPackage.UseUpstreamWeightingForDiffusiveWave := USE_UPSTREAM_WEIGHTING;
  FSwrPackage.UseInexactNewton := USE_INEXACT_NEWTON;
  FSwrPackage.UseSteadyStateStorage := USE_STEADYSTATE_STORAGE;
  FSwrPackage.UseLaggedStagesAndFlows := USE_LAGGED_OPR_DATA;
  FSwrPackage.UseLinearDepthScaling := USE_LINEAR_DEPTH_SCALING;

  if USE_DIAGONAL_SCALING then
  begin
    FSwrPackage.Scaling := ssDiagonal;
  end
  else if USE_L2NORM_SCALING then
  begin
    FSwrPackage.Scaling := ssL2Norm;
  end
  else
  begin
    FSwrPackage.Scaling := ssNone;
  end;

  if USE_RCMREORDERING then
  begin
    FSwrPackage.Reordering := srUse;
  end
  else if USE_RCMREORDERING_IF_IMPROVEMENT then
  begin
    FSwrPackage.Reordering := srUseIfImproved;
  end
  else
  begin
    FSwrPackage.Reordering := srNone;
  end;

  if USE_IMPLICIT_NEWTON_CORRECTION then
  begin
    FSwrPackage.NewtonCorrection := sncImplicit;
  end
  else if USE_EXPLICIT_NEWTON_CORRECTION then
  begin
    FSwrPackage.NewtonCorrection := sncExplicit;
  end
  else
  begin
    FSwrPackage.NewtonCorrection := sncNone;
  end;

  FSwrPackage.InitialTimeStepLength := RTINI;
  FSwrPackage.MinTimeStepLength := RTMIN;
  FSwrPackage.MaxTimeStepLength := RTMAX;
  FSwrPackage.TimeStepMultiplier := RTMULT;
  FSwrPackage.TimeStepIncreaseFrequency := NTMULT;
  FSwrPackage.MinGradientForDiffusiveFlow := DMINGRAD;
  FSwrPackage.MinDepthForOutflow := DMNDEPTH;
  FSwrPackage.MaxRainfallForStepAdjustment := DMAXRAI;
  FSwrPackage.MaxStageChangePerStep := DMAXSTG;
  FSwrPackage.MaxInflowChange := DMAXINF;

  if ISWRPRGF = 0 then
  begin
    FSwrPackage.PrintInflowsAndOutflows := spoNone;
  end
  else if ISWRPRGF > 0 then
  begin
    FSwrPackage.PrintInflowsAndOutflows := spoASCII;
  end
  else
  begin
    FSwrPackage.PrintInflowsAndOutflows := spoBinary;
  end;

  if ISWRPSTG = 0 then
  begin
    FSwrPackage.PrintStage := spoNone;
  end
  else if ISWRPSTG > 0 then
  begin
    FSwrPackage.PrintStage := spoASCII;
  end
  else
  begin
    FSwrPackage.PrintStage := spoBinary;
  end;

  if ISWRPQAQ = 0 then
  begin
    FSwrPackage.PrintReachExchangeAndProperties := spoNone;
  end
  else if ISWRPQAQ > 0 then
  begin
    FSwrPackage.PrintReachExchangeAndProperties := spoASCII;
  end
  else
  begin
    FSwrPackage.PrintReachExchangeAndProperties := spoBinary;
  end;

  if ISWRPQM = 0 then
  begin
    FSwrPackage.PrintReachLateralFlow := spoNone;
  end
  else if ISWRPQM > 0 then
  begin
    FSwrPackage.PrintReachLateralFlow := spoASCII;
  end
  else
  begin
    FSwrPackage.PrintReachLateralFlow := spoBinary;
  end;

  if ISWRPSTR = 0 then
  begin
    FSwrPackage.PrintStructureFlow := spoNone;
  end
  else if ISWRPSTR > 0 then
  begin
    FSwrPackage.PrintStructureFlow := spoASCII;
  end
  else
  begin
    FSwrPackage.PrintStructureFlow := spoBinary;
  end;

  FSwrPackage.PrintMaxFroude := ISWRPFRN > 0;
  FSwrPackage.PrintSwrDataToScreen := PRINT_SWR_TO_SCREEN;

  if SAVE_SWRDT then
  begin
    if SWRDT_Unit = 0 then
    begin
      FSwrPackage.SaveSwrTimeStepLength := spoNone;
    end
    else if SWRDT_Unit > 0 then
    begin
      FSwrPackage.SaveSwrTimeStepLength := spoASCII;
    end
    else
    begin
      FSwrPackage.SaveSwrTimeStepLength := spoBinary;
    end;
  end
  else
  begin
    FSwrPackage.SaveSwrTimeStepLength := spoNone;
  end;

  FSwrPackage.SaveAverageSimulatedResults := SAVE_AVERAGE_RESULTS;
  FSwrPackage.SaveConvergenceHistory := SAVE_CONVERGENCE_HISTORY;

  if SAVE_RIVER_PACKAGE then
  begin
    FSwrPackage.SaveRiver := ssrSaveActive;
  end
  else if SAVE_RIVER_PACKAGE_ALL then
  begin
    FSwrPackage.SaveRiver := ssrSaveAll;
  end
  else
  begin
    FSwrPackage.SaveRiver := ssrNone;
  end;

  if SAVE_SWROBSERVATIONS then
  begin
    FSwrPackage.SaveObs := ssoSaveObs;
  end
  else if SAVE_SWROBSERVATIONS_ALL then
  begin
    FSwrPackage.SaveObs := ssoSaveObsAll;
  end
  else
  begin
    FSwrPackage.SaveObs := ssoNone;
  end;

  if FSwrPackage.SaveObs in [ssoSaveObs, ssoSaveObsAll] then
  begin
    if SWROBSERVATIONS_Unit > 0 then
    begin
      FSwrPackage.ObsFormat := swofAscii;
    end
    else
    begin
      FSwrPackage.ObsFormat := swofBinary;
    end;
  end;

  FSwrPackage.SaveFrequency := RTPRN;

  case ISOLVER of
    1..3:
      begin
        FSwrPackage.Solver := TSwrSolver(ISOLVER - 1);
      end;
  else
    Assert(False);
  end;

  FSwrPackage.MaxOuterIterations := NOUTER;
  FSwrPackage.MaxInnerIterations := NINNER;
  FSwrPackage.MaxLineSearchIterations := IBT;
  FSwrPackage.StageTolerance := TOLS;

  if USE_FRACTIONAL_TOLR then
  begin
    FSwrPackage.FlowToleranceOption := rtoFractional;
  end
  else if USE_L2NORM_TOLR then
  begin
    FSwrPackage.FlowToleranceOption := rtoL2Norm;
  end
  else
  begin
    FSwrPackage.FlowToleranceOption := rtoNone;
  end;

  FSwrPackage.FlowTolerance := TOLR;

  if USE_GLOBAL_TOLA then
  begin
    FSwrPackage.ExchangeToleranceOption := etGlobal;
  end
  else if USE_ABSOLUTE_TOLA then
  begin
    FSwrPackage.ExchangeToleranceOption := etAbsolute;
  end
  else
  begin
    FSwrPackage.ExchangeToleranceOption := etNone;
  end;

  FSwrPackage.ExchangeTolerance := TOLA;
  FSwrPackage.SteadyStateDampingFactor := DAMPSS;
  FSwrPackage.TransientDampingFactor := DAMPTR;
  FSwrPackage.ConvergencePrintoutInterval := IPRSWR;

  case MUTSWR of
    0..3:
      FSwrPackage.PrintConvergence := TSwrPrintConvergence(MUTSWR);
  else
    Assert(False);
  end;

  case IPC of
    0..4:
      FSwrPackage.Preconditioner := TSwrPreconditioner(IPC);
  else
    Assert(False);
  end;

  FSwrPackage.MaxLevels := NLEVELS;
  FSwrPackage.DropThreshold := DROPTOL;
  FSwrPackage.PrintLineSearchInterval := IBTPRT;
  FSwrPackage.AlternativeFlowTolerance := PTOLR;
end;

procedure TSwrImporter.ReadDataSet1B_UnitNumber;
var
  IOPTUNIT: Integer;
  AnOption: string;
begin
  Readln(FImporter.FFile, AnOption);
  AnOption := UpperCase(Trim(AnOption));
  Readln(FImporter.FFile, IOPTUNIT);
  if AnOption = 'SAVE_SWRDT' then
  begin
    SWRDT_Unit := IOPTUNIT;
  end
  else if AnOption = 'SAVE_CONVERGENCE_HISTORY' then
  begin
  end
  else // do nothing
  if AnOption = 'SAVE_RIVER_PACKAGE' then
  begin
  end
  else // do nothing
  if AnOption = 'SAVE_RIVER_PACKAGE_ALL' then
  begin
  end
  else // do nothing
  if AnOption = 'SAVE_SWROBSERVATIONS' then
  begin
    SWROBSERVATIONS_Unit := IOPTUNIT;
  end
  else if AnOption = 'SAVE_SWROBSERVATIONS_ALL' then
  begin
    SWROBSERVATIONS_Unit := IOPTUNIT;
  end
  else if AnOption = 'USE_DIRECT_RUNOFF' then
  begin
  end
  else
  // do nothing
  begin
    Assert(False);
  end;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadRunoffMapVariable;
var
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Assert(ID = KRunoffMap);
  if Length(FRunoffMap) = 0 then
  begin
    SetLength(FRunoffMap, FModel.ModflowStressPeriods.Count);
  end;
  SetLength(FRunoffMap[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
  ReadVariable2DIntArray(FRunoffMap[FCurrentStressPeriod]);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadRunoffMapConstant;
var
  Value: Integer;
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Readln(FImporter.FFile, Value);
  Assert(ID = KRunoffMap);
  if Length(FRunoffMap_Const) = 0 then
  begin
    SetLength(FRunoffMap_Const, FModel.ModflowStressPeriods.Count);
    InitializeConstIntArray(FRunoffMap_Const);
  end;
  FRunoffMap_Const[FCurrentStressPeriod].IsConstant := True;
  FRunoffMap_Const[FCurrentStressPeriod].IntegerValue := Value;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_9;
begin
  Read(FImporter.FFile, FCurrentStructure.ISTRTAB_Gate);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_8;
begin
  Read(FImporter.FFile, FCurrentStructure.STRMAX);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_7;
begin
  Read(FImporter.FFile, FCurrentStructure.STRCRITC);
  Read(FImporter.FFile, FCurrentStructure.STRRT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_6;
begin
  Read(FImporter.FFile, FCurrentStructure.STRCRIT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_5;
begin
  Read(FImporter.FFile, FCurrentStructure.ISTRTAB_Control);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_4;
var
  CSTROLO: string;
begin
  Readln(FImporter.FFile, CSTROLO);
  FCurrentStructure.CSTROLO := Trim(UpperCase(CSTROLO));
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_3;
begin
  Read(FImporter.FFile, FCurrentStructure.ISTROQCON);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_2;
begin
  Read(FImporter.FFile, FCurrentStructure.ISTRORCH);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13B_1;
var
  CSTROTYP: string;
begin
  Readln(FImporter.FFile, CSTROTYP);
  FCurrentStructure.CSTROTYP := Trim(UpperCase(CSTROTYP));
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13C;
var
  TableItem: TSwrStructureTableItem;
begin
  Inc(FCurrentStructure.FCurrentPointIndex);
  TableItem := FCurrentStructure.FTable[FCurrentStructure.FCurrentPointIndex];
  Read(FImporter.FFile, TableItem.STRELEV);
  Read(FImporter.FFile, TableItem.STRQ);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_16;
begin
  Read(FImporter.FFile, FCurrentStructure.ISFRRCH);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_15;
begin
  Read(FImporter.FFile, FCurrentStructure.ISFRSEG);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_14;
begin
  Read(FImporter.FFile, FCurrentStructure.STRVAL);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_13;
begin
  Read(FImporter.FFile, FCurrentStructure.ISTRTAB_Discharge);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_12;
begin
  Read(FImporter.FFile, FCurrentStructure.STRLEN);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_11;
begin
  Read(FImporter.FFile, FCurrentStructure.STRCD);
  Read(FImporter.FFile, FCurrentStructure.STRCD2);
  Read(FImporter.FFile, FCurrentStructure.STRCD3);
  Read(FImporter.FFile, FCurrentStructure.STRINV);
  Read(FImporter.FFile, FCurrentStructure.STRWID);
  Read(FImporter.FFile, FCurrentStructure.STRVAL);
  Read(FImporter.FFile, FCurrentStructure.ISTRDIR);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_10;
begin
  Read(FImporter.FFile, FCurrentStructure.STRCD);
  Read(FImporter.FFile, FCurrentStructure.STRCD3);
  Read(FImporter.FFile, FCurrentStructure.STRINV);
  Read(FImporter.FFile, FCurrentStructure.STRWID);
  Read(FImporter.FFile, FCurrentStructure.STRVAL);
  Read(FImporter.FFile, FCurrentStructure.ISTRDIR);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_9;
begin
  Read(FImporter.FFile, FCurrentStructure.STRLEN);
  Read(FImporter.FFile, FCurrentStructure.STRMAN);
  Read(FImporter.FFile, FCurrentStructure.ISTRDIR);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_8;
begin
  Read(FImporter.FFile, FCurrentStructure.STRWID2);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_7;
begin
  Read(FImporter.FFile, FCurrentStructure.STRCD);
  Read(FImporter.FFile, FCurrentStructure.STRCD2);
  Read(FImporter.FFile, FCurrentStructure.STRINV);
  Read(FImporter.FFile, FCurrentStructure.STRINV2);
  Read(FImporter.FFile, FCurrentStructure.STRWID);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_6;
begin
  Read(FImporter.FFile, FCurrentStructure.NSTRPTS);
  Readln(FImporter.FFile);
  FCurrentStructure.FTable.ArrayLength := FCurrentStructure.NSTRPTS;
  FCurrentStructure.FCurrentPointIndex := -1;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_5;
begin
  Read(FImporter.FFile, FCurrentStructure.STRVAL);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_4;
begin
  Read(FImporter.FFile, FCurrentStructure.STRLEN2);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_3;
begin
  Read(FImporter.FFile, FCurrentStructure.STRLEN);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_2;
begin
  Read(FImporter.FFile, FCurrentStructure.STRINV);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet13A_1;
var
  ISTRRCH: Integer;
  StructureList: TStructureStressPeriodArray;
begin
  StructureList := FStructures.Last;
  if (StructureList = nil) or (StructureList.FStartingStressPeriod <> FCurrentStressPeriod) then
  begin
    FStructures.ArrayLength := FStructures.ArrayLength + 1;
    StructureList := FStructures.Last;
    StructureList.FStartingStressPeriod := FCurrentStressPeriod;
  end;
  FCurrentStructures := StructureList;
  FCurrentStructures.ArrayLength := FCurrentStructures.ArrayLength + 1;
  FCurrentStructure := FCurrentStructures.Last;
  Read(FImporter.FFile, ISTRRCH);
  FCurrentStructure.ISTRRCH := ISTRRCH - 1;
  Read(FImporter.FFile, FCurrentStructure.ISTRNUM);
  Read(FImporter.FFile, FCurrentStructure.ISTRCONN);
  Read(FImporter.FFile, FCurrentStructure.ISTRTYPE);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet12;
var
  NSTRUCT: Integer;
  ISMODRCH: Integer;
  StructureCountItem: TSwrReachStructureCount;
begin
  Read(FImporter.FFile, ISMODRCH);
  FCurrentReach := FReachArray[ISMODRCH - 1];
  FCurrentReach.FReachStructureCounts.ArrayLength := FCurrentReach.FReachStructureCounts.ArrayLength + 1;
  Read(FImporter.FFile, NSTRUCT);
  StructureCountItem := FCurrentReach.FReachStructureCounts.Last;
  StructureCountItem.StartingStressPeriodIndex := FCurrentStressPeriod;
  StructureCountItem.NSTRUCT := NSTRUCT;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11C;
var
  TableItem: TSwrGeomTableItem;
begin
  Inc(FCurrentGeom.FCurrentIndex);
  if FCurrentGeom.FTable.ArrayLength = 0 then
  begin
    FCurrentGeom.FTable.ArrayLength := FCurrentGeom.NGEOPTS;
  end;
  TableItem := FCurrentGeom.FTable[FCurrentGeom.FCurrentIndex];
  Read(FImporter.FFile, TableItem.ELEV);
  Read(FImporter.FFile, TableItem.VOL);
  Read(FImporter.FFile, TableItem.WETPER);
  Read(FImporter.FFile, TableItem.SAREA);
  Read(FImporter.FFile, TableItem.XAREA);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11B;
var
  CrossSectionPoint: TSwrGeomCrossSectionPoint;
begin
  Inc(FCurrentGeom.FCurrentIndex);
  if FCurrentGeom.FCrossSection.ArrayLength = 0 then
  begin
    FCurrentGeom.FCrossSection.ArrayLength := FCurrentGeom.NGEOPTS;
  end;
  CrossSectionPoint := FCurrentGeom.FCrossSection[FCurrentGeom.FCurrentIndex];
  Read(FImporter.FFile, CrossSectionPoint.XB);
  Read(FImporter.FFile, CrossSectionPoint.ELEVB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_GETEXTD;
begin
  Read(FImporter.FFile, FCurrentGeom.GETEXTD);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_GCNDLN;
begin
  Read(FImporter.FFile, FCurrentGeom.GCNDLN);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_GLK;
begin
  Read(FImporter.FFile, FCurrentGeom.GLK);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_GCND;
begin
  Read(FImporter.FFile, FCurrentGeom.GCND);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_GSSLOPE;
begin
  Read(FImporter.FFile, FCurrentGeom.GSSLOPE);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_GWIDTH;
begin
  Read(FImporter.FFile, FCurrentGeom.GWIDTH);
  Read(FImporter.FFile, FCurrentGeom.GBELEV);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet11A_NGEOPTS;
begin
  Read(FImporter.FFile, FCurrentGeom.NGEOPTS);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FCurrentGeom.FCurrentIndex := -1;
end;

procedure TSwrImporter.ReadDataSet11A_IGEONUM;
var
  GeomStressPeriods: TSwrGeomStressPeriodArray;
begin
  GeomStressPeriods := FGeomArray.Last;
  if (GeomStressPeriods = nil) or (GeomStressPeriods.FStartingStressPeriod <> FCurrentStressPeriod) then
  begin
    FGeomArray.ArrayLength := FGeomArray.ArrayLength + 1;
    GeomStressPeriods := FGeomArray.Last;
    GeomStressPeriods.FStartingStressPeriod := FCurrentStressPeriod;
  end;
  FCurrentGeomArrays := GeomStressPeriods;
  FCurrentGeomArrays.ArrayLength := FCurrentGeomArrays.ArrayLength + 1;
  FCurrentGeom := FCurrentGeomArrays.Last;
  Read(FImporter.FFile, FCurrentGeom.IGEONUM);
  Read(FImporter.FFile, FCurrentGeom.IGEOTYPE);
  Read(FImporter.FFile, FCurrentGeom.IGCNDOP);
  Read(FImporter.FFile, FCurrentGeom.GMANNING);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet10;
var
  GeomLink: TSwrReachGeomLink;
  IGMODRCH: Integer;
  GZSHIFT: Double;
  IGEONUMR: Integer;
begin
  Read(FImporter.FFile, IGMODRCH);
  FCurrentReach := FReachArray[IGMODRCH - 1];
  FCurrentReach.FReachGeom_Array.ArrayLength := FCurrentReach.FReachGeom_Array.ArrayLength + 1;
  Read(FImporter.FFile, IGEONUMR);
  Read(FImporter.FFile, GZSHIFT);
  GeomLink := FCurrentReach.FReachGeom_Array.Last;
  GeomLink.StartingStressPeriodIndex := FCurrentStressPeriod;
  GeomLink.IGEONUMR := IGEONUMR;
  GeomLink.GZSHIFT := GZSHIFT;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet14A;
var
  STAGE: Double;
  IRCHSTG: Integer;
  SwrStage: TSwrStage;
begin
  Read(FImporter.FFile, IRCHSTG);
  FCurrentReach := FReachArray[IRCHSTG - 1];
  FCurrentReach.FStage.ArrayLength := FCurrentReach.FStage.ArrayLength + 1;
  Read(FImporter.FFile, STAGE);
  SwrStage := FCurrentReach.FStage.Last;
  SwrStage.StartingStressPeriodIndex := FCurrentStressPeriod;
  SwrStage.STAGE := STAGE;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet9A;
var
  LatFlow: TSwrLateralFlow;
  ILINRCH: Integer;
  QLATFLOW: Double;
begin
  Read(FImporter.FFile, ILINRCH);
  FCurrentReach := FReachArray[ILINRCH - 1];
  FCurrentReach.FLateralFlow.ArrayLength := FCurrentReach.FLateralFlow.ArrayLength + 1;
  Read(FImporter.FFile, QLATFLOW);
  LatFlow := FCurrentReach.FLateralFlow.Last;
  LatFlow.StartingStressPeriodIndex := FCurrentStressPeriod;
  LatFlow.QLATFLOW := QLATFLOW;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadConstantRealArrays;
var
  ID: string;
  Value: double;
  ConstArray: TRealConstantRecordArray;
begin
  ConstArray:= nil;
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  Readln(FImporter.FFile, Value);
  if ID = KRain then
  begin
    if Length(FRain_Const) = 0 then
    begin
      SetLength(FRain_Const, FModel.ModflowStressPeriods.Count);
      InitializeConstArray(FRain_Const);
    end;
    ConstArray := FRain_Const;
  end
  else if ID = KEvap then
  begin
    if Length(FEvap_Const) = 0 then
    begin
      SetLength(FEvap_Const, FModel.ModflowStressPeriods.Count);
      InitializeConstArray(FEvap_Const);
    end;
    ConstArray := FEvap_Const;
  end
  else if ID = KLatFlow then
  begin
    if Length(FLatFlow_Const) = 0 then
    begin
      SetLength(FLatFlow_Const, FModel.ModflowStressPeriods.Count);
      InitializeConstArray(FLatFlow_Const);
    end;
    ConstArray := FLatFlow_Const;
  end
  else if ID = KStage then
  begin
    if Length(FStage_Const) = 0 then
    begin
      SetLength(FStage_Const, FModel.ModflowStressPeriods.Count);
      InitializeConstArray(FStage_Const);
    end;
    ConstArray := FStage_Const;
  end
  else if ID = KRunoffMult then
  begin
    if Length(FRunoffMultiplier_Const) = 0 then
    begin
      SetLength(FRunoffMultiplier_Const, FModel.ModflowStressPeriods.Count);
      InitializeConstArray(FRunoffMultiplier_Const);
    end;
    ConstArray := FRunoffMultiplier_Const;
  end
  else if ID = KRunoffValue then
  begin
    if Length(FRunoffValue_Const) = 0 then
    begin
      SetLength(FRunoffValue_Const, FModel.ModflowStressPeriods.Count);
      InitializeConstArray(FRunoffValue_Const);
    end;
    ConstArray := FRunoffValue_Const;
  end
  else
  begin
    Assert(False);
  end;
  ConstArray[FCurrentStressPeriod].IsConstant := True;
  ConstArray[FCurrentStressPeriod].RealValue := Value;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadVariableRealArrays;
var
  ID: string;
begin
  ReadLn(FImporter.FFile, ID);
  ID := Trim(ID);
  if ID = KRain then
  begin
    if Length(FRain) = 0 then
    begin
      SetLength(FRain, FModel.ModflowStressPeriods.Count);
    end;
    SetLength(FRain[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(FRain[FCurrentStressPeriod], ID);
  end
  else if ID = KEvap then
  begin
    if Length(FEvap) = 0 then
    begin
      SetLength(FEvap, FModel.ModflowStressPeriods.Count);
    end;
    SetLength(FEvap[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(FEvap[FCurrentStressPeriod], ID);
  end
  else if ID = KLatFlow then
  begin
    if Length(FLatFlow) = 0 then
    begin
      SetLength(FLatFlow, FModel.ModflowStressPeriods.Count);
    end;
    SetLength(FLatFlow[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(FLatFlow[FCurrentStressPeriod], ID);
  end
  else if ID = KStage then
  begin
    if Length(FStage) = 0 then
    begin
      SetLength(FStage, FModel.ModflowStressPeriods.Count);
    end;
    SetLength(FStage[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(FStage[FCurrentStressPeriod], ID);
  end
  else if ID = KRunoffMult then
  begin
    if Length(FRunoffMultiplier) = 0 then
    begin
      SetLength(FRunoffMultiplier, FModel.ModflowStressPeriods.Count);
    end;
    SetLength(FRunoffMultiplier[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(FRunoffMultiplier[FCurrentStressPeriod], ID);
  end
  else if ID = KRunoffValue then
  begin
    if Length(FRunoffValue) = 0 then
    begin
      SetLength(FRunoffValue, FModel.ModflowStressPeriods.Count);
    end;
    SetLength(FRunoffValue[FCurrentStressPeriod], FGrid.RowCount, FGrid.ColumnCount);
    Read2DRealArray(FRunoffValue[FCurrentStressPeriod], ID);
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TSwrImporter.ReadDataSet8A;
var
  IEVPRCH: Integer;
  EVAP: Double;
  SwrEvap: TSwrEvap;
begin
  Read(FImporter.FFile, IEVPRCH);
  FCurrentReach := FReachArray[IEVPRCH - 1];
  FCurrentReach.FEvap.ArrayLength := FCurrentReach.FEvap.ArrayLength + 1;
  Read(FImporter.FFile, EVAP);
  SwrEvap := FCurrentReach.FEvap.Last;
  SwrEvap.StartingStressPeriodIndex := FCurrentStressPeriod;
  SwrEvap.EVAP := EVAP;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet7A;
var
  SwrRain: TSwrRain;
  RAIN: Double;
  IRAIRCH: Integer;
begin
  Read(FImporter.FFile, IRAIRCH);
  FCurrentReach := FReachArray[IRAIRCH - 1];
  FCurrentReach.FRain.ArrayLength := FCurrentReach.FRain.ArrayLength + 1;
  Read(FImporter.FFile, RAIN);
  SwrRain := FCurrentReach.FRain.Last;
  SwrRain.StartingStressPeriodIndex := FCurrentStressPeriod;
  SwrRain.RAIN := RAIN;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet6;
var
  ISWRBND: Integer;
  IBNDRCH: Integer;
  SWRBND: TSwrISWRBND;
begin
  Read(FImporter.FFile, IBNDRCH);
  FCurrentReach := FReachArray[IBNDRCH - 1];
  FCurrentReach.F_ISWRBND_Array.ArrayLength := FCurrentReach.F_ISWRBND_Array.ArrayLength + 1;
  Read(FImporter.FFile, ISWRBND);
  SWRBND := FCurrentReach.F_ISWRBND_Array.Last;
  SWRBND.StartingStressPeriodIndex := FCurrentStressPeriod;
  SWRBND.ISWRBND := ISWRBND;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

{$HINTS OFF}
procedure TSwrImporter.ReadDataSet5Changed;
var
  ITMP: Integer;
  IRDGEO: Integer;
  IPTFLG: Integer;
  IRDSTG: Integer;
  IRDLIN: Integer;
  IRDSTR: Integer;
  IRDEVP: Integer;
  IRDBND: Integer;
  IRDRAI: Integer;
begin
  InitializeStructureChanged;
  Inc(FCurrentStressPeriod);
  Read(FImporter.FFile, ITMP);
  Read(FImporter.FFile, IRDBND);
  Read(FImporter.FFile, IRDRAI);
  Read(FImporter.FFile, IRDEVP);
  Read(FImporter.FFile, IRDLIN);
  Read(FImporter.FFile, IRDGEO);
  Read(FImporter.FFile, IRDSTR);
  FStructureChanged[FCurrentStressPeriod] := IRDSTR > 0;
  Read(FImporter.FFile, IRDSTG);
  Read(FImporter.FFile, IPTFLG);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  Assert(ITMP > 0);
end;
{$HINTS ON}

procedure TSwrImporter.ReadDataSet5_NoChange;
var
  ITMP: Integer;
begin
  InitializeStructureChanged;
  Read(FImporter.FFile, ITMP);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  Inc(FCurrentStressPeriod);
  Assert(ITMP <= 0);
end;

procedure TSwrImporter.ReadDataSet4F_IOBSLOC2_IOBSLAY;
var
  IOBSLOC2_IOBSLAY: Integer;
begin
  Readln(FImporter.FFile, IOBSLOC2_IOBSLAY);
  if (FCurrentObs.COBSTYPE = 'FLOW') or (FCurrentObs.COBSTYPE = 'STRUCTURE') then
  begin
    FCurrentObs.IOBSLOC2 := IOBSLOC2_IOBSLAY;
  end
  else if FCurrentObs.COBSTYPE = 'BASEFLOW' then
  begin
    FCurrentObs.IOBSLAY := IOBSLOC2_IOBSLAY;
  end
  else
  begin
    Assert(False);
  end;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4F_IOBSLOC;
var
  IOBSLOC: integer;
begin
  Readln(FImporter.FFile, IOBSLOC);
  FCurrentObs.IOBSLOC := IOBSLOC;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4F_COBSTYPE;
var
  COBSTYPE: string;
begin
  Readln(FImporter.FFile, COBSTYPE);
  FCurrentObs.COBSTYPE := upperCase(Trim(COBSTYPE));
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4F_COBSNAME;
begin
  Inc(FCurrentObsIndex);
  FCurrentObs := FObsArray[FCurrentObsIndex];
  Readln(FImporter.FFile, FCurrentObs.COBSNAME);
  FCurrentObs.COBSNAME := Trim(FCurrentObs.COBSNAME);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4E;
var
  NOBS: Integer;
begin
  Read(FImporter.FFile, NOBS);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FObsArray.ArrayLength := NOBS;
  FCurrentObsIndex := -1;
end;

procedure TSwrImporter.ReadDataSet4D_ITABRCH;
var
  ReachIndex: Integer;
  ITABRCH: Integer;
  ntabrch: Integer;
begin
  Readln(FImporter.FFile, ntabrch);
  SetLength(FCurrentTabFile.ITABRCH, ntabrch);
  for ReachIndex := 0 to ntabrch - 1 do
  begin
    Readln(FImporter.FFile, ITABRCH);
    FCurrentTabFile.ITABRCH[ReachIndex] := ITABRCH-1;
  end;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4D_CTABRCH;
var
  CTABRCH: string;
begin
  Readln(FImporter.FFile, CTABRCH);
  FCurrentTabFile.CTABRCH := Trim(UpperCase(CTABRCH));
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4D_CINTP;
var
  CINTP: string;
begin
  Readln(FImporter.FFile, CINTP);
  FCurrentTabFile.CINTP := Trim(UpperCase(CINTP));
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4D_ITABUNIT;
begin
  Read(FImporter.FFile, FCurrentTabFile.ITABUNIT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4D_CTABTYPE;
var
  CTABTYPE: string;
begin
  Readln(FImporter.FFile, CTABTYPE);
  FCurrentTabFile.CTABTYPE := Trim(UpperCase(CTABTYPE));
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4D_ITAB;
begin
  Inc(FCurrentTabIndex);
  FCurrentTabFile := FTabFiles[FCurrentTabIndex];
  Read(FImporter.FFile, FCurrentTabFile.ITAB);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4C;
var
  NTABS: Integer;
begin
  Read(FImporter.FFile, NTABS);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FTabFiles.ArrayLength := NTABS;
  FCurrentTabIndex := -1;
end;

procedure TSwrImporter.ReadDataSet4B_ICONN;
var
  ICONN: Integer;
begin
  Read(FImporter.FFile, ICONN);
  Inc(FCurrentConnection);
  Readln(FImporter.FFile);
  FCurrentReach.ICONN[FCurrentConnection] := ICONN - 1;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4B_NCONN;
var
  NCONN: Integer;
  IRCH4B: Integer;
begin
  Read(FImporter.FFile, IRCH4B);
  Read(FImporter.FFile, NCONN);
  FCurrentReach := FReachArray[IRCH4B - 1];
  SetLength(FCurrentReach.ICONN, NCONN);
  FCurrentConnection := -1;
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet4A;
var
  IRCH4A: Integer;
begin
  Read(FImporter.FFile, IRCH4A);
  FCurrentReach := FReachArray[IRCH4A - 1];
  Read(FImporter.FFile, FCurrentReach.IROUTETYPE);
  Read(FImporter.FFile, FCurrentReach.IRGNUM);
  Read(FImporter.FFile, FCurrentReach.Layer);
  Read(FImporter.FFile, FCurrentReach.Row);
  Read(FImporter.FFile, FCurrentReach.Column);
  Read(FImporter.FFile, FCurrentReach.RLEN);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ImportReaches;
var
  ReachIndex: Integer;
  ReachItem: TSwrReach;
  LocationList: TList;
  AScreenObject: TScreenObject;
  AReachBoundary: TSwrReachBoundary;
  VertexValue: TPointValuesItem;
  VVItem: TPointValue;
  ConnectionIndex: Integer;
  AConnection: TSwrConnectionItem;
  IntList: TGenericIntegerList;
  StressPeriodIndex: Integer;
  ActiveIndex: Integer;
  StageIndex: Integer;
  GeomIndex: Integer;
  ActiveItem: TSwrISWRBND;
  StressPeriod: Integer;
  StartingTime: Double;
  EndingTime: Double;
  ReachValues: TSwrReachCollection;
  TransientReachItem: TSwrTransientReachItem;
  StageItem: TSwrStage;
  GeomLink: TSwrReachGeomLink;
  EndStressPeriod: Integer;
  GeomItem: TReachGeometryItem;
  RainItem: TSwrRain;
  NextRainItem: TSwrRain;
  RainBoundary: TSwrRainBoundary;
  RainCollection: TSwrRainListCollection;
  SwrRainItem: TSwrRainItem;
  EvapBoundary: TSwrEvapBoundary;
  EvapCollection: TSwrEvapListCollection;
  EvapItem: TSwrEvap;
  NextEvapItem: TSwrEvap;
  SwrEvapItem: TSwrEvapItem;
  LatInflow: TSwrLatInflowBoundary;
  LatInflowCollection: TSwrLatInflowListCollection;
  LatInflowItem: TSwrLateralFlow;
  NextLatInflowItem: TSwrLateralFlow;
  SwrLatInflowItem: TSwrLatInflowItem;
  procedure AddStartingStressPeriods(SwrObjectArray: TCustomSwrObjectArray);
  var
    StressPeriodIndex: integer;
  begin
    for StressPeriodIndex := 0 to SwrObjectArray.ArrayLength - 1 do
    begin
      IntList.Add(SwrObjectArray[StressPeriodIndex].StartingStressPeriodIndex);
    end;
  end;
  procedure UpdateIndex(var AnIndex: integer;
    SwrObjectArray: TCustomSwrObjectArray);
  var
    TestIndex: Integer;
    SwrItem: TCustomSwrArrayMember;
  begin
    if AnIndex < SwrObjectArray.ArrayLength then
    begin
      for TestIndex := AnIndex to SwrObjectArray.ArrayLength - 1 do
      begin
        SwrItem := SwrObjectArray[TestIndex];
        if SwrItem.StartingStressPeriodIndex = StressPeriod then
        begin
          AnIndex := TestIndex;
          break;
        end
        else if SwrItem.StartingStressPeriodIndex > StressPeriod then
        begin
          AnIndex := TestIndex-1;
          break;
        end;
      end;
    end
  end;
  function FindGeom(IGEONUMR: integer): TReachGeometryItem;
  var
    GeomArrayStart: Integer;
    GeomArrayIndex: Integer;
    GeomArray: TSwrGeomStressPeriodArray;
    GeomIndex: integer;
    GeomItem: TSwrGeomItem;
  begin
    result := nil;
    GeomArrayStart := FGeomArray.FindByStressPeriod(StressPeriod);
    for GeomArrayIndex := GeomArrayStart downto 0 do
    begin
      GeomArray := FGeomArray[GeomArrayIndex];
      for GeomIndex := 0 to GeomArray.ArrayLength - 1 do
      begin
        GeomItem := GeomArray[GeomIndex];
        if GeomItem.IGEONUM = IGEONUMR then
        begin
          result := GeomItem.FGeomItem;
          Exit;
        end;
      end;
    end;
  end;
begin
  FScreenObjectIndex := 0;
  LocationList := TList.Create;
  IntList := TGenericIntegerList.Create;
  try
    for ReachIndex := 0 to FReachArray.ArrayLength - 1 do
    begin
      ReachItem := FReachArray[ReachIndex];
      LocationList.Clear;
      LocationList.Add(ReachItem);
      AScreenObject := CreateScreenObject(LocationList, FScreenObjectIndex,
        -1, -1, otPoint);

      if AScreenObject <> nil then
      begin
        VertexValue := AScreenObject.PointPositionValues.Add;
        VertexValue.Position := 0;
        VVItem := VertexValue.Values.Add;
        VVItem.Name := 'Reach';
        VVItem.Value := ReachIndex + 1;

        AScreenObject.CreateSwrReachesBoundary;
        AReachBoundary := AScreenObject.ModflowSwrReaches;
        AReachBoundary.RouteType := TSwrRouteType(ReachItem.IROUTETYPE -1);
        AReachBoundary.Grouped := True;
        AReachBoundary.GroupNumber := ReachItem.IRGNUM;
        AReachBoundary.ReachLengthFormula := FortranFloatToStr(ReachItem.RLEN);
        AReachBoundary.MultiLayer := ReachItem.Layer < 1;

        AReachBoundary.Connections.Capacity := Length(ReachItem.ICONN);
        for ConnectionIndex := 0 to Length(ReachItem.ICONN) - 1 do
        begin
          AConnection := AReachBoundary.Connections.Add;
          AConnection.Method := scmSpecifiedReach;
          AConnection.Reach := ReachItem.ICONN[ConnectionIndex]+1;
        end;

        AddStartingStressPeriods(ReachItem.F_ISWRBND_Array);
        AddStartingStressPeriods(ReachItem.FStage);
        AddStartingStressPeriods(ReachItem.FReachGeom_Array);

        IntList.Sort;
        for StressPeriodIndex := IntList.Count - 1 downto 1 do
        begin
          if IntList[StressPeriodIndex] = IntList[StressPeriodIndex-1] then
          begin
            IntList.Delete(StressPeriodIndex);
          end;
        end;

        ActiveIndex := 0;
        StageIndex := 0;
        GeomIndex := 0;

        ReachValues := AReachBoundary.ReachValues;
        ReachValues.Capacity := IntList.Count;
        for StressPeriodIndex := 0 to IntList.Count - 1 do
        begin
          StressPeriod := IntList[StressPeriodIndex];
          UpdateIndex(ActiveIndex, ReachItem.F_ISWRBND_Array);
          UpdateIndex(StageIndex, ReachItem.FStage);
          UpdateIndex(GeomIndex, ReachItem.FReachGeom_Array);

          StartingTime := FModel.ModflowStressPeriods[StressPeriod].StartTime;
          if StressPeriodIndex+1 < IntList.Count then
          begin
            EndStressPeriod := IntList[StressPeriodIndex+1];
            EndingTime := FModel.ModflowStressPeriods[EndStressPeriod].StartTime;
          end
          else
          begin
            EndingTime := FModel.ModflowStressPeriods.Last.EndTime;
          end;

          TransientReachItem := ReachValues.Add;
          TransientReachItem.StartTime := StartingTime;
          TransientReachItem.EndTime := EndingTime;

          if ActiveIndex < ReachItem.F_ISWRBND_Array.ArrayLength then
          begin
            ActiveItem := ReachItem.F_ISWRBND_Array[ActiveIndex];
            TransientReachItem.ReachType := TSwrReachType(1-ActiveItem.ISWRBND)
          end
          else
          begin
            TransientReachItem.ReachType := srtActive;
          end;

          if StageIndex < ReachItem.FStage.ArrayLength then
          begin
            FSwrPackage.StageSpecification := smObject;
            StageItem := ReachItem.FStage[StageIndex];
            TransientReachItem.Stage := FortranFloatToStr(StageItem.STAGE);
          end;

          Assert(GeomIndex < ReachItem.FReachGeom_Array.ArrayLength);
          GeomLink := ReachItem.FReachGeom_Array[GeomIndex];
          GeomItem := FindGeom(GeomLink.IGEONUMR);
          TransientReachItem.GeometryName := GeomItem.Name;
          TransientReachItem.VerticalOffset := FortranFloatToStr(GeomLink.GZSHIFT);
        end;

        if ReachItem.FRain.ArrayLength > 0 then
        begin
          FSwrPackage.RainSpecification := smObject;

          AScreenObject.CreateSwrRainBoundary;
          RainBoundary := AScreenObject.ModflowSwrRain;
          RainCollection := RainBoundary.Values as TSwrRainListCollection;
          RainCollection.Capacity := ReachItem.FRain.ArrayLength;
          for StressPeriodIndex := 0 to ReachItem.FRain.ArrayLength - 1 do
          begin
            RainItem := ReachItem.FRain[StressPeriodIndex];
            StartingTime := FModel.ModflowStressPeriods[
              RainItem.StartingStressPeriodIndex].StartTime;
            if StressPeriodIndex+1 < ReachItem.FRain.ArrayLength then
            begin
              NextRainItem := ReachItem.FRain[StressPeriodIndex+1];
              EndingTime := FModel.ModflowStressPeriods[
                NextRainItem.StartingStressPeriodIndex].StartTime;
            end
            else
            begin
              EndingTime := FModel.ModflowStressPeriods.Last.EndTime;
            end;

            SwrRainItem := RainCollection.Add as TSwrRainItem;
            SwrRainItem.StartTime := StartingTime;
            SwrRainItem.EndTime := EndingTime;
            SwrRainItem.SwrValue := FortranFloatToStr(RainItem.RAIN);
          end;
        end;

        if ReachItem.FEvap.ArrayLength > 0 then
        begin
          FSwrPackage.EvapSpecification := smObject;

          AScreenObject.CreateSwrEvapBoundary;
          EvapBoundary := AScreenObject.ModflowSwrEvap;
          EvapCollection := EvapBoundary.Values as TSwrEvapListCollection;
          EvapCollection.Capacity := ReachItem.FEvap.ArrayLength;
          for StressPeriodIndex := 0 to ReachItem.FEvap.ArrayLength - 1 do
          begin
            EvapItem := ReachItem.FEvap[StressPeriodIndex];
            StartingTime := FModel.ModflowStressPeriods[
              EvapItem.StartingStressPeriodIndex].StartTime;
            if StressPeriodIndex+1 < ReachItem.FEvap.ArrayLength then
            begin
              NextEvapItem := ReachItem.FEvap[StressPeriodIndex+1];
              EndingTime := FModel.ModflowStressPeriods[
                NextEvapItem.StartingStressPeriodIndex].StartTime;
            end
            else
            begin
              EndingTime := FModel.ModflowStressPeriods.Last.EndTime;
            end;

            SwrEvapItem := EvapCollection.Add as TSwrEvapItem;
            SwrEvapItem.StartTime := StartingTime;
            SwrEvapItem.EndTime := EndingTime;
            SwrEvapItem.SwrValue := FortranFloatToStr(EvapItem.EVAP);
          end;
        end;

        if ReachItem.FLateralFlow.ArrayLength > 0 then
        begin
          FSwrPackage.LateralInflowSpecification := smObject;

          AScreenObject.CreateSwrLatInflowBoundary;
          LatInflow := AScreenObject.ModflowSwrLatInflow;
          LatInflowCollection := LatInflow.Values as TSwrLatInflowListCollection;
          LatInflowCollection.Capacity := ReachItem.FLateralFlow.ArrayLength;
          for StressPeriodIndex := 0 to ReachItem.FLateralFlow.ArrayLength - 1 do
          begin
            LatInflowItem := ReachItem.FLateralFlow[StressPeriodIndex];
            StartingTime := FModel.ModflowStressPeriods[
              LatInflowItem.StartingStressPeriodIndex].StartTime;
            if StressPeriodIndex+1 < ReachItem.FLateralFlow.ArrayLength then
            begin
              NextLatInflowItem := ReachItem.FLateralFlow[StressPeriodIndex+1];
              EndingTime := FModel.ModflowStressPeriods[
                NextLatInflowItem.StartingStressPeriodIndex].StartTime;
            end
            else
            begin
              EndingTime := FModel.ModflowStressPeriods.Last.EndTime;
            end;

            SwrLatInflowItem := LatInflowCollection.Add as TSwrLatInflowItem;
            SwrLatInflowItem.StartTime := StartingTime;
            SwrLatInflowItem.EndTime := EndingTime;
            SwrLatInflowItem.SwrValue := FortranFloatToStr(LatInflowItem.QLATFLOW);
          end;
        end;
      end;
    end;
  finally
    IntList.Free;
    LocationList.Free;
  end
end;

procedure TSwrImporter.HandlePackage;
var
  AScreenObject: TScreenObject;
begin
  FSwrPackage := FModel.ModflowPackages.SwrPackage;
  FSwrPackage.IsSelected := True;
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  if FModel.ModelSelection = msModflow then
  begin
    FModel.ModelSelection := msModflowNWT;
  end;

  SetPackageData;
  ImportReachGeom;
  ImportReaches;

  AScreenObject := nil;
  ImportRainArray(AScreenObject);
  ImportEvapArray(AScreenObject);
  ImportLateralFlowArray(AScreenObject);
  ImportStageArray(AScreenObject);
  ImportDirectRunoffArrays(AScreenObject);

  ImportTabFiles;
  ImportStructures;
  ImportObservations;

  frmGoPhast.EnableSwrActions;

//  FModel.DataArrayManager.CreateInitialDataSets;
//  FModel.UpdateOnPostInitialize;
//  for ChildIndex := 0 to FModel.ChildModels.Count - 1 do
//  begin
//    ChildModel := FModel.ChildModels[ChildIndex].ChildModel;
//    ChildModel.DataArrayManager.CreateInitialDataSets;
//    ChildModel.UpdateOnPostInitialize;
//  end;

end;

procedure TSwrImporter.ReadDataSet3_PTOLR;
begin
  Read(FImporter.FFile, PTOLR);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet3_IBTPRT;
begin
  Read(FImporter.FFile, IBTPRT);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet3_NLEVELS;
begin
  Read(FImporter.FFile, NLEVELS);
  Read(FImporter.FFile, DROPTOL);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet3IPC;
begin
  Read(FImporter.FFile, IPC);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet3Required;
begin
  Read(FImporter.FFile, ISOLVER);
  Read(FImporter.FFile, NOUTER);
  Read(FImporter.FFile, NINNER);
  Read(FImporter.FFile, IBT);
  Read(FImporter.FFile, TOLS);
  Read(FImporter.FFile, TOLR);
  Read(FImporter.FFile, TOLA);
  Read(FImporter.FFile, DAMPSS);
  Read(FImporter.FFile, DAMPTR);
  Read(FImporter.FFile, IPRSWR);
  Read(FImporter.FFile, MUTSWR);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet2Optional;
begin
  Read(FImporter.FFile, DMAXRAI);
  Read(FImporter.FFile, DMAXSTG);
  Read(FImporter.FFile, DMAXINF);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet2Required;
begin
  Read(FImporter.FFile, DLENCONV);
  Read(FImporter.FFile, TIMECONV);
  Read(FImporter.FFile, RTINI);
  Read(FImporter.FFile, RTMIN);
  Read(FImporter.FFile, RTMAX);
  Read(FImporter.FFile, RTPRN);
  Read(FImporter.FFile, RTMULT);
  Read(FImporter.FFile, NTMULT);
  Read(FImporter.FFile, DMINGRAD);
  Read(FImporter.FFile, DMNDEPTH);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet1B;
var
  AnOption: string;
begin
  Readln(FImporter.FFile, AnOption);
  AnOption := UpperCase(Trim(AnOption));
  if AnOption = 'PRINT_SWR_TO_SCREEN' then
  begin
    PRINT_SWR_TO_SCREEN := True;
  end
  else if AnOption = 'SAVE_SWRDT' then
  begin
    SAVE_SWRDT := True;
  end
  else if AnOption = 'SAVE_CONVERGENCE_HISTORY' then
  begin
    SAVE_CONVERGENCE_HISTORY := True;
  end
  else if AnOption = 'SAVE_RIVER_PACKAGE' then
  begin
    SAVE_RIVER_PACKAGE := True;
    SAVE_RIVER_PACKAGE_ALL := False;
  end
  else if AnOption = 'SAVE_RIVER_PACKAGE_ALL' then
  begin
    SAVE_RIVER_PACKAGE_ALL := True;
    SAVE_RIVER_PACKAGE := False;
  end
  else if AnOption = 'SAVE_AVERAGE_RESULTS' then
  begin
    SAVE_AVERAGE_RESULTS := True;
  end
  else if AnOption = 'USE_TABFILES' then
  begin
    USE_TABFILES := True;
  end
  else if AnOption = 'USE_NONCONVERGENCE_CONTINUE' then
  begin
    USE_NONCONVERGENCE_CONTINUE := True;
  end
  else if AnOption = 'USE_UPSTREAM_WEIGHTING' then
  begin
    USE_UPSTREAM_WEIGHTING := True;
  end
  else if AnOption = 'USE_INEXACT_NEWTON' then
  begin
    USE_INEXACT_NEWTON := True;
  end
  else if AnOption = 'USE_STEADYSTATE_STORAGE' then
  begin
    USE_STEADYSTATE_STORAGE := True;
  end
  else if AnOption = 'USE_LAGGED_OPR_DATA' then
  begin
    USE_LAGGED_OPR_DATA := True;
  end
  else if AnOption = 'USE_LINEAR_DEPTH_SCALING' then
  begin
    USE_LINEAR_DEPTH_SCALING := True;
  end
  else if AnOption = 'USE_DIAGONAL_SCALING' then
  begin
    USE_DIAGONAL_SCALING := True;
    USE_L2NORM_SCALING := False;
  end
  else if AnOption = 'USE_L2NORM_SCALING' then
  begin
    USE_L2NORM_SCALING := True;
    USE_DIAGONAL_SCALING := False;
  end
  else if AnOption = 'USE_RCMREORDERING' then
  begin
    USE_RCMREORDERING := True;
    USE_RCMREORDERING_IF_IMPROVEMENT := False;
  end
  else if AnOption = 'USE_RCMREORDERING_IF_IMPROVEMENT' then
  begin
    USE_RCMREORDERING_IF_IMPROVEMENT := True;
    USE_RCMREORDERING := False;
  end
//  else if AnOption = 'USE_STAGE_TRANSFORM' then
//  begin
//    USE_STAGE_TRANSFORM := True;
//  end
//  else if AnOption = 'USE_WEIGHTED_HEADS' then
//  begin
//    USE_WEIGHTED_HEADS := True;
//  end
  else if AnOption = 'USE_IMPLICIT_NEWTON_CORRECTION' then
  begin
    USE_IMPLICIT_NEWTON_CORRECTION := True;
    USE_EXPLICIT_NEWTON_CORRECTION := False;
  end
  else if AnOption = 'USE_EXPLICIT_NEWTON_CORRECTION' then
  begin
    USE_EXPLICIT_NEWTON_CORRECTION := True;
    USE_IMPLICIT_NEWTON_CORRECTION := False;
  end
//  else if AnOption = 'USE_ORIGINAL_2D_QM_FORMULATION' then
//  begin
//    USE_ORIGINAL_2D_QM_FORMULATION := True;
//  end
//  else if AnOption = 'USE_IMPLICIT_INVARIATE_QM' then
//  begin
//    USE_IMPLICIT_INVARIATE_QM := True;
//  end
//  else if AnOption = 'USE_SOURCECELL_INVARIATE_QM' then
//  begin
//    USE_SOURCECELL_INVARIATE_QM := True;
//  end
  else if AnOption = 'USE_FRACTIONAL_TOLR' then
  begin
    USE_FRACTIONAL_TOLR := True;
    USE_L2NORM_TOLR := False;
  end
  else if AnOption = 'USE_L2NORM_TOLR' then
  begin
    USE_L2NORM_TOLR := True;
    USE_FRACTIONAL_TOLR := False;
  end
  else if AnOption = 'SAVE_SWROBSERVATIONS' then
  begin
    SAVE_SWROBSERVATIONS := True;
    SAVE_SWROBSERVATIONS_ALL := False;
  end
  else if AnOption = 'SAVE_SWROBSERVATIONS_ALL' then
  begin
    SAVE_SWROBSERVATIONS_ALL := True;
    SAVE_SWROBSERVATIONS := False;
  end
//  else if AnOption = 'USE_MULTICORE' then
//  begin
//    USE_MULTICORE := True;
//  end
//  else if AnOption = 'USE_MULTICORE_VECTOR' then
//  begin
//    USE_MULTICORE_VECTOR := True;
//  end
  else if AnOption = 'USE_DIRECT_RUNOFF' then
  begin
    USE_DIRECT_RUNOFF := True;
  end
  else if AnOption = 'USE_GLOBAL_TOLA' then
  begin
    USE_GLOBAL_TOLA := True;
    USE_ABSOLUTE_TOLA := False;
  end
  else if AnOption = 'USE_ABSOLUTE_TOLA' then
  begin
    USE_ABSOLUTE_TOLA := True;
    USE_GLOBAL_TOLA := False;
  end
  else if AnOption = 'END' then
  begin
  end
  else
  // do nothing
  begin
    Assert(False);
  end;
  FImporter.UpdateProgress;
end;

procedure TSwrImporter.ReadDataSet1A;
begin
  Read(FImporter.FFile, NREACHES);
  Read(FImporter.FFile, ISWRONLY);
  Read(FImporter.FFile, ISWRCBC);
  Read(FImporter.FFile, ISWRPRGF);
  Read(FImporter.FFile, ISWRPSTG);
  Read(FImporter.FFile, ISWRPQAQ);
  Read(FImporter.FFile, ISWRPQM);
  Read(FImporter.FFile, ISWRPSTR);
  Read(FImporter.FFile, ISWRPFRN);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
  FReachArray.ArrayLength := NREACHES;
end;

procedure TSwrImporter.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'NREACHES,ISWRONLY,ISWRCBC,ISWRPRGF,ISWRPSTG,ISWRPQAQ,ISWRPQM,ISWRPSTR,ISWRPFRN:' then
  begin
    ReadDataSet1A;
  end
  else if ALabel = 'AUXILIARY SWR1 VARIABLE:' then
  begin
    // Skip names of auxiliary variables
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'SWROPTIONS nopt:' then
  begin
    // Skip number of options.
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'CSWROPT:' then
  begin
    ReadDataSet1B;
  end
  else if ALabel = 'IOPTUNIT:' then
  begin
    ReadDataSet1B_UnitNumber;
  end
  else if ALabel = 'DLENCONV, TIMECONV, RTINI, RTMIN, RTMAX, RTPRN, RTMULT, NTMULT, DMINGRAD, DMNDEPTH:' then
  begin
    ReadDataSet2Required;
  end
  else if ALabel = 'DMAXRAI,DMAXSTG,DMAXINF:' then
  begin
    ReadDataSet2Optional;
  end
  else if ALabel = 'ISOLVER,NOUTER,NINNER,IBT,TOLS,TOLR,TOLA,DAMPSS,DAMPTR,IPRSWR,MUTSWR:' then
  begin
    ReadDataSet3Required;
  end
  else if ALabel = 'IPC:' then
  begin
    ReadDataSet3IPC;
  end
  else if ALabel = 'NLEVELS,DROPTOL:' then
  begin
    ReadDataSet3_NLEVELS;
  end
  else if ALabel = 'IBTPRT:' then
  begin
    ReadDataSet3_IBTPRT;
  end
  else if ALabel = 'PTOLR:' then
  begin
    ReadDataSet3_PTOLR;
  end
  else if ALabel = 'IRCH4A IROUTETYPE IRGNUM KRCH IRCH JRCH RLEN:' then
  begin
    ReadDataSet4A;
  end
  else if ALabel = 'IRCH4B NCONN:' then
  begin
    ReadDataSet4B_NCONN;
  end
  else if ALabel = 'ICONN:' then
  begin
    ReadDataSet4B_ICONN;
  end
  else if ALabel = 'NTABS:' then
  begin
    ReadDataSet4C;
  end
  else if ALabel = 'itab:' then
  begin
    ReadDataSet4D_ITAB;
  end
  else if ALabel = 'CTABTYPE:' then
  begin
    ReadDataSet4D_CTABTYPE;
  end
  else if ALabel = 'ITABUNIT:' then
  begin
    ReadDataSet4D_ITABUNIT;
  end
  else if ALabel = 'CINTP:' then
  begin
    ReadDataSet4D_CINTP;
  end
  else if ALabel = 'CTABRCH:' then
  begin
    ReadDataSet4D_CTABRCH;
  end
  else if ALabel = 'ntabrch ITABRCH:' then
  begin
    ReadDataSet4D_ITABRCH;
  end
  else if ALabel = 'NOBS:' then
  begin
    ReadDataSet4E;
  end
  else if ALabel = 'COBSNAME:' then
  begin
    ReadDataSet4F_COBSNAME;
  end
  else if ALabel = 'COBSTYPE:' then
  begin
    ReadDataSet4F_COBSTYPE;
  end
  else if ALabel = 'IOBSLOC:' then
  begin
    ReadDataSet4F_IOBSLOC;
  end
  else if ALabel = 'IOBSLOC2 or IOBSLAY:' then
  begin
    ReadDataSet4F_IOBSLOC2_IOBSLAY;
  end
  else if ALabel = 'ITMP:' then
  begin
    ReadDataSet5_NoChange;
  end
  else if ALabel = 'ITMP, IRDBND, IRDRAI, IRDEVP, IRDLIN, IRDGEO, IRDSTR, IRDSTG, IPTFLG:' then
  begin
    ReadDataSet5Changed;
  end
  else if ALabel = 'IRDAUX:' then
  begin
    // Skip IRDAUX.
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'IBNDRCH ISWRBND:' then
  begin
    ReadDataSet6;
  end
  else if ALabel = 'IRAIRCH RAIN:' then
  begin
    ReadDataSet7A;
  end
  else if ALabel = 'IEVPRCH EVAP:' then
  begin
    ReadDataSet8A;
  end
  else if ALabel = 'ILINRCH QLATFLOW:' then
  begin
    ReadDataSet9A;
  end
  else if ALabel = 'IGMODRCH IGEONUMR GZSHIFT:' then
  begin
    ReadDataSet10;
  end
  else if ALabel = 'IGEONUM IGEOTYPE IGCNDOP GMANNING:' then
  begin
    ReadDataSet11A_IGEONUM;
  end
  else if ALabel = 'NGEOPTS:' then
  begin
    ReadDataSet11A_NGEOPTS;
  end
  else if ALabel = 'GWIDTH GBELEV:' then
  begin
    ReadDataSet11A_GWIDTH;
  end
  else if ALabel = 'GSSLOPE:' then
  begin
    ReadDataSet11A_GSSLOPE;
  end
  else if ALabel = 'GCND:' then
  begin
    ReadDataSet11A_GCND;
  end
  else if ALabel = 'GLK:' then
  begin
    ReadDataSet11A_GLK;
  end
  else if ALabel = 'GCNDLN:' then
  begin
    ReadDataSet11A_GCNDLN;
  end
  else if ALabel = 'GETEXTD:' then
  begin
    ReadDataSet11A_GETEXTD;
  end
  else if ALabel = 'XB(I) ELEVB(I):' then
  begin
    ReadDataSet11B;
  end
  else if ALabel = 'ELEV(I) VOL(I) WETPER(I) SAREA(I) XAREA(I):' then
  begin
    ReadDataSet11C;
  end
  else if ALabel = 'ISMODRCH NSTRUCT:' then
  begin
    ReadDataSet12;
  end
  else if ALabel = 'ISTRRCH ISTRNUM ISTRCONN ISTRTYPE:' then
  begin
    ReadDataSet13A_1;
  end
  else if ALabel = 'STRINV:' then
  begin
    ReadDataSet13A_2;
  end
  else if ALabel = 'STRLEN:' then
  begin
    ReadDataSet13A_3;
  end
  else if ALabel = 'STRLEN2:' then
  begin
    ReadDataSet13A_4;
  end
  else if ALabel = 'STRVAL:' then
  begin
    ReadDataSet13A_5;
  end
  else if ALabel = 'NSTRPTS:' then
  begin
    ReadDataSet13A_6;
  end
  else if ALabel = 'STRCD, STRCD2, STRINV, STRINV2, STRWID:' then
  begin
    ReadDataSet13A_7;
  end
  else if ALabel = 'STRWID2:' then
  begin
    ReadDataSet13A_8;
  end
  else if ALabel = 'STRLEN, STRMAN, ISTRDIR:' then
  begin
    ReadDataSet13A_9;
  end
  else if ALabel = 'STRCD, STRCD3, STRINV, STRWID, STRVAL, ISTRDIR:' then
  begin
    ReadDataSet13A_10;
  end
  else if ALabel = 'STRCD, STRCD2, STRCD3, STRINV, STRWID, STRVAL, ISTRDIR:' then
  begin
    ReadDataSet13A_11;
  end
  else if ALabel = 'STRLEN:' then
  begin
    ReadDataSet13A_12;
  end
  else if ALabel = 'STRVAL TABDATA:' then
  begin
    ReadDataSet13A_13;
  end
  else if ALabel = 'STRVAL:' then
  begin
    ReadDataSet13A_14;
  end
  else if ALabel = 'ISFRSEG:' then
  begin
    ReadDataSet13A_15;
  end
  else if ALabel = 'ISFRRCH:' then
  begin
    ReadDataSet13A_16;
  end
  else if ALabel = 'CSTROTYP:' then
  begin
    ReadDataSet13B_1;
  end
  else if ALabel = 'ISTRORCH:' then
  begin
    ReadDataSet13B_2;
  end
  else if ALabel = 'ISTROQCON:' then
  begin
    ReadDataSet13B_3;
  end
  else if ALabel = 'CSTROLO:' then
  begin
    ReadDataSet13B_4;
  end
  else if ALabel = 'TABDATA CSTRCRIT ISTRTAB:' then
  begin
    ReadDataSet13B_5;
  end
  else if ALabel = 'REACH, ISTROSTG:' then
  begin
    Assert(False, 'Undocumented structure option in SWR');
//    Read(FImporter.FFile, FCurrentStructure.REACH);
//    Read(FImporter.FFile, FCurrentStructure.ISTROSTG);
//    Readln(FImporter.FFile);
//    FImporter.UpdateProgress;
  end
  else if ALabel = 'STRCRIT:' then
  begin
    ReadDataSet13B_6;
  end
  else if ALabel = 'STRCRITC, STRRT:' then
  begin
    ReadDataSet13B_7;
  end
  else if ALabel = 'STRMAX:' then
  begin
    ReadDataSet13B_8;
  end
  else if ALabel = 'TABDATA CSTRVAL ISTRTAB:' then
  begin
    ReadDataSet13B_9;
  end
  else if ALabel = 'STRELEV STRQ:' then
  begin
    ReadDataSet13C;
  end
  else if ALabel = 'IRCHSTG STAGE:' then
  begin
    ReadDataSet14A;
  end
  else if ALabel = 'IRCHAUX:' then
  begin
    // Skip IRCHAUX.
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = 'xyz:' then
  begin
    // Skip xyz.
    Readln(FImporter.FFile);
    FImporter.UpdateProgress;
  end
  else if ALabel = StrConstant2DRealArray then
  begin
    ReadConstantRealArrays;
  end
  else if ALabel = StrVariable2DRealArray then
  begin
    ReadVariableRealArrays;
  end
  else if ALabel = StrConstant2DIntegerArray then
  begin
    ReadRunoffMapConstant;
  end
  else if ALabel = StrVariable2DIntegerArray then
  begin
    ReadRunoffMapVariable;
  end
  else
  begin
    Assert(False, Format('Unrecognized label %s', [ALabel]));
  end;
end;

function TSwrImporter.ScreenObjectNameRoot: string;
begin
  result := 'SWR_Object';
end;

{ TSwrReachArray }

function TSwrReachArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrReach;
end;

function TSwrReachArray.GetReaches(Index: integer): TSwrReach;
begin
  result := Objects[Index] as TSwrReach
end;

{ TSwrTabFileArray }

function TSwrTabFileArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrTabFile;
end;

function TSwrTabFileArray.GetTabfile(Index: integer): TSwrTabFile;
begin
  result := Objects[Index] as TSwrTabFile;
end;

{ TSwrObsArray }

function TSwrObsArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrObs;
end;

function TSwrObsArray.GetObs(Index: integer): TSwrObs;
begin
  result := Objects[Index] as TSwrObs;
end;

{ TSwrISWRBND_Array }

function TSwrISWRBND_Array.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrISWRBND;
end;

function TSwrISWRBND_Array.GetSwrISWRBND(Index: integer): TSwrISWRBND;
begin
  result := Objects[Index] as TSwrISWRBND;
end;

function TSwrISWRBND_Array.Last: TSwrISWRBND;
begin
  result := SwrISWRBND[ArrayLength-1];
end;

{ TSwrReach }

constructor TSwrReach.Create;
begin
  inherited;
  F_ISWRBND_Array := TSwrISWRBND_Array.Create;
  FRain := TSwrRain_Array.Create;
  FEvap := TSwrEvap_Array.Create;
  FLateralFlow := TSwrLateralFlow_Array.Create;
  FStage := TSwrStage_Array.Create;
  FReachGeom_Array := TSwrReachGeom_Array.Create;
  FReachStructureCounts := TSwrReachStructureCountArray.Create;
end;

destructor TSwrReach.Destroy;
begin
  FReachStructureCounts.Free;
  FReachGeom_Array.Free;
  FStage.Free;
  FLateralFlow.Free;
  FEvap.Free;
  FRain.Free;
  F_ISWRBND_Array.Free;
  inherited;
end;

{ TSwrRain_Array }

function TSwrRain_Array.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrRain;
end;

function TSwrRain_Array.GetRain(Index: integer): TSwrRain;
begin
  result := Objects[Index] as TSwrRain;
end;

function TSwrRain_Array.Last: TSwrRain;
begin
  result := SwrRain[ArrayLength-1];
end;

{ TSwrEvap_Array }

function TSwrEvap_Array.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrEvap;
end;

function TSwrEvap_Array.GetEvap(Index: integer): TSwrEvap;
begin
  result := Objects[Index] as TSwrEvap;
end;

function TSwrEvap_Array.Last: TSwrEvap;
begin
  result := SwrEvap[ArrayLength-1];
end;

{ TSwrLateralFlow_Array }

function TSwrLateralFlow_Array.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrLateralFlow;
end;

function TSwrLateralFlow_Array.GetLateralFlow(Index: integer): TSwrLateralFlow;
begin
  result := Objects[Index] as TSwrLateralFlow;
end;

function TSwrLateralFlow_Array.Last: TSwrLateralFlow;
begin
  result := SwrLateralFlow[ArrayLength-1];
end;

{ TSwrStage_Array }

function TSwrStage_Array.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrStage;
end;

function TSwrStage_Array.GetStage(Index: integer): TSwrStage;
begin
  result := Objects[Index] as TSwrStage;
end;

function TSwrStage_Array.Last: TSwrStage;
begin
  result := SwrStage[ArrayLength-1];
end;

{ TSwrReachGeom_Array }

function TSwrReachGeom_Array.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrReachGeomLink;
end;

function TSwrReachGeom_Array.GetReachGeomLink(
  Index: integer): TSwrReachGeomLink;
begin
  result := Objects[Index] as TSwrReachGeomLink;
end;

function TSwrReachGeom_Array.Last: TSwrReachGeomLink;
begin
  result := ReachGeomLink[ArrayLength-1];
end;

{ TGeomStressPeriodArray }

function TSwrGeomStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrGeomItem;
end;

function TSwrGeomStressPeriodArray.GetGeom(Index: integer): TSwrGeomItem;
begin
  result := Objects[Index] as TSwrGeomItem;
end;

function TSwrGeomStressPeriodArray.Last: TSwrGeomItem;
begin
  result := Geom[ArrayLength-1];
end;

{ TGeomArray }

function TSwrGeomArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrGeomStressPeriodArray;
end;

function TSwrGeomArray.FindByStressPeriod(StressPeriod: Integer): integer;
var
  Index: Integer;
begin
  result := 0;
  for Index := 0 to ArrayLength - 1 do
  begin
    if GeomArray[Index].FStartingStressPeriod = StressPeriod then
    begin
      result := Index;
      Exit;
    end
    else if GeomArray[Index].FStartingStressPeriod > StressPeriod then
    begin
      result := Index-1;
      Exit;
    end;
  end;
end;

function TSwrGeomArray.GetGeomArray(Index: integer): TSwrGeomStressPeriodArray;
begin
  result := Objects[Index] as TSwrGeomStressPeriodArray;
end;

function TSwrGeomArray.Last: TSwrGeomStressPeriodArray;
begin
  if ArrayLength > 0 then
  begin
    result := GeomArray[ArrayLength-1];
  end
  else
  begin
    result := nil;
  end;
end;

{ TCrossSectionArray }

function TSwrCrossSectionArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrGeomCrossSectionPoint;
end;

function TSwrCrossSectionArray.GetPoint(Index: integer): TSwrGeomCrossSectionPoint;
begin
  result := Objects[Index] as TSwrGeomCrossSectionPoint;
end;

function TSwrCrossSectionArray.IsSame(AnItem: TSwrCrossSectionArray): boolean;
var
  index: Integer;
begin
  Result := (AnItem <> nil)
    and (ArrayLength = AnItem.ArrayLength);
  if result then
  begin
    for index := 0 to ArrayLength - 1 do
    begin
      result := Points[index].IsSame(AnItem.Points[index]);
      if not result then
      begin
        Exit;
      end;
    end;
  end;
end;

{ TGeomItem }

constructor TSwrGeomItem.Create;
begin
  inherited;
  FCrossSection := TSwrCrossSectionArray.Create;
  FTable := TSwrGeomTableArray.Create;
end;

destructor TSwrGeomItem.Destroy;
begin
  FTable.Free;
  FCrossSection.Free;
  inherited;
end;

function TSwrGeomItem.IsSame(AnItem: TSwrGeomItem): boolean;
begin
  Result := (AnItem <> nil)
    and (IGEONUM = AnItem.IGEONUM)
    and (IGEOTYPE = AnItem.IGEOTYPE)
    and (IGCNDOP = AnItem.IGCNDOP)
    and (GMANNING = AnItem.GMANNING)
    and (NGEOPTS = AnItem.NGEOPTS)
    and (GWIDTH = AnItem.GWIDTH)
    and (GBELEV = AnItem.GBELEV)
    and (GSSLOPE = AnItem.GSSLOPE)
    and (GCND = AnItem.GCND)
    and (GLK = AnItem.GLK)
    and (GCNDLN = AnItem.GCNDLN)
    and (GETEXTD = AnItem.GETEXTD)
    and FCrossSection.IsSame(AnItem.FCrossSection)
    and FTable.IsSame(AnItem.FTable)
end;

{ TSwrGeomTableArray }

function TSwrGeomTableArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrGeomTableItem;
end;

function TSwrGeomTableArray.GetItem(Index: integer): TSwrGeomTableItem;
begin
  result := Objects[Index] as TSwrGeomTableItem;
end;

function TSwrGeomTableArray.IsSame(AnItem: TSwrGeomTableArray): boolean;
var
  index: Integer;
begin
  Result := (AnItem <> nil)
    and (ArrayLength = AnItem.ArrayLength);
  if result then
  begin
    for index := 0 to ArrayLength - 1 do
    begin
      result := Items[index].IsSame(AnItem.Items[index]);
      if not result then
      begin
        Exit;
      end;
    end;
  end;
end;

{ TSwrReachStructureCountArray }

function TSwrReachStructureCountArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrReachStructureCount
end;

function TSwrReachStructureCountArray.GetItem(
  Index: integer): TSwrReachStructureCount;
begin
  result := Objects[Index] as TSwrReachStructureCount;
end;

function TSwrReachStructureCountArray.Last: TSwrReachStructureCount;
begin
  result := Items[ArrayLength-1];
end;

{ TStructureStressPeriodArray }

function TStructureStressPeriodArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrStructure
end;

function TStructureStressPeriodArray.GetItem(Index: integer): TSwrStructure;
begin
  result := Objects[Index] as TSwrStructure;
end;

function TStructureStressPeriodArray.Last: TSwrStructure;
begin
  result := Items[ArrayLength-1];
end;

{ TStructureArray }

function TStructureArray.ArrayMemberClass: TArrayMemberClass;
begin
  result := TStructureStressPeriodArray;
end;

function TStructureArray.GetItem(Index: integer): TStructureStressPeriodArray;
begin
  result := Objects[Index] as TStructureStressPeriodArray;
end;

function TStructureArray.Last: TStructureStressPeriodArray;
begin
  if ArrayLength > 0 then
  begin
    result := Items[ArrayLength-1];
  end
  else
  begin
    result := nil;
  end;
end;

{ TSwrStructureTable }

function TSwrStructureTable.ArrayMemberClass: TArrayMemberClass;
begin
  result := TSwrStructureTableItem;
end;

function TSwrStructureTable.GetItem(Index: integer): TSwrStructureTableItem;
begin
  result := Objects[index] as TSwrStructureTableItem;
end;

function TSwrStructureTable.IsSame(
  AStructureTable: TSwrStructureTable): boolean;
var
  index: integer;
begin
  result := ArrayLength = AStructureTable.ArrayLength;
  if result then
  begin
    for index := 0 to ArrayLength - 1 do
    begin
      result := Items[Index].IsSame(AStructureTable.Items[Index]);
      if not Result then
      begin
        Exit;
      end;
    end;

  end;
end;

{ TSwrStructure }

constructor TSwrStructure.Create;
begin
  inherited;
  FTable := TSwrStructureTable.Create;
end;

destructor TSwrStructure.Destroy;
begin
  FTable.Free;
  inherited;
end;

function TSwrStructure.IsSame(AStructure: TSwrStructure): boolean;
begin
  result := (ISTRRCH = AStructure.ISTRRCH)
    and (ISTRNUM = AStructure.ISTRNUM)
    and (ISTRCONN = AStructure.ISTRCONN)
    and (ISTRTYPE = AStructure.ISTRTYPE)
    and (NSTRPTS = AStructure.NSTRPTS)
    and (STRCD = AStructure.STRCD)
    and (STRCD2 = AStructure.STRCD2)
    and (STRCD3 = AStructure.STRCD3)
    and (STRINV = AStructure.STRINV)
    and (STRINV2 = AStructure.STRINV2)
    and (STRWID = AStructure.STRWID)
    and (STRWID2 = AStructure.STRWID2)
    and (STRLEN = AStructure.STRLEN)
    and (STRLEN2 = AStructure.STRLEN2)
    and (STRMAN = AStructure.STRMAN)
    and (STRCD2 = AStructure.STRCD2)
    and (STRVAL = AStructure.STRVAL)
    and (ISTRDIR = AStructure.ISTRDIR)
    and (ISFRSEG = AStructure.ISFRSEG)
    and (ISFRRCH = AStructure.ISFRRCH)
    and (CSTROTYP = AStructure.CSTROTYP)
    and (STRCD2 = AStructure.STRCD2)
    and (ISTRORCH = AStructure.ISTRORCH)
    and (ISTROQCON = AStructure.ISTROQCON)
    and (CSTROLO = AStructure.CSTROLO)
    and (CSTRCRIT = AStructure.CSTRCRIT)
    and (STRRT = AStructure.STRRT)
    and (STRMAX = AStructure.STRMAX)
    and (CSTRVAL = AStructure.CSTRVAL)
    and (ISTRTAB_Discharge = AStructure.ISTRTAB_Discharge)
    and (ISTRTAB_Control = AStructure.ISTRTAB_Control)
    and (ISTRTAB_Gate = AStructure.ISTRTAB_Gate)
    and FTable.IsSame(AStructure.FTable);
end;

{ TSwrGeomCrossSectionPoint }

function TSwrGeomCrossSectionPoint.IsSame(
  AnItem: TSwrGeomCrossSectionPoint): boolean;
begin
  Result := (AnItem <> nil)
    and (XB = AnItem.XB)
    and (ELEVB = AnItem.ELEVB)
end;

{ TSwrGeomTableItem }

function TSwrGeomTableItem.IsSame(AnItem: TSwrGeomTableItem): boolean;
begin
  Result := (AnItem <> nil)
    and (ELEV = AnItem.ELEV)
    and (VOL = AnItem.VOL)
    and (WETPER = AnItem.WETPER)
    and (SAREA = AnItem.SAREA)
    and (XAREA = AnItem.XAREA)
end;

{ TCustomSwrObjectArray }

function TCustomSwrObjectArray.GetAnItem(Index: Integer): TCustomSwrArrayMember;
begin
  result := Objects[Index] as TCustomSwrArrayMember;
end;

function TPackageImporter.GetStressPeriodString(StressPeriodIndex
  : integer): string;
var
  StressPeriodMaxLength: integer;
begin
  result := IntToStr(FModel.ModflowStressPeriods.Count);
  StressPeriodMaxLength := Length(result);
  result := IntToStr(StressPeriodIndex + 1);
  while Length(result) < StressPeriodMaxLength do
  begin
    result := '0' + result;
  end;
end;

procedure TPackageImporter.CreateTransientDataSet(StressPeriodIndex: integer;
  const Root: string; DataType: TRbwDataType; var DataSet: TDataArray);
var
  NewName: string;
  Interpolator: TNearestPoint2DInterpolator;
begin
  // DataSet := TDataArray.Create(FModel);
  if StressPeriodIndex >= 0 then
  begin
    NewName := Root + GetStressPeriodString(StressPeriodIndex);
  end
  else
  begin
    NewName := Root;
  end;
  DataSet := FModel.DataArrayManager.CreateNewDataArray(TDataArray, NewName,
    '0', NewName, [dcType], DataType, eaBlocks, dsoTop, '');
  DataSet.Comment := Format(StrImportedFromExisti, [DateTimeToStr(Now)]);
  DataSet.Comment := DataSet.Comment + sLineBreak +
    Format('Stress Period: %d', [StressPeriodIndex+1]);
  DataSet.UpdateDimensions(FGrid.LayerCount, FGrid.RowCount, FGrid.ColumnCount);
  // FModel.CreateVariables(DataSet);
  Interpolator := TNearestPoint2DInterpolator.Create(nil);
  try
    DataSet.TwoDInterpolator := Interpolator;
  finally
    Interpolator.Free;
  end;
end;

function TPackageImporter.CreateScreenObjectAroundGrid(const Name: string)
  : TScreenObject;
begin
  result := CreateScreenObject(Name);
  result.Capacity := 5;
  result.AddPoint(FGrid.TwoDElementCorner(0, 0), False);
  result.AddPoint(FGrid.TwoDElementCorner(0, FGrid.RowCount), False);
  result.AddPoint(FGrid.TwoDElementCorner(FGrid.ColumnCount,
    FGrid.RowCount), False);
  result.AddPoint(FGrid.TwoDElementCorner(FGrid.ColumnCount, 0), False);
  result.AddPoint(FGrid.TwoDElementCorner(0, 0), False);
end;

{ TSwrStructureTableItem }

function TSwrStructureTableItem.IsSame(
  ATableItem: TSwrStructureTableItem): boolean;
begin
  result := (STRELEV = ATableItem.STRELEV)
    and (STRQ = ATableItem.STRQ)
end;

{ TMnw1Importer }

constructor TMnw1Importer.Create(Importer: TModflow2005Importer);
begin
  inherited Create(Importer, 'MNW1');
  FWells := TObjectList<TMnw1Well>.Create;
  FMnw1OutputFiles := TMnw1OutputFiles.Create;
  FWellPriorStressPeriod := TMnw1Wells.Create;
  FWellCurrentStressPeriod := TMnw1Wells.Create;
  FCellsCurrentStressPeriod := TList<TMnw1Cell>.Create;
  FWellLists := TMnw1WellsObjectList.Create;
  FCurrentStressPeriod := -1;
end;

destructor TMnw1Importer.Destroy;
begin
  FWellLists.Free;
  FCellsCurrentStressPeriod.Free;
  FWellCurrentStressPeriod.Free;
  FWellPriorStressPeriod.Free;
  FMnw1OutputFiles.Free;
  FWells.Free;
  inherited;
end;

procedure TMnw1Importer.HandleCellsFromPriorStressPeriod;
begin
  ExpandMulti;
  AssignCellToWells;
end;

procedure TMnw1Importer.ExpandMulti;
var
  NewCell: TMnw1Cell;
  StartCell: TMnw1Cell;
  InnerCellIndex: Integer;
  Direction: Integer;
  CellIndex: Integer;
  MaxDiff: Integer;
  ACell: TMnw1Cell;
begin
  for CellIndex := FCellsCurrentStressPeriod.Count - 1 downto 0 do
  begin
    ACell := FCellsCurrentStressPeriod[CellIndex];
    if ACell.Multi then
    begin
      StartCell := FCellsCurrentStressPeriod[CellIndex - 1];
      MaxDiff := MaxIntValue([Abs(ACell.Layer - StartCell.Layer),
        Abs(ACell.Row - StartCell.Row), Abs(ACell.Column - StartCell.Column)]);
      if ACell.Layer <> StartCell.Layer then
      begin
        Direction := Sign(ACell.Layer - StartCell.Layer);
        for InnerCellIndex := 1 to MaxDiff - 1 do
        begin
          NewCell := TMnw1Cell.Create;
          NewCell.Assign(ACell);
          NewCell.Layer := NewCell.Layer - InnerCellIndex * Direction;
          NewCell.Qdes := 0;
          FCellsCurrentStressPeriod.Insert(CellIndex, NewCell);
        end;
      end
      else if ACell.Row <> StartCell.Row then
      begin
        Direction := Sign(ACell.Row - StartCell.Row);
        for InnerCellIndex := 1 to MaxDiff - 1 do
        begin
          NewCell := TMnw1Cell.Create;
          NewCell.Assign(ACell);
          NewCell.Row := NewCell.Row - InnerCellIndex * Direction;
          NewCell.Qdes := 0;
          FCellsCurrentStressPeriod.Insert(CellIndex, NewCell);
        end;
      end
      else if ACell.Column <> StartCell.Column then
      begin
        Direction := Sign(ACell.Column - StartCell.Column);
        for InnerCellIndex := 1 to MaxDiff - 1 do
        begin
          NewCell := TMnw1Cell.Create;
          NewCell.Assign(ACell);
          NewCell.Column := NewCell.Column - InnerCellIndex * Direction;
          NewCell.Qdes := 0;
          FCellsCurrentStressPeriod.Insert(CellIndex, NewCell);
        end;
      end
      else
      begin
        Assert(False);
      end;
    end;
  end;
end;

procedure TMnw1Importer.ReadDataSet5_2;
var
  Href: Double;
  Hlim: Double;
  Iwgrp: Double;
  QWval: Double;
  Rw: Double;
  Skin: Double;
  ACell: TMnw1Cell;
begin
  Read(FImporter.FFile, QWval);
  Read(FImporter.FFile, Rw);
  Read(FImporter.FFile, Skin);
  Read(FImporter.FFile, Hlim);
  Read(FImporter.FFile, Href);
  Readln(FImporter.FFile, Iwgrp);
  ACell := FCellsCurrentStressPeriod.Last;
  ACell.QWval := QWval;
  ACell.Rw := Rw;
  ACell.Skin := Skin;
  ACell.Hlim := Hlim;
  ACell.Href := Href;
  ACell.Iwgrp := Round(Iwgrp);
end;

procedure TMnw1Importer.ReadSiteLabel;
var
  Site: string;
  ACell: TMnw1Cell;
begin
  Readln(FImporter.FFile, Site);
  ACell := FCellsCurrentStressPeriod.Last;
  ACell.Site := Trim(Site);
  if ACell.Site = 'NO-PRINT' then
  begin
    ACell.Site := '';
  end;
end;

procedure TMnw1Importer.ReadCp_C;
var
  Cp_C: Double;
  ACell: TMnw1Cell;
begin
  Readln(FImporter.FFile, Cp_C);
  ACell := FCellsCurrentStressPeriod.Last;
  ACell.Cp_C := Cp_C;
end;

procedure TMnw1Importer.ReadActivationPumpingRate;
var
  ACell: TMnw1Cell;
  Qfrcmx: Double;
  Qfrcmn: Double;
begin
  Read(FImporter.FFile, Qfrcmn);
  Readln(FImporter.FFile, Qfrcmx);
  ACell := FCellsCurrentStressPeriod.Last;
  ACell.Qfrcmn := Qfrcmn;
  ACell.Qfrcmx := Qfrcmx;
end;

procedure TMnw1Importer.ReadQPercentCUT;
begin
  FCellsCurrentStressPeriod.Last.QPercentCUT := True;
end;

procedure TMnw1Importer.ReadQCUT;
begin
  FCellsCurrentStressPeriod.Last.QCUT := True;
end;

procedure TMnw1Importer.ReadDataSet5_1;
var
  ACell: TMnw1Cell;
  Qdes: Double;
  Column: Integer;
  Layer: Integer;
  Row: Integer;
begin
  Read(FImporter.FFile, Layer);
  Read(FImporter.FFile, Row);
  Read(FImporter.FFile, Column);
  Readln(FImporter.FFile, Qdes);
  ACell := TMnw1Cell.Create;
  FCellsCurrentStressPeriod.Add(ACell);
  ACell.Layer := Layer;
  ACell.Row := Row;
  ACell.Column := Column;
  ACell.Qdes := Qdes;
end;

procedure TMnw1Importer.ReadAddNewWells;
begin
  FAdd := True;
end;

procedure TMnw1Importer.ReadDataSet4;
var
  WellIndex: Integer;
  AWell: TMnw1Well;
begin
  Inc(FCurrentStressPeriod);
  Readln(FImporter.FFile, itmp);
  FAdd := False;
  if itmp < 0 then
  begin
    for WellIndex := 0 to FWellPriorStressPeriod.Count - 1 do
    begin
      AWell := FWellPriorStressPeriod[WellIndex];
      AWell.Last.EndingStressPeriod := FCurrentStressPeriod;
    end;
  end
  else if itmp = 0 then
  begin
    FWellPriorStressPeriod.Clear;
  end;
  FImporter.UpdateProgress;
end;

procedure TMnw1Importer.AssignAllTimeFlag;
begin
  FMnw1OutputFiles.Last.AllTime := True;
end;

procedure TMnw1Importer.ReadDataSet3;
var
  FileName: string;
  UnitNumber: Integer;
  OutputFile: TMnw1OutputFile;
  Flag: string;
begin
  Readln(FImporter.FFile, FileName);
  FileName := Trim(FileName);
  Readln(FImporter.FFile, Flag);
  Flag := Trim(Flag);
  Readln(FImporter.FFile, UnitNumber);
  OutputFile := TMnw1OutputFile.Create;
  OutputFile.FileName := FileName;
  OutputFile.Flag := Flag;
  OutputFile.UnitNumber := UnitNumber;
  FMnw1OutputFiles.Add(OutputFile);
end;

procedure TMnw1Importer.ReadMnwFilePrefix;
var
  MNWNAME: string;
begin
  Readln(FImporter.FFile, MNWNAME);
  MNWNAME := Trim(MNWNAME);
end;

procedure TMnw1Importer.ReadDataSet2Version2;
var
  LOSSTYPE: string;
begin
  Readln(FImporter.FFile, LOSSTYPE);
  LOSSTYPE := UpperCase(Trim(LOSSTYPE));
  if LOSSTYPE = 'SKIN' then
  begin
    FLossType := mlt1Skin;
  end
  else
  begin
    Assert(False);
  end;
end;

procedure TMnw1Importer.ReadDataSet2Version1;
var
  LOSSTYPE: string;
begin
  Readln(FImporter.FFile, LOSSTYPE);
  LOSSTYPE := UpperCase(Trim(LOSSTYPE));
  if LOSSTYPE = 'NONLINEAR' then
  begin
    FLossType := mlt1NonLinear;
  end
  else if LOSSTYPE = 'LINEAR' then
  begin
    FLossType := mlt1Linear;
  end
  else
  begin
    Assert(False);
  end;
  Readln(FImporter.FFile, PLossMNW);
end;

{$HINTS OFF}
procedure TMnw1Importer.ReadDataSet1;
var
  IWL2CB: Integer;
  MXMNW: Integer;
  IWELPT: integer;
begin
  Read(FImporter.FFile, MXMNW);
  Read(FImporter.FFile, IWL2CB);
  Read(FImporter.FFile, IWELPT);
  Read(FImporter.FFile, NOMOITER);
  Read(FImporter.FFile, KSPREF);
  Readln(FImporter.FFile);
  FImporter.UpdateProgress;
end;
{$HINTS ON}

procedure TMnw1Importer.HandlePackage;
var
  OutputIndex: integer;
  OutputFile: TMnw1OutputFile;
  WellIndex: integer;
  AWell: TMnw1Well;
  AScreenObject: TScreenObject;
  AList: TList;
  CellIndex: Integer;
  ImportedElevations: TValueArrayStorage;
  ALocation: TLocation;
  Grid: TModflowGrid;
  Layer: Integer;
  TimeIndex: Integer;
  CellList: TMnw1Cells;
  Mnw1Boundary: TMnw1Boundary;
  Mnw1Item: TMnw1Item;
  DesiredPumpingRateItem: TValueArrayItem;
  Mnw1Cell: TMnw1Cell;
  StressPeriods: TModflowStressPeriods;
  ImportName: string;
  WaterQualityItem: TValueArrayItem;
  WellRadiusItem: TValueArrayItem;
  SkinItem: TValueArrayItem;
  LimitItem: TValueArrayItem;
  RefElevItem: TValueArrayItem;
  WaterQualityGroupItem: TValueArrayItem;
  LossCoefficientItem: TValueArrayItem;
  ActiveItem: TValueArrayItem;
  ReActivationItem: TValueArrayItem;
begin
  if (FCurrentStressPeriod < 0) or
    (FCurrentStressPeriod < FModel.ModflowStressPeriods.Count -1) then
  begin
    Exit;
  end;
  inherited;
  HandleCellsFromPriorStressPeriod;

  FMnw1Package := FModel.ModflowPackages.Mnw1Package;
  FMnw1Package.IsSelected := True;
  FMnw1Package.Comments := FComments;
  FMnw1Package.MaxMnwIterations := NOMOITER;
  FMnw1Package.LossType := FLossType;

  if KSPREF > 0 then
  begin
    FModel.ModflowStressPeriods[KSPREF-1].DrawDownReference := True;
  end;

  if FLossType = mlt1NonLinear then
  begin
    FMnw1Package.LossExponent := PLossMNW;
  end;

  for OutputIndex := 0 to FMnw1OutputFiles.Count - 1 do
  begin
    OutputFile := FMnw1OutputFiles[OutputIndex];
    if OutputFile.Flag = 'WEL1' then
    begin
      FMnw1Package.WellFileName := OutputFile.FileName;
    end
    else if OutputFile.Flag = 'BYNODE' then
    begin
      FMnw1Package.ByNodeFileName := OutputFile.FileName;
      if OutputFile.AllTime then
      begin
        FMnw1Package.ByNodePrintFrequency := mpfAll;
      end
      else
      begin
        FMnw1Package.ByNodePrintFrequency := mpfOutputControl;
      end;
    end
    else if OutputFile.Flag = 'QSUM' then
    begin
      FMnw1Package.QSumFileName := OutputFile.FileName;
      if OutputFile.AllTime then
      begin
        FMnw1Package.QSumPrintFrequency := mpfAll;
      end
      else
      begin
        FMnw1Package.QSumPrintFrequency := mpfOutputControl;
      end;
    end
    else
    begin
      Assert(false);
    end;
  end;

  AList := TList.Create;
  try
    Grid := FModel.ModflowGrid;
    StressPeriods := FModel.ModflowStressPeriods;
    for WellIndex := 0 to FWells.Count - 1 do
    begin
      FImporter.texthandler('MNW1: Importing well ' + IntToStr(WellIndex+1) + ' of ' + IntToStr(FWells.Count));
      AWell := FWells[WellIndex];
      AScreenObject := CreateScreenObject(Format('MNW1_Well_%d', [WellIndex+1]));
      AScreenObject.SetValuesOfEnclosedCells := False;
      AScreenObject.SetValuesOfIntersectedCells := True;
      AList.Clear;
      AList.Capacity := AWell[0].Count;
      ImportedElevations := AScreenObject.ImportedSectionElevations;
      ImportedElevations.Count := AWell[0].Count;
      for CellIndex := 0 to AWell[0].Count - 1 do
      begin
        ALocation := AWell[0][CellIndex];
        Layer := FModel.ModflowLayerToDataSetLayer(ALocation.Layer);
        ImportedElevations.RealValues[CellIndex] :=
          Grid.ThreeDElementCenter(ZeroBasedID(Layer, ALocation.Row-1, ALocation.Column-1)).z;
        AList.Add(ALocation);
      end;
      for CellIndex := 0 to AList.Count - 1 do
      begin
        AddBoundaryPoints(AList, CellIndex, otPoint, AScreenObject);
      end;
      AScreenObject.ElevationFormula := rsObjectImportedValuesR
        + '("' + StrImportedElevations + '")';
      AScreenObject.CreateMnw1Boundary;
      Mnw1Boundary := AScreenObject.ModflowMnw1Boundary;
      Mnw1Boundary.Values.Capacity := AWell.Count;
      for TimeIndex := 0 to AWell.Count - 1 do
      begin
        CellList := AWell[TimeIndex];
        
        if TimeIndex > 0 then
        begin
          if AWell[TimeIndex-1].SameValues(CellList) then
          begin
            Mnw1Item := Mnw1Boundary.Values.Last as TMnw1Item;
            Mnw1Item.EndTime := StressPeriods[CellList.EndingStressPeriod].EndTime;
            AWell[TimeIndex-1].Clear;
            Continue;
          end;
        end;
        
        Mnw1Item := Mnw1Boundary.Values.Add as TMnw1Item;

        Mnw1Item.StartTime := StressPeriods[CellList.StartingStressPeriod].StartTime;
        Mnw1Item.EndTime := StressPeriods[CellList.EndingStressPeriod].EndTime;

        if CellList.Count > 1 then
        begin
          DesiredPumpingRateItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedPumpumpingRate%d', [TimeIndex+1]);
          DesiredPumpingRateItem.Name := ImportName;
          DesiredPumpingRateItem.Values.Count := CellList.Count;
          Mnw1Item.DesiredPumpingRate := rsObjectImportedValuesR
            + '("' + ImportName + '")';

          WaterQualityItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedWaterQuality%d', [TimeIndex+1]);
          WaterQualityItem.Name := ImportName;
          WaterQualityItem.Values.Count := CellList.Count;
          Mnw1Item.WaterQuality := rsObjectImportedValuesR
            + '("' + ImportName + '")';

          Mnw1Cell := CellList[0];

          if Mnw1Cell.Rw > 0 then
          begin
            Mnw1Item.ConductanceMethod := mcmRadius;
            WellRadiusItem := AScreenObject.ImportedValues.Add;
            ImportName := Format('ImportedWellRadius%d', [TimeIndex+1]);
            WellRadiusItem.Name := ImportName;
            WellRadiusItem.Values.Count := CellList.Count;
            Mnw1Item.WellRadius := rsObjectImportedValuesR
              + '("' + ImportName + '")';
          end
          else if Mnw1Cell.Rw < 0 then
          begin
            Mnw1Item.ConductanceMethod := mcmConductance;
            WellRadiusItem := AScreenObject.ImportedValues.Add;
            ImportName := Format('ImportedConductance%d', [TimeIndex+1]);
            WellRadiusItem.Name := ImportName;
            WellRadiusItem.Values.Count := CellList.Count;
            Mnw1Item.Conductance := rsObjectImportedValuesR
              + '("' + ImportName + '")';
          end
          else
          begin
            Mnw1Item.ConductanceMethod := mcmFixed;
            WellRadiusItem := nil;
            Mnw1Item.WellRadius := '0';
            Mnw1Item.Conductance := '0';
          end;

          SkinItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedSkin%d', [TimeIndex+1]);
          SkinItem.Name := ImportName;
          SkinItem.Values.Count := CellList.Count;
          Mnw1Item.SkinFactor := rsObjectImportedValuesR
            + '("' + ImportName + '")';

          if Mnw1Cell.DD then
          begin
            Mnw1Item.WaterLevelLimitType := mwlltRelative;
          end
          else
          begin
            Mnw1Item.WaterLevelLimitType := mwlltAbsolute;
          end;

          LimitItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedLimitingWaterLevel%d', [TimeIndex+1]);
          LimitItem.Name := ImportName;
          LimitItem.Values.Count := CellList.Count;
          Mnw1Item.LimitingWaterLevel := rsObjectImportedValuesR
            + '("' + ImportName + '")';

          RefElevItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedReferenceElevation%d', [TimeIndex+1]);
          RefElevItem.Name := ImportName;
          RefElevItem.Values.Count := CellList.Count;
          Mnw1Item.ReferenceElevation := rsObjectImportedValuesR
            + '("' + ImportName + '")';

          WaterQualityGroupItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedWaterQualityGroup%d', [TimeIndex+1]);
          WaterQualityGroupItem.Name := ImportName;
          WaterQualityGroupItem.Values.DataType := rdtInteger;
          WaterQualityGroupItem.Values.Count := CellList.Count;
          Mnw1Item.WaterQualityGroup := rsObjectImportedValuesI
            + '("' + ImportName + '")';

          LossCoefficientItem := AScreenObject.ImportedValues.Add;
          ImportName := Format('ImportedNonlinearHeadLossCoefficient%d', [TimeIndex+1]);
          LossCoefficientItem.Name := ImportName;
          LossCoefficientItem.Values.Count := CellList.Count;
          Mnw1Item.NonLinearLossCoefficient := rsObjectImportedValuesR
            + '("' + ImportName + '")';

          if Mnw1Cell.QCUT then
          begin
            Mnw1Item.PumpingLimitType := mpltAbsolute;
          end
          else if Mnw1Cell.QPercentCUT then
          begin
            Mnw1Item.PumpingLimitType := mpltPercent;
          end
          else
          begin
            Mnw1Item.PumpingLimitType := mpltNone;
          end;

          if Mnw1Item.PumpingLimitType in [mpltAbsolute, mpltPercent] then
          begin
            ActiveItem := AScreenObject.ImportedValues.Add;
            ImportName := Format('ImportedActiveWellRate%d', [TimeIndex+1]);
            ActiveItem.Name := ImportName;
            ActiveItem.Values.Count := CellList.Count;
            Mnw1Item.MinimumPumpingRate := rsObjectImportedValuesR
              + '("' + ImportName + '")';

            ReActivationItem := AScreenObject.ImportedValues.Add;
            ImportName := Format('ImportedReactivationWellRate%d', [TimeIndex+1]);
            ReActivationItem.Name := ImportName;
            ReActivationItem.Values.Count := CellList.Count;
            Mnw1Item.ReactivationPumpingRate := rsObjectImportedValuesR
              + '("' + ImportName + '")';
          end
          else
          begin
            Mnw1Item.MinimumPumpingRate := '0';
            Mnw1Item.ReactivationPumpingRate := '0';
            ActiveItem := nil;
            ReActivationItem := nil;
          end;

          if Mnw1Cell.Site <> '' then
          begin
            Mnw1Boundary.Site := Mnw1Cell.Site;
          end;

          for CellIndex := 0 to CellList.Count - 1 do
          begin
            Mnw1Cell := CellList[CellIndex];
            DesiredPumpingRateItem.Values.RealValues[CellIndex] := Mnw1Cell.Qdes;
            WaterQualityItem.Values.RealValues[CellIndex] := Mnw1Cell.QWval;
            if WellRadiusItem <> nil then
            begin
              WellRadiusItem.Values.RealValues[CellIndex] := Mnw1Cell.Rw;
            end;
            SkinItem.Values.RealValues[CellIndex] := Mnw1Cell.Skin;
            LimitItem.Values.RealValues[CellIndex] := Mnw1Cell.Hlim;
            RefElevItem.Values.RealValues[CellIndex] := Mnw1Cell.Href;
            WaterQualityGroupItem.Values.IntValues[CellIndex] := Mnw1Cell.Iwgrp;
            LossCoefficientItem.Values.RealValues[CellIndex] := Mnw1Cell.Cp_C;
            if Mnw1Item.PumpingLimitType in [mpltAbsolute, mpltPercent] then
            begin
              ActiveItem.Values.RealValues[CellIndex] := Mnw1Cell.Qfrcmn;
              ReActivationItem.Values.RealValues[CellIndex] := Mnw1Cell.Qfrcmx;
            end;
          end;

          if DesiredPumpingRateItem.Values.UniformValues then
          begin
            Mnw1Item.DesiredPumpingRate :=
              FortranFloatToStr(DesiredPumpingRateItem.Values.RealValues[0]);
            DesiredPumpingRateItem.Free;
          end;

          if WaterQualityItem.Values.UniformValues then
          begin
            Mnw1Item.WaterQuality :=
              FortranFloatToStr(WaterQualityItem.Values.RealValues[0]);
            WaterQualityItem.Free;
          end;

          if (WellRadiusItem <> nil) and WellRadiusItem.Values.UniformValues then
          begin
            if WellRadiusItem.Values.RealValues[0] > 0 then
            begin
              Mnw1Item.WellRadius :=
                FortranFloatToStr(WellRadiusItem.Values.RealValues[0]);
            end
            else
            begin
              Mnw1Item.Conductance :=
                FortranFloatToStr(WellRadiusItem.Values.RealValues[0]);
            end;
            WellRadiusItem.Free;
          end;

          if SkinItem.Values.UniformValues then
          begin
            Mnw1Item.SkinFactor :=
              FortranFloatToStr(SkinItem.Values.RealValues[0]);
            SkinItem.Free;
          end;

          if LimitItem.Values.UniformValues then
          begin
            Mnw1Item.LimitingWaterLevel :=
              FortranFloatToStr(LimitItem.Values.RealValues[0]);
            LimitItem.Free;
          end;

          if RefElevItem.Values.UniformValues then
          begin
            Mnw1Item.ReferenceElevation :=
              FortranFloatToStr(RefElevItem.Values.RealValues[0]);
            RefElevItem.Free;
          end;

          if WaterQualityGroupItem.Values.UniformValues then
          begin
            Mnw1Item.WaterQualityGroup :=
              IntToStr(WaterQualityGroupItem.Values.IntValues[0]);
            WaterQualityGroupItem.Free;
          end;

          if LossCoefficientItem.Values.UniformValues then
          begin
            Mnw1Item.NonLinearLossCoefficient :=
              FortranFloatToStr(LossCoefficientItem.Values.RealValues[0]);
            LossCoefficientItem.Free;
          end;

          if (ActiveItem <> nil) and ActiveItem.Values.UniformValues then
          begin
            Mnw1Item.MinimumPumpingRate :=
              FortranFloatToStr(ActiveItem.Values.RealValues[0]);
            ActiveItem.Free;
          end;

          if (ReActivationItem <> nil) and ReActivationItem.Values.UniformValues then
          begin
            Mnw1Item.ReactivationPumpingRate :=
              FortranFloatToStr(ReActivationItem.Values.RealValues[0]);
            ReActivationItem.Free;
          end;
        end
        else
        begin
          Mnw1Cell := CellList[0];
          Mnw1Item.DesiredPumpingRate := FortranFloatToStr(Mnw1Cell.Qdes);
          Mnw1Item.WaterQuality := FortranFloatToStr(Mnw1Cell.QWval);
          if Mnw1Cell.Rw > 0 then
          begin
            Mnw1Item.WellRadius := FortranFloatToStr(Mnw1Cell.Rw);
            Mnw1Item.Conductance := '0';
          end
          else if Mnw1Cell.Rw < 0 then
          begin
            Mnw1Item.WellRadius := '0';
            Mnw1Item.Conductance := FortranFloatToStr(Mnw1Cell.Rw);
          end
          else
          begin
            Mnw1Item.WellRadius := '0';
            Mnw1Item.Conductance := '0';
          end;
          Mnw1Item.SkinFactor := FortranFloatToStr(Mnw1Cell.Skin);
          if Mnw1Cell.DD then
          begin
            Mnw1Item.WaterLevelLimitType := mwlltRelative;
          end
          else
          begin
            Mnw1Item.WaterLevelLimitType := mwlltAbsolute;
          end;
          Mnw1Item.LimitingWaterLevel := FortranFloatToStr(Mnw1Cell.Hlim);
          Mnw1Item.ReferenceElevation := FortranFloatToStr(Mnw1Cell.Href);
          Mnw1Item.WaterQualityGroup := IntToStr(Mnw1Cell.Iwgrp);
          Mnw1Item.NonLinearLossCoefficient := FortranFloatToStr(Mnw1Cell.Cp_C);
          if Mnw1Cell.QCUT then
          begin
            Mnw1Item.PumpingLimitType := mpltAbsolute;
          end
          else if Mnw1Cell.QPercentCUT then
          begin
            Mnw1Item.PumpingLimitType := mpltPercent;
          end
          else
          begin
            Mnw1Item.PumpingLimitType := mpltNone;
          end;

          if Mnw1Item.PumpingLimitType in [mpltAbsolute, mpltPercent] then
          begin
            Mnw1Item.MinimumPumpingRate := FortranFloatToStr(Mnw1Cell.Qfrcmn);
            Mnw1Item.ReactivationPumpingRate := FortranFloatToStr(Mnw1Cell.Qfrcmx);
          end
          else
          begin
            Mnw1Item.MinimumPumpingRate := '0.';
            Mnw1Item.ReactivationPumpingRate := '0.';
          end;

          if Mnw1Cell.Site <> '' then
          begin
            Mnw1Boundary.Site := Mnw1Cell.Site;
          end;
        end;

      end;
    end;
  finally
    AList.Free;
  end;

end;

procedure TMnw1Importer.AssignCellToWells;
var
  CellsForOneWell: TMnw1Cells;
  CellIndex: Integer;
  ACell: TMnw1Cell;
//  UsedWells: TMnw1Wells;
  AWell: TMnw1Well;
  SelectedWell: TMnw1Well;
  Grid: TModflowGrid;
  WellIndex: Integer;
  procedure AssignCellsToAParticularWell;
  var
    WellIndex: Integer;
    FirstCell: TMnw1Cell;
    AWellList: TMnw1Wells;
  begin
    SelectedWell := nil;

    FirstCell := CellsForOneWell[0];
    AWellList := FWellLocationsPriorStressPeriod[FirstCell.Layer-1, FirstCell.Row-1, FirstCell.Column-1];
    if AWellList = nil then
    begin
      AWellList := TMnw1Wells.Create;
      FWellLists.Add(AWellList);
      FWellLocationsPriorStressPeriod[FirstCell.Layer-1, FirstCell.Row-1, FirstCell.Column-1] := AWellList;
    end;
    // Find well for these cells or create a new well.
    for WellIndex := 0 to AWellList.Count - 1 do
    begin
      AWell := AWellList[WellIndex];
      if (not AWell.UsedInThisStressPeriod) 
        and AWell.Last.SameLocations(CellsForOneWell) then
      begin
        SelectedWell := AWell;
//        AWellList.Delete(WellIndex);
        break;
      end;
    end;
    if SelectedWell = nil then
    begin
      SelectedWell := TMnw1Well.Create;
      AWellList.Add(SelectedWell);
      FWells.Add(SelectedWell);
    end;
    SelectedWell.UsedInThisStressPeriod := True;
    SelectedWell.Add(CellsForOneWell);
    FWellCurrentStressPeriod.Add(SelectedWell);
    CellsForOneWell := nil;
  end;
begin
  if FCellsCurrentStressPeriod.Count > 0 then
  begin
    for WellIndex := 0 to FWells.Count - 1 do
    begin
      FWells[WellIndex].UsedInThisStressPeriod := False;
    end;

    if FWellLocationsPriorStressPeriod = nil then
    begin
      Grid := frmGoPhast.PhastModel.ModflowGrid;
      SetLength(FWellLocationsPriorStressPeriod,
        Grid.LayerCount, Grid.RowCount, Grid.ColumnCount);
//      SetLength(FWellLocationsCurrentStressPeriod,
//        Grid.LayerCount, Grid.RowCount, Grid.ColumnCount);
    end;
//    UsedWells := TMnw1Wells.Create;
//    try
      CellsForOneWell := nil;
      for CellIndex := 0 to FCellsCurrentStressPeriod.Count - 1 do
      begin
        ACell := FCellsCurrentStressPeriod[CellIndex];
        if (not (ACell.Mn or ACell.Multi)) then
        begin
          if CellsForOneWell <> nil then
          begin
            AssignCellsToAParticularWell;
          end;
        end;
        if CellsForOneWell = nil then
        begin
          CellsForOneWell := TMnw1Cells.Create;
          CellsForOneWell.StartingStressPeriod := FCurrentStressPeriod;
          CellsForOneWell.EndingStressPeriod := FCurrentStressPeriod;
        end;
        CellsForOneWell.Add(ACell);
      end;
      // Find the well for the last group of cells or create a new well.
      AssignCellsToAParticularWell;
      FWellPriorStressPeriod.Clear;
      FWellPriorStressPeriod.AddRange(FWellCurrentStressPeriod.ToArray);
      FWellCurrentStressPeriod.Clear;
//    finally
//      UsedWells.Free;
//    end;
    FCellsCurrentStressPeriod.Clear;
  end;
end;

procedure TMnw1Importer.ReadData(const ALabel: string);
begin
  inherited;
  if ALabel = 'MXMNW IWL2CB IWELPT NOMOITER KSPREF:' then
  begin
    ReadDataSet1;
  end
  else if ALabel = 'LOSSTYPE PLossMNW:' then
  begin
    ReadDataSet2Version1;
  end
  else if ALabel = 'LOSSTYPE:' then
  begin
    ReadDataSet2Version2;
  end
  else if ALabel = 'MNWNAME:' then
  begin
    ReadMnwFilePrefix;
  end
  else if ALabel = 'MNW DATA SET 3:' then
  begin
    ReadDataSet3;
  end
  else if ALabel = 'ALLTIME:' then
  begin
    AssignAllTimeFlag;
  end
  else if ALabel = 'itmp:' then
  begin
    HandleCellsFromPriorStressPeriod;
    ReadDataSet4;
  end
  else if ALabel = 'ADD:' then
  begin
    ReadAddNewWells;
  end
  else if ALabel = 'Layer Row Column Qdes:' then
  begin
    ReadDataSet5_1;
  end
  else if ALabel = 'QCUT:' then
  begin
    ReadQCUT;
  end
  else if ALabel = '%CUT:' then
  begin
    ReadQPercentCUT;
  end
  else if ALabel = 'Qfrcmn, Qfrcmx:' then
  begin
    ReadActivationPumpingRate;
  end
  else if ALabel = 'Cp:C:' then
  begin
    ReadCp_C;
  end
  else if ALabel = 'MNWsite:' then
  begin
    ReadSiteLabel;
  end
  else if ALabel = 'DD:' then
  begin
    FCellsCurrentStressPeriod.Last.DD := True;
  end
  else if ALabel = 'QWval, Rw, Skin, Hlim, Href, Iwgrp:' then
  begin
    ReadDataSet5_2;
  end
  else if ALabel = 'MULTI:' then
  begin
    FCellsCurrentStressPeriod.Last.Multi :=  True;
  end
  else if ALabel = 'MN:' then
  begin
    FCellsCurrentStressPeriod.Last.Mn := True;
  end

end;

{ TMnw1Cells }

function TMnw1Cells.SameLocations(OtherCells: TMnw1Cells): boolean;
var
  Index: Integer;
begin
  result := Count = OtherCells.Count;
  if result then
  begin
    for Index := 0 to Count - 1 do
    begin
      result := Items[Index].SameLocation(OtherCells.Items[Index]);
      if not result then
      begin
        Exit;
      end;
    end;
  end;
end;

function TMnw1Cells.SameValues(OtherCells: TMnw1Cells): boolean;
var
  Index: Integer;
begin
  result := Count = OtherCells.Count;
  if result then 
  begin
    for Index := 0 to Count-1 do
    begin
      result := Items[Index].SameValues(OtherCells.Items[Index]);
      if not result then
      begin
        Exit;
      end;
    end;
  end;
end;

{ TMnw1Cell }

procedure TMnw1Cell.Assign(Source: TMnw1Cell);
begin
  Layer := Source.Layer;
  Row := Source.Row;
  Column := Source.Column;
  Qdes := Source.Qdes;
  QWval := Source.QWval;
  Rw := Source.Rw;
  Skin := Source.Skin;
  Hlim := Source.Hlim;
  Href := Source.Href;
  DD := Source.DD;
  Iwgrp := Source.Iwgrp;
  Cp_C := Source.Cp_C;
  QCUT := Source.QCUT;
  QPercentCUT := Source.QPercentCUT;
  Qfrcmn := Source.Qfrcmn;
  Qfrcmx := Source.Qfrcmx;
  Site := Source.Site;
  Multi := Source.Multi;
  Mn := Source.Mn;
end;

function TMnw1Cell.SameLocation(OtherCell: TMnw1Cell): boolean;
begin
  result := (Layer = OtherCell.Layer)
    and (Row = OtherCell.Row)
    and (Column = OtherCell.Column);
end;

function TMnw1Cell.SameValues(OtherCell: TMnw1Cell): boolean;
begin
  result := (Qdes = OtherCell.Qdes)
    and (QWval = OtherCell.QWval)
    and (Rw = OtherCell.Rw)
    and (Skin = OtherCell.Skin)
    and (Hlim = OtherCell.Hlim)
    and (Href = OtherCell.Href)
    and (DD = OtherCell.DD)
    and (Iwgrp = OtherCell.Iwgrp)
    and (Cp_C = OtherCell.Cp_C)
    and (QCUT = OtherCell.QCUT)
    and (QPercentCUT = OtherCell.QPercentCUT)
    and (Qfrcmn = OtherCell.Qfrcmn)
    and (Qfrcmx = OtherCell.Qfrcmx)
    and (Site = OtherCell.Site)
    and (Multi = OtherCell.Multi)
    and (Mn = OtherCell.Mn);
end;

{ TMnw1OutputFile }

procedure TMnw1OutputFile.SetFileName(const Value: string);
begin
  FFileName := StringReplace(Value, '/', '\', [rfReplaceAll, rfIgnoreCase]);
end;

{ TWellTabValues }

function TWellTabValues.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWellTabValue;
end;

function TWellTabValues.GetWellItems(Index: Integer): TWellTabValue;
begin
  result := Objects[Index] as TWellTabValue;
end;

{ TWellTabFiles }

function TWellTabFiles.ArrayMemberClass: TArrayMemberClass;
begin
  result := TWellTabValues;
end;

function TWellTabFiles.GetWellValues(Index: Integer): TWellTabValues;
begin
  result := Objects[Index] as TWellTabValues;
end;

{ TImportParameters }

destructor TImportParameters.Destroy;
begin
  Outline.Free;
  if TFile.Exists(HeadFile) then
  begin
    TFile.Delete(HeadFile);
  end;
  if TFile.Exists(FlowFile) then
  begin
    TFile.Delete(FlowFile);
  end;
  inherited;
end;

{ TSubModelHeadImporter }

function TSubModelHeadImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Submodel_Boundary_Head';
end;

{ TSubModelFlowImporter }

function TSubModelFlowImporter.ScreenObjectNameRoot: string;
begin
  result := 'Imported_Submodel_Boundary_Flow_' + Suffix;
end;

{ TSubModelInactiveImporter }

function TSubModelInactiveImporter.ScreenObjectNameRoot: string;
begin
  Result := 'BAS';
end;

end.
