{@abstract(
The main purpose of @name is to provide classes used in saving a
PHAST model to a stream and reading a PHAST model from a stream.)
@Link(TPhastModel) does this by making the significant features of a model
published properties.  Because @Link(TPhastModel)
is derived from TPersistent, this
automatically provides it with methods to read and write its published
properties.  Most of the published properties of @Link(TPhastModel) correspond
directly to settings in PHAST.  However @Link(TPhastModel.DataSetList) and
@Link(TPhastModel.ObjectList) are are descendants of TCollection.  They store
instances of @Link(TDataArray) and @Link(TScreenObject) respectively.

@link(TDataArrayManager.DefinePackageDataArrays) is used to define
@link(TDataArray)s that are used in the model.

@author(Richard B. Winston <rbwinst@usgs.gov>)}
unit PhastModelUnit;

interface

uses System.UITypes,
  Windows, Types, GuiSettingsUnit, SysUtils, Classes, Contnrs, Controls,
  Forms, ZoomBox2, ScreenObjectUnit, DataSetUnit, FastGEO, IniFiles,
  ModflowPackageSelectionUnit, PhastGridUnit, RbwParser, GoPhastTypes,
  PrintFrequency, TimeUnit, PhastDataSets, RealListUnit, CompressedImageUnit,
  LayerStructureUnit, AbstractGridUnit, ModflowGridUnit, SubscriptionUnit,
  ModflowPackagesUnit, ModflowOptionsUnit, ModflowTimeUnit, FluxObservationUnit,
  ModflowOutputControlUnit, ModflowParameterUnit, Graphics, ColorSchemes,
  ModflowTransientListParameterUnit, GlobalVariablesUnit, OrderedCollectionUnit,
  ModflowBoundaryDisplayUnit, ModflowBoundaryUnit,
  ModflowHfbDisplayUnit, EdgeDisplayUnit, ModflowUnitNumbers, HufDefinition,
  ModelMateClassesUnit, ModflowHobUnit, FormulaManagerUnit,
  PathlineReader, LegendUnit, DisplaySettingsUnit, ModflowCellUnit,
  ModflowGageUnit, ModflowHeadObsResults, GR32, AxCtrls, Generics.Collections,
  Generics.Defaults, Mt3dmsTimesUnit, Mt3dmsChemSpeciesUnit,
  Mt3dmsFluxObservationsUnit, SutraMeshUnit,
  SutraOptionsUnit, SutraTimeScheduleUnit,
  SutraOutputControlUnit, FishnetMeshGenerator,
  VectorDisplayUnit, ModflowFmpCropUnit, ModflowFmpSoilUnit,
  ModflowFmpClimateUnit, ModflowFmpAllotmentUnit, ModflowSwrTabfilesUnit,
  ModflowSwrReachGeometryUnit, ModflowSwrStructureUnit, ModflowSwrObsUnit,
  ModflowFmpFarmUnit, LinkedRastersUnit, FootprintGridUnit,
  FootprintPropertiesUnit, ModflowSwiObsUnit, ModflowRipPlantGroupsUnit,
  QuadMeshGenerator, GeoRefUnit, SutraBoundaryUnit, Character,
  ModflowIrregularMeshUnit, MeshRenumberingTypes, DrawMeshTypesUnit,
  Mt3dCtsSystemUnit, ObservationComparisonsUnit, PestObsUnit, SutraPestObsUnit,
  PestPropertiesUnit, PestParamGroupsUnit, PestObsGroupUnit, ObsInterfaceUnit,
  PilotPointDataUnit, SvdaPrepPropertiesUnit, PestObservationResults,
  Modflow6TimeSeriesCollectionsUnit, ModflowFmpIrrigationUnit,
  DataArrayManagerUnit, CrossSectionUnit,
  DataSetNamesUnit, ModelMuseInterfaceUnit, FormulaManagerInterfaceUnit,
  Modflow6DynamicTimeSeriesInterfaceUnit, Modflow6TimeSeriesCollectionsInterfaceUnit,
  PhastModelInterfaceUnit, OrderedCollectionInterfaceUnit,
  LockedGlobalVariableChangersInterfaceUnit, ScreenObjectInterfaceUnit,
  ColorSchemesInterface, DataArrayInterfaceUnit, SubscriptionInterfaceUnit,
  GlobalVariablesInterfaceUnit, AbstractGridInterfaceUnit, CellLocationUnit,
  ModelCellInterfaceUnit, ModflowParameterInterfaceUnit,
  InputDataObservationsUnit, Mt3dObservationResultsUnit;

{#BACKUP Documentation5\ModelMuse.hmxp}
{#BACKUP Documentation5\*.gif}
{#BACKUP Documentation5\MODFLOW 6 Supported Features.docx}
{#BACKUP Documentation5\Maps\*.*}
{#BACKUP Documentation5\ScreenShots\*.*}
{#BACKUP Documentation5\Topics\*.*}
{#BACKUP Documentation5\Topics\Invisible\*.*}
{#BACKUP Documentation5\Used Images\*.*}
{#BACKUP Documentation5\ModflowGuide\ModflowGuide.hmxp}
{#BACKUP Documentation5\ModflowGuide\*.gif}
{#BACKUP Documentation5\ModflowGuide\Baggage\*.*}
{#BACKUP Documentation5\ModflowGuide\Figures\*.*}
{#BACKUP Documentation5\ModflowGuide\Maps\*.*}
{#BACKUP Documentation5\ModflowGuide\Topics\*.*}
{#BACKUP Documentation5\ModpathGuide\ModPathGuide.hmxp}
{#BACKUP Documentation5\ModpathGuide\*.gif}
{#BACKUP Documentation5\ModpathGuide\images\*.*}
{#BACKUP Documentation5\ModpathGuide\Maps\*.*}
{#BACKUP Documentation5\ModpathGuide\Topics\*.*}
{#BACKUP Documentation5\ZoneBudgetGuide\ZoneBudgetGuide.hmxp}
{#BACKUP Documentation5\ZoneBudgetGuide\*.gif}
{#BACKUP Documentation5\ZoneBudgetGuide\Maps\*.*}
{#BACKUP Documentation5\ZoneBudgetGuide\Topics\*.*}
{#BACKUP Documentation5\Release\Release.hmxp}
{#BACKUP Documentation5\Release\*.gif}
{#BACKUP Documentation5\Release\Maps\*.*}
{#BACKUP Documentation5\Release\Topics\*.*}
{#BACKUP MF2005_Importer\*.f}
{#BACKUP MF2005_Importer\MF2005_Importer\MF2005_Importer.*}
{#BACKUP ..\Components\GraphicEX\*.pas}
{#BACKUP ..\Components\GraphicEX\*.OBJ}
{#BACKUP ..\Components\GraphicEX\*.chm}
{#BACKUP ..\Components\GraphicEX\*.inc}
{#BACKUP ..\Components\xyGraph\*.pas}
{#BACKUP ..\Components\xyGraph\*.dfm}
{#BACKUP ..\Components\xyGraph\*.dpr}
{#BACKUP ..\Components\xyGraph\*.dproj}
{#BACKUP ..\Components\xyGraph\*.hlp}
{#BACKUP ..\Components\xyGraph\*.cnt}
{#BACKUP ..\Components\xyGraph\*.ico}
{#BACKUP ..\Components\xyGraph\README.TXT}
{#BACKUP ..\Components\xyGraph\xygrph23.zip}


resourcestring
  NoSegmentsWarning = 'One or more objects do not define segments '
    + 'in the SFR package because they do not intersect the grid.';

const
  StrMT3DMS = 'MT3DMS';
  StrMt3dUsgs = 'MT3D-USGS';
  KSutra22  = 'SUTRA2.2';
  KSutra30  = 'SUTRA3.0';
  KSutra40  = 'SUTRA4.0';
  StrDisvgrb = '.disv.grb';
  StrDisgrb = '.dis.grb';

resourcestring
  StrVerticalConductanceDisplayName = StrVerticalConductance;
  StrAllLakeCellsAreI = 'All Lake cells are inactive except for ' +
  'lakes that only have vertical connections.';
  StrGwtSolver = 'GWT Solver: IMS';
  StrGwtMST = 'GWT MST: Mobile Storage and Transport';
  StrGwtIST = 'GWT IST: Immobile Storage and Transport';
  StrSpecifiedTemp = 'Specified Temperature';
  StrSpecifiedConc = 'Specified Concentration';
  StrFluidFlux = 'Fluid Flux';
  StrMassFlux = 'Mass Flux';
  StrEnergyFlux = 'Energy Flux';
  StrSTRflows = 'STR_flows';
  StrRIVflows = 'RIV_flows';
  StrDRNflows = 'DRN_flows';
  StrGHBflows = 'GHB_flows';
  StrCHOBflows = 'CHOB_flows';
  StrTheFollowingSWRSt = 'The following SWR structures are never used because'
    + ' no times have been defined for them on the Timing tab of the SWR '
    + 'Structures dialog box.';
  StrHeads = 'Heads';
  StrHeadChanges = 'Head_Changes';
  strUzfClassification = 'UZF';
  StrUzfFmpClassifiation = 'UZF and FMP';
  StrFmp2Classifiation = 'FMP';
  StrCFPClassifiation = 'CFP';
  StrSwrClassifiation = 'SWR';
  StrHydrology = 'Hydrology';
  StrChemistry = 'Chemistry';
  StrOutput = 'Output';
  WetError = 'The wetting option is active but '
    + 'no layers of the proper type have been specified.';
  StrNewDataSet = 'NewDataSet';
  rsResClassificaton = 'Reservoir';
  rsLakeClassificaton = 'Lake';
  StrMT3DMS_GWT_Classificaton = 'MT3DMS, MT3D-USGS, or GWT';
  StrMT3DMS_GWT_GWE_Classificaton = 'MT3DMS, MT3D-USGS, GWT, or GWE';
  StrMt3dClassification = 'MT3DMS or MT3D-USGS';
  StrGwtClassification = 'GWT: Groundwater Transport';
  StrGweClassification = 'GWE: Groundwater Energy Transport';
  StrGwtGweClassification = 'GWT, GWE: Groundwater Solute or Energy Transport';

  StrNoStressPeriods = 'No stress periods have been defined for MT3DMS.';
  StrMODFLOWFHBHeads = 'FHB Heads';
  StrMODFLOWFHBFlows = 'FHB Flows';
//  StrFarmID = 'Farm_ID';
  StrFootprintInputClassification = 'WellFootprint';
  StrTheFollowingObjectNoCells = 'The following objects do not assign proper' +
  'ties to any cells.';
  StrPorosityLessThanO = 'Porosity less than or equal to zero in layer %d.';
const
  WettableLayers = [1,3];


resourcestring


  StrWrongHeadModpath = 'Wrong head output file type for MODPATH';
  StrWrongHeadModpathDetailed = 'MODPATH version 6 requires that heads be '
  + 'saved in a binary format instead of a text format. You can change the '
  + 'format in the Output Control dialog box.';
  Str0sMultipliedByT = '%0:s multiplied by the parameter value for "%1:s."';
  StrFileNotFound = 'File not found.';

type
  // etExportCSV results in exporting data to a .csv file rather than to
  // a model input file. It is hidden because it does not have general
  // applicability.
  TEvaluationType = (etExport, etDisplay, etExportCSV);

  // @name represents how PHAST results are printed - XY orientation or
  // XZ orientation.
  TpgPrintOrientation = (pgXY, pgXZ);

  TModelMateOperation = (mmoImport, mmoExport);

  TPestExportChoice = (pecNone, pecPestCheck, pecPest);

  TGetZoomBoxEvent = procedure (Sender: TObject; VD: TViewDirection;
    var ZoomBox: TQrbwZoomBox2) of object;
  TGetCurrentScreenObjectEvent = procedure (Sender: TObject; VD: TViewDirection;
    var ScreenObject: TScreenObject) of object;
  TConvertPointEvent = procedure (Sender: TObject; VD: TViewDirection;
    const RealPoint: TPoint2D; var ScreenCoordinate: TPoint) of object;
  TCheckScreenObjectEvent = procedure(Sender: TObject;
    ScreenObject: TScreenObject; var IsACurrentScreenObject: boolean) of object;

  TProgramLocations = class(TPersistent)
  private
    FTextEditorLocation: string;
    FModflowLocation: string;
    FModPathLocation: string;
    FModelMonitorLocation: string;
    FPhastLocation: string;
    FZoneBudgetLocation: string;
    FModelMateLocation: string;
    FModflowLgrLocation: string;
    FModflowNwtLocation: string;
    FMt3dmsLocation: string;
    FModPathLocationV6: string;
    FSutra22Location: string;
    FModflowLgr2Location: string;
    FModflowFmpLocation: string;
    FModflowCfpLocation: string;
    FGmshLocation: string;
    FFootprintLocation: string;
    FModflow6Location: string;
    FGeompackLocation: string;
    FMt3dUsgsLocation: string;
    FModPathLocationV7: string;
    FZoneBudgetLocationMf6: string;
    FSutra30Location: string;
    FPestDirectory: string;
    FSutra40Location: string;
    FModflowOwhmV2Location: string;
    function GetTextEditorLocation: string;
    procedure SetModflowLocation(const Value: string);
    procedure SetModPathLocation(const Value: string);
    procedure SetModelMonitorLocation(const Value: string);
    procedure SetPhastLocation(const Value: string);
    procedure SetZoneBudgetLocation(const Value: string);
    procedure SetModelMateLocation(const Value: string);
    procedure SetModflowLgrLocation(const Value: string);
    procedure SetModflowNwtLocation(const Value: string);
    procedure SetMt3dmsLocation(const Value: string);
    procedure SetModPathLocationV6(const Value: string);
    procedure SetSutra22Location(const Value: string);
    procedure SetModflowLgr2Location(const Value: string);
    procedure SetModflowFmpLocation(const Value: string);
    procedure SetModflowCfpLocation(const Value: string);
    procedure SetGmshLocation(const Value: string);
    procedure SetFootprintLocation(const Value: string);
    procedure SetModflow6Location(const Value: string);
    procedure SetGeompackLocation(const Value: string);
    procedure SetMt3dUsgsLocation(const Value: string);
    procedure SetModPathLocationV7(const Value: string);
    procedure SetZoneBudgetLocationMf6(const Value: string);
    procedure SetSutra30Location(const Value: string);
    procedure SetPestDirectory(const Value: string);
    procedure SetSutra40Location(const Value: string);
    procedure SetModflowOwhmV2Location(const Value: string);
  public
    procedure Assign(Source: TPersistent); override;
    Constructor Create;
    procedure WriteToIniFile(IniFile: TMemInifile);
    procedure ReadFromIniFile(IniFile: TMemInifile);
  published
    property ModflowLocation: string read FModflowLocation
      write SetModflowLocation;
    property TextEditorLocation: string read GetTextEditorLocation
      write FTextEditorLocation;
    property ModPathLocation: string read FModPathLocation
      write SetModPathLocation;
    property ModPathLocationVersion6: string read FModPathLocationV6
      write SetModPathLocationV6;
    property ModPathLocationVersion7: string read FModPathLocationV7
      write SetModPathLocationV7;
    property ModelMonitorLocation: string read FModelMonitorLocation
      write SetModelMonitorLocation;
    property PhastLocation: string read FPhastLocation write SetPhastLocation;
    property ZoneBudgetLocation: string read FZoneBudgetLocation
      write SetZoneBudgetLocation;
    property ZoneBudgetLocationMf6: string read FZoneBudgetLocationMf6
      write SetZoneBudgetLocationMf6;
    property ModelMateLocation: string read FModelMateLocation
      write SetModelMateLocation;
    property ModflowLgrLocation: string read FModflowLgrLocation
      write SetModflowLgrLocation;
    property ModflowLgr2Location: string read FModflowLgr2Location
      write SetModflowLgr2Location;
    property ModflowNwtLocation: string read FModflowNwtLocation
      write SetModflowNwtLocation;
    property ModflowOwhmLocation: string read FModflowFmpLocation
      write SetModflowFmpLocation;
    property Mt3dmsLocation: string read FMt3dmsLocation
      write SetMt3dmsLocation;
    property Mt3dUsgsLocation: string read FMt3dUsgsLocation
      write SetMt3dUsgsLocation;
    property Sutra22Location: string read FSutra22Location
      write SetSutra22Location;
    property Sutra30Location: string read FSutra30Location
      write SetSutra30Location;
    property Sutra40Location: string read FSutra40Location
      write SetSutra40Location;
    property ModflowCfpLocation: string read FModflowCfpLocation
      write SetModflowCfpLocation;
    property GmshLocation: string read FGmshLocation write SetGmshLocation;
    property GeompackLocation: string read FGeompackLocation write SetGeompackLocation;
    property FootprintLocation: string read FFootprintLocation
      write SetFootprintLocation;
    // @name is retained for backwards compatiblility. It has been replaced by
    // @link(Modflow6Location).
    property Modflow2015Location: string read FModflow6Location
      write SetModflow6Location stored False;
    property Modflow6Location: string read FModflow6Location
      write SetModflow6Location;
    property PestDirectory: string read FPestDirectory write SetPestDirectory;
    property ModflowOwhmV2Location: string read FModflowOwhmV2Location
      write SetModflowOwhmV2Location;
  end;

  {
    @abstract(@name is used to save or load a @link(TDataArray) from a stream or
    save it to a stream.)  For the most part, writing to @name
    simply stores the value being written to @name in one of the
    private fields of @name whereas reading from @name
    reads data not from the private field but from the associated data set.
    The private procedure @Link(TDataSetItem.UpdateDataSet) is used to
    transfer the stored values to an actual data set.

    See @link(TDataSetCollection).
  }
  TDataSetItem = class(TCollectionItem)
  private
    // @name: @link(TDataArray);
    // @name is set to a subcomponent in @link(SetDataSetClass).  This is
    // required for the data set properties to be saved to file.
    // See @link(DataSet).
    FDataSet: TDataArray;
    // @name: string;
    // See @link(DataSetFormula).
    FDataSetFormula: string;
    // @name: string;
    // See @link(MixtureFormula).
    FMixtureFormula: string;
    FParameterFormula: string;
    // See @link(DataSetClass).
    function GetDataSetClass: string;
    // See @link(DataSetFormula).
    function GetDataSetFormula: string;
    // See @link(MixtureFormula).
    function GetMixtureFormula: string;
    // See @link(DataSetClass).
    procedure SetDataSetClass(const Value: string);
    // @name calls TDataArray.@link(TObserver.UpdateWithName).
    procedure UpdateDataSet;
    function GetParameterFormula: string;
  public
    // If Source is a @classname,
    // @name copies the published properties of Source.
    // It seems that @name is never called.
    procedure Assign(Source: TPersistent); override;
  published
    // @name is the name of the the class of @link(DataSet).
    // @name must be read before @link(DataSet) to ensure that @link(DataSet) is
    // created before being read.
    property DataSetClass: string read GetDataSetClass write SetDataSetClass;
    // @name is the formula used with @link(DataSet).
    property DataSetFormula: string read GetDataSetFormula write
      FDataSetFormula;
    // See @link(DataSetFormula)
    // @name is only for backwards compatibility.
    property DataSetFunction: string read GetDataSetFormula write
      FDataSetFormula stored False;
    // @name is the formula for mixtures used with @link(DataSet).
    property MixtureFormula: string read GetMixtureFormula write
      FMixtureFormula;
    // See @link(MixtureFormula)
    // @name is only for backwards compatibility.
    property MixtureFunction: string read GetMixtureFormula write
      FMixtureFormula stored False;
    property ParameterFormula: string read GetParameterFormula
      write FParameterFormula;
    // @name is the @link(TDataArray) whose values are being saved or read.
    // @name must be read after @link(DataSetClass) to ensure that it is
    // created before being read.
    property DataSet: TDataArray read FDataSet;
  end;

  {
    @abstract(@name is a collection of @Link(TDataSetItem)s.)
  }
  TDataSetCollection = class(TCollection)
  public
    // @name creates an instance of @classname that will store
    // @link(TDataSetItem)s in its Items property.
    constructor Create;
  end;

  {@abstract(@name stores the default units in PHAST.)}
  TUnits = class(TPersistent)
  private
    // @name: @link(TLengthUnits);
    // See @link(DefaultDispersivityUnits).
    FDefaultDispersivityUnits: TLengthUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultFluxLengthUnits).
    FDefaultFluxLengthUnits: TLengthUnits;
    // @name: @link(TTimeUnits);
    // See @link(DefaultFluxTimeUnits).
    FDefaultFluxTimeUnits: TTimeUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultHeadUnits).
    FDefaultHeadUnits: TLengthUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultHorizontalGridUnits).
    FDefaultHorizontalGridUnits: TLengthUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultHydraulicConductivityLengthUnits).
    FDefaultHydraulicConductivityLengthUnits: TLengthUnits;
    // @name: @link(TTimeUnits);
    // See @link(DefaultHydraulicConductivityTimeUnits).
    FDefaultHydraulicConductivityTimeUnits: TTimeUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultLeakyHydraulicConductivityLengthUnits).
    FDefaultLeakyHydraulicConductivityLengthUnits: TLengthUnits;
    // @name: @link(TTimeUnits);
    // See @link(DefaultLeakyHydraulicConductivityTimeUnits).
    FDefaultLeakyHydraulicConductivityTimeUnits: TTimeUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultLeakyThicknessUnits).
    FDefaultLeakyThicknessUnits: TLengthUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultRiverBedHydraulicConductivityLengthUnits).
    FDefaultRiverBedHydraulicConductivityLengthUnits: TLengthUnits;
    // @name: @link(TTimeUnits);
    // See @link(DefaultRiverBedHydraulicConductivityTimeUnits).
    FDefaultRiverBedHydraulicConductivityTimeUnits: TTimeUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultRiverBedThicknessUnits).
    FDefaultRiverBedThicknessUnits: TLengthUnits;
    // @name: @link(TInverseLengthUnits);
    // See @link(DefaultSpecificStorageUnits).
    FDefaultSpecificStorageUnits: TInverseLengthUnits;
    // @name: @link(TTimeUnits);
    // See @link(DefaultTimeUnits).
    FDefaultTimeUnits: TTimeUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultVerticalGridUnits).
    FDefaultVerticalGridUnits: TLengthUnits;
    // @name: @link(TLengthUnits);
    // See @link(DefaultWellDiameterUnits).
    FDefaultWellDiameterUnits: TLengthUnits;
    // @name: @link(TTimeUnits);
    // See @link(DefaultWellFlowTimeUnits).
    FDefaultWellFlowTimeUnits: TTimeUnits;
    // @name: @link(TVolumeUnits);
    // See @link(DefaultWellFlowVolumnUnits).
    FDefaultWellFlowVolumnUnits: TVolumeUnits;
    // See @link(DefaultDispersivityUnits).
    procedure SetDefaultDispersivityUnits(const Value: TLengthUnits);
    // See @link(DefaultFluxLengthUnits).
    procedure SetDefaultFluxLengthUnits(const Value: TLengthUnits);
    // See @link(DefaultFluxTimeUnits).
    procedure SetDefaultFluxTimeUnits(const Value: TTimeUnits);
    // See @link(DefaultHeadUnits).
    procedure SetDefaultHeadUnits(const Value: TLengthUnits);
    // See @link(DefaultHorizontalGridUnits).
    procedure SetDefaultHorizontalGridUnits(const Value: TLengthUnits);
    // See @link(DefaultHydraulicConductivityLengthUnits).
    procedure SetDefaultHydraulicConductivityLengthUnits(
      const Value: TLengthUnits);
    // See @link(DefaultHydraulicConductivityTimeUnits).
    procedure SetDefaultHydraulicConductivityTimeUnits(
      const Value: TTimeUnits);
    // See @link(DefaultLeakyHydraulicConductivityLengthUnits).
    procedure SetDefaultLeakyHydraulicConductivityLengthUnits(
      const Value: TLengthUnits);
    // See @link(DefaultLeakyHydraulicConductivityTimeUnits).
    procedure SetDefaultLeakyHydraulicConductivityTimeUnits(
      const Value: TTimeUnits);
    // See @link(DefaultLeakyThicknessUnits).
    procedure SetDefaultLeakyThicknessUnits(const Value: TLengthUnits);
    // See @link(DefaultRiverBedHydraulicConductivityLengthUnits).
    procedure SetDefaultRiverBedHydraulicConductivityLengthUnits(
      const Value: TLengthUnits);
    // See @link(DefaultRiverBedHydraulicConductivityTimeUnits).
    procedure SetDefaultRiverBedHydraulicConductivityTimeUnits(
      const Value: TTimeUnits);
    // See @link(DefaultRiverBedThicknessUnits).
    procedure SetDefaultRiverBedThicknessUnits(const Value: TLengthUnits);
    // See @link(DefaultSpecificStorageUnits).
    procedure SetDefaultSpecificStorageUnits(
      const Value: TInverseLengthUnits);
    // See @link(DefaultTimeUnits).
    procedure SetDefaultTimeUnits(const Value: TTimeUnits);
    // See @link(DefaultVerticalGridUnits).
    procedure SetDefaultVerticalGridUnits(const Value: TLengthUnits);
    // See @link(DefaultWellDiameterUnits).
    procedure SetDefaultWellDiameterUnits(const Value: TLengthUnits);
    // See @link(DefaultWellFlowTimeUnits).
    procedure SetDefaultWellFlowTimeUnits(const Value: TTimeUnits);
    // See @link(DefaultWellFlowVolumnUnits).
    procedure SetDefaultWellFlowVolumnUnits(const Value: TVolumeUnits);
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create;
  published
    // @name is the default units for dispersivity in PHAST.
    property DefaultDispersivityUnits: TLengthUnits read
      FDefaultDispersivityUnits write SetDefaultDispersivityUnits;
    // @name is the default length units for flux in PHAST.
    property DefaultFluxLengthUnits: TLengthUnits read FDefaultFluxLengthUnits
      write SetDefaultFluxLengthUnits;
    // @name is the default time units for flux in PHAST.
    property DefaultFluxTimeUnits: TTimeUnits read FDefaultFluxTimeUnits write
      SetDefaultFluxTimeUnits;
    // @name is the default units for head in PHAST.
    property DefaultHeadUnits: TLengthUnits read FDefaultHeadUnits write
      SetDefaultHeadUnits;
    // @name is the default units for the horizontal grid dimensions in PHAST.
    property DefaultHorizontalGridUnits: TLengthUnits read
      FDefaultHorizontalGridUnits write SetDefaultHorizontalGridUnits;
    // @name is the default length units for the
    // hydraulic conductivity in PHAST.
    property DefaultHydraulicConductivityLengthUnits: TLengthUnits read
      FDefaultHydraulicConductivityLengthUnits write
      SetDefaultHydraulicConductivityLengthUnits;
    // @name is the default time units for the hydraulic conductivity in PHAST.
    property DefaultHydraulicConductivityTimeUnits: TTimeUnits read
      FDefaultHydraulicConductivityTimeUnits write
      SetDefaultHydraulicConductivityTimeUnits;
    // @name is the default length units for the
    // hydraulic conductivity of the leaky boundary condition in PHAST.
    property DefaultLeakyHydraulicConductivityLengthUnits: TLengthUnits read
      FDefaultLeakyHydraulicConductivityLengthUnits write
      SetDefaultLeakyHydraulicConductivityLengthUnits;
    // @name is the default time units for the hydraulic
    // conductivity of the leaky boundary condition in PHAST.
    property DefaultLeakyHydraulicConductivityTimeUnits: TTimeUnits read
      FDefaultLeakyHydraulicConductivityTimeUnits write
      SetDefaultLeakyHydraulicConductivityTimeUnits;
    // @name is the default units for the thickness of the
    // leaky boundary condition in PHAST.
    property DefaultLeakyThicknessUnits: TLengthUnits read
      FDefaultLeakyThicknessUnits write SetDefaultLeakyThicknessUnits;
    // @name is the default length units for the hydraulic
    // conductivity of the river boundary condition in PHAST.
    property DefaultRiverBedHydraulicConductivityLengthUnits: TLengthUnits read
      FDefaultRiverBedHydraulicConductivityLengthUnits write
      SetDefaultRiverBedHydraulicConductivityLengthUnits;
    // @name is the default time units for the hydraulic
    // conductivity of the river boundary condition in PHAST.
    property DefaultRiverBedHydraulicConductivityTimeUnits: TTimeUnits read
      FDefaultRiverBedHydraulicConductivityTimeUnits write
      SetDefaultRiverBedHydraulicConductivityTimeUnits;
    // @name is the default units for the thickness
    // of the river boundary condition in PHAST.
    property DefaultRiverBedThicknessUnits: TLengthUnits read
      FDefaultRiverBedThicknessUnits write SetDefaultRiverBedThicknessUnits;
    // @name is the default units for the specific storage in PHAST.
    property DefaultSpecificStorageUnits: TInverseLengthUnits read
      FDefaultSpecificStorageUnits write SetDefaultSpecificStorageUnits;
    // @name is the default units for the time in PHAST.
    property DefaultTimeUnits: TTimeUnits read FDefaultTimeUnits write
      SetDefaultTimeUnits;
    // @name is the default units for the vertical grid dimensions in PHAST.
    property DefaultVerticalGridUnits: TLengthUnits read
      FDefaultVerticalGridUnits write SetDefaultVerticalGridUnits;
    // @name is the default units for the well diameter
    // in the well boundary condition in PHAST.
    property DefaultWellDiameterUnits: TLengthUnits read
      FDefaultWellDiameterUnits write SetDefaultWellDiameterUnits;
    // @name is the default time units for the pumping
    // rate in the well boundary condition in PHAST.
    property DefaultWellFlowTimeUnits: TTimeUnits
      read FDefaultWellFlowTimeUnits write SetDefaultWellFlowTimeUnits;
    // @name is the default volume units for the pumping
    // rate in the well boundary condition in PHAST.
    property DefaultWellFlowVolumnUnits: TVolumeUnits read
      FDefaultWellFlowVolumnUnits write SetDefaultWellFlowVolumnUnits;
  end;

  {@abstract(@name stores options related to the PRINT_INITIAL
    data block in PHAST.)}
  TPrintInitial = class(TPersistent)
  private
    // @name: boolean;
    // See @link(PrintInitialBoundaryConditions).
    FPrintInitialBoundaryConditions: boolean;
    // @name: boolean;
    // See @link(PrintInitialComponents).
    FPrintInitialComponents: boolean;
    // @name: boolean;
    // See @link(PrintInitialConductance).
    FPrintInitialConductance: boolean;
    // @name: boolean;
    // See @link(PrintInitialEchoInput).
    FPrintInitialEchoInput: boolean;
    // @name: boolean;
    // See @link(PrintInitialFluidProperties).
    FPrintInitialFluidProperties: boolean;
    // @name: boolean;
    // See @link(PrintInitialForceChemistryPrint).
    FPrintInitialForceChemistryPrint: boolean;
    // @name: boolean;
    // See @link(PrintInitialHDF_Chemistry).
    FPrintInitialHDF_Chemistry: boolean;
    // @name: boolean;
    // See @link(PrintInitialHDF_Heads).
    FPrintInitialHDF_Heads: boolean;
    // @name: boolean;
    // See @link(PrintInitialHDF_SteadyFlowVelocites).
    FPrintInitialHDF_SteadyFlowVelocites: boolean;
    // @name: boolean;
    // See @link(PrintInitialHeads).
    FPrintInitialHeads: boolean;
    // @name: boolean;
    // See @link(PrintInitialMediaProperties).
    FPrintInitialMediaProperties: boolean;
    // @name: boolean;
    // See @link(PrintInitialSolutionMethod).
    FPrintInitialSolutionMethod: boolean;
    // @name: boolean;
    // See @link(PrintInitialSteadyFlowVelocities).
    FPrintInitialSteadyFlowVelocities: boolean;
    // @name: boolean;
    // See @link(PrintInitialWells).
    FPrintInitialWells: boolean;
    // @name: boolean;
    // See @link(PrintInitialXYZ_Chemistry).
    FPrintInitialXYZ_Chemistry: boolean;
    // @name: boolean;
    // See @link(PrintInitialXYZ_Components).
    FPrintInitialXYZ_Components: boolean;
    // @name: boolean;
    // See @link(PrintInitialXYZ_Heads).
    FPrintInitialXYZ_Heads: boolean;
    // @name: boolean;
    // See @link(PrintInitialXYZ_SteadyFlowVelocities).
    FPrintInitialXYZ_SteadyFlowVelocities: boolean;
    // @name: boolean;
    // See @link(PrintInitialXYZ_Wells).
    FPrintInitialXYZ_Wells: boolean;
    // See @link(PrintInitialBoundaryConditions).
    procedure SetPrintInitialBoundaryConditions(const Value: boolean);
    // See @link(PrintInitialComponents).
    procedure SetPrintInitialComponents(const Value: boolean);
    // See @link(PrintInitialConductance).
    procedure SetPrintInitialConductance(const Value: boolean);
    // See @link(PrintInitialEchoInput).
    procedure SetPrintInitialEchoInput(const Value: boolean);
    // See @link(PrintInitialFluidProperties).
    procedure SetPrintInitialFluidProperties(const Value: boolean);
    // See @link(PrintInitialForceChemistryPrint).
    procedure SetPrintInitialForceChemistryPrint(const Value: boolean);
    // See @link(PrintInitialHDF_Chemistry).
    procedure SetPrintInitialHDF_Chemistry(const Value: boolean);
    // See @link(PrintInitialHDF_Heads).
    procedure SetPrintInitialHDF_Heads(const Value: boolean);
    // See @link(PrintInitialHDF_SteadyFlowVelocites).
    procedure SetPrintInitialHDF_SteadyFlowVelocites(const Value: boolean);
    // See @link(PrintInitialHeads).
    procedure SetPrintInitialHeads(const Value: boolean);
    // See @link(PrintInitialMediaProperties).
    procedure SetPrintInitialMediaProperties(const Value: boolean);
    // See @link(PrintInitialSolutionMethod).
    procedure SetPrintInitialSolutionMethod(const Value: boolean);
    // See @link(PrintInitialSteadyFlowVelocities).
    procedure SetPrintInitialSteadyFlowVelocities(const Value: boolean);
    // See @link(PrintInitialWells).
    procedure SetPrintInitialWells(const Value: boolean);
    // See @link(PrintInitialXYZ_Chemistry).
    procedure SetPrintInitialXYZ_Chemistry(const Value: boolean);
    // See @link(PrintInitialXYZ_Components).
    procedure SetPrintInitialXYZ_Components(const Value: boolean);
    // See @link(PrintInitialXYZ_Heads).
    procedure SetPrintInitialXYZ_Heads(const Value: boolean);
    // See @link(PrintInitialXYZ_SteadyFlowVelocities).
    procedure SetPrintInitialXYZ_SteadyFlowVelocities(
      const Value: boolean);
    // See @link(PrintInitialXYZ_Wells).
    procedure SetPrintInitialXYZ_Wells(const Value: boolean);
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create;
  published
    // @name specifies whether PHAST will print the initial boundary conditions.
    property PrintInitialBoundaryConditions: boolean read
      FPrintInitialBoundaryConditions write SetPrintInitialBoundaryConditions;
    // @name specifies whether PHAST will print the initial components.
    property PrintInitialComponents: boolean read FPrintInitialComponents
      write SetPrintInitialComponents;
    // @name specifies whether PHAST will print the initial conductance.
    property PrintInitialConductance: boolean read FPrintInitialConductance
      write SetPrintInitialConductance;
    // @name specifies whether PHAST will echo the input.
    property PrintInitialEchoInput: boolean read FPrintInitialEchoInput write
      SetPrintInitialEchoInput;
    // @name specifies whether PHAST will print the initial fluid properties.
    property PrintInitialFluidProperties: boolean read
      FPrintInitialFluidProperties write SetPrintInitialFluidProperties;
    // @name specifies whether PHAST will force the chemistry to be printed.
    property PrintInitialForceChemistryPrint: boolean read
      FPrintInitialForceChemistryPrint write SetPrintInitialForceChemistryPrint;
    // @name specifies whether PHAST will print the
    // initial chemistry in the HDF file.
    property PrintInitialHDF_Chemistry: boolean read FPrintInitialHDF_Chemistry
      write SetPrintInitialHDF_Chemistry;
    // @name specifies whether PHAST will print the
    //
    // initial heads in the HDF file.
    property PrintInitialHDF_Heads: boolean read FPrintInitialHDF_Heads write
      SetPrintInitialHDF_Heads;
    // @name specifies whether PHAST will print the
    // steady flow velocities in the HDF file.
    property PrintInitialHDF_SteadyFlowVelocites: boolean read
      FPrintInitialHDF_SteadyFlowVelocites write
      SetPrintInitialHDF_SteadyFlowVelocites;
    // @name specifies whether PHAST will print the initial heads.
    property PrintInitialHeads: boolean read FPrintInitialHeads write
      SetPrintInitialHeads;
    // @name specifies whether PHAST will print the initial media properties.
    property PrintInitialMediaProperties: boolean read
      FPrintInitialMediaProperties write SetPrintInitialMediaProperties;
    // @name specifies whether PHAST will print the initial solution method.
    property PrintInitialSolutionMethod: boolean
      read FPrintInitialSolutionMethod write SetPrintInitialSolutionMethod;
    // @name specifies whether PHAST will print
    // the initial steady flow velocities.
    property PrintInitialSteadyFlowVelocities: boolean read
      FPrintInitialSteadyFlowVelocities write
      SetPrintInitialSteadyFlowVelocities;
    // @name specifies whether PHAST will print the initial wells.
    property PrintInitialWells: boolean read FPrintInitialWells write
      SetPrintInitialWells;
    // @name specifies whether PHAST will print
    // the initial chemistry at X,Y,Z locations.
    property PrintInitialXYZ_Chemistry: boolean read FPrintInitialXYZ_Chemistry
      write SetPrintInitialXYZ_Chemistry;
    // @name specifies whether PHAST will print
    // the initial components at X,Y,Z locations.
    property PrintInitialXYZ_Components: boolean
      read FPrintInitialXYZ_Components write SetPrintInitialXYZ_Components;
    // @name specifies whether PHAST will print
    // the initial heads at X,Y,Z locations.
    property PrintInitialXYZ_Heads: boolean read FPrintInitialXYZ_Heads
      write SetPrintInitialXYZ_Heads;
    // @name specifies whether PHAST will print
    // the initial steady flow velocities at X,Y,Z locations.
    property PrintInitialXYZ_SteadyFlowVelocities: boolean
      read FPrintInitialXYZ_SteadyFlowVelocities
      write SetPrintInitialXYZ_SteadyFlowVelocities;
    // @name specifies whether PHAST will print
    // the initial wells at X,Y,Z locations.
    property PrintInitialXYZ_Wells: boolean read FPrintInitialXYZ_Wells
      write SetPrintInitialXYZ_Wells;
  end;

  {@abstract(@name is used to store options related to the grid in PHAST.)}
  TGridOptions = class(TPersistent)
  private
    // @name: boolean;
    // See @link(ChemicalDimensionX).
    FChemicalDimensionX: boolean;
    // @name: boolean;
    // See @link(ChemicalDimensionY).
    FChemicalDimensionY: boolean;
    // @name: boolean;
    // See @link(ChemicalDimensionZ).
    FChemicalDimensionZ: boolean;
    // @name: boolean;
    // See @link(PrintOrientation).
    FPrintOrientation: TpgPrintOrientation;
    // See @link(ChemicalDimensionX).
    procedure SetChemicalDimensionX(const Value: boolean);
    // See @link(ChemicalDimensionY).
    procedure SetChemicalDimensionY(const Value: boolean);
    // See @link(ChemicalDimensionZ).
    procedure SetChemicalDimensionZ(const Value: boolean);
    // See @link(PrintOrientation).
    procedure SetPrintOrientation(const Value: TpgPrintOrientation);
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create;
  published
    // @name determines whether chemical calculations in the X direction
    // are performed.
    property ChemicalDimensionX: boolean read FChemicalDimensionX
      write SetChemicalDimensionX;
    // @name determines whether chemical calculations in the Y direction
    // are performed.
    property ChemicalDimensionY: boolean read FChemicalDimensionY
      write SetChemicalDimensionY;
    // @name determines whether chemical calculations in the Z direction
    // are performed.
    property ChemicalDimensionZ: boolean read FChemicalDimensionZ
      write SetChemicalDimensionZ;
    // @name determines whether PHAST prints data in an X,Y or X,Z orientation.
    property PrintOrientation: TpgPrintOrientation read FPrintOrientation
      write SetPrintOrientation;
  end;

  {@abstract(@name is used to store fluid properties in PHAST.)}
  TFluidProperties = class(TComponent)
  private
    // @name: boolean;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(FluidCompressibility) is specified by
    // the user, it can be recovered correctly when reading the file.
    FCompressibilitySet: boolean;
    // @name: boolean;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(FluidDensity) is specified by
    // the user, it can be recovered correctly when reading the file.
    FDensitySet: boolean;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(FluidDiffusivity) is specified by
    // the user, it can be recovered correctly when reading the file.
    FDiffusivitySet: boolean;
    // @name: double;
    // See @link(FluidCompressibility).
    FFluidCompressibility: double;
    // @name: double;
    // See @link(FluidDensity).
    FFluidDensity: Double;
    // @name: double;
    // See @link(FluidDiffusivity).
    FFluidDiffusivity: double;
    // @name: double;
    // See @link(FluidViscosity).
    FFluidViscosity: double;
    // @name: boolean;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(FluidViscosity) is specified by
    // the user, it can be recovered correctly when reading the file.
    FViscositySet: boolean;
    // See @link(FluidCompressibility).
    procedure SetFluidCompressibility(const Value: double);
    // See @link(FluidDensity).
    procedure SetFluidDensity(const Value: Double);
    // See @link(FluidDiffusivity).
    procedure SetFluidDiffusivity(const Value: double);
    // See @link(FluidViscosity).
    procedure SetFluidViscosity(const Value: double);
  protected
    // @name checks @link(FCompressibilitySet), @link(FDensitySet),
    // and @link(FViscositySet). If any of them is false, the corresponding
    // property is set to zero.
    procedure Loaded; override;
    // @name initializes all published properties.
    procedure Initialize;
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create(AOwner: TComponent); override;
  published
    // @name is the fluid compressibility.
    property FluidCompressibility: double read FFluidCompressibility
      write SetFluidCompressibility;
    // @name is the fluid density.
    property FluidDensity: Double read FFluidDensity write SetFluidDensity;
    // @name is the fluid diffusivity.
    property FluidDiffusivity: double read FFluidDiffusivity
      write SetFluidDiffusivity;
    // @name is the fluid viscosity..
    property FluidViscosity: double read FFluidViscosity
      write SetFluidViscosity;
  end;

  {@abstract(@name specifies options related to the solution method in PHAST.)}
  TSolutionOptions = class(TComponent)
  private
    // See @link(CrossDispersion).
    FCrossDispersion: boolean;
    // See @link(MaximumIterations).
    FMaximumIterations: integer;
    // See @link(SaveDirections).
    FSaveDirections: integer;
    // See @link(SolverType).
    FSolverType: TPhastSolver;
    // See @link(SpaceDifferencing).
    FSpaceDifferencing: double;
    // See @link(TimeDifferencing).
    FTimeDifferencing: double;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(TimeDifferencing) is specified by
    // the user, it can be recovered correctly when reading the file.
    FTimeDifferencingSet: boolean;
    // See @link(Tolerance).
    FTolerance: double;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(Tolerance) is specified by
    // the user, it can be recovered correctly when reading the file.
    FToleranceSet: boolean;
    FRebalanceByCell: boolean;
    FRebalanceFraction: TRealStorage;
    // See @link(CrossDispersion).
    procedure SetCrossDispersion(const Value: boolean);
    // See @link(MaximumIterations).
    procedure SetMaximumIterations(const Value: integer);
    // See @link(SaveDirections).
    procedure SetSaveDirections(const Value: integer);
    // See @link(SolverType).
    procedure SetSolverType(const Value: TPhastSolver);
    // See @link(SpaceDifferencing).
    procedure SetSpaceDifferencing(const Value: double);
    // See @link(TimeDifferencing).
    procedure SetTimeDifferencing(const Value: double);
    // See @link(Tolerance).
    procedure SetTolerance(const Value: double);
    procedure SetRebalanceByCell(const Value: boolean);
    procedure SetRebalanceFraction(const Value: TRealStorage);
  protected
    // @name initializes all published properties.
    procedure Initialize;
    // @name checks @link(FTimeDifferencingSet)
    // and @link(FToleranceSet). If one of them is false, the corresponding
    // property is set to zero.
    procedure Loaded; override;
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    // @name specifies whether PHAST should use cross-dispersion.
    property CrossDispersion: boolean read FCrossDispersion write
      SetCrossDispersion stored True;
    // @name specifies the maximum number of iterations in PHAST.
    property MaximumIterations: integer read FMaximumIterations write
      SetMaximumIterations default 500;
    property RebalanceFraction: TRealStorage read FRebalanceFraction
      write SetRebalanceFraction stored True;
    property RebalanceByCell: boolean read FRebalanceByCell
      write SetRebalanceByCell;
    // @name specifies the number of save-directions in PHAST.
    property SaveDirections: integer read FSaveDirections
      write SetSaveDirections default 10;
    // @name specifies which solver to use in PHAST.
    property SolverType: TPhastSolver read FSolverType write SetSolverType
      default psIterative;
    // @name specifies the space-differencing in PHAST.
    property SpaceDifferencing: double read FSpaceDifferencing write
      SetSpaceDifferencing stored True;
    // @name specifies the time-differencing in PHAST.
    property TimeDifferencing: double read FTimeDifferencing write
      SetTimeDifferencing stored True;
    // @name specifies the tolerance in PHAST.
    property Tolerance: double read FTolerance write SetTolerance stored True;
  end;

  {@abstract(@name is used to store options related to the STEADY_FLOW
    data block in PHAST.)}
  TSteadyFlowOptions = class(TPersistent)
  private
    // @name: double;
    // See @link(FlowBalanceTolerance).
    FFlowBalanceTolerance: double;
    // @name: double;
    // See @link(HeadChangeLimit).
    FHeadChangeLimit: double;
    // @name: double;
    // See @link(HeadTolerance).
    FHeadTolerance: double;
    // @name: integer;
    // See @link(Iterations).
    FIterations: integer;
    // @name: double;
    // See @link(MaximumTimeStep).
    FMaximumTimeStep: double;
    // @name: double;
    // See @link(MinimumTimeStep).
    FMinimumTimeStep: double;
    // @name: boolean;
    // See @link(SteadyFlow).
    FSteadyFlow: boolean;
    // @name: boolean;
    // See @link(UseDefaultHeadChangeLimit).
    FUseDefaultHeadChangeLimit: boolean;
    // @name: boolean;
    // See @link(UseDefaultMaximumTimeStep).
    FUseDefaultMaximumTimeStep: boolean;
    // @name: boolean;
    // See @link(UseDefaultMinimumTimeStep).
    FUseDefaultMinimumTimeStep: boolean;
    // See @link(FlowBalanceTolerance).
    procedure SetFlowBalanceTolerance(const Value: double);
    // See @link(HeadChangeLimit).
    procedure SetHeadChangeLimit(const Value: double);
    // See @link(HeadTolerance).
    procedure SetHeadTolerance(const Value: double);
    // See @link(Iterations).
    procedure SetIterations(const Value: integer);
    // See @link(MaximumTimeStep).
    procedure SetMaximumTimeStep(const Value: double);
    // See @link(MinimumTimeStep).
    procedure SetMinimumTimeStep(const Value: double);
    // See @link(SteadyFlow).
    procedure SetSteadyFlow(const Value: boolean);
    // See @link(UseDefaultHeadChangeLimit).
    procedure SetUseDefaultHeadChangeLimit(const Value: boolean);
    // See @link(UseDefaultMaximumTimeStep).
    procedure SetUseDefaultMaximumTimeStep(const Value: boolean);
    // See @link(UseDefaultMinimumTimeStep).
    procedure SetUseDefaultMinimumTimeStep(const Value: boolean);
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create;
  published
    // @name is the error tolerance for the flow balance in PHAST.
    property FlowBalanceTolerance: double read FFlowBalanceTolerance
      write SetFlowBalanceTolerance;
    // @name is the maximum head change in one time step in PHAST.
    property HeadChangeLimit: double read FHeadChangeLimit
      write SetHeadChangeLimit;
    // @name is the error tolerance for the head in PHAST.
    property HeadTolerance: double read FHeadTolerance write SetHeadTolerance;
    // @name is the maximum number of iterations in PHAST.
    property Iterations: integer read FIterations write SetIterations
      default 100;
    // @name is the maximum time-step size in PHAST.
    property MaximumTimeStep: double read FMaximumTimeStep
      write SetMaximumTimeStep;
    // @name is the minimum time-step size in PHAST.
    property MinimumTimeStep: double read FMinimumTimeStep
      write SetMinimumTimeStep;
    // @name species whether or not the PHAST is a steady-state simulation.
    property SteadyFlow: boolean read FSteadyFlow write SetSteadyFlow;
    // @name specifies whether PHAST should use the default head-change limit
    // or used @link(HeadChangeLimit).
    property UseDefaultHeadChangeLimit: boolean read FUseDefaultHeadChangeLimit
      write SetUseDefaultHeadChangeLimit default True;
    // @name specifies whether PHAST should use the default maximum time-step
    // size or used @link(MaximumTimeStep).
    property UseDefaultMaximumTimeStep: boolean read FUseDefaultMaximumTimeStep
      write SetUseDefaultMaximumTimeStep default True;
    // @name specifies whether PHAST should use the default minimum time-step
    // size or used @link(MinimumTimeStep).
    property UseDefaultMinimumTimeStep: boolean read FUseDefaultMinimumTimeStep
      write SetUseDefaultMinimumTimeStep default True;
  end;

  {@abstract(@name stores options related to chemistry in PHAST.)}
  TChemistryOptions = class(TPersistent)
  private
    // @name: boolean;
    // See @link(UseEquilibriumPhases).
    FUseEquilibriumPhases: boolean;
    // @name: boolean;
    // See @link(UseExchange).
    FUseExchange: boolean;
    // @name: boolean;
    // See @link(UseGasPhases).
    FUseGasPhases: boolean;
    // @name: boolean;
    // See @link(UseKineticReactants).
    FUseKineticReactants: boolean;
    // @name: boolean;
    // See @link(UseSolidSolution).
    FUseSolidSolution: boolean;
    // @name: boolean;
    // See @link(UseSurfaceAssemblages).
    FUseSurfaceAssemblages: boolean;
    // See @link(UseEquilibriumPhases).
    procedure SetUseEquilibriumPhases(const Value: boolean);
    // See @link(UseExchange).
    procedure SetUseExchange(const Value: boolean);
    // See @link(UseGasPhases).
    procedure SetUseGasPhases(const Value: boolean);
    // See @link(UseKineticReactants).
    procedure SetUseKineticReactants(const Value: boolean);
    // See @link(UseSolidSolution).
    procedure SetUseSolidSolution(const Value: boolean);
    // See @link(UseSurfaceAssemblages).
    procedure SetUseSurfaceAssemblages(const Value: boolean);
  public
    // If Source is a @classname, @name copies Source to the
    // object that called @name.
    procedure Assign(Source: TPersistent); override;
    // @name creates an instance of @classname
    constructor Create;
  published
    // @name specifies whether or not PHAST will use equilibrium phases.
    property UseEquilibriumPhases: boolean read FUseEquilibriumPhases
      write SetUseEquilibriumPhases stored True;
    // @name specifies whether or not PHAST will use exchange.
    property UseExchange: boolean read FUseExchange write SetUseExchange
      stored True;
    // @name specifies whether or not PHAST will use gas phases.
    property UseGasPhases: boolean read FUseGasPhases write SetUseGasPhases
      stored True;
    // @name specifies whether or not PHAST will use kinetic reactions.
    property UseKineticReactants: boolean read FUseKineticReactants
      write SetUseKineticReactants stored True;
    // @name specifies whether or not PHAST will use solid solutions.
    property UseSolidSolution: boolean read FUseSolidSolution
      write SetUseSolidSolution stored True;
    // @name specifies whether or not PHAST will use surface assemblages.
    property UseSurfaceAssemblages: boolean read FUseSurfaceAssemblages
      write SetUseSurfaceAssemblages stored True;
  end;

  {@abstract(@name is used to group together a series of related
    @link(TPhastTimeList)s.)}
  TTimeListGroup = class(TObject)
  private
    // @name: TList;
    // @name stores the @link(TPhastTimeList)s.
    FList: TList;
    // @name: string;
    // See @link(Name).
    FName: string;
    // See @link(Items).
    function GetItems(const Index: integer): TPhastTimeList;
    // See @link(Items).
    procedure SetItems(const Index: integer; const Value: TPhastTimeList);
    // See @link(Name).
    procedure SetName(const Value: string);
  public
    // @name adds TimeList to the group stored in this @classname.
    // @returns(@name returns the position in Items at
    // which TimeList is stored.)
    function Add(const TimeList: TPhastTimeList): integer;
    // @name is the number of @link(TPhastTimeList)s in this @classname.
    function Count: integer;
    // @name creates an instance of @classname
    constructor Create;
    // @name destroys the current instance of @classname.
    // do not call @name directly.  Call Free instead.
    destructor Destroy; override;
    // @name returns the position of TimeList in @classname.
    // If TimeList is not in @classname, @name returns -1.
    function IndexOf(const TimeList: TPhastTimeList): integer;
    // @name provides access to the @link(TPhastTimeList)s in @classname.
    property Items[const Index: integer]: TPhastTimeList read GetItems
      write SetItems;
    // @name is a name for the group of @link(TPhastTimeList)s.
    property Name: string read FName write SetName;
  end;


  TLookUpList = class(TStringList)
  private
    FLastIndex: integer;
  public
    Constructor Create;
  end;


{ TODO :
Make comments a pervasive feature of the model.  The project as whole
should show the project name, author, date, and coordinate system.
There should also be a general comment field for the project.  Each
DataArray and  ScreenObject should have a comment and there should
also be comments for each DataArray or boundary condition specified
by a ScreenObject.  Any special dialog box that has a preserved state
that affects the model output should also have a comment. }

  TChildModelCollection = class;

  TCustomModel = class abstract (TBaseModel, IModelMuseModel,
    ICustomModelForDataArrayManager, ICustomModelInterfaceForCrosssection,
    IModelForTOrderedCollection,
    IModelForDynamicTimeSeries, IModelForTimesSeriesInterface,
    IModelForTGwtPestMethodCollection, IModelForTLandUsePestMethodCollection,
    IModelForTPilotPointObsGrp, IModelForTCustomDefinedGlobalObject,
    IModelForTModflowParameter, IModelForCustomModelGrid, IModelForTValueCell)
  private
    FOnModelSelectionChange: TNotifyEvent;
    // See @link(PhastGrid).
    FPhastGrid: TPhastGrid;
    FModelSelection: TModelSelection;
    FClearing: Boolean;
    FDataArrayManager: TDataArrayManager;
    FAlternateFlowPackage: boolean;
    FAlternateSolver: boolean;
    FBatchFileAdditionsAfterModel: TStrings;
    FBatchFileAdditionsBeforeModel: TStrings;
    FModflowGrid: TModflowGrid;
    FModflowNameFileLines: TStrings;
    FModflowPackages: TModflowPackages;
    FDrainObservations: TFluxObservationGroups;
    FGhbObservations: TFluxObservationGroups;
    FHeadFluxObservations: TFluxObservationGroups;
    FRiverObservations: TFluxObservationGroups;
    FHydrogeologicUnits: THydrogeologicUnits;
    // ancillary files.
    FFilesToArchive: TStrings;
    FModelInputFiles: TStrings;
    FFileName: string;
    FModflowWettingOptions: TWettingOptions;

    FrpFrontFormulaCompiler: TRbwParser;
    FrpFrontFormulaCompilerNodes: TRbwParser;
    FrpSideFormulaCompiler: TRbwParser;
    FrpSideFormulaCompilerNodes: TRbwParser;
    FrpThreeDFormulaCompiler: TRbwParser;
    FrpThreeDFormulaCompilerNodes: TRbwParser;
    FrpTopFormulaCompiler: TRbwParser;
    FrpTopFormulaCompilerNodes: TRbwParser;
    FParsers: TList;
    FThreeDGridObserver: TObserver;
    FTopGridObserver: TObserver;
    FEdgeDisplay: TCustomModflowGridEdgeDisplay;
    FHufKxNotifier: TObserver;
    FHufKyNotifier: TObserver;
    FHufKzNotifier: TObserver;
    FHufSsNotifier: TObserver;
    FHufSyNotifier: TObserver;
    FBinaryFiles: TStringList;
    FLakScreenObjects: TStringList;
    FMawScreenObjects: TStringList;
    FSfrScreenObjects: TStringList;
    FUzfMf6ScreenObjects: TStringList;
    FDirectObservationLines: TStringList;
    FDerivedObservationLines: TStringList;
    FFileNameLines: TStringList;
    FUpdatingMeshElevations: Boolean;
    // @name consists of lines that will be added to RunModel.Bat before the
    // model executable line
    FPestTemplateLines: TStringList;
//    FMeshFileName: string;
    FPilotPointDataArrays: TDataArrayList;
    FPestParamDictionay: TDictionary<string, TModflowSteadyParameter>;
    FInputObservationDataSets: TStringList;
    //  @name is implemented as a @link(TMf6GwtNameWriters).
    FMf6GwtNameWriters: TObject;
    FInputObservations: TInputObservationObjectList;
    FInputObsInstructionFileNames: TStringList;
    FInputObsInstructionFiles: TStringList;
    function GetGlobalVariables: TGlobalVariables; virtual; abstract;
    function GetSomeSegmentsUpToDate: boolean; virtual; abstract;
    procedure SetSomeSegmentsUpToDate(const Value: boolean); virtual; abstract;
    // See @link(PhastGrid).
    procedure SetPhastGrid(const Value: TPhastGrid);
    procedure UpdateDischargeRouting(Sender: TObject);
    // @name returns true if the model uses solute transport.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoChemistryUsed(Sender: TObject): boolean; virtual;
    function GetChemistryUsed: TObjectUsedEvent;
    property ChemistryUsed: TObjectUsedEvent read GetChemistryUsed;
    // @name returns true if the model uses initial heads.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoInitialHeadUsed(Sender: TObject): boolean; virtual;
    function GetInitialHeadUsed: TObjectUsedEvent;
    property InitialHeadUsed: TObjectUsedEvent read GetInitialHeadUsed;
    // @name returns true if the model uses equilibrium phases.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoEquilibriumPhasesUsed(Sender: TObject): boolean; virtual;
    function GetEquilibriumPhasesUsed: TObjectUsedEvent;
    property EquilibriumPhasesUsed: TObjectUsedEvent read GetEquilibriumPhasesUsed;
    // @name returns true if the model uses surface reactions.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoSurfacesUsed(Sender: TObject): boolean; virtual;
    function GetSurfacesUsed: TObjectUsedEvent;
    property SurfacesUsed: TObjectUsedEvent read GetSurfacesUsed;
    // @name returns true if the model uses exchange reactions.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoExchangeUsed(Sender: TObject): boolean; virtual;
    function GetExchangeUsed: TObjectUsedEvent;
    property ExchangeUsed: TObjectUsedEvent read GetExchangeUsed;
    // @name returns true if the model uses gas phases.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoGasPhaseUsed(Sender: TObject): boolean; virtual;
    function GetGasPhaseUsed: TObjectUsedEvent;
    property GasPhaseUsed: TObjectUsedEvent read GetGasPhaseUsed;
    // @name returns true if the model uses solid solutions.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoSolidSolutionUsed(Sender: TObject): boolean; virtual;
    function GetSolidSolutionUsed: TObjectUsedEvent;
    property SolidSolutionUsed: TObjectUsedEvent read GetSolidSolutionUsed;
    // @name returns true if the model uses kinetics.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed)
    function DoKineticsUsed(Sender: TObject): boolean; virtual;
    function GetKineticsUsed: TObjectUsedEvent;
    property KineticsUsed: TObjectUsedEvent read GetKineticsUsed;
    function DoModflowUsed(Sender: TObject): boolean; virtual;
    function GetModflowUsed: TObjectUsedEvent;
    property ModflowUsed: TObjectUsedEvent read GetModflowUsed;
    function DoRouteUzfDischarge(Sender: TObject): boolean; virtual;
    function GetRouteUzfDischarge: TObjectUsedEvent;
    property RouteUzfDischarge: TObjectUsedEvent read GetRouteUzfDischarge;
    function DoModflowInitialHeadUsed(Sender: TObject): boolean; virtual;
    function GetModflowInitialHeadUsed: TObjectUsedEvent;
    property ModflowInitialHeadUsed: TObjectUsedEvent read GetModflowInitialHeadUsed;
    function DoConfiningBedKzUsed(Sender: TObject): boolean; virtual;
    function GetConfiningBedKzUsed: TObjectUsedEvent;
    property ConfiningBedKzUsed: TObjectUsedEvent read GetConfiningBedKzUsed;
    function DoVerticalAnisotropyUsed(Sender: TObject): boolean; virtual;
    function GetVerticalAnisotropyUsed: TObjectUsedEvent;
    property VerticalAnisotropyUsed: TObjectUsedEvent read GetVerticalAnisotropyUsed;
    function DoHorizontalAnisotropyUsed(Sender: TObject): boolean; virtual;
    function GetHorizontalAnisotropyUsed: TObjectUsedEvent;
    property HorizontalAnisotropyUsed: TObjectUsedEvent read GetHorizontalAnisotropyUsed;
    function DoSpecificYieldUsed(Sender: TObject): boolean; virtual;
    function GetSpecificYieldUsed: TObjectUsedEvent;
    property SpecificYieldUsed: TObjectUsedEvent read GetSpecificYieldUsed;
    function DoWetDryUsed(Sender: TObject): boolean; virtual;
    function GetWetDryUsed: TObjectUsedEvent;
    property WetDryUsed: TObjectUsedEvent read GetWetDryUsed;
    function ModpathUsed(Sender: TObject): boolean; virtual;
    function DoHufReferenceSurfaceNeeded(Sender: TObject): boolean; virtual;
    function GetHufReferenceSurfaceNeeded: TObjectUsedEvent;
    property HufReferenceSurfaceNeeded: TObjectUsedEvent read GetHufReferenceSurfaceNeeded;
    function DoBcfUsed(Sender: TObject): boolean; virtual;
    function GetBcfUsed: TObjectUsedEvent;
    property BcfUsed: TObjectUsedEvent read GetBcfUsed;
    function DoConfinedStorageCoefUsed(Sender: TObject): boolean; virtual;
    function GetConfinedStorageCoefUsed: TObjectUsedEvent;
    property ConfinedStorageCoefUsed: TObjectUsedEvent read GetConfinedStorageCoefUsed;
    function DoOptionalDataSet(Sender: TObject): boolean;
    function GetOptionalDataSet: TObjectUsedEvent;
    property OptionalDataSet: TObjectUsedEvent read GetOptionalDataSet;
    function DoHufSelected(Sender: TObject): boolean;
    function GetHufSelected: TObjectUsedEvent;
    property HufSelected: TObjectUsedEvent read GetHufSelected;
    function DoHufStorageUsed(Sender: TObject): boolean;
    function GetHufStorageUsed: TObjectUsedEvent;
    property HufStorageUsed: TObjectUsedEvent read GetHufStorageUsed;
    function DoZoneBudgetSelected(Sender: TObject): boolean; virtual;
    function GetZoneBudgetSelected: TObjectUsedEvent;
    property ZoneBudgetSelected: TObjectUsedEvent read GetZoneBudgetSelected;
    function DoSwtSelected(Sender: TObject): boolean; virtual;
    function GetSwtSelected: TObjectUsedEvent;
    property SwtSelected: TObjectUsedEvent read GetSwtSelected;
    function DoSwtOffsetsUsed(Sender: TObject): boolean; virtual;
    function GetSwtOffsetsUsed: TObjectUsedEvent;
    property SwtOffsetsUsed: TObjectUsedEvent read GetSwtOffsetsUsed;
    function DoSwtSpecifiedUsed(Sender: TObject): boolean; virtual;
    function GetSwtSpecifiedUsed: TObjectUsedEvent;
    property SwtSpecifiedUsed: TObjectUsedEvent read GetSwtSpecifiedUsed;
    function DoSutraUsed(Sender: TObject): boolean;
    function GetSutraUsed: TObjectUsedEvent;
    property SutraUsed: TObjectUsedEvent read GetSutraUsed;
    function Sutra30OrAboveUsed(Sender: TObject): boolean;
    function DoSutraLakeUsed(Sender: TObject): boolean;
    function GetSutraLakeUsed: TObjectUsedEvent;
    property SutraLakeUsed: TObjectUsedEvent read GetSutraLakeUsed;
    function DoSutraLakeBottomUsed(Sender: TObject): boolean;
    function GetSutraLakeBottomUsed: TObjectUsedEvent;
    property SutraLakeBottomUsed: TObjectUsedEvent read GetSutraLakeBottomUsed;
    function UztUsed(Sender: TObject): boolean; virtual;
//    function GwtUztUsed(Sender: TObject): boolean; virtual;
//    function Xt3DUsed(Sender: TObject): boolean; virtual;
    function DoNpfUsed(Sender: TObject): boolean; virtual;
    function GetNpfUsed: TObjectUsedEvent;
    property NpfUsed: TObjectUsedEvent read GetNpfUsed;
    function DoSutra3DModel(Sender: TObject): boolean;
    function GetSutra3DModel: TObjectUsedEvent;
    property Sutra3DModel: TObjectUsedEvent read GetSutra3DModel;
    function DoSutraConcentrationUsed(Sender: TObject): boolean;
    function GetSutraConcentrationUsed: TObjectUsedEvent;
    property SutraConcentrationUsed: TObjectUsedEvent read GetSutraConcentrationUsed;
    function DoSutraTemperatureUsed(Sender: TObject): boolean;
    function GetSutraTemperatureUsed: TObjectUsedEvent;
    property SutraTemperatureUsed: TObjectUsedEvent read GetSutraTemperatureUsed;
    function ModflowOrPhastUsed(Sender: TObject): boolean; virtual;
    function DoSwiUsed(Sender: TObject): boolean;
    function GetSwiUsed: TObjectUsedEvent;
    property SwiUsed: TObjectUsedEvent read GetSwiUsed;
//    function DoSwiUsed(Sender: TObject): boolean;
    function DoZetaUsed(Sender: TObject): boolean;
    function DoHorizAnisotropyMf6Used(Sender: TObject): boolean;
    function GetHorizAnisotropyMf6Used: TObjectUsedEvent;
    property HorizAnisotropyMf6Used: TObjectUsedEvent read GetHorizAnisotropyMf6Used;
    function DoVertAnisotropyMf6Used(Sender: TObject): boolean;
    function GetVertAnisotropyMf6Used: TObjectUsedEvent;
    property VertAnisotropyMf6Used: TObjectUsedEvent read GetVertAnisotropyMf6Used;
    function DoCSubDataSetsUsed(Sender: TObject): boolean;
    function GetCSubDataSetsUsed: TObjectUsedEvent;
    property CSubDataSetsUsed: TObjectUsedEvent read GetCSubDataSetsUsed;
    function DoCSubInitialElasticStorageUsed(Sender: TObject): boolean;
    function GetCSubInitialElasticStorageUsed: TObjectUsedEvent;
    property CSubInitialElasticStorageUsed: TObjectUsedEvent read GetCSubInitialElasticStorageUsed;
    function DoCSubInitialRecompressionIndexUsed(Sender: TObject): boolean;
    function GetCSubInitialRecompressionIndexUsed: TObjectUsedEvent;
    property CSubInitialRecompressionIndexUsed: TObjectUsedEvent read GetCSubInitialRecompressionIndexUsed;

    function IndenticalTransientArray(DataArray: TDataArray; DataArrays: TList;
      var CachedIndex: integer): TDataArray;
    // See @link(TimeLists).
    function GetTimeLists(Index: integer): TCustomTimeList;
    // See @link(TimeListCount).
    function GetTimeListCount: integer;
    procedure ClearAllTimeLists;
    procedure InitializeHobDisplay(Sender: TObject);
    procedure InitializeTobDisplay(Sender: TObject);
    function ModflowHobPackageUsed(Sender: TObject): boolean;
    function Mt3dmsTobPackageUsed(Sender: TObject): boolean;
    procedure GetMfHobHeadsUseList(Sender: TObject; NewUseList: TStringList);
    procedure GetMt3dTobCondUseList(Sender: TObject; NewUseList: TStringList);
    procedure CreateModflowDisplayTimeLists;
    procedure SetUnitNumbers(const Value: TUnitNumbers);
    procedure UpdateHfb(Sender: TObject);
    // See @link(DataSetList).
    function GetDataSetCollection: TDataSetCollection;
    procedure FinalizeDischargeRouting(Sender: TObject);
    procedure GetParameterUsedAndParameterFormulaForLPF(
      out ParameterUsed: Boolean; out ParameterFormula: string;
      ParameterType: TParameterType);
    procedure UpdateLpfDataArrayParameterUsed(const DataArrayName: string;
      ParameterType: TParameterType);
    function PrepareModflowFullStressPeriods(ShowWarning: boolean): Boolean;
    function CountStepsInExport: Integer;
    procedure GetDefaultOutputFileExtension(var Extension: string);
    function CheckMt3dTimes(ShowWarning: Boolean): boolean;
    procedure DoAssignFootprintBoundarydWithdrawal(Sender: TObject);
    function GetAssignFootprintBoundarydWithdrawal: TNotifyEvent;
    property AssignFootprintBoundarydWithdrawal: TNotifyEvent read GetAssignFootprintBoundarydWithdrawal;
//    procedure AssignFootprintDistributedWithdrawals(Sender: TObject);
    procedure DoUseFootprintWells(Sender: TObject; var ShouldUse: Boolean);
    function GetUseFootprintWells: TCheckUsageEvent;
    property UseFootprintWells: TCheckUsageEvent read GetUseFootprintWells;
    procedure FillListWithMeshSpecificationScreenObjects(
      var ErrorMessage: string; List: TList);
    procedure CreateBoundariesForMeshCreator(MeshCreator: TQuadMeshCreator;
      List: TList; Exag: Extended);
    procedure UpdateAllDataArrayDimensions;
    procedure DoAssignModflow6LakeDisplayArrays(Sender: TObject);
    function GetAssignModflow6LakeDisplayArrays: TNotifyEvent;
    property AssignModflow6LakeDisplayArrays: TNotifyEvent read GetAssignModflow6LakeDisplayArrays;
    // Ensure that IDOMAIN is only set to -1 if the cell is vertically between
    // active cells.
    procedure UpdateIdomain(Sender: TObject);

    // functions procedures and properties used in interfaces to TCustomModel.
    function GetDataSetByName(const DataSetName: string): TDataArray;
    function GetDataArrayInterface: ISimpleDataArrayManager;
    procedure RestoreSubscriptions;
    function AddFormulaObject: IFormulaObject;
    procedure RemoveFormulaObject(FormulaObject: TFormulaObject;
      OnRemoveSubscription, OnRestoreSubscription:TChangeSubscription;
      Subject: TObject); overload;
    procedure RemoveFormulaObject(FormulaObject: IFormulaObject;
      OnRemoveSubscription, OnRestoreSubscription:TChangeSubscription;
      Subject: TObject); overload;
    function TimeToTimeStepTimes(ATime: double; out StartTime, EndTime: double): Boolean;
    function GetPestParameterValueByName(PestParamName: string; out Value: double): Boolean;
    procedure UpdateFormulaDependencies(OldFormula: string;
      var NewFormula: string; Observer: IObserver; Compiler: TRbwParser;
      ScreenObject: IScreenObject = nil);
    function CreateBlockFormulaObject(Orientation: TDataSetOrientation): TObject;
    function CreateBlockFormulaObjectI(Orientation: TDataSetOrientation): IFormulaObject;
    procedure ChangeFormula(var FormulaObject: IFormulaObject;
      NewFormula: string; EvaluatedAt: TEvaluatedAt; OnRemoveSubscription,
      OnRestoreSubscription: TChangeSubscription; Subject: TObject);
    function GetMobileComponentCount: Integer;
    function CropCount: integer;
    function GetObsGroupFromName(const Value: string): IObservationGroup;
    function GetScreenObjectInterface(const Index: integer): IScreenObject;
    property ScreenObjectInterfaces[const Index: integer]: IScreenObject
      read GetScreenObjectInterface;
    procedure NotifyHufKx;
    procedure NotifyHufKy;
    procedure NotifyHufKz;
    procedure NotifyHufSS;
    procedure NotifyHufSy;
    procedure RemoveVariables(const DataSet: IDataArray); overload;
    procedure ChangeGlobalVariable(const ParameterName: string;
      const Value: TParameterType);
    procedure SetGlobalVariablesI(const Value: IGlobalVariables); virtual; abstract;
    function GetGlobalVariablesI: IGlobalVariables; virtual; abstract;
    property GlobalVariablesI: IGlobalVariables read GetGlobalVariablesI
      write SetGlobalVariablesI;
  private
    FGrid: TCustomModelGrid;
    FModflowOptions: TModflowOptions;
    FNameFileWriter: TObject;
    FHeadObsResults: THeadObsCollection;
    FMt3dmsHeadMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsMassLoadingMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsGhbMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsRivMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsWellMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsResMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsRchMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsDrtMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsEtsMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsEvtMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsDrnMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsLakMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsStrMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsFhbHeadMassFluxObservations: TMt3dmsFluxObservationGroups;
    FMt3dmsFhbFlowMassFluxObservations: TMt3dmsFluxObservationGroups;
    FSutraMesh: TSutraMesh3D;
    FSutraOptions: TSutraOptions;
    FSutraOutputControl: TSutraOutputControl;
    FStrObservations: TFluxObservationGroups;
    FSutraSpecPressureTimeList: TSutraMergedTimeList;
    FSutraSpecPresUTimeList: TSutraMergedTimeList;
    FSutraConcTempTimeList: TSutraMergedTimeList;
    FSutraFluidFluxTimeList: TSutraMergedTimeList;
    FSutraFluidFluxUTimeList: TSutraMergedTimeList;
    FSutraMassEnergyFluxTimeList: TSutraMergedTimeList;
    FSutraGenFlowPress1: TSutraMergedTimeList;
    FSutraGenFlowPress2: TSutraMergedTimeList;
    FSutraGenFlowRate1: TSutraMergedTimeList;
    FSutraGenFlowRate2: TSutraMergedTimeList;
    FSutraGenFlowU1: TSutraMergedTimeList;
    FSutraGenFlowU2: TSutraMergedTimeList;
    FSutraGenTranU1: TSutraMergedTimeList;
    FSutraGenTranU2: TSutraMergedTimeList;
    FSutraGenTranQU1: TSutraMergedTimeList;
    FSutraGenTranQU2: TSutraMergedTimeList;
    FOnHeadOBsChanged: TNotifyEvent;
    FCrossSection: TCrossSection;
    FOnCrossSectionChanged: TNotifyEvent;
    FSwrTabFiles: TTabFileCollection;
    FSwrReachGeometry: TReachGeometryCollection;
    FSwrStructures: TStructureCollection;
    FSwrObservations: TSwrObsCollection;
    FMt3dTobCond: TMt3dmsTobDisplayTimeList;
    FFootPrintGrid: TFootPrintGrid;
    FSimNameWriter: IMf6_SimNameFileWriter;
    FModpathOutputFiles: TStrings;
    FModpathInputFiles: TStrings;
    FZoneBudgetOutputFiles: TStrings;
    FZoneBudgetInputFiles: TStrings;
    FMt3dmsOutputFiles: TStrings;
    FMt3dmsInputFiles: TStrings;
    FModelOutputFiles: TStrings;
    FExternalFiles: TStrings;
    FSwiObsExtractorInputFiles: TStrings;
    FSwiObsExtractorOutputFiles: TStrings;
    FDisvGrid: TModflowDisvGrid;
    FMf6GridType: TMf6GridType;
    FOnGridTypeChanged: TNotifyEvent;
    FTopContoursUpToDate: Boolean;
    FSideContoursUpToDate: Boolean;
    FFrontContoursUpToDate: Boolean;
    FModflowGlobalObservationComparisons: TGlobalObservationComparisons;
    FSutraGlobalObservationComparisons: TGlobalObservationComparisons;
    FSutraFluxObs: TSutraFluxObs;
    FModflow6GlobalObservationComparisons: TGlobalObservationComparisons;
    FVelocityVectors: TVectorCollection;
    FPilotPointData: TStoredPilotParamDataCollection;
    FKrigfactorsScriptLines: TStringList;
    FCanDrawContours: Boolean;
    FPestObsCollection: TPestObsCollection;
    FMt3dObsCollection: TMt3dObsCollection;
    procedure CrossSectionChanged(Sender: TObject);
    procedure SetAlternateFlowPackage(const Value: boolean);
    procedure SetAlternateSolver(const Value: boolean);
    procedure SetBatchFileAdditionsAfterModel(const Value: TStrings);
    procedure SetBatchFileAdditionsBeforeModel(const Value: TStrings);
    procedure SetModflowGrid(const Value: TModflowGrid);
    procedure SetModflowNameFileLines(const Value: TStrings);
    procedure SetModflowPackages(const Value: TModflowPackages);
    procedure SetHeadFluxObservations(const Value: TFluxObservationGroups);
    procedure SetRiverObservations(const Value: TFluxObservationGroups);
    procedure SetDrainObservations(const Value: TFluxObservationGroups);
    procedure SetGhbObservations(const Value: TFluxObservationGroups);
    procedure SetHydrogeologicUnits(const Value: THydrogeologicUnits);
    procedure SetFilesToArchive(const Value: TStrings);
    procedure SetModelInputFiles(const Value: TStrings);
    procedure SetModflowWettingOptions(const Value: TWettingOptions);


    procedure ClearParsers;
    function GetParsers(Index: integer): TRbwParser;
    procedure SetGlobalVariables(const Value: TGlobalVariables); virtual; abstract;
    procedure SetEdgeDisplay(const Value: TCustomModflowGridEdgeDisplay);
    procedure AllObserversStopTalking;
    procedure FreeHufNotifiers;
    procedure FreeGridNotifiers;
    function GetModflowFullStressPeriods: TModflowStressPeriods; virtual; abstract;
    function StoreDrainObservations: Boolean;
    function StoreGhbObservations: Boolean;
    function StoreHeadFluxObservations: Boolean;
    function StoreRiverObservations: Boolean;
    function StoreHydrogeologicUnits: Boolean; virtual;
    function GetDisplayColumn: integer;
    function GetDisplayLayer: integer;
    function GetDisplayRow: integer;
    function GetSelectedColumn: integer;
    function GetSelectedLayer: integer;
    function GetSelectedRow: integer;
    procedure SetDisplayColumn(const Value: integer);
    procedure SetDisplayLayer(const Value: integer);
    procedure SetDisplayRow(const Value: integer);
    procedure SetSelectedColumn(const Value: integer);
    procedure SetSelectedLayer(const Value: integer);
    procedure SetSelectedRow(const Value: integer);
    function WettingActive: boolean; virtual;
    procedure SetNameFileWriter(const Value: TObject);
    function GetThreeDGridObserver: TObserver;
    function GetSaveBfhBoundaryConditions: boolean; virtual; abstract;
    procedure SetSaveBfhBoundaryConditions(const Value: boolean);  virtual; abstract;
    function GetModflowLocation: string;
    procedure SetModflowLocation(const Value: string);
    procedure SetHeadObsResults(const Value: THeadObsCollection);
    procedure CreateHeadObsResults;
    function GetHeadObsResults: THeadObsCollection;
    procedure ExportLakePackage(const FileName: string);
    procedure ExportSfrPackage(const FileName: string);
    procedure EvaluateSfrPackage;
    procedure ExportUzfPackage(const FileName: string);
    function DoMt3dMSBulkDensityUsed(Sender: TObject): boolean; virtual;
    function GetMt3dMSBulkDensityUsed: TObjectUsedEvent;
    property Mt3dMSBulkDensityUsed: TObjectUsedEvent read GetMt3dMSBulkDensityUsed;
    function DoMt3dMSImmobPorosityUsed(Sender: TObject): boolean; virtual;
    function GetMt3dMSImmobPorosityUsed: TObjectUsedEvent;
    property Mt3dMSImmobPorosityUsed: TObjectUsedEvent read GetMt3dMSImmobPorosityUsed;
    procedure SetMt3dmsOutputControl(const Value: TMt3dmsOutputControl); virtual; abstract;
    function GetMt3dmsOutputControl: TMt3dmsOutputControl; virtual; abstract;
    function GetMt3dmsTimes: TMt3dmsTimeCollection; virtual; abstract;
    procedure SetMt3dmsTimes(const Value: TMt3dmsTimeCollection); virtual; abstract;
    function DoGwtDispUsed(Sender: TObject): boolean; virtual;
    function DoGweCndUsed(Sender: TObject): boolean; virtual;
    function GetGwtDispUsed: TObjectUsedEvent;
    property GwtDispUsed: TObjectUsedEvent read GetGwtDispUsed;
    function DoLongitudinalDispersionUsed(Sender: TObject): boolean; virtual;
    function GetLongitudinalDispersionUsed: TObjectUsedEvent;
    property LongitudinalDispersionUsed: TObjectUsedEvent read GetLongitudinalDispersionUsed;
    function DoHorizontalTransverseDispersionUsed(Sender: TObject): boolean; virtual;
    function GetHorizontalTransverseDispersionUsed: TObjectUsedEvent;
    property HorizontalTransverseDispersionUsed: TObjectUsedEvent read GetHorizontalTransverseDispersionUsed;
    function DoVerticalTransverseDispersionUsed(Sender: TObject): boolean; virtual;
    function GetVerticalTransverseDispersionUsed: TObjectUsedEvent;
    property VerticalTransverseDispersionUsed: TObjectUsedEvent read GetVerticalTransverseDispersionUsed;
    function DoSeparatedLongitudinalDispersionUsed(Sender: TObject): boolean; virtual;
    function GetSeparatedLongitudinalDispersionUsed: TObjectUsedEvent;
    property SeparatedLongitudinalDispersionUsed: TObjectUsedEvent read GetSeparatedLongitudinalDispersionUsed;
    function DoSeparatedHorizontalTransverseDispersionUsed(Sender: TObject): boolean; virtual;
    function GetSeparatedHorizontalTransverseDispersionUsed: TObjectUsedEvent;
    property SeparatedHorizontalTransverseDispersionUsed: TObjectUsedEvent
      read GetSeparatedHorizontalTransverseDispersionUsed;
    // separate Dispersion for each species.
    function DoGwtDispUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetGwtDispUsedPerSpecies: TObjectUsedEvent;
    function DoLongitudinalDispersionUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetLongitudinalDispersionUsedPerSpecies: TObjectUsedEvent;
    function DoHorizontalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
    function DoVerticalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetVerticalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
    function DoSeparatedLongitudinalDispersionUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetSeparatedLongitudinalDispersionUsedPerSpecies: TObjectUsedEvent;
    function DoSeparatedHorizontalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetSeparatedHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
    function DoCombinedHorizontalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetCombinedHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;

    function DoSeparatedThermalConductivityUsedPerSpecies(Sender: TObject): boolean; virtual;
    function GetSeparatedThermalConductivityUsed: TObjectUsedEvent;

    function DoSeparatedDecayWaterUsedPerSpecies(Sender: TObject): boolean; virtual;
    function DoSeparatedDecaySolidUsedPerSpecies(Sender: TObject): boolean; virtual;
    function DoSeparatedHeatCapacitySolidUsedPerSpecies(Sender: TObject): boolean; virtual;
    function DoSeparatedDensitySolidUsedPerSpecies(Sender: TObject): boolean; virtual;

//    function
    procedure UpdateMt3dmsActive(Sender: TObject);
    function CountStepsInMt3dExport: Integer;
    procedure SetMt3dmsHeadMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    function StoreHeadMassFluxObservations: Boolean;
    procedure SetMt3dmsDrnMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsDrtMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsEtsMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsEvtMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsGhbMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsLakMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsMassLoadingMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsRchMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsResMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsRivMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    procedure SetMt3dmsWellMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    function StoreDrnMassFluxObservations: Boolean;
    function StoreDrtMassFluxObservations: Boolean;
    function StoreEtsMassFluxObservations: Boolean;
    function StoreEvtMassFluxObservations: Boolean;
    function StoreGhbMassFluxObservations: Boolean;
    function StoreLakMassFluxObservations: Boolean;
    function StoreMassLoadingMassFluxObservations: Boolean;
    function StoreRchMassFluxObservations: Boolean;
    function StoreResMassFluxObservations: Boolean;
    function StoreRivMassFluxObservations: Boolean;
    function StoreWellMassFluxObservations: boolean;
    procedure SetPathLine(const Value: TPathLineReader);
    function GetPathLine: TPathLineReader;
    function StorePathLine: boolean;
    function StoreTimeSeries: boolean;
    procedure SetTimeSeries(const Value: TTimeSeriesReader);
    function GetTimeSeries: TTimeSeriesReader;
    function StoreEndPoints: boolean;
    function GetEndPoints: TEndPointReader;
    procedure SetEndPoints(const Value: TEndPointReader);
    procedure SetSutraMesh(const Value: TSutraMesh3D);
    procedure RenameOldVerticalLeakance; virtual;
    function GetThreeDDataSet: TDataArray;
    function GetFrontDataSet: TDataArray;
    function GetSideDataSet: TDataArray;
    function GetTopDataSet: TDataArray;
    function GetMesh: IMesh;
    procedure SetSutraOptions(const Value: TSutraOptions);
    function DoModpathBudgetNeeded(Sender: TObject): boolean;
    function GetModpathBudgetNeeded: TObjectUsedEvent;
    property ModpathBudgetNeeded: TObjectUsedEvent read GetModpathBudgetNeeded;
    function DoModpathRetardationNeeded(Sender: TObject): boolean;
    function GetModpathRetardationNeeded: TObjectUsedEvent;
    property ModpathRetardationNeeded: TObjectUsedEvent read GetModpathRetardationNeeded;
    function GetModPathLocation: string;
    function DoModpathZonesNeeded(Sender: TObject): boolean; virtual;
    function GetModpathZonesNeeded: TObjectUsedEvent;
    property ModpathZonesNeeded: TObjectUsedEvent read GetModpathZonesNeeded;
    procedure SetSutraOutputControl(const Value: TSutraOutputControl);
    function DoSutraThicknessUsed(Sender: TObject): boolean;
    function GetSutraThicknessUsed: TObjectUsedEvent;
    property SutraThicknessUsed: TObjectUsedEvent read GetSutraThicknessUsed;
    function GetSutraUnsatRegionUsed: TObjectUsedEvent;
    function GetSutraMesh: TSutraMesh3D;
    procedure InitializeSutraSpecPres(Sender: TObject);
    procedure InitializeSutraSpecifiedConcTemp(Sender: TObject);
    procedure InitializeSutraFluidFlux(Sender: TObject);
    procedure InitializeSutraMassEnergyFlux(Sender: TObject);
    procedure InitializeSutraGeneralFlow(Sender: TObject);
    procedure InitializeSutraGeneralTransport(Sender: TObject);
    procedure DiscretizationChangedEvent(Sender: TObject);
    function DoSutraHydraulicConductivityUsed(Sender: TObject): boolean;
    function GetSutraHydraulicConductivityUsed: TObjectUsedEvent;
    property SutraHydraulicConductivityUsed: TObjectUsedEvent read GetSutraHydraulicConductivityUsed;
    function DoSutraPermeabilityUsed(Sender: TObject): boolean;
    function GetSutraPermeabilityUsed: TObjectUsedEvent;
    property SutraPermeabilityUsed: TObjectUsedEvent read GetSutraPermeabilityUsed;
    function DoSutraMiddlePermeabilityUsed(Sender: TObject): boolean;
    function GetSutraMiddlePermeabilityUsed: TObjectUsedEvent;
    property SutraMiddlePermeabilityUsed: TObjectUsedEvent read GetSutraMiddlePermeabilityUsed;
    function DoSutraMiddleHydraulicConductivityUsed(Sender: TObject): boolean;
    function GetSutraMiddleHydraulicConductivityUsed: TObjectUsedEvent;
    property SutraMiddleHydraulicConductivityUsed: TObjectUsedEvent read GetSutraMiddleHydraulicConductivityUsed;
    procedure SetStrObservations(const Value: TFluxObservationGroups);
    function StoreStrObservations: Boolean;
    procedure SetMt3dmsStrMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    function StoreStrMassFluxObservations: Boolean;
    procedure SetMt3dmsFhbHeadMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    function StoreFhbHeadMassFluxObservations: Boolean;
    procedure SetMt3dmsFhbFlowMassFluxObservations(
      const Value: TMt3dmsFluxObservationGroups);
    function StoreFhbFlowMassFluxObservations: Boolean;
    procedure UpdateCropFullStressPeriods(TimeList: TRealList);
    procedure UpdateAllotmentFullStressPeriods(TimeList: TRealList);
    procedure UpdateFarmsFullStressPeriods(TimeList: TRealList);
    procedure UpdateIrrigationTypesFullStressPeriods(TimeList: TRealList);
    procedure SetCrossSection(const Value: TCrossSection);
    procedure SetSwrTabFiles(const Value: TTabFileCollection);
    procedure SetSwrReachGeometry(const Value: TReachGeometryCollection);
    procedure SetSwrStructures(const Value: TStructureCollection);
    procedure SetSwrObservations(const Value: TSwrObsCollection);
    function GetUnitNumbers: TUnitNumbers;
    function DoSwrSelected(Sender: TObject): Boolean;
    function GetSwrSelected: TObjectUsedEvent;
    property SwrSelected: TObjectUsedEvent read GetSwrSelected;
    procedure UpdateSwrReachNumber(Sender: TObject);
    procedure UpdateSfr6SteadyData(Sender: TObject);
    procedure UpdateSftSteadyData(Sender: TObject);
    procedure UpdateMawSteadyData(Sender: TObject);
    function DoFootprintSelected(Sender: TObject): Boolean;
    function GetFootprintSelected: TObjectUsedEvent;
    property FootprintSelected: TObjectUsedEvent read GetFootprintSelected;
    procedure UpdateSpecifiedHeadArray(Sender: TObject);

    function GetModelInputFiles: TStrings;
    function GetFilesToArchive: TStrings;
//    procedure EvaluateFarmProcess;
    procedure ExportFarmProcess(const FileName: string);
    function GetFarms: TFarmCollection; virtual; abstract;
    function GetFmpAllotment: TAllotmentCollection; virtual; abstract;
    function GetFmpClimate: TClimateCollection; virtual; abstract;
    function GetFmpCrops: TCropCollection; virtual; abstract;
    function GetFmpSoils: TSoilCollection; virtual; abstract;
    procedure SetFarms(const Value: TFarmCollection); virtual; abstract;
    procedure SetFmpClimate(const Value: TClimateCollection); virtual; abstract;
    procedure SetFmpCrops(const Value: TCropCollection); virtual; abstract;
    procedure SetFmpSoils(const Value: TSoilCollection); virtual; abstract;
    procedure SetFmpAllotment(const Value: TAllotmentCollection); virtual; abstract;
    procedure SetFootPrintGrid(const Value: TFootPrintGrid);
    function StoreLinkedRaster: Boolean;
    procedure SetModpathInputFiles(const Value: TStrings);
    procedure SetModpathOutputFiles(const Value: TStrings);
    procedure SetZoneBudgetInputFiles(const Value: TStrings);
    procedure SetZoneBudgetOutputFiles(const Value: TStrings);
    procedure TestAddModelModelFile(AFileName: string; FileNames: TStrings);
    procedure SetMt3dmsInputFiles(const Value: TStrings);
    procedure SetMt3dmsOutputFiles(const Value: TStrings);
    procedure SetModelOutputFiles(const Value: TStrings);
    procedure SetExternalFiles(const Value: TStrings);
    procedure SetSwiObsExtractorInputFiles(const Value: TStrings);
    procedure SetSwiObsExtractorOutputFiles(const Value: TStrings);
    procedure SetDisvGrid(const Value: TModflowDisvGrid);
    procedure SetMf6GridType(const Value: TMf6GridType);
    function GetDrawMesh: IDrawMesh;
    function GetMesh3D: IMesh3D;
    function GetFrontContourDataSet: TDataArray;
    function GetSideContourDataSet: TDataArray;
    function GetThreeDContourDataSet: TDataArray;
    function GetTopContourDataSet: TDataArray;
    function GetGrid: TCustomModelGrid;
    function GetDiscretiztionElevation(Column, Row, Layer: Integer): Double;
    function GetLayerThickness(Layer, Row, Column: Integer): Double;
    function DoSfrMf6Selected(Sender: TObject): Boolean;
    function GetSfrMf6Selected: TObjectUsedEvent;
    property SfrMf6Selected: TObjectUsedEvent read GetSfrMf6Selected;
    function DoMawSelected(Sender: TObject): Boolean;
    function GetMawSelected: TObjectUsedEvent;
    property MawSelected: TObjectUsedEvent read GetMawSelected;
    function DoLakMf6Selected(Sender: TObject): Boolean;
    function GetLakMf6Selected: TObjectUsedEvent;
    property LakMf6Selected: TObjectUsedEvent read GetLakMf6Selected;
    function GetMt3dSpecesName(const Index: Integer): string;
    procedure SetModflowGlobalObservationComparisons(
      const Value: TGlobalObservationComparisons);
    function GetPestUsed: Boolean;
    procedure SetSutraGlobalObservationComparisons(
      const Value: TGlobalObservationComparisons);
    procedure SetSutraFluxObs(const Value: TSutraFluxObs);
    function GetSutraLakesUsed: Boolean;
    procedure SetModflow6GlobalObservationComparisons(
      const Value: TGlobalObservationComparisons);
    procedure SetVelocityVectors(const Value: TVectorCollection);
    // See @link(Exaggeration).
    function GetExaggeration: double;
    // See @link(Exaggeration).
    procedure SetExaggeration(Value: double);
    function GetElementLocation(Layer, Row,
      Column: Integer): TDualLocation;
    function GetActiveElement(Layer, Row, Column: Integer): Boolean;
    function GetDiscretization: TCustomDiscretization;
    function GetItemTopLocation(const EvalAt: TEvaluatedAt; const Column,
      Row: integer): TPoint2D;
    procedure SetPilotPointData(const Value: TStoredPilotParamDataCollection);
    function GetPilotPointCount: integer;
    function GetPilotPoint(Index: Integer): TPoint2D;
    function GetPilotPointBuffer: double;
    procedure SetCanDrawContours(const Value: Boolean);
    function GetShortestHorizontalBlockEdge(Layer, Row,
      Column: Integer): double;
    procedure SetPestObsCollection(const Value: TPestObsCollection);
    function GetMf6TimesSeries: TTimesSeriesCollections; virtual; abstract;
    procedure SetMf6TimesSeries(const Value: TTimesSeriesCollections);
      virtual; abstract;
    procedure FixSutraMeshEdge;
    function Sutra4SorptionUsed(Sender: TObject): boolean;
    function GetAppsMoved: TStringList; virtual; abstract;
    function GetPestStatus: TPestStatus;
    function GetSeparateGwtUsed: Boolean;
    function DoFarmProcess4SteadArrayEfficiencyUsed(Sender: TObject): Boolean;
    function GetFarmProcess4SteadArrayEfficiencyUsed: TObjectUsedEvent;
    property FarmProcess4SteadArrayEfficiencyUsed: TObjectUsedEvent read GetFarmProcess4SteadArrayEfficiencyUsed;
    function DoFarmProcess4SteadArrayEfficiencyImprovementUsed(Sender: TObject): Boolean;
    function GetFarmProcess4SteadArrayEfficiencyImprovementUsed: TObjectUsedEvent;
    property FarmProcess4SteadArrayEfficiencyImprovementUsed: TObjectUsedEvent
      read GetFarmProcess4SteadArrayEfficiencyImprovementUsed;
    function DoFarmProcess4SteadArrayBareRunoffFractionUsed(Sender: TObject): Boolean;
    function GetFarmProcess4SteadArrayBareRunoffFractionUsed: TObjectUsedEvent;
    property FarmProcess4SteadArrayBareRunoffFractionUsed: TObjectUsedEvent
      read GetFarmProcess4SteadArrayBareRunoffFractionUsed;
    function DoFarmProcess4SteadArrayAddedDemandRunoffSplitUsed(Sender: TObject): Boolean;
    function GetFarmProcess4SteadArrayAddedDemandRunoffSplitUsed: TObjectUsedEvent;
    property FarmProcess4SteadArrayAddedDemandRunoffSplitUsed: TObjectUsedEvent
      read GetFarmProcess4SteadArrayAddedDemandRunoffSplitUsed;
    function DoFarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed(Sender: TObject): Boolean;
    function GetFarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed: TObjectUsedEvent;
    property FarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed: TObjectUsedEvent
      read GetFarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed;
    function DoCapillaryFringeUsed(Sender: TObject): Boolean;
    function GetCapillaryFringeUsed: TObjectUsedEvent;
    property CapillaryFringeUsed: TObjectUsedEvent read GetCapillaryFringeUsed;
    function DoSurfaceKUsed(Sender: TObject): Boolean;
    function GetSurfaceKUsed: TObjectUsedEvent;
    property SurfaceKUsed: TObjectUsedEvent read GetSurfaceKUsed;
    function DoPotentialEvapBareUsed(Sender: TObject): Boolean;
    function GetPotentialEvapBareUsed: TObjectUsedEvent;
    property PotentialEvapBareUsed: TObjectUsedEvent read GetPotentialEvapBareUsed;
    function DoDirectRechargeUsed(Sender: TObject): Boolean;
    function GetDirectRechargeUsed: TObjectUsedEvent;
    property DirectRechargeUsed: TObjectUsedEvent read GetDirectRechargeUsed;
    function DoPrecipPotConsumptionUsed(Sender: TObject): Boolean;
    function GetPrecipPotConsumptionUsed: TObjectUsedEvent;
    property PrecipPotConsumptionUsed: TObjectUsedEvent read GetPrecipPotConsumptionUsed;
    function DoNrdInfilLocationUsed(Sender: TObject): Boolean;
    function GetNrdInfilLocationUsed: TObjectUsedEvent;
    property NrdInfilLocationUsed: TObjectUsedEvent read GetNrdInfilLocationUsed;
    function DoCropCoefficientUsed(Sender: TObject): Boolean;
    function GetCropCoefficientUsed: TObjectUsedEvent;
    property CropCoefficientUsed: TObjectUsedEvent read GetCropCoefficientUsed;
    function DoLandUseAreaFractionUsed(Sender: TObject): Boolean;
    function GetLandUseAreaFractionUsed: TObjectUsedEvent;
    property LandUseAreaFractionUsed: TObjectUsedEvent read GetLandUseAreaFractionUsed;
    function DoConsumptiveUseUsed(Sender: TObject): Boolean;
    function GetConsumptiveUseUsed: TObjectUsedEvent;
    property ConsumptiveUseUsed: TObjectUsedEvent read GetConsumptiveUseUsed;
    function DoIrrigationUsed(Sender: TObject): Boolean;
    function GetIrrigationUsed: TObjectUsedEvent;
    property IrrigationUsed: TObjectUsedEvent read GetIrrigationUsed;
    function DoRootDepthUsed(Sender: TObject): Boolean;
    function GetRootDepthUsed: TObjectUsedEvent;
    property RootDepthUsed: TObjectUsedEvent read GetRootDepthUsed;
    function DoGwRootInteractionUsed(Sender: TObject): Boolean;
    function GetGwRootInteractionUsed: TObjectUsedEvent;
    property GwRootInteractionUsed: TObjectUsedEvent read GetGwRootInteractionUsed;
    function DoTranspirationFractionUsed(Sender: TObject): Boolean;
    function GetTranspirationFractionUsed: TObjectUsedEvent;
    property TranspirationFractionUsed: TObjectUsedEvent read GetTranspirationFractionUsed;
    function DoEvaporationIrrigationFractionUsed(Sender: TObject): Boolean;
    function GetEvaporationIrrigationFractionUsed: TObjectUsedEvent;
    property EvaporationIrrigationFractionUsed: TObjectUsedEvent read GetEvaporationIrrigationFractionUsed;
    function DoFractionOfPrecipToSurfaceWaterUsed(Sender: TObject): Boolean;
    function GetFractionOfPrecipToSurfaceWaterUsed: TObjectUsedEvent;
    property FractionOfPrecipToSurfaceWaterUsed: TObjectUsedEvent read GetFractionOfPrecipToSurfaceWaterUsed;
    function DoFractionOfIrrigToSurfaceWaterUsed(Sender: TObject): Boolean;
    function GetFractionOfIrrigToSurfaceWaterUsed: TObjectUsedEvent;
    property FractionOfIrrigToSurfaceWaterUsed: TObjectUsedEvent read GetFractionOfIrrigToSurfaceWaterUsed;
    function DoAddedDemandUsed(Sender: TObject): Boolean;
    function GetAddedDemandUsed: TObjectUsedEvent;
    property AddedDemandUsed: TObjectUsedEvent read GetAddedDemandUsed;
    function DoCropHasSalinityDemandUsed(Sender: TObject): Boolean;
    function GetCropHasSalinityDemandUsed: TObjectUsedEvent;
    property CropHasSalinityDemandUsed: TObjectUsedEvent read GetCropHasSalinityDemandUsed;
    function DoLandUseCellsToPrintUsed(Sender: TObject): Boolean;
    function GetLandUseCellsToPrintUsed: TObjectUsedEvent;
    property LandUseCellsToPrintUsed: TObjectUsedEvent read GetLandUseCellsToPrintUsed;
    function GetModflowPackages: TModflowPackages;
    procedure DoOnActiveDataSetChanged(Sender: TObject);
    function GetOnActiveDataSetChanged: TNotifyEvent;
    function GetOnNodeActiveDataSetChanged: TNotifyEvent;
  protected
    function GetGwtUsed: Boolean; override;
    function GetGweUsed: Boolean; override;
    procedure SetFrontDataSet(const Value: TDataArray); virtual;
    procedure SetSideDataSet(const Value: TDataArray); virtual;
    procedure SetTopDataSet(const Value: TDataArray); virtual;
    procedure SetThreeDDataSet(const Value: TDataArray); virtual;
    procedure SetThreeDContourDataSet(const Value: TDataArray); virtual;
    procedure SetTopContourDataSet(const Value: TDataArray); virtual;
    procedure SetFrontContourDataSet(const Value: TDataArray); virtual;
    procedure SetSideContourDataSet(const Value: TDataArray); virtual;
    procedure Loaded; override;
    procedure InternalExportModflowModel(const FileName: string;
      ExportAllLgr: boolean); virtual;
    function GetFootprintProperties: TFootprintProperties; virtual; Abstract;
    procedure SetFootprintProperties(const Value: TFootprintProperties); virtual; Abstract;
    function GetParentModel: TCustomModel; virtual;
    procedure GenerateIrregularMesh(var ErrorMessage: string);
    procedure GenerateFishNetMesh(var ErrorMessage: string); virtual;
    procedure GenerateMeshUsingGmsh(var ErrorMessage: string);
    procedure GenerateMeshUsingGeompack(var ErrorMessage: string);
    function GetLinkedRasters: TLinkedRasterCollection; virtual; abstract;
    procedure SetLinkedRasters(const Value: TLinkedRasterCollection);  virtual; abstract;
    function GetGeoRef: TGeoRef; virtual; abstract;
    procedure SetGeoRef(const Value: TGeoRef); virtual; abstract;
    function GetContourLegend: TLegend; virtual; abstract;
    function GetUseGsflowFormat: boolean; virtual; abstract;
    procedure SetUseGsflowFormat(const Value: boolean); virtual; abstract;
    procedure SetCtsSystems(const Value: TCtsSystemCollection); virtual; abstract;
    function GetCtsSystems: TCtsSystemCollection; virtual; abstract;
    function DoMt3d_LktIsSelected(Sender: TObject): Boolean; virtual;
    function GetMt3d_LktIsSelected: TObjectUsedEvent;
    property Mt3d_LktIsSelected: TObjectUsedEvent read GetMt3d_LktIsSelected;
    function GetParamGroups: TPestParamGroups; virtual; abstract;
    procedure SetParamGroups(const Value: TPestParamGroups); virtual; abstract;
    function GetPestProperties: TPestProperties; virtual; abstract;
    procedure SetPestProperties(const Value: TPestProperties); virtual; abstract;
    function GetFilesToDelete: TStrings; virtual; abstract;
    function FarmProcess4TransientEfficiencyArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientEfficiencyImprovementArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientBareRunoffFractionArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientBareEvapArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientDirectRechargeArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientPrecipPotConsumptionArrayIsSelected: Boolean; virtual;
    function FarmProcess4TransientNrdInfilLocIsSelected: Boolean; virtual;
    function FarmProcess4TransientLandUseAreaFractionIsSelected: Boolean; virtual;
    function FarmProcess4TransientLandUseAreaFractionMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientCropCoefficientIsSelected: Boolean; virtual;
    function FarmProcess4TransientCropCoefficientMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientConsumptiveUseIsSelected: Boolean; virtual;
    function FarmProcess4TransientConsumptiveUseMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientIrrigationIsSelected: Boolean; virtual;
    function FarmProcess4TransientIrrigationMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientRootDepthIsSelected: Boolean; virtual;
    function FarmProcess4TransientRootDepthMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientTranspirationFractionIsSelected: Boolean; virtual;
    function FarmProcess4TransientTranspirationFractionMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientEvaporationIrrigationFractionIsSelected: Boolean; virtual;
    function FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected: Boolean; virtual;
    function FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected: Boolean; virtual;
    function FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientAddedDemandIsSelected: Boolean; virtual;
    function FarmProcess4TransientAddedDemandMultIsSelected: Boolean; virtual;
    function FarmProcess4TransientCropHasSalinityDemandIsSelected: Boolean; virtual;
    function FarmProcess4TransientCropHasSalinityDemandMultIsSelected: Boolean; virtual;

    function GetIrrigationTypes: TIrrigationCollection; virtual; abstract;
    procedure SetIrrigationTypes(const Value: TIrrigationCollection); virtual; abstract;
  var
    LakWriter: TObject;
    SfrWriter: TObject;
    FarmWriter3: TObject;
    FarmWriter4: TObject;
    FTransientMultiplierArrays: TList;
    FCachedMultiplierArrayIndex: Integer;
    FTransientZoneArrays: TList;
    FCachedZoneArrayIndex: integer;
    FUpdatingFullStressPeriods: Boolean;
    // See @link(DataSetList).
    FDataSetCollection: TDataSetCollection;
    // See @link(FrontTimeList).
    FFrontTimeList: TCustomTimeList;
    // See @link(SideTimeList).
    FSideTimeList: TCustomTimeList;
    // See @link(TopTimeList).
    FTopTimeList: TCustomTimeList;
    // See @link(TopDisplayTime).
    FTopDisplayTime: double;
    // See @link(FrontDisplayTime).
    FFrontDisplayTime: double;
    // See @link(SideDisplayTime).
    FSideDisplayTime: double;
    // See @link(ThreeDDisplayTime).
    FThreeDDisplayTime: double;
    // See @link(ThreeDTimeList).
    FThreeDTimeList: TCustomTimeList;
    FPValFile: TStringList;
    FPvalTemplate: TStringList;
    FPestPValFile: TStringList;
    FPestPvalTemplate: TStringList;
    FGages: TStringList;
    FPathLine: TPathLineReader;
    FTimeSeries: TTimeSeriesReader;
    FEndPoints: TEndPointReader;
    F_SP_Epsilon: double;
    FSutraPestScripts: TStringList;
  strict private
    FUnitNumbers: TUnitNumbers;
    FHfbWriter: TObject;
    FMfHobHeads: THobDisplayTimeList;
    FHfbDisplayer: THfbDisplayer;

    // @name holds the @link(TCustomTimeList)s in the model.
    // See @link(TimeLists).
    FTimeLists: TList;
  private
    function GetZetaUsed: TObjectUsedEvent;
    function GetSftUsed: TObjectUsedEvent;
    property ZetaUsed: TObjectUsedEvent read GetZetaUsed;
    function DoSftUsed(Sender: TObject): boolean; virtual;
    property SftUsed: TObjectUsedEvent read GetSftUsed;
    function DoGwtUztUsed(Sender: TObject): boolean; virtual;
    function GetGwtUztUsed: TObjectUsedEvent;
    property GwtUztUsed: TObjectUsedEvent read GetGwtUztUsed;
    function DoActiveUsed(Sender: TObject): boolean;
    function GetActiveUsed: TObjectUsedEvent;
    property ActiveUsed: TObjectUsedEvent read GetActiveUsed;

    procedure DoInitializeActiveDataArrayWithCellSizeObjects(Sender: TObject);
    function GetInitializeActiveDataArrayWithCellSizeObjects: TNotifyEvent;
    property InitializeActiveDataArrayWithCellSizeObjects: TNotifyEvent
      read GetInitializeActiveDataArrayWithCellSizeObjects;

    procedure DoShouldActiveBeSetByCellSize(Sender: TObject; var ShouldCheck: Boolean);
    function GetDoShouldActiveBeSetByCellSize: TCheckUsageEvent;
    property ShouldActiveBeSetByCellSize: TCheckUsageEvent
      read GetDoShouldActiveBeSetByCellSize;

    function DoAquiferPropertiesUsed(Sender: TObject): boolean; virtual;
    function GetAquiferPropertiesUsed: TObjectUsedEvent;
    property AquiferPropertiesUsed: TObjectUsedEvent read GetAquiferPropertiesUsed;

    function DoKyUsed(Sender: TObject): boolean; virtual;
    function GetKyUsed: TObjectUsedEvent;
    property KyUsed: TObjectUsedEvent read GetKyUsed;

    procedure DoDetermineKyFromAnisotropy(Sender: TObject);
    function GetDetermineKyFromAnisotropy: TNotifyEvent;
    property DetermineKyFromAnisotropy: TNotifyEvent read GetDetermineKyFromAnisotropy;

    procedure DoShouldKyBeDeterminedFromAnisotropy(Sender: TObject; var ShouldCheck: Boolean);
    function GetShouldKyBeDeterminedFromAnisotropy: TCheckUsageEvent;
    property ShouldKyBeDeterminedFromAnisotropy: TCheckUsageEvent read GetShouldKyBeDeterminedFromAnisotropy;

    function DoKzUsed(Sender: TObject): boolean; virtual;
    function GetKzUsed: TObjectUsedEvent;
    property KzUsed: TObjectUsedEvent read GetKzUsed;

    procedure DoDetermineKzFromAnisotropy(Sender: TObject);
    function GetDetermineKzFromAnisotropy: TNotifyEvent;
    property DetermineKzFromAnisotropy: TNotifyEvent read GetDetermineKzFromAnisotropy;

    procedure DoShouldKzBeDeterminedFromAnisotropy(Sender: TObject; var ShouldCheck: Boolean);
    function GetShouldKzBeDeterminedFromAnisotropy: TCheckUsageEvent;
    property ShouldKzBeDeterminedFromAnisotropy: TCheckUsageEvent read GetShouldKzBeDeterminedFromAnisotropy;

    function DoPorosityUsed(Sender: TObject): boolean; virtual;
    function GetPorosityUsed: TObjectUsedEvent;
    property PorosityUsed:  TObjectUsedEvent read GetPorosityUsed;

//    function DoSpecificStorageUsed(Sender: TObject): boolean; virtual;
    function DoSpecificStorageUsed(Sender: TObject): boolean; virtual;
    function GetSpecificStorageUsed: TObjectUsedEvent;
    property SpecificStorageUsed: TObjectUsedEvent read GetSpecificStorageUsed;

//      TCheckUsageEvent
  protected
    function GetSfrStreamLinkPlot: TSfrStreamLinkPlot; virtual; abstract;
    procedure SetSfrStreamLinkPlot(const Value: TSfrStreamLinkPlot); virtual; abstract;
    function GetStrStreamLinkPlot: TSfrStreamLinkPlot; virtual; abstract;
    procedure SetStrStreamLinkPlot(const Value: TSfrStreamLinkPlot); virtual; abstract;
    function GetSfrMf6StreamLinkPlot: TSfrStreamLinkPlot; virtual; abstract;
    procedure SetSfrMf6StreamLinkPlot(const Value: TSfrStreamLinkPlot); virtual; abstract;
    function GetSwrReachConnectionsPlot: TSwrReachConnectionsPlot; virtual; abstract;
    procedure SetSwrReachConnectionsPlot(const Value: TSwrReachConnectionsPlot); virtual; abstract;
    procedure SetFileName(const Value: string); virtual;
    procedure SetFrontTimeList(const Value: TCustomTimeList); virtual;
    procedure SetSideTimeList(const Value: TCustomTimeList); virtual;
    procedure SetTopTimeList(const Value: TCustomTimeList); virtual;
    function GetFormulaManager: TFormulaManager; virtual; abstract;
    function GetSelectedModel: TCustomModel; virtual; abstract;
    procedure SetSelectedModel(const Value: TCustomModel); virtual; abstract;
    function GetScreenObjects(const Index: integer): TScreenObject;virtual;abstract;
    function GetScreenObjectCount: integer;virtual;abstract;
    function GetModflowSteadyParameters: TModflowSteadyParameters;virtual;abstract;
    procedure SetModflowSteadyParameters(const Value: TModflowSteadyParameters);virtual;abstract;
//    function GetModelSelection: TModelSelection;virtual;abstract;
    // Among other things, if @link(OnModelSelectionChange)
    // is assigned, @name calls @link(TfrmGoPhast.ModelSelectionChange
    // TfrmGoPhast.ModelSelectionChange).  @name also changes
    // the functions that are available. and sets @Link(TObserver)s
    // for the @link(Grid).
    procedure SetModelSelection(const Value: TModelSelection); override;
    // @name causes the grid to not be colored by any @link(TDataArray).
    function GetLayerStructure: TLayerStructure;virtual;abstract;
    procedure SetLayerStructure(const Value: TLayerStructure);virtual;abstract;
    procedure SetModflowOptions(const Value: TModflowOptions);
    function GetModflowStressPeriods: TModflowStressPeriods;virtual;abstract;
    procedure SetModflowStressPeriods(const Value: TModflowStressPeriods);virtual;abstract;
    procedure SetSoluteTransport(const Value: boolean);virtual;abstract;
    function GetSoluteTransport: boolean;virtual;abstract;
    procedure SetUseWaterTable(const Value: boolean);virtual;abstract;
    function GetUseWaterTable: boolean;virtual;abstract;
    function GetFreeSurface: boolean;virtual;abstract;
    procedure SetFreeSurface(const Value: boolean);virtual;abstract;
    procedure SetChemistryOptions(const Value: TChemistryOptions); virtual; abstract;
    function GetChemistryOptions: TChemistryOptions; virtual; abstract;
    procedure SetHufParameters(const Value: THufModflowParameters);virtual;abstract;
    function GetHufParameters: THufModflowParameters;virtual;abstract;
    function GetObservationPurpose: TObservationPurpose; virtual; abstract;
    procedure SetObservationPurpose(const Value: TObservationPurpose); virtual; abstract;
    function GetModflowTransientParameters: TModflowTransientListParameters; virtual;abstract;
    procedure SetModflowTransientParameters(
      const Value: TModflowTransientListParameters);virtual;abstract;
    function GetModflowOutputControl: TModflowOutputControl;virtual;abstract;
    procedure SetModflowOutputControl(const Value: TModflowOutputControl);virtual;abstract;
    function GetProgramLocations: TProgramLocations;virtual;abstract;
    procedure SetProgramLocations(const Value: TProgramLocations);virtual;abstract;
    procedure ClearViewedItems; virtual;
    procedure InternalClear; virtual;
    procedure InitializeGages; virtual;
    procedure InitializeSfrWriter(EvaluationType: TEvaluationType); virtual;
    procedure FreeSfrWriter; virtual;
    procedure SetContourFont(const Value: TFont) ; virtual; abstract;
    procedure SetShowContourLabels(const Value: boolean);  virtual; abstract;
    function GetContourFont: TFont;  virtual; abstract;
    function GetShowContourLabels: boolean; virtual; abstract;
    function GetImmobileComponents: TChemSpeciesCollection; virtual; abstract;
    function GetMobileComponents: TMobileChemSpeciesCollection; virtual; abstract;
    procedure SetImmobileComponents(const Value: TChemSpeciesCollection);
      virtual; abstract;
    procedure SetMobileComponents(const Value: TMobileChemSpeciesCollection);
      virtual; abstract;
    function GetContourLabelSpacing: Integer; virtual; abstract;
    procedure SetContourLabelSpacing(const Value: Integer);virtual; abstract;
  private
//    FGlobalVariables: TGlobalVariables;
    function GetMt3dMS_StrictUsed: TObjectUsedEvent;
    function GetCrossSection: TCrossSection;
    function GetModflowOptions: TModflowOptions;
    function GetDataArrayManager: TDataArrayManager;
    function GetClearing: Boolean;
    function GetMf6TimesSeriesI: ITimesSeriesCollections;
    function GetGridI: ICustomModelGrid;
    function GetBuoyancyDensityUsed: Boolean;
    function GetBuoyancyUsed: Boolean;
    function GetCfpCadsSelected: TObjectUsedEvent;
    function GetViscosityPkgUsedUsed: Boolean;
    function GetViscosityPkgViscUsed: Boolean;
    function GetInputObservationDataSets: TStrings;
    function GetInputObsInstructionFileNames: TStrings;
    function GetInputObsInstructionFiles: TStrings;
    procedure SetMt3dObsCollection(const Value: TMt3dObsCollection);
    function GetSeparatedDecaySolidUsed: TObjectUsedEvent;
    function GetSeparatedDecayWaterUsed: TObjectUsedEvent;
    function GetSeparatedDensitySolidUsed: TObjectUsedEvent;
    function GetSeparatedHeatCapacitySolidUsed: TObjectUsedEvent;
  public
    function ChdIsSelected: Boolean; virtual;
    function TvkIsSelected: Boolean; virtual;
    function TvsIsSelected: Boolean; virtual;
    function FhbIsSelected: Boolean; virtual;
    function DoMt3dMS_StrictUsed(Sender: TObject): boolean; virtual;
    property Mt3dMS_StrictUsed: TObjectUsedEvent read GetMt3dMS_StrictUsed;
    function Mf6GwtUsed(Sender: TObject): boolean; virtual;
    function Mf6GweUsed(Sender: TObject): boolean; virtual;
    procedure ClearPval;
    procedure FinalizePvalAndTemplate(FileName: string);
    function ParamNamesDataSetUsed(Sender: TObject): boolean; virtual;
    function ParamWeightsDataSetUsed(Sender: TObject): boolean; virtual;
    function InterpSwiObsDefined: Boolean;
    function DoSwiObsUsed(Sender: TObject): boolean;
    function GetSwiObsUsed: TObjectUsedEvent;
    property SwiObsUsed: TObjectUsedEvent read GetSwiObsUsed;
    property FmpCrops: TCropCollection read GetFmpCrops write SetFmpCrops;
    property FmpSoils: TSoilCollection read GetFmpSoils write SetFmpSoils;
    property FmpClimate: TClimateCollection read GetFmpClimate write SetFmpClimate;
    property FmpAllotment: TAllotmentCollection read GetFmpAllotment
       write SetFmpAllotment;
    property Farms: TFarmCollection read GetFarms write SetFarms;
    property IrrigationTypes: TIrrigationCollection read GetIrrigationTypes
      write SetIrrigationTypes;
    property ParentModel: TCustomModel read GetParentModel;
    procedure DrawSfrStreamLinkages(const BitMap: TPersistent;
      const ZoomBox: TQRbwZoomBox2);
    procedure DrawStrStreamLinkages(const BitMap: TPersistent;
      const ZoomBox: TQRbwZoomBox2);
    procedure DrawSfrMf6StreamLinkages(const BitMap: TPersistent;
      const ZoomBox: TQRbwZoomBox2);
    procedure DrawSwrReachConnections(const BitMap: TPersistent;
      const ZoomBox: TQRbwZoomBox2);
    procedure RenameDataArray(DataArray: TDataArray;
      const NewName, NewDisplayName: string);
    // When a @link(TDataArray) or global variable is renamed, @name is
    // called to update all the formulas with the new names.
    procedure UpdateFormulas(OldNames, NewNames: TStringList);
    procedure UpdateDataArrayDimensions(DataArray: TDataArray);
    function IndexOfMt3dmsSpeciesName(const AChemSpecies: string): integer;
    property Gages: TStringList read FGages;
    function StoreHeadObsResults: boolean;
    function TestModpathOK(Model: TCustomModel): Boolean;
    property ModflowLocation: string read GetModflowLocation write SetModflowLocation;
    property ModPathLocation: string read GetModPathLocation;
    procedure ExportSeparateLgrModel(const FileName: string;
      RunModel, ExportModpath, ExportZoneBudget, ShowWarning: boolean);
    // @name returns the name of the most likely output file from which
    // model results will be imported.  If heads were saved, the name of the
    // file containing heads will be returned.
    // If heads were not saved by drawdowns were saved, the name of the
    // file containing drawdowns will be returned.
    // After that, it is the file containing the cell-by-cell flows.
    function DefaultModflowOutputFileName: string; virtual;
    procedure ModelObserversStopTalkingTo(Observer: TObserver);
    procedure UpdateActive(Sender: TObject);
    procedure UpdateWetDry(Sender: TObject);
    procedure UpdateLakeId(Sender: TObject);
    procedure FinalizeActive(Sender: TObject);
    procedure FinalizeWetDry(Sender: TObject);
    procedure FinalizeLakeId(Sender: TObject);
    procedure UpdateModPathZone(Sender: TObject);
      // @name updates @link(TDataArray.OnPostInitialize
    // TDataArray.OnPostInitialize) for several @link(TDataArray)s.
    procedure UpdateOnPostInitialize;
  // MODFLOW can not use a file name containing a space character.
    // @name replaces the space character in a file name with an underscore.
    // @name is the event handler for @link(TDataArray.OnDataSetUsed
    // TDataArray.OnDataSetUsed) for @link(TDataArray)s related to the HUF
    // package.
    function HufDataArrayUsed(Sender: TObject): boolean;
    function CSubInterbedDataArrayUsed(Sender: TObject): boolean;
    // @name assigns frmGoPhast.Grid.@link(TCustomModelGrid.FrontDataSet)
    // to be the @link(TDataArray) in TimeList at Time.
    procedure UpdateFrontTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); virtual;
    // @name assigns frmGoPhast.Grid.@link(TCustomModelGrid.SideDataSet)
    // to be the @link(TDataArray) in TimeList at Time.
    procedure UpdateSideTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); virtual;
    // @name assigns frmGoPhast.Grid.@link(TCustomModelGrid.TopDataSet)
    // to be the @link(TDataArray) in TimeList at Time.
    procedure UpdateTopTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); virtual;
    // @name assigns frmGoPhast.Grid.@link(TCustomModelGrid.ThreeDDataSet)
    // to be the @link(TDataArray) in TimeList at Time.
    procedure UpdateThreeDTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); virtual;
    function GetTimeListByName(const AName: string): TCustomTimeList;
    property FormulaManager: TFormulaManager read GetFormulaManager;
    function AddDataSet(const DataSet: TDataArray): Integer; virtual;
    function LayerGroupUsed(LayerGroup: TLayerGroup): boolean; virtual;
    // When a layer group represents more than one layer, @name gives the
    // relative positions of the dividing lines between layers.
    // The values is @name should decrease monotonically.
    // For example, if a layer group is divided into 4 uniform layers,
    // @name should return [0.75, 0.5, 0.25].
    // Each value represents the fraction of the distance from the bottom
    // to the top of the layer group.
    function LayerFractions(LayerGroup: TCustomLayerGroup): TDoubleDynArray; virtual;
    function MaxColumnCount: Integer;
    function ColumnCount: Integer;
    function RowCount: Integer;
    function LayerCount: integer; virtual;
    procedure UpdateDisplayUseList(NewUseList: TStringList;
      ParamType: TParameterType; DataIndex: integer; const DisplayName: string); virtual; abstract;
    procedure Assign(Source: TPersistent); override;
    // @name clears @link(FInputObservationDataSets), @link(FInputObservations),
    // @link(FInputObsInstructionFileNames), and @link(FInputObsInstructionFiles).;
    procedure ClearInputObservationDataSets;
    // @name adds the names of input data sets to @link(FInputObservationDataSets).
    // The data sets should have one of more input values with a known weight
    // that will be used as an observed value in PEST.
    procedure AddInputObsDataSet(DataArray: TDataArray);
    Procedure ExportInputObsDataSets(RootName: string);
    procedure AddInputObsInstructionFileName(AFileName: string);
    procedure AddInputObsInstructionFile(AFileName: string);

    property Clearing: Boolean read GetClearing;
    property DataArrayManager: TDataArrayManager read GetDataArrayManager;

    property OnActiveDataSetChanged: TNotifyEvent read GetOnActiveDataSetChanged;
    procedure DoOnNodeActiveDataSetChanged(Sender: TObject);
    property OnNodeActiveDataSetChanged: TNotifyEvent read GetOnNodeActiveDataSetChanged;
    procedure Clear;
    constructor Create(AnOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddModelInputFile(const FileName: string);
    procedure AddFileToArchive(const FileName: string);

    property Grid: TCustomModelGrid read GetGrid;
    property GridI: ICustomModelGrid read GetGridI;

    // @name is the TRbwParser for formulas for data sets on the front
    // view of the model evaluated at elements.
    property rpFrontFormulaCompiler: TRbwParser read FrpFrontFormulaCompiler;
    // @name is the TRbwParser for formulas for data sets on the front
    // view of the model evaluated at nodes.
    property rpFrontFormulaCompilerNodes: TRbwParser
      read FrpFrontFormulaCompilerNodes;
    // @name is the TRbwParser for formulas for data sets on the side
    // view of the model evaluated at elements.
    property rpSideFormulaCompiler: TRbwParser read FrpSideFormulaCompiler;
    // @name is the TRbwParser for formulas for data sets on the side
    // view of the model evaluated at nodes.
    property rpSideFormulaCompilerNodes: TRbwParser
      read FrpSideFormulaCompilerNodes;
    // @name is the TRbwParser for formulas for 3D data sets
    // view of the model evaluated at elements.
    property rpThreeDFormulaCompiler: TRbwParser read FrpThreeDFormulaCompiler;
    // @name is the TRbwParser for formulas for 3D data sets
    // view of the model evaluated at nodes.
    property rpThreeDFormulaCompilerNodes: TRbwParser
      read FrpThreeDFormulaCompilerNodes;
    // @name is the TRbwParser for formulas for data sets on the top
    // view of the model evaluated at elements.
    property rpTopFormulaCompiler: TRbwParser read FrpTopFormulaCompiler;
    // @name is the TRbwParser for formulas for data sets on the top
    // view of the model evaluated at nodes.
    property rpTopFormulaCompilerNodes: TRbwParser
      read FrpTopFormulaCompilerNodes;
    // @name returns the TRbwParser that should be used for a particular
    // @link(TDataSetOrientation) and @link(TEvaluatedAt).
    function GetCompiler(const Orientation: TDataSetOrientation;
      const EvaluatedAt: TEvaluatedAt): TRbwParser;
    property FormulaCompiler[const Orientation: TDataSetOrientation;
      const EvaluatedAt: TEvaluatedAt]:TRbwParser read GetCompiler;
    function ParserCount: integer;
    property Parsers[Index: integer]: TRbwParser read GetParsers;
    procedure ClearExpressionsAndVariables;
    procedure FillCompilerList(CompilerList: TList);
{
    procedure RefreshGlobalVariables(CompilerList: TList);
    procedure CreateGlobalVariables;
}
    // @name creates a TCustomVariable to represent DataSet in each TRbwParser
    // that should have one.
    // @seealso(RemoveVariables)
    procedure CreateVariables(const DataSet: TDataArray);
    // @name removes the variables that represent DataSet in any
    // expression.
    // @seealso(CreateVariables).
    procedure RemoveVariables(const DataSet: TDataArray); overload;
    procedure RemoveVariables(const DataSetName: String;
      Orientation: TDataSetOrientation; EvaluatedAt: TEvaluatedAt); overload;
    property ThreeDGridObserver: TObserver read GetThreeDGridObserver;
    property TopGridObserver: TObserver read FTopGridObserver;
    property HufKxNotifier: TObserver read FHufKxNotifier;
    property HufKyNotifier: TObserver read FHufKyNotifier;
    property HufKzNotifier: TObserver read FHufKzNotifier;
    property HufSsNotifier: TObserver read FHufSsNotifier;
    property HufSyNotifier: TObserver read FHufSyNotifier;

    // If @name is the currently active @link(TCustomModflowGridEdgeDisplay).
    property EdgeDisplay: TCustomModflowGridEdgeDisplay read FEdgeDisplay
      write SetEdgeDisplay;

    // @name provides access to the @link(TScreenObject)s in the model.
    // However, the @link(TScreenObject)s are saved are read from files
    // via @link(TPhastModel.ObjectList).
    property ScreenObjects[const Index: integer]: TScreenObject
      read GetScreenObjects;

    // @name returns the number of @link(TScreenObject)s
    // in @link(ScreenObjects).
    property ScreenObjectCount: integer read GetScreenObjectCount;

    // @name returns true if the model uses the water table
    // to set the initial condition.
    // @name is used an event handler for
    // TDataArray.@link(TDataArray.OnDataSetUsed).
    // @name is also used in WriteHeadIC which
    // is found in the implementation section of @link(WritePhastUnit).
    function DoInitialWaterTableUsed(Sender: TObject): boolean; virtual;
    function GetInitialWaterTableUsed: TObjectUsedEvent;
    property InitialWaterTableUsed: TObjectUsedEvent read GetInitialWaterTableUsed;
    function DoReservoirLayerUsed(Sender: TObject): boolean; virtual;
    function GetReservoirLayerUsed: TObjectUsedEvent;
    property ReservoirLayerUsed: TObjectUsedEvent read GetReservoirLayerUsed;
    function DoReservoirPackageUsed(Sender: TObject): boolean; virtual;
    function GetReservoirPackageUsed: TObjectUsedEvent;
    property ReservoirPackageUsed: TObjectUsedEvent read GetReservoirPackageUsed;
    function DoLakePackageUsed(Sender: TObject): boolean; virtual;
    function GetLakePackageUsed: TObjectUsedEvent;
    property LakePackageUsed: TObjectUsedEvent read GetLakePackageUsed;
    function DoUzfPackageUsed(Sender: TObject): boolean; virtual;
    function GetUzfPackageUsed: TObjectUsedEvent;
    property UzfPackageUsed: TObjectUsedEvent read GetUzfPackageUsed;
    function DoUzfMf6PackageUsed(Sender: TObject): boolean; virtual;
    function GetUzfMf6PackageUsed: TObjectUsedEvent;
    property UzfMf6PackageUsed: TObjectUsedEvent read GetUzfMf6PackageUsed;
    function FarmProcessUsed(Sender: TObject): boolean; virtual;
    function Farm4ProcessUsed(Sender: TObject): boolean; virtual;
    function DoFarmProcess4SteadyFarmsUsed(Sender: TObject): boolean; virtual;
    function GetFarmProcess4SteadyFarmsUsed: TObjectUsedEvent;
    property FarmProcess4SteadyFarmsUsed: TObjectUsedEvent read GetFarmProcess4SteadyFarmsUsed;
    function FarmProcess4TransientFarmsUsed(Sender: TObject): boolean; virtual;
    function DoFarmProcess4SteadyPrecipUsed(Sender: TObject): boolean; virtual;
    function GetFarmProcess4SteadyPrecipUsed: TObjectUsedEvent;
    property FarmProcess4SteadyPrecipUsed: TObjectUsedEvent read GetFarmProcess4SteadyPrecipUsed;
    function DoFarmProcess4SteadyRefETUsed(Sender: TObject): boolean; virtual;
    function GetFarmProcess4SteadyRefETUsed: TObjectUsedEvent;
    property FarmProcess4SteadyRefETUsed: TObjectUsedEvent read GetFarmProcess4SteadyRefETUsed;
    function DoFarmProcess4SteadyCropsUsed(Sender: TObject): boolean; virtual;
    function GetFarmProcess4SteadyCropsUsed: TObjectUsedEvent;
    property FarmProcess4SteadyCropsUsed: TObjectUsedEvent read GetFarmProcess4SteadyCropsUsed;
    function FarmProcess4TransientCropsUsed(Sender: TObject): boolean; virtual;
    function FarmProcess4TransientEfficiencyArrayUsed(Sender: TObject): boolean; virtual;
    function DoSoilIDUsed(Sender: TObject): boolean; virtual;
    function GetSoilIDUsed: TObjectUsedEvent;
    property SoilIDUsed: TObjectUsedEvent read GetSoilIDUsed;
    // LAND_USE_AREA_FRACTION
    function MultipleLandUseFractionsUsed(Sender: TObject): Boolean;
    // CROP_COEFFICIENT
    function MultipleCropCoefficientUsed(Sender: TObject): Boolean;
    // CONSUMPTIVE_USE
    function MultipleConsumptiveUseUsed(Sender: TObject): Boolean;
    // IRRIGATION
    function MultipleIrrigationUsed(Sender: TObject): Boolean;
    // ROOT_DEPTH
    function MultipleRootDepthUsed(Sender: TObject): Boolean;
    // GROUNDWATER_ROOT_INTERACTION
    function MultipleGroundwaterRootInteractionUsed(Sender: TObject): Boolean;
    // TRANSPIRATION_FRACTION
    function MultipleTranspirationFractionUsed(Sender: TObject): Boolean;
    // EVAPORATION_IRRIGATION_FRACTION
    function MultipleEvaporationIrrigationUsed(Sender: TObject): Boolean;
    // SURFACEWATER_LOSS_FRACTION_PRECIPITATION
    function MultipleSWLossFractionPrecipUsed(Sender: TObject): Boolean;
    // SURFACEWATER_LOSS_FRACTION_IRRIGATION
    function MultipleSWLossFractionIrrigationUsed(Sender: TObject): Boolean;
    // ADDED_DEMAND
    function MultipleAddedDemandUsed(Sender: TObject): Boolean;
    // CROP_HAS_SALINITY_DEMAND
    function MultipleCropHasSalinityDemandUsed(Sender: TObject): Boolean;

    function DoGroundSurfaceUsed(Sender: TObject): boolean; virtual;
    function GetGroundSurfaceUsed: TObjectUsedEvent;
    property GroundSurfaceUsed: TObjectUsedEvent read GetGroundSurfaceUsed;
    function DoUzfUnsatVertKUsed(Sender: TObject): boolean; virtual;
    function GetUzfUnsatVertKUsed: TObjectUsedEvent;
    property UzfUnsatVertKUsed: TObjectUsedEvent read GetUzfUnsatVertKUsed;
    function DoUzfInitialInfiltrationUsed(Sender: TObject): boolean; virtual;
    function GetUzfInitialInfiltrationUsed: TObjectUsedEvent;
    property UzfInitialInfiltrationUsed: TObjectUsedEvent read GetUzfInitialInfiltrationUsed;
    function DoUzfResidualWaterContentUsed(Sender: TObject): boolean; virtual;
    function GetUzfResidualWaterContentUsed: TObjectUsedEvent;
    property UzfResidualWaterContentUsed: TObjectUsedEvent read GetUzfResidualWaterContentUsed;
    function DoUzfSurfKUsed(Sender: TObject): boolean; virtual;
    function GetUzfSurfKUsed: TObjectUsedEvent;
    property UzfSurfKUsed: TObjectUsedEvent read GetUzfSurfKUsed;

    property TransientMultiplierArrays: TList read FTransientMultiplierArrays;
    property TransientZoneArrays: TList read FTransientZoneArrays;

    function IndenticalTransientMultiplierArray(DataArray: TDataArray): TDataArray;
    function IndenticalTransientZoneArray(DataArray: TDataArray): TDataArray;

    property ModflowFullStressPeriods: TModflowStressPeriods
      read GetModflowFullStressPeriods;

    procedure UpdateModflowFullStressPeriods;
    procedure AddTimeList(TimeList: TCustomTimeList);
    procedure RemoveTimeList(TimeList: TCustomTimeList);
    // @name provides access to all the @link(TCustomTimeList)s in the model.
    property TimeLists[Index: integer]: TCustomTimeList read GetTimeLists;
    // @name is the number of @link(TCustomTimeList)s in @link(TimeLists).
    property TimeListCount: integer read GetTimeListCount;

    property MfHobHeads: THobDisplayTimeList read FMfHobHeads;
    property Mt3dTobCond: TMt3dmsTobDisplayTimeList read FMt3dTobCond;

    function ProgramName: string;

    property UnitNumbers: TUnitNumbers read GetUnitNumbers
      write SetUnitNumbers stored False;

    function PackageGeneratedExternally(const PackageName: string): boolean;
    procedure WritePValAndTemplate(const ParameterName: string;
      const Value: double; Parameter: TModflowParameter;
      DirectAddRequired: Boolean = False);

    property HfbDisplayer: THfbDisplayer read FHfbDisplayer;

    function GetObserverByName(const ObserverName: string): TObserver;
    function CheckWetting: boolean;

    property ProgramLocations: TProgramLocations read GetProgramLocations
      write SetProgramLocations;

    function FixFileName(AFileName: string): string;
    // @name exports the input files for MODFLOW and optionally runs MODFLOW.
    procedure ExportModflowModel(const FileName: string;
      RunModel, ExportModpath, NewBudgetFileForModpath, ExportZoneBudget,
      ShowWarning: boolean);
    procedure InvalidateAllDynamicLists;
    procedure ExportWellCsv(const FileName: string);
    procedure ExportModpathModel(FileName: string;
      RunModel, NewBudgetFile: boolean; EmbeddedExport: boolean = False);
    procedure ExportZoneBudgetModel(FileName: string;
      RunModel, EmbeddedExport: boolean);
    procedure ExportMt3dmsModel(const FileName: string;
      RunModel, ShowWarning: Boolean);
    function DoSutra4Used(Sender: TObject): boolean;
    function GetSutra4Used: TObjectUsedEvent;
    property Sutra4Used: TObjectUsedEvent read GetSutra4Used;
    function DoSutra4EnergyUsed(Sender: TObject): boolean;
    function GetSutra4EnergyUsed: TObjectUsedEvent;
    property Sutra4EnergyUsed: TObjectUsedEvent read GetSutra4EnergyUsed;
    function DoSutra4SoluteUsed(Sender: TObject): boolean;
    function GetSutra4SoluteUsed: TObjectUsedEvent;
    property Sutra4SoluteUsed: TObjectUsedEvent read GetSutra4SoluteUsed;
    function DoSutra4EnergyOrSorptionUsed(Sender: TObject): boolean;
    function GetSutra4EnergyOrSorptionUsed: TObjectUsedEvent;
    property Sutra4EnergyOrSorptionUsed: TObjectUsedEvent read GetSutra4EnergyOrSorptionUsed;
    function DoSutra4FreezingUsed(Sender: TObject): boolean;
    function GetSutra4FreezingUsed: TObjectUsedEvent;
    property Sutra4FreezingUsed: TObjectUsedEvent read GetSutra4FreezingUsed;
    function DoSutra4ProductionUsed(Sender: TObject): boolean;
    function GetSutra4ProductionUsed: TObjectUsedEvent;
    property Sutra4ProductionUsed: TObjectUsedEvent read GetSutra4ProductionUsed;

    // @name is the @link(TCustomTimeList) for
    // the transient data set used to color
    // the front view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(FrontDisplayTime) and
    // TCustomModelGrid.@link(TCustomModelGrid.FrontDataSet).
    property FrontTimeList: TCustomTimeList read FFrontTimeList
      write SetFrontTimeList;

    // @name is the TPhastTimeList for the transient data set used to color
    // the side view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(SideDisplayTime) and
    // TCustomModelGrid.@link(TCustomModelGrid.SideDataSet).
    property SideTimeList: TCustomTimeList read FSideTimeList
      write SetSideTimeList;
    // @name is the @link(TCustomTimeList)
    // for the transient data set used to color
    // the top view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(TopDisplayTime) and
    // TCustomModelGrid.@link(TCustomModelGrid.TopDataSet).
    property TopTimeList: TCustomTimeList read FTopTimeList
      write SetTopTimeList;
    // @name is the time for the transient data set used to color the
    // top view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(TopTimeList) and
    // TCustomModelGrid.@link(TCustomModelGrid.TopDataSet).
    property TopDisplayTime: double read FTopDisplayTime;
    // @name is the time for the transient data set used to color the
    // front view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(FrontTimeList) and
    // TCustomModelGrid.@link(TCustomModelGrid.FrontDataSet).
    property FrontDisplayTime: double read FFrontDisplayTime;
    // @name is the time for the transient data set used to color the
    // side view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(SideTimeList) and
    // TCustomModelGrid.@link(TCustomModelGrid.SideDataSet).
    property SideDisplayTime: double read FSideDisplayTime;
    // @name is the time for the transient data set used to color the
    // 3D view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(ThreeDTimeList) and
    // TCustomModelGrid.@link(TCustomModelGrid.ThreeDDataSet).
    property ThreeDDisplayTime: double read FThreeDDisplayTime
      write FThreeDDisplayTime;
    // @name is the @link(TCustomTimeList) for
    // the transient data set used to color
    // the 3D view of the grid.
    // If the data set used to color the grid is not transient, or the grid
    // is not colored, @name has no meaning.
    // See @link(ThreeDDisplayTime) and
    // TCustomModelGrid.@link(TCustomModelGrid.ThreeDDataSet).
    property ThreeDTimeList: TCustomTimeList read FThreeDTimeList
      write FThreeDTimeList;
    property ModflowSteadyParameters: TModflowSteadyParameters
      read GetModflowSteadyParameters write SetModflowSteadyParameters;

    property LayerStructure: TLayerStructure read GetLayerStructure
      write SetLayerStructure;

    property ModflowStressPeriods: TModflowStressPeriods
      read GetModflowStressPeriods write SetModflowStressPeriods;

    // @name stores SoluteTransport option in PHAST.
    property SoluteTransport: boolean read GetSoluteTransport
      write SetSoluteTransport;

    // @name stores whether PHAST is using the water table
    // to set the initial condition.
    property UseWaterTable: boolean read GetUseWaterTable write SetUseWaterTable;

    // @name stores FreeSurface option in PHAST.
    property FreeSurface: boolean read GetFreeSurface write SetFreeSurface;

    // @name stores options related to chemistry in PHAST.
    property ChemistryOptions: TChemistryOptions read GetChemistryOptions
      write SetChemistryOptions;

    property HufParameters: THufModflowParameters read GetHufParameters
      write SetHufParameters;

    property ObservationPurpose: TObservationPurpose read GetObservationPurpose
      write SetObservationPurpose;

    property ModflowTransientParameters: TModflowTransientListParameters
      read GetModflowTransientParameters write SetModflowTransientParameters;

    property ModflowOutputControl: TModflowOutputControl
      read GetModflowOutputControl write SetModflowOutputControl;

    property Mt3dmsOutputControl: TMt3dmsOutputControl
      read GetMt3dmsOutputControl write SetMt3dmsOutputControl;
    property Mt3dmsTimes: TMt3dmsTimeCollection read GetMt3dmsTimes
      write SetMt3dmsTimes;

    // @name stores the @link(TDataArray)s in GoPhast.
    property DataSetList: TDataSetCollection read GetDataSetCollection
      write FDataSetCollection;

    procedure InvalidateMfSfrStreamTop(Sender: TObject);
    procedure InvalidateMfSfrStreamSlope(Sender: TObject);
    procedure InvalidateMfSfrStreamThickness(Sender: TObject);
    procedure InvalidateMfSfrStreamK(Sender: TObject);
    procedure InvalidateMfSfrSaturatedWaterContent(Sender: TObject);
    procedure InvalidateMfSfrInitialWaterContent(Sender: TObject);
    procedure InvalidateMfSfrBrooksCorey(Sender: TObject);
    procedure InvalidateMfSfrVerticalUnsatK(Sender: TObject);
    procedure InvalidateMfSfrUpstreamHydraulicConductivity(Sender: TObject);
    procedure InvalidateMfSfrDownstreamHydraulicConductivity(Sender: TObject);
    procedure InvalidateMfSfrUpstreamWidth(Sender: TObject);
    procedure InvalidateMfSfrDownstreamWidth(Sender: TObject);
    procedure InvalidateMfSfrUpstreamThickness(Sender: TObject);
    procedure InvalidateMfSfrDownstreamThickness(Sender: TObject);
    procedure InvalidateMfSfrUpstreamElevation(Sender: TObject);
    procedure InvalidateMfSfrDownstreamElevation(Sender: TObject);
    procedure InvalidateMfSfrUpstreamUnsaturatedWaterContent(Sender: TObject);
    procedure InvalidateMfSfrDownstreamUnsaturatedWaterContent(Sender: TObject);
    procedure InvalidateMfSfrUpstreamUnsatInitialWaterContent(Sender: TObject);
    procedure InvalidateMfSfrDownstreamUnsatInitialWaterContent(
      Sender: TObject);
    procedure InvalidateMfSfrUpstreamBrooksCorey(Sender: TObject);
    procedure InvalidateMfSfrDownstreamBrooksCorey(Sender: TObject);
    procedure InvalidateMfSfrUpstreamUnsatKz(Sender: TObject);
    procedure InvalidateMfSfrDownstreamUnsatKz(Sender: TObject);
    procedure InvalidateMfRchLayer(Sender: TObject);
    procedure InvalidateMfConduitRecharge(Sender: TObject);
    procedure InvalidateMfConduitCadsRecharge(Sender: TObject);

    procedure InvalidateMnw1DesiredPumpingRate(Sender: TObject);
    procedure InvalidateMnw1WaterQuality(Sender: TObject);
    procedure InvalidateMnw1WellRadius(Sender: TObject);
    procedure InvalidateMnw1Conductance(Sender: TObject);
    procedure InvalidateMnw1SkinFactor(Sender: TObject);
    procedure InvalidateMnw1LimitingWaterLevel(Sender: TObject);
    procedure InvalidateMnw1ReferenceElevation(Sender: TObject);
    procedure InvalidateMnw1WaterQualityGroup(Sender: TObject);
    procedure InvalidateMnw1NonLinearLossCoefficient(Sender: TObject);
    procedure InvalidateMnw1MinimumPumpingRate(Sender: TObject);
    procedure InvalidateMnw1ReactivationPumpingRate(Sender: TObject);

    procedure InvalidateRipGroundSurface(Sender: TObject);
    procedure InvalidateRipCoverages(Sender: TObject);

    function GetScreenObjectInterfaceByName(AName: string): IScreenObject;
    function GetScreenObjectByName(AName: string): TScreenObject; virtual; abstract;
    // @name sets the event handlers for the discharge routing array in
    // the UZF package.
    procedure DischargeRoutingUpdate;
    property SelectedModel: TCustomModel read GetSelectedModel write SetSelectedModel;

    // name is called in @link(SetModelSelection).
    // The event handler for this event is
    // @link(TfrmGoPhast.ModelSelectionChange).
    property OnModelSelectionChange: TNotifyEvent read FOnModelSelectionChange
      write FOnModelSelectionChange;
    // @name updates @link(TDataArray.ParameterUsed TDataArray.ParameterUsed)
    // and @link(TDataArray.ParameterFormula TDataArray.ParameterFormula)
    // for the @link(TDataArray)s related to the LPF parameters.
    procedure UpdateDataArrayParameterUsed; virtual;
    // @name calls TScreenObject.@link(TScreenObject.Invalidate)
    // for every @link(TScreenObject) in @link(ScreenObjects).
    procedure InvalidateScreenObjects;
    property SelectedColumn: integer read GetSelectedColumn write SetSelectedColumn;
    property SelectedRow: integer read GetSelectedRow write SetSelectedRow;
    property SelectedLayer: integer read GetSelectedLayer write SetSelectedLayer;
    property DisplayColumn: integer read GetDisplayColumn write SetDisplayColumn;
    property DisplayRow: integer read GetDisplayRow write SetDisplayRow;
    property DisplayLayer: integer read GetDisplayLayer write SetDisplayLayer;
    // If @name is @true, there is at least one @link(TScreenObject)
    // in which TScreenObject.Segments.@link(
    // TCellElementSegmentList.UpToDate) is @True
    // @name is used in @link(TPhastModel.InvalidateSegments).
    property SomeSegmentsUpToDate: boolean read GetSomeSegmentsUpToDate
      write SetSomeSegmentsUpToDate;
    procedure InvalidateMfChdStartingHead(Sender: TObject);
    procedure InvalidateMfChdEndingHead(Sender: TObject);
    procedure InvalidateMfChdActive(Sender: TObject);
    procedure InvalidateMfChdMultiplier(Sender: TObject);
    procedure InvalidateMfChdConc(Sender: TObject);
    procedure InvalidateMfGhbConductance(Sender: TObject);
    procedure InvalidateMfGhbMultiplier(Sender: TObject);
    procedure InvalidateMfGhbBoundaryHead(Sender: TObject);
    procedure InvalidateMfGhbConc(Sender: TObject);
    procedure InvalidateMfWellPumpage(Sender: TObject);
    procedure InvalidateMfWellMultiplier(Sender: TObject);
    procedure InvalidateMfWellConc(Sender: TObject);
    procedure InvalidateMfRivConductance(Sender: TObject);
    procedure InvalidateMfRivMultiplier(Sender: TObject);
    procedure InvalidateMfRivStage(Sender: TObject);
    procedure InvalidateMfRivBottom(Sender: TObject);
    procedure InvalidateMfRivConc(Sender: TObject);
    procedure InvalidateMfDrnConductance(Sender: TObject);
    procedure InvalidateMfDrnElevation(Sender: TObject);
    procedure InvalidateMfDrnDdrn(Sender: TObject);
    procedure InvalidateMfDrnMultiplier(Sender: TObject);
    procedure InvalidateMfDrtConductance(Sender: TObject);
    procedure InvalidateMfDrtElevation(Sender: TObject);
    procedure InvalidateMfDrtReturnFraction(Sender: TObject);
    procedure InvalidateMfRchRate(Sender: TObject);
    procedure InvalidateMfRchMultiplier(Sender: TObject);
    procedure InvalidateMfRchConc(Sender: TObject);
    procedure InvalidateMfUzfInfiltration(Sender: TObject);
    procedure InvalidateMfEvtEvapRate(Sender: TObject);
    procedure InvalidateMfEvtEvapSurface(Sender: TObject);
    procedure InvalidateMfEvtEvapDepth(Sender: TObject);
    procedure InvalidateMfEvtEvapLayer(Sender: TObject);
    procedure InvalidateMfEtsEvapRate(Sender: TObject);
    procedure InvalidateMfEtsEvapSurface(Sender: TObject);
    procedure InvalidateMfEtsEvapDepth(Sender: TObject);
    procedure InvalidateMfEtsMultiplier(Sender: TObject);
    procedure InvalidateMfEtsEvapLayer(Sender: TObject);
    procedure InvalidateEtsDepthFractions(Sender: TObject);
    procedure InvalidateEtsRateFractions(Sender: TObject);
//    procedure InvalidateEtsConc(Sender: TObject);
    procedure InvalidateMfUzfEtDemand(Sender: TObject);
    procedure InvalidateMfUzfExtinctionDepth(Sender: TObject);
    procedure InvalidateMfUzfWaterContent(Sender: TObject);
    procedure InvalidateMt3dmsChemSources(Sender: TObject);

    procedure InvalidateUzfMf6Infiltration(Sender: TObject);
    procedure InvalidateUzfMf6PotentialET(Sender: TObject);
    procedure InvalidateUzfMf6ExtinctionDepth(Sender: TObject);
    procedure InvalidateUzfMf6ExtinctionWaterContent(Sender: TObject);
    procedure InvalidateUzfMf6AirEntryPotential(Sender: TObject);
    procedure InvalidateUzfMf6RootPotential(Sender: TObject);
    procedure InvalidateUzfMf6RootActivity(Sender: TObject);
    procedure InvalidateUzfMf6Multiplier(Sender: TObject);
    procedure InvalidateUzfGwtConc(Sender: TObject);

    procedure InvalidateMfStrConductance(Sender: TObject);
    procedure InvalidateMfStrStage(Sender: TObject);
    procedure InvalidateMfStrBedTop(Sender: TObject);
    procedure InvalidateMfStrBedBottom(Sender: TObject);
    procedure InvalidateMfStrFlow(Sender: TObject);
    procedure InvalidateMfStrWidth(Sender: TObject);
    procedure InvalidateMfStrSlope(Sender: TObject);
    procedure InvalidateMfStrRoughness(Sender: TObject);
    procedure InvalidateMfStrSegmentNumber(Sender: TObject);
    procedure InvalidateMfStrOutflowSegmentNumber(Sender: TObject);
    procedure InvalidateMfStrDiversionSegmentNumber(Sender: TObject);
    procedure InvalidateMfStrReachNumber(Sender: TObject);

    procedure InvalidateMfFhbHeads(Sender: TObject);
    procedure InvalidateMfFhbFlows(Sender: TObject);

    // relates to pumping rate in farm wells.
    procedure InvalidateMfFmpMaxPumpingRate(Sender: TObject);
    // relates to the NOCIRNOQ option in farm wells.
    procedure InvalidateMfFmpPumpOnlyIfCropRequiresWater(Sender: TObject);
    // relates to Farm ID in farm wells in FMP3.
    procedure InvalidateMfFmpWellFarmID(Sender: TObject);
    procedure InvalidateMfFmpPrecip(Sender: TObject);
    procedure InvalidateMfFmpEvap(Sender: TObject);
    procedure InvalidateMfFmpCropID(Sender: TObject);
    procedure InvalidateMfFmpFarmID(Sender: TObject);

    // relates to Farm ID in FMP4.
    procedure InvalidateMfFmp4FarmID(Sender: TObject);
    procedure InvalidateMfFmp4Precip(Sender: TObject);
    procedure InvalidateMfFmp4Evap(Sender: TObject);
    procedure InvalidateMfFmp4CropID(Sender: TObject);
    procedure InvalidateMfFmp4Efficiency(Sender: TObject);
    procedure InvalidateMfFmp4EfficiencyImprovement(Sender: TObject);
    procedure InvalidateMfFmp4BareRunoffFraction(Sender: TObject);
    procedure InvalidateMfFmp4AddedDemandRunoffSplit(Sender: TObject);
    procedure InvalidateMfFmp4BarePrecipitationConsumptionFraction(Sender: TObject);
    procedure InvalidateMfFmp4BareEvap(Sender: TObject);
    procedure InvalidateMfFmp4DirectRecharge(Sender: TObject);
    procedure InvalidateMfFmp4PrecipPotConsumption(Sender: TObject);
    procedure InvalidateMfFmp4NrdInfilLocation(Sender: TObject);
    procedure InvalidateMfFmp4LandUseAreaFraction(Sender: TObject);
    procedure InvalidateMfFmp4CropCoefficient(Sender: TObject);
    procedure InvalidateMfFmp4ConsumptiveUse(Sender: TObject);
    procedure InvalidateMfFmp4Irrigation(Sender: TObject);
    procedure InvalidateMfFmp4RootDepth(Sender: TObject);
    procedure InvalidateMfFmp4TranspirationFraction(Sender: TObject);
    procedure InvalidateMfFmp4EvaporationIrrigationFraction(Sender: TObject);
    procedure InvalidateMfFmp4FractionOfPrecipToSurfaceWater(Sender: TObject);
    procedure InvalidateMfFmp4FractionOfIrrigToSurfaceWater(Sender: TObject);
    procedure InvalidateMfFmp4AddedDemand(Sender: TObject);
    procedure InvalidateMfFmp4CropHasSalinityDemand(Sender: TObject);

    procedure InvalidateMfSwrRainfall(Sender: TObject);
    procedure InvalidateMfSwrEvaporation(Sender: TObject);
    procedure InvalidateMfSwrLateralInflow(Sender: TObject);
    procedure InvalidateMfSwrStage(Sender: TObject);
    procedure InvalidateMfSwrDirectRunoffReach(Sender: TObject);
    procedure InvalidateMfSwrDirectRunoffValue(Sender: TObject);
    procedure InvalidateMfSwrVerticalOffset(Sender: TObject);
    procedure InvalidateMfSwrBoundaryType(Sender: TObject);
    procedure InvalidateMfSwrGeometryNumber(Sender: TObject);

    procedure InvalidateUztRechConc(Sender: TObject);
    procedure InvalidateUztUnsatConc(Sender: TObject);
    procedure InvalidateUztSatConc(Sender: TObject);
    procedure InvalidateUzfSsmSinkConc(Sender: TObject);

    procedure InvalidateSftHeadwatersConc(Sender: TObject);
    procedure InvalidateSftPrecipConc(Sender: TObject);
    procedure InvalidateSftRunoffConc(Sender: TObject);
    procedure InvalidateSftConstConc(Sender: TObject);

    procedure InvalidateSfr6Inflow(Sender: TObject);
    procedure InvalidateSfr6Rainfall(Sender: TObject);
    procedure InvalidateSfr6Evaporation(Sender: TObject);
    procedure InvalidateSfr6Runoff(Sender: TObject);
    procedure InvalidateSfr6UpstreamFraction(Sender: TObject);
    procedure InvalidateSfr6Stage(Sender: TObject);
    procedure InvalidateSfr6Roughness(Sender: TObject);
    procedure InvalidateSfr6StreamStatus(Sender: TObject);
    procedure InvalidateSfr6ReachNumber(Sender: TObject);
    procedure InvalidateSfr6GwtConc(Sender: TObject);

    procedure InvalidateMawFlowingWellElevation(Sender: TObject);
    procedure InvalidateMawFlowingWellConductance(Sender: TObject);
    procedure InvalidateMawFlowingWellReductionLength(Sender: TObject);
    procedure InvalidateMawWell_Rate(Sender: TObject);
    procedure InvalidateMawWell_Head(Sender: TObject);
    procedure InvalidateMawWell_Limit(Sender: TObject);
    procedure InvalidateMawMinimumPumpRate(Sender: TObject);
    procedure InvalidateMawMaximumPumpRate(Sender: TObject);
    procedure InvalidateMawPumpElevation(Sender: TObject);
    procedure InvalidateMawScalingLength(Sender: TObject);
    procedure InvalidateMawGwtConc(Sender: TObject);
    procedure InvalidateMawDensity(Sender: TObject);
    procedure InvalidateMawViscosity(Sender: TObject);

    procedure InvalidateCSubStressOffset(Sender: TObject);

    procedure InvalidateCncActive(Sender: TObject);
    procedure InvalidateCncConcentration(Sender: TObject);
    procedure InvalidateCncMultiplier(Sender: TObject);
    procedure InvalidateMassSrcActive(Sender: TObject);
    procedure InvalidateMassSrc(Sender: TObject);
    procedure InvalidateMassSrcMultiplier(Sender: TObject);

    procedure InvalidateTransientKx(Sender: TObject);
    procedure InvalidateTransientKy(Sender: TObject);
    procedure InvalidateTransientKz(Sender: TObject);
    procedure InvalidateTransientSS(Sender: TObject);
    procedure InvalidateTransientSY(Sender: TObject);

    property NameFileWriter: TObject read FNameFileWriter write SetNameFileWriter;
    property SimNameWriter: IMf6_SimNameFileWriter read FSimNameWriter write FSimNameWriter;
    function ModflowLayerCount: integer; virtual;
    function ModflowConfiningBedCount: integer; virtual;
    procedure WriteLAYCB(const DiscretizationWriter: TObject); virtual;
    // @name returns true if a layer in the MODFLOW grid is simulated
    // LayerID is zero-based.
    function IsLayerSimulated(const LayerID: integer): boolean; virtual;
    function IsLayerConfined(const LayerID: integer): boolean; virtual;
    Function Laytyp: TOneDIntegerArray; virtual;
    Function Layavg: TOneDIntegerArray; virtual;
    function Chani: TOneDIntegerArray; virtual;
    Function Layvka: TOneDIntegerArray; virtual;
    function Trpy: TOneDRealArray; virtual;
    Function TRPT: TOneDRealArray; virtual;
    function TRPV: TOneDRealArray; virtual;
    Function DMCOEF: TOneDRealArray; virtual;
    function GetLayerGroupByLayer(const Layer: integer): TLayerGroup; virtual;
    function ModflowLayerBottomDescription(const LayerID: integer): string; virtual;
    // @name converts a MODFLOW model layer (starting at 1) to the
    // appropriate index in a 3D data array;
    Function ModflowLayerToDataSetLayer(ModflowLayer: integer): integer; virtual;
    function DataSetLayerToModflowLayer(DataSetLayer: integer): integer; virtual;
    // @name is used to move a boundary to a new position when
    // the current position is invalid.  This version of @name does nothing
    // but in @link(TChildModel.AdjustCellPosition
    // TChildModel.AdjustCellPosition), it is used to move boundary cells away
    // from the edge of the model.
    procedure AdjustCellPosition(AValueCell: TValueCell); overload; virtual;
    procedure AdjustCellPosition(ACellAssignment: TCellAssignment); overload; virtual;
    // @name is used in local grid refinement to adjust the values
    // of recharge (RCH, UZF package) and max ET (in EVT, ETS, and UZF) packages.
    // at the interface between the grids.
    procedure AdjustDataArray(ADataArray: TDataArray); virtual; abstract;
    procedure AdjustResKvArray(Sender: TObject);
    // @name is the event handler for @link(TDataArray.OnDataSetUsed
    // TDataArray.OnDataSetUsed) for @link(TDataArray)s that have model results.
    function ModelResultsRequired(Sender: TObject): boolean;
    procedure BeginGridChange; virtual;
    procedure EndGridChange; virtual;
    property SaveBfhBoundaryConditions: boolean read GetSaveBfhBoundaryConditions
      write SetSaveBfhBoundaryConditions default True;
    procedure DrawHeadObservations(const BitMap: TPersistent;
      const ZoomBox: TQrbwZoomBox2); virtual;
    procedure DrawPestPointObservations(const BitMap: TPersistent;
      const ZoomBox: TQrbwZoomBox2);
    procedure DrawMt3dPointObservations(const BitMap: TPersistent;
      const ZoomBox: TQrbwZoomBox2);
    procedure InvalidateMfHobHeads(Sender: TObject);
    procedure InvalidateSwiObs(Sender: TObject);
    procedure InvalidateMt3dTobConcs(Sender: TObject);
    property ContourFont: TFont read GetContourFont write SetContourFont;
    property ShowContourLabels: boolean read GetShowContourLabels
      write SetShowContourLabels default True;
    procedure UpdateMt3dmsChemDataSets; virtual; abstract;
    procedure GenerateSutraMesh(var ErrorMessage: string);
    procedure OnTopSutraMeshChanged(Sender: TObject);
    property ThreeDDataSet: TDataArray read GetThreeDDataSet
      write SetThreeDDataSet;
    property TopDataSet: TDataArray read GetTopDataSet
      write SetTopDataSet;
    property FrontDataSet: TDataArray read GetFrontDataSet
      write SetFrontDataSet;
    property SideDataSet: TDataArray read GetSideDataSet
      write SetSideDataSet;
    property ThreeDContourDataSet: TDataArray read GetThreeDContourDataSet
      write SetThreeDContourDataSet;
    property TopContourDataSet: TDataArray read GetTopContourDataSet
      write SetTopContourDataSet;
    property FrontContourDataSet: TDataArray read GetFrontContourDataSet
      write SetFrontContourDataSet;
    property SideContourDataSet: TDataArray read GetSideContourDataSet
      write SetSideContourDataSet;
    procedure DiscretizationChanged;
    property Mesh: IMesh read GetMesh;
    property DrawMesh: IDrawMesh read GetDrawMesh;
    property Mesh3D: IMesh3D read GetMesh3D;
    function TwoDElementCenter(const Column, Row: integer): TPoint2D;
    function TwoDElementCorner(const Column, Row: integer): TPoint2D;
    property SfrStreamLinkPlot: TSfrStreamLinkPlot read GetSfrStreamLinkPlot
      write SetSfrStreamLinkPlot;
    property StrStreamLinkPlot: TSfrStreamLinkPlot read GetStrStreamLinkPlot
      write SetStrStreamLinkPlot;
    property SfrMf6StreamLinkPlot: TSfrStreamLinkPlot read GetSfrMf6StreamLinkPlot
      write SetSfrMf6StreamLinkPlot;
    property SwrReachConnectionsPlot: TSwrReachConnectionsPlot
      read GetSwrReachConnectionsPlot write SetSwrReachConnectionsPlot;
    procedure InvalidateSutraSpecPressure(Sender: TObject);
    procedure InvalidateSutraSpecPressureU(Sender: TObject);
    procedure InvalidateSutraFluidFlux(Sender: TObject);
    procedure InvalidateSutraFluidFluxU(Sender: TObject);
    procedure InvalidateSutraSpecifiedU(Sender: TObject);
    procedure InvalidateSutraUFlux(Sender: TObject);
    procedure InvalidateSutraGenFlowPress1(Sender: TObject);
    procedure InvalidateSutraGenFlowPress2(Sender: TObject);
    procedure InvalidateSutraGenFlowRate1(Sender: TObject);
    procedure InvalidateSutraGenFlowRate2(Sender: TObject);
    procedure InvalidateSutraGenFlowU1(Sender: TObject);
    procedure InvalidateSutraGenFlowU2(Sender: TObject);
    procedure InvalidateSutraGenTransU1(Sender: TObject);
    procedure InvalidateSutraGenTransU2(Sender: TObject);
    procedure InvalidateSutraGenTransQU1(Sender: TObject);
    procedure InvalidateSutraGenTransQU2(Sender: TObject);
    procedure UpdateSutraTimeListNames;
    property SP_Epsilon: double read F_SP_Epsilon;
    function RelativeFileName(const FullFileName: string): string;
    function CfpIsSelected: Boolean; virtual;
    function SwrIsSelected: Boolean; virtual;
    function Mf6ObsIsSelected: Boolean; virtual;
    function DoCfpPipesSelected(Sender: TObject): Boolean;
    function DoCfp2PipesSelected(Sender: TObject): Boolean;
    function DoCfpCadsSelected(Sender: TObject): Boolean;
    function GetCfpPipesSelected: TObjectUsedEvent;
    function GetCfpPipes2Selected: TObjectUsedEvent;
    property CfpPipesSelected: TObjectUsedEvent read GetCfpPipesSelected;
    property CfpCadsSelected: TObjectUsedEvent read GetCfpCadsSelected;
    property Cfp2PipesSelected: TObjectUsedEvent read GetCfpPipes2Selected;
    procedure ExportHeadObservationsToShapeFile(const FileName: string);
    property OnHeadOBsChanged: TNotifyEvent read FOnHeadOBsChanged
      write FOnHeadOBsChanged;
    property CrossSection: TCrossSection read GetCrossSection write SetCrossSection;
    property OnCrossSectionChanged: TNotifyEvent read FOnCrossSectionChanged
      write FOnCrossSectionChanged;
    function DiscretizationLimits(ViewDirection: TViewDirection): TGridLimit;
    function DoModflow6Selected(Sender: TObject): boolean;
    function GetModflow6Selected: TObjectUsedEvent;
    property Modflow6Selected: TObjectUsedEvent read GetModflow6Selected;
    function DoStorageSelected(Sender: TObject): boolean;
    function GetStorageSelected: TObjectUsedEvent;
    property StorageSelected: TObjectUsedEvent read GetStorageSelected;
    procedure AddModpathInputFile(AFileName: string);
    procedure AddModpathOutputFile(AFileName: string);
    procedure AddZoneBudgetInputFile(AFileName: string);
    procedure AddZoneBudgetOutputFile(AFileName: string);
    procedure AddSwiObsExtInputFile(AFileName: string);
    procedure AddSwiObsExtOutputFile(AFileName: string);
    procedure AddMt3dmsInputFile(AFileName: string);
    procedure AddMt3dmsOutputFile(AFileName: string);
    procedure AddModelOutputFile(AFileName: string);
    procedure AddExternalFile(AFileName: string);
    procedure AddBinaryFile(AFileName: string);
    property GeoRef: TGeoRef read GetGeoRef write SetGeoRef;
    function NWT_Format: TNwtFormat;
    property ContourLegend: TLegend read GetContourLegend;
    procedure ClearBinaryFiles; virtual;
    function UzfSeepageUsed: boolean; virtual;
    function DisvUsed: Boolean;
    property OnGridTypeChanged: TNotifyEvent read FOnGridTypeChanged
      write FOnGridTypeChanged;
    property DiscretiztionElevation[Column, Row, Layer: Integer]: Double
      read GetDiscretiztionElevation;
    property LayerThickness[Layer, Row, Column: Integer]: Double
      read GetLayerThickness;
    // @name converts the MODFLOW-2005 version of SFR to the MODFLOW-6 version
    // of SFR.
    procedure ConvertSfr;
    // @name converts the MODFLOW-2005 STR package to the MODFLOW-6 version
    // of SFR.
    procedure ConvertStr;
    function StoreDisvGrid: Boolean;
    property TopContoursUpToDate: Boolean read FTopContoursUpToDate write FTopContoursUpToDate;
    property SideContoursUpToDate: Boolean read FSideContoursUpToDate write FSideContoursUpToDate;
    property FrontContoursUpToDate: Boolean read FFrontContoursUpToDate write FFrontContoursUpToDate;
    procedure InvalidateContours; virtual;
    property UseGsflowFormat: boolean read GetUseGsflowFormat
      write SetUseGsflowFormat;
    function MawScreenObjects: TStringList;
    function SfrMf6ScreenObjects: TStringList;
    function LakScreenObjects: TStringList;
    function UzfMf6ScreenObjects: TStringList;
    function NumberOfMt3dChemComponents: integer;
    property Mt3dSpecesName[const Index: Integer]: string read GetMt3dSpecesName;
    function Mt3dIsSelected: Boolean; virtual;
    procedure FillObsItemList(List: TObservationList; IncludeComparisons: Boolean = False);
    procedure FillObsInterfaceItemList(List: TObservationInterfaceList;
      IncludeComparisons: Boolean = False);
    property PestUsed: Boolean read GetPestUsed;
    property PestStatus: TPestStatus read GetPestStatus;
    property SutraLakesUsed: Boolean read GetSutraLakesUsed;
    property DirectObservationLines: TStringList read FDirectObservationLines;
    property DerivedObservationLines: TStringList read FDerivedObservationLines;
    property FileNameLines: TStringList read FFileNameLines;
    // @name is the vertical exaggeration of the front, side, and 3D views
    // of the model in GoPhast.
    // @name is used in PHAST, MODFLOW, and SUTRA models.
    property Exaggeration: double read GetExaggeration write SetExaggeration;
    // Layer, Row, and Column are Zero based.
    property ElementLocation[Layer, Row, Column: Integer]: TDualLocation
      read GetElementLocation;
    property ActiveElement[Layer, Row, Column: Integer]: Boolean
      read GetActiveElement;
    // @name consists of lines that will be added to RunModel.Bat before the
    // model executable line
    property PestTemplateLines: TStringList read FPestTemplateLines;
    property KrigfactorsScriptLines: TStringList read FKrigfactorsScriptLines;
    property Discretization: TCustomDiscretization read GetDiscretization;
    property PilotPointDataArrays: TDataArrayList read FPilotPointDataArrays;
    property ParamGroups: TPestParamGroups read GetParamGroups
      write SetParamGroups;
    procedure SetMf2005ObsGroupNames; virtual;
    procedure FillFluxObsList(List: TFluxObservationList);
    procedure FillHobList(List: THobList);
    procedure UpdateHobGroupNames;
    property ItemTopLocation[const EvalAt: TEvaluatedAt; const Column,
      Row: integer]: TPoint2D read GetItemTopLocation;
    function PointToCell(EvalAt: TEvaluatedAt; APoint: TPoint2D): T2DTopCell;
    // ACell uses 1-based indexing not 0-based indexing in CellToPoint.
    function CellToPoint(ACell: TCellLocation; EvalAt: TEvaluatedAt): TPoint3D;
    property PestProperties: TPestProperties read GetPestProperties
      write SetPestProperties;
    property PilotPointCount: integer read GetPilotPointCount;
    property PilotPointBuffer: double read GetPilotPointBuffer;
    property PilotPoints[Index: Integer]: TPoint2D read GetPilotPoint;
    // @name  is filled with the names of files to delete in the RunModel.bat
    // file used by PEST.
    property FilesToDelete: TStrings read GetFilesToDelete;
    procedure AddFilesToDeleteToBatchFile(BatchFile: TStrings;
      const BatchFileName: string);
    property CanDrawContours: Boolean read FCanDrawContours
      write SetCanDrawContours;
    function GetPestParameterByName(PestParamName: string)
      : TModflowSteadyParameter;
    function GetPestParameterByNameI(PestParamName: string)
      : IModflowParameter;
    procedure ClearPestParmDictionary;
    procedure InvalidateMfSfrReachLength(Sender: TObject);
    procedure InvalidateMfSfrUpstreamDepth(Sender: TObject);
    procedure InvalidateMfSfrDownstreamDepth(Sender: TObject);
    procedure InvalidateMfSfrRunoff(Sender: TObject);
    procedure InvalidateMfSfrPrecipitation(Sender: TObject);
    procedure InvalidateMfSfrFlow(Sender: TObject);
    procedure InvalidateMfSfrEvapotranspiration(Sender: TObject);
    property ShortestHorizontalBlockEdge[Layer, Row, Column: Integer]: double
      read GetShortestHorizontalBlockEdge;
    procedure ClearPestArrayFileNames;
    property Mf6TimesSeriesI: ITimesSeriesCollections read GetMf6TimesSeriesI;
    property Mf6TimesSeries: TTimesSeriesCollections read GetMf6TimesSeries
      write SetMf6TimesSeries;
    property SeparateGwtUsed: Boolean read GetSeparateGwtUsed;
    Procedure UpdateGwtConc;
    procedure ClearPestPriorInfoGroupData;
    property AppsMoved: TStringList read GetAppsMoved;
    property Mf6GwtNameWriters: TObject read FMf6GwtNameWriters;
    procedure InvalidateParamNamesDataSets;
    function DoSutraUnsatRegionUsed(Sender: TObject): boolean;
    property SutraUnsatRegionUsed: TObjectUsedEvent read GetSutraUnsatRegionUsed;
    procedure GetPestParameterNames(ParameterNames: TStringList);
    property BuoyancyUsed: Boolean read GetBuoyancyUsed;
    property BuoyancyDensityUsed: Boolean read GetBuoyancyDensityUsed;
    property ViscosityPkgUsed: Boolean read GetViscosityPkgUsedUsed;
    property ViscosityPkgViscUsed: Boolean read GetViscosityPkgViscUsed;

    procedure GetIgnoredSpeciesNames(IgnoredNames: TStringList);
    property GwtDispUsedPerSpecies: TObjectUsedEvent read GetGwtDispUsedPerSpecies;
    property LongitudinalDispersionUsedPerSpecies: TObjectUsedEvent read GetLongitudinalDispersionUsedPerSpecies;
    property HorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent read GetHorizontalTransverseDispersionUsedPerSpecies;
    property VerticalTransverseDispersionUsedPerSpecies: TObjectUsedEvent read GetVerticalTransverseDispersionUsedPerSpecies;
    property SeparatedLongitudinalDispersionUsedPerSpecies: TObjectUsedEvent read GetSeparatedLongitudinalDispersionUsedPerSpecies;
    property SeparatedHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent
      read GetSeparatedHorizontalTransverseDispersionUsedPerSpecies;
    property CombinedHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent
      read GetCombinedHorizontalTransverseDispersionUsedPerSpecies;
    property SeparatedThermalConductivityUsed: TObjectUsedEvent read GetSeparatedThermalConductivityUsed;
    property SeparatedDecayWaterUsed: TObjectUsedEvent read GetSeparatedDecayWaterUsed;
    property SeparatedDecaySolidUsed: TObjectUsedEvent read GetSeparatedDecaySolidUsed;
    property SeparatedHeatCapacitySolidUsed: TObjectUsedEvent read GetSeparatedHeatCapacitySolidUsed;
    property SeparatedDensitySolidUsed: TObjectUsedEvent read GetSeparatedDensitySolidUsed;
  published
    property DisvGrid: TModflowDisvGrid read FDisvGrid write SetDisvGrid
      stored StoreDisvGrid;
    property Mf6GridType: TMf6GridType read FMf6GridType write SetMf6GridType;
    // @name defines the grid used with PHAST.
    property PhastGrid: TPhastGrid read FPhastGrid write SetPhastGrid;
    property AlternateFlowPackage: boolean read FAlternateFlowPackage
      write SetAlternateFlowPackage;
    property AlternateSolver: boolean read FAlternateSolver
      write SetAlternateSolver;
    property BatchFileAdditionsAfterModel: TStrings
      read FBatchFileAdditionsAfterModel write SetBatchFileAdditionsAfterModel;
    property BatchFileAdditionsBeforeModel: TStrings
      read FBatchFileAdditionsBeforeModel
      write SetBatchFileAdditionsBeforeModel;
    property ModflowGrid: TModflowGrid read FModflowGrid write SetModflowGrid;
    property ModflowNameFileLines: TStrings read FModflowNameFileLines
      write SetModflowNameFileLines;
    property ModflowPackages: TModflowPackages read GetModflowPackages
      write SetModflowPackages;
    property HeadFluxObservations: TFluxObservationGroups
      read FHeadFluxObservations write SetHeadFluxObservations
      stored StoreHeadFluxObservations;
    property DrainObservations: TFluxObservationGroups
      read FDrainObservations write SetDrainObservations
      stored StoreDrainObservations;
    property GhbObservations: TFluxObservationGroups
      read FGhbObservations write SetGhbObservations
      stored StoreGhbObservations;
    property RiverObservations: TFluxObservationGroups
      read FRiverObservations write SetRiverObservations
      stored StoreRiverObservations;
    property StreamObservations: TFluxObservationGroups
      read FStrObservations write SetStrObservations
      stored StoreStrObservations;

    property Mt3dmsHeadMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsHeadMassFluxObservations write SetMt3dmsHeadMassFluxObservations
      stored StoreHeadMassFluxObservations;

    property Mt3dmsWellMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsWellMassFluxObservations write SetMt3dmsWellMassFluxObservations
      stored StoreWellMassFluxObservations;

    property Mt3dmsDrnMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsDrnMassFluxObservations write SetMt3dmsDrnMassFluxObservations
      stored StoreDrnMassFluxObservations;

    property Mt3dmsRivMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsRivMassFluxObservations write SetMt3dmsRivMassFluxObservations
      stored StoreRivMassFluxObservations;

    property Mt3dmsGhbMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsGhbMassFluxObservations write SetMt3dmsGhbMassFluxObservations
      stored StoreGhbMassFluxObservations;

    property Mt3dmsRchMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsRchMassFluxObservations write SetMt3dmsRchMassFluxObservations
      stored StoreRchMassFluxObservations;

    property Mt3dmsEvtMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsEvtMassFluxObservations write SetMt3dmsEvtMassFluxObservations
      stored StoreEvtMassFluxObservations;

    property Mt3dmsMassLoadingMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsMassLoadingMassFluxObservations write SetMt3dmsMassLoadingMassFluxObservations
      stored StoreMassLoadingMassFluxObservations;

    property Mt3dmsResMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsResMassFluxObservations write SetMt3dmsResMassFluxObservations
      stored StoreResMassFluxObservations;

    property Mt3dmsLakMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsLakMassFluxObservations write SetMt3dmsLakMassFluxObservations
      stored StoreLakMassFluxObservations;

    property Mt3dmsDrtMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsDrtMassFluxObservations write SetMt3dmsDrtMassFluxObservations
      stored StoreDrtMassFluxObservations;

    property Mt3dmsEtsMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsEtsMassFluxObservations write SetMt3dmsEtsMassFluxObservations
      stored StoreEtsMassFluxObservations;

    property Mt3dmsStrMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsStrMassFluxObservations write SetMt3dmsStrMassFluxObservations
      stored StoreStrMassFluxObservations;

    property Mt3dmsFhbHeadMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsFhbHeadMassFluxObservations write SetMt3dmsFhbHeadMassFluxObservations
      stored StoreFhbHeadMassFluxObservations;

    property Mt3dmsFhbFlowMassFluxObservations: TMt3dmsFluxObservationGroups
      read FMt3dmsFhbFlowMassFluxObservations write SetMt3dmsFhbFlowMassFluxObservations
      stored StoreFhbFlowMassFluxObservations;

    property HydrogeologicUnits: THydrogeologicUnits read FHydrogeologicUnits
      write SetHydrogeologicUnits stored StoreHydrogeologicUnits;
    property FilesToArchive: TStrings read GetFilesToArchive
      write SetFilesToArchive;
    property ModelInputFiles: TStrings read GetModelInputFiles
      write SetModelInputFiles;
    property ModelOutputFiles: TStrings read FModelOutputFiles
      write SetModelOutputFiles;
    property ModpathInputFiles: TStrings read FModpathInputFiles
      write SetModpathInputFiles;
    property ModpathOutputFiles: TStrings read FModpathOutputFiles
      write SetModpathOutputFiles;
    property ZoneBudgetInputFiles: TStrings read FZoneBudgetInputFiles
      write SetZoneBudgetInputFiles;
    property ZoneBudgetOutputFiles: TStrings read FZoneBudgetOutputFiles
      write SetZoneBudgetOutputFiles;
    property Mt3dmsInputFiles: TStrings read FMt3dmsInputFiles
      write SetMt3dmsInputFiles;
    property ExternalFiles: TStrings read FExternalFiles write SetExternalFiles;
    property Mt3dmsOutputFiles: TStrings read FMt3dmsOutputFiles
      write SetMt3dmsOutputFiles;
    property SwiObsExtractorInputFiles: TStrings
      read FSwiObsExtractorInputFiles write SetSwiObsExtractorInputFiles;
    property SwiObsExtractorOutputFiles: TStrings
      read FSwiObsExtractorOutputFiles write SetSwiObsExtractorOutputFiles;
    // @name is the name of the ModelMuse file that has been opened or saved.
    property ModelFileName: string read FFileName write SetFileName;
    property ModflowOptions: TModflowOptions read GetModflowOptions
      write SetModflowOptions;
    property ModflowWettingOptions: TWettingOptions read FModflowWettingOptions
      write SetModflowWettingOptions;
    property GlobalVariables: TGlobalVariables read GetGlobalVariables
      write SetGlobalVariables;
    property HeadObsResults: THeadObsCollection read GetHeadObsResults
      write SetHeadObsResults stored StoreHeadObsResults;
    property MobileComponents: TMobileChemSpeciesCollection
      read GetMobileComponents write SetMobileComponents;
    property ImmobileComponents: TChemSpeciesCollection
      read GetImmobileComponents write SetImmobileComponents;
    // @name stores MODPATH pathline data.
    // @name is used only in MODFLOW models.
    property PathLines: TPathLineReader read GetPathLine write SetPathLine
      stored StorePathLine;
    // @name is retained for backwards compatibility. See @link(PathLines).
    property PathLine: TPathLineReader read GetPathLine write SetPathLine
      stored False;
    // @name stores MODPATH times series data.
    // @name is used only in MODFLOW models.
    property TimeSeries: TTimeSeriesReader read GetTimeSeries
      write SetTimeSeries stored StoreTimeSeries;
    // @name stores MODPATH endpoint data.
    // @name is used only in MODFLOW models.
    property EndPoints: TEndPointReader read GetEndPoints Write SetEndPoints
      stored StoreEndPoints;
    property SutraMesh: TSutraMesh3D read GetSutraMesh write SetSutraMesh;
    property SutraOptions: TSutraOptions read FSutraOptions
      write SetSutraOptions;
    property SutraOutputControl: TSutraOutputControl read FSutraOutputControl
      write SetSutraOutputControl;
    property SwrTabFiles: TTabFileCollection read FSwrTabFiles
      write SetSwrTabFiles;
    property SwrReachGeometry: TReachGeometryCollection read FSwrReachGeometry
      write SetSwrReachGeometry;
    property SwrStructures: TStructureCollection read FSwrStructures
      write SetSwrStructures;
    property SwrObservations: TSwrObsCollection read FSwrObservations
      write SetSwrObservations;
    property ContourLabelSpacing: Integer read GetContourLabelSpacing
      write SetContourLabelSpacing default 100;
    property LinkedRasters: TLinkedRasterCollection read GetLinkedRasters
      write SetLinkedRasters Stored StoreLinkedRaster;
    property FootPrintGrid: TFootPrintGrid read FFootPrintGrid
      write SetFootPrintGrid;
    property FootprintProperties: TFootprintProperties
      read GetFootprintProperties write SetFootprintProperties;

    property CtsSystems: TCtsSystemCollection read GetCtsSystems
      write SetCtsSystems;
    property GlobalObservationComparisons: TGlobalObservationComparisons
      read FModflowGlobalObservationComparisons
      write SetModflowGlobalObservationComparisons
      stored False;
    property ModflowGlobalObservationComparisons: TGlobalObservationComparisons
      read FModflowGlobalObservationComparisons
      write SetModflowGlobalObservationComparisons;
    property SutraGlobalObservationComparisons: TGlobalObservationComparisons
      read FSutraGlobalObservationComparisons
      write SetSutraGlobalObservationComparisons;
    property Modflow6GlobalObservationComparisons: TGlobalObservationComparisons
      read FModflow6GlobalObservationComparisons
      write SetModflow6GlobalObservationComparisons;
    property SutraFluxObs: TSutraFluxObs read FSutraFluxObs
      write SetSutraFluxObs;
    property VelocityVectors: TVectorCollection read FVelocityVectors
      write SetVelocityVectors;

    // Name contains the names of scripts that are to be run before running
    // SUTRA.
    property SutraPestScripts: TStringList read FSutraPestScripts;
    property PilotPointData: TStoredPilotParamDataCollection
      read FPilotPointData write SetPilotPointData;
    property PestObsCollection: TPestObsCollection read FPestObsCollection
      write SetPestObsCollection;
    property InputObservationDataSets: TStrings read GetInputObservationDataSets;
    property InputObsInstructionFileNames: TStrings read GetInputObsInstructionFileNames;
    property InputObsInstructionFiles: TStrings
      read GetInputObsInstructionFiles;
    property Mt3dObsCollection: TMt3dObsCollection read FMt3dObsCollection
      write SetMt3dObsCollection;

    { Any new members added to TCustomModel should be cleared in InternalClear.}



//    property GeoRefFileName: string read FGeoRefFileName write SetGeoRefFileName;
  end;

  TMapping = record
    ParentPostion: integer;
    ChildPositions: array of integer;
  end;

  TMappingArray = array of TMapping;

  TSaveDataSetValues = (sdsvNever, sdsvAlways);

  TFontChangeNotifier = class(TFontAdapter)
  private
    FInvalidateModelEvent: TNotifyEvent;
  public
    procedure Changed; override;
    Constructor Create(InvalidateModelEvent: TNotifyEvent; AFont: TFont);
  end;

  {
  @abstract(@name is used to read model configuration data to and
  from a stream and to store @link(TDataArray)s and @link(TScreenObject)s.)

  @name allows model configuration data to be read from a stream
  by making the significant features of a model
  published properties.  Because TModel is derived from TPersistent, this
  automatically provides it with methods to read and write its published
  properties.  Most of the published properties of @Link(TPhastModel)
  correspond
  directly to settings for the simulation models it supports such as
  PHAST and MODFLOW.

  @Link(TPhastModel.DataSetList) and @Link(TPhastModel.ObjectList) are
  are descendants of TCollection.  They store and read
  instances of @Link(TDataArray) and @Link(TScreenObject) respectively.
  However, when not reading data from a stream or writing it to a stream.
  @Link(TDataArray)s and @Link(TScreenObject)s are accessed via
  @link(FDataArrayManager).@link(TDataArrayManager.DataSets)
  and @link(TCustomModel.ScreenObjects) respectively.
  The number @Link(TDataArray)s or @Link(TScreenObject)s can be determined
  using @link(FDataArrayManager).@Link(TDataArrayManager.DataSetCount) and
  @Link(TCustomModel.ScreenObjectCount).
  }
  TPhastModel = class(TCustomModel, IPhastModelForTLayerOwnerCollection,
    IModelForTUserDefinedColorSchemeCollection)
  private
    FObservationPurpose: TObservationPurpose;
    FCachedScreenObjectIndex: integer;
    // See @link(Bitmaps).
    FBitmaps: TCompressedBitmapCollection;
    // See @link(ChemistryOptions).
    FChemistryOptions: TChemistryOptions;
    // See @link(Diffusivity).
    FDiffusivity: double;
    // Values of zero are never stored for real-number properties
    // in Delphi.  @name is used to get around this limitation so that
    // if a value of zero for @link(Diffusivity) is specified by
    // the user, it can be recovered correctly when reading the file.
    FDiffusivitySet: boolean;
    // See @link(FileVersion).
    FFileVersion: string;
    // See @link(FluidProperties).
    FFluidProperties: TFluidProperties;
    // See @link(FluxBoundaryChemistryGroup).
    FFluxBoundaryChemistryGroup: TTimeListGroup;
    // See @link(FluxBoundaryChemistryGroup).
    FFluxBoundaryFluxGroup: TTimeListGroup;
    // See @link(FreeSurface).
    FFreeSurface: boolean;
    // See @link(FrontBoundaryType).
    FFrontBoundaryType: TDataArray;
    // See @link(FrontFluxBoundaryChemistry).
    FFrontFluxBoundaryChemistry: TPhastTimeList;
    // See @link(FrontFluxBoundaryFlux).
    FFrontFluxBoundaryFlux: TPhastTimeList;
    // See @link(FrontLeakyAssociatedSolution).
    FFrontLeakyAssociatedSolution: TPhastTimeList;
    // See @link(FrontLeakyHead).
    FFrontLeakyHead: TPhastTimeList;
    // See @link(GridOptions).
    FGridOptions: TGridOptions;
    // See @link(LeakyAssociatedSolutionGroup).
    FLeakyAssociatedSolutionGroup: TTimeListGroup;
    // See @link(LeakyHeadGroup).
    FLeakyHeadGroup: TTimeListGroup;
    // See @link(ModelTimes).
    FModelTimes: TRealList;
    // See @link(PrintFrequency).
    FPrintFrequency: TPrintFrequencyCollection;
    // See @link(PrintInitial).
    FPrintInitial: TPrintInitial;
    // See @link(RiverAssociatedSolution).
    FRiverAssociatedSolution: TPhastTimeList;
    // See @link(RiverAssociatedSolutionGroup).
    FRiverAssociatedSolutionGroup: TTimeListGroup;
    // See @link(RiverHead).
    FRiverHead: TPhastTimeList;
    // See @link(RiverHeadGroup).
    FRiverHeadGroup: TTimeListGroup;
    // @name is used to store or read @link(TScreenObject)s.
    // However, most handling of read @link(TScreenObject)s in the program
    // is via @link(FScreenObjectList) rather than @name.
    // See @link(FScreenObjectList).
    FScreenObjectCollection: TScreenObjectCollection;
    // @name holds the @link(TScreenObject)s in the model.
    // Nearly all access to @link(TScreenObject)s is through @name.
    // However, see @link(FScreenObjectCollection).
    // @name is actually as TObjectList.
    FScreenObjectList: TList;
    // See @link(SideBoundaryType).
    FSideBoundaryType: TDataArray;
    // See @link(SideFluxBoundaryChemistry).
    FSideFluxBoundaryChemistry: TPhastTimeList;
    // See @link(SideFluxBoundaryFlux).
    FSideFluxBoundaryFlux: TPhastTimeList;
    // See @link(SideLeakyAssociatedSolution).
    FSideLeakyAssociatedSolution: TPhastTimeList;
    // See @link(SideLeakyHead).
    FSideLeakyHead: TPhastTimeList;
    // See @link(SoluteTransport).
    FSoluteTransport: boolean;
    // See @link(SolutionOptions).
    FSolutionOptions: TSolutionOptions;
    // See @link(SomeSegmentsUpToDate).
    FSomeSegmentsUpToDate: boolean;
    // See @link(SpecifiedHeadAssociatedSolution).
    FSpecifiedHeadAssociatedSolution: TPhastTimeList;
    // See @link(SpecifiedHeadGroup).
    FSpecifiedHeadGroup: TTimeListGroup;
    // See @link(SpecifiedHeadHead).
    FSpecifiedHeadHead: TPhastTimeList;
    // See @link(SpecifiedHeadSolutionGroup).
    FSpecifiedHeadSolutionGroup: TTimeListGroup;
    // See @link(SpecifiedSolution).
    FSpecifiedSolution: TPhastTimeList;
    // See @link(SteadyFlowOptions).
    FSteadyFlowOptions: TSteadyFlowOptions;
    // See @link(Times).
    FTimes: TTimeCollection;
    // See @link(Title).
    FTitle: TStrings;
    // See @link(Top2DBoundaryType).
    FTop2DBoundaryType: TDataArray;
    // See @link(TopBoundaryType).
    FTopBoundaryType: TDataArray;
    // See @link(TopFluxBoundaryChemistry).
    FTopFluxBoundaryChemistry: TPhastTimeList;
    // See @link(TopFluxBoundaryFlux).
    FTopFluxBoundaryFlux: TPhastTimeList;
    // See @link(TopLeakyAssociatedSolution).
    FTopLeakyAssociatedSolution: TPhastTimeList;
    // See @link(TopLeakyHead).
    FTopLeakyHead: TPhastTimeList;
    // See @link(Units).
    FUnits: TUnits;
    // See @link(UseWaterTable).
    FUseWaterTable: boolean;
    // See @link(WellInjectionOrPumpingRate).
    FWellInjectionOrPumpingRate: TPhastTimeList;
    // See @link(WellPumpingRateGroup).
    FWellPumpingRateGroup: TTimeListGroup;
    // See @link(WellSolution).
    FWellSolution: TPhastTimeList;
    // See @link(WellSolutionGroup).
    FWellSolutionGroup: TTimeListGroup;
    FLayerStructure: TLayerStructure;
    FGuiSettings: TGuiSettings;
    FModflowStressPeriods: TModflowStressPeriods;
    FModflowOutputControl: TModflowOutputControl;
    FModflowSteadyParameters: TModflowSteadyParameters;
    FModflowTransientParameters: TModflowTransientListParameters;
    FOnGetZoomBox: TGetZoomBoxEvent;
    FOnScreenObjectsChanged: TNotifyEvent;
    FOnGetCurrentScreenObject: TGetCurrentScreenObjectEvent;
    FOnConvertPoint: TConvertPointEvent;
    FOnScreenObjectSelected: TNotifyEvent;
    FOnCheckScreenObject: TCheckScreenObjectEvent;
    FOn3DViewChanged: TNotifyEvent;
    FOnRefreshScreenObjects: TNotifyEvent;
    FProgramLocations: TProgramLocations;
    FModflowFullStressPeriods: TModflowStressPeriods;
    FOnScreenObjectUnSelected: TNotifyEvent;
    // See @link(SelectedScreenObjectCount).
    FSelectedScreenObjectCount: Integer;
    FScreenObjectUpdateCount: Integer;
    FArchiveName: string;
    FSortedObjectList: TLookUpList;
    FGridColors: TColorParameters;
    FContourColors: TColorParameters;
    FModelMateProjectFileName: string;
    FModelMateProject: TProject;
    FFormulaManager: TFormulaManager;
    FHufParameters: THufModflowParameters;
    FColorLegend: TLegend;
    FContourLegend: TLegend;
    FDisplaySettings: TDisplaySettingsCollection;
    FChildModels: TChildModelCollection;
    FImportingModel: boolean;
    FSelectedModel: TCustomModel;
    FColumnMapping: TMappingArray;
    FRowMapping: TMappingArray;
    FLayerMapping: TMappingArray;
    FCombinedDisplayColumn: integer;
    FCombinedDisplayLayer: integer;
    FCombinedDisplayRow: integer;
    FSaveDataSetValues: TSaveDataSetValues;
    FChildGridUpdateCount: Integer;
    FDataSetUpdateCount: Integer;
    FSaveBfhBoundaryConditions: Boolean;
    FContourFont: TFont;
    FShowContourLabels: Boolean;
    FSfrStreamLinkPlot: TSfrStreamLinkPlot;
    FStrStreamLinkPlot: TSfrStreamLinkPlot;
    FSfrMf6StreamLinkPlot: TSfrStreamLinkPlot;
    FSwrReachConnectionsPlot: TSwrReachConnectionsPlot;
    FMt3dmsOutputControl: TMt3dmsOutputControl;
    FMt3dmsTimes: TMt3dmsTimeCollection;
    FImmobileComponents: TChemSpeciesCollection;
    FGlobalVariables: TGlobalVariables;
    FMobileComponents: TMobileChemSpeciesCollection;
    FSutraLayerStructure: TSutraLayerStructure;
    FSutraTimeOptions: TSutraTimeOptions;
    FColorSchemes: TUserDefinedColorSchemeCollection;
    FFishnetMeshGenerator: TFishnetMeshGenerator;

    FSutraSettings: TSutraSettings;
    FMaxVectors: TPredefinedVectors;
    FMinVectors: TPredefinedVectors;
    FMidVectors: TPredefinedVectors;
    FFmpCrops: TCropCollection;
    FFmpSoils: TSoilCollection;
    FFmpClimate: TClimateCollection;
    FFmpAllotment: TAllotmentCollection;
    FContourLabelSpacing: integer;
    FFarms: TFarmCollection;
    FLinkedRasters: TLinkedRasterCollection;
    FFootprintProperties: TFootprintProperties;
    FRipPlantGroups: TRipPlantGroups;
    FEndPointLegend: TLegend;
    FGeoRef: TGeoRef;
    FFixingModel: boolean;
    FUseGsflowFormat: Boolean;
    FCtsSystems: TCtsSystemCollection;
    FParamGroups: TPestParamGroups;
    FPestProperties: TPestProperties;
    FFilesToDelete: TStringList;
    FSvdaPrepProperties: TSvdaPrepProperties;
    FSupCalcProperties: TSupCalcProperties;
    FTimesSeries: TTimesSeriesCollections;
    FAppsMoved: TStringList;
    FIrrigationTypes: TIrrigationCollection;
    //     See @link(OwnsScreenObjects).
    function GetOwnsScreenObjects: boolean;
//     See @link(ObjectList).
    function GetScreenObjectCollection: TScreenObjectCollection;
    // See @link(Version).
    function GetVersion: string;
    // @name initializes all the @link(TPhastTimeList)s in @link(TimeLists).
    procedure InitializePhastBoundaries;
    // @name adds all the TTimeItem.@link(TTimeItem.EndingTime)s
    // in @link(Times) to @link(ModelTimes).
    // @name is only used in PHAST models;
    procedure RecordTimeControl;
    // See @link(Bitmaps).
    procedure SetBitmaps(const Value: TCompressedBitmapCollection);
    // See @link(Diffusivity).
    procedure SetDiffusivity(const Value: double);
    // See @link(Exaggeration).

    // See @link(FlowOnly).
    procedure SetFlowOnly(const Value: boolean);
    // See @link(FrontHeight).
    procedure SetFrontHeight(Value : integer);
    // See @link(FrontX).
    procedure SetFrontX(const Value: double);
    // See @link(FrontY).
    procedure SetFrontY(const Value: double);
    // See @link(Height).
    procedure SetHeight(const Value: integer);
    // See @link(Left).
    procedure SetLeft(const Value: integer);
    // See @link(MagnificationFront).
    procedure SetMagnificationFront(Value: double);
    // See @link(MagnificationSide).
    procedure SetMagnificationSide(Value: double);
    // See @link(MagnificationTop).
    procedure SetMagnificationTop(Value: double);
    // See @link(OwnsScreenObjects).
    procedure SetOwnsScreenObjects(const Value: boolean);
    // See @link(PrintFrequency).
    procedure SetPrintFrequency(const Value: TPrintFrequencyCollection);
    // See @link(ObjectList).
    procedure SetScreenObjectCollection(
      const Value: TScreenObjectCollection);
    // See @link(MagnificationTop).
    procedure SetSideWidth(const Value: integer);
    // See @link(SideX).
    procedure SetSideX(const Value: double);
    // See @link(SideY).
    procedure SetSideY(const Value: double);
    // See @link(Times).
    procedure SetTimes(const Value: TTimeCollection);
    // See @link(Title).
    procedure SetTitle(const Value: TStrings);
    // See @link(Top).
    procedure SetTop(const Value: integer);
    // See @link(TopViewHeight).
    procedure SetTopViewHeight(const Value: integer);
    // See @link(TopViewWidth).
    procedure SetTopViewWidth(const Value: integer);
    // See @link(TopX).
    procedure SetTopX(const Value: double);
    // See @link(TopY).
    procedure SetTopY(const Value: double);
    // See @link(Version).
    procedure SetVersion(const Value: string);
    // See @link(Width).
    procedure SetWidth(const Value: integer);
    // See @link(WindowState).
    procedure SetWindowState(const Value: TWindowState);
    // See @link(Units);
    procedure SetUnits(const Value: TUnits);
    procedure UpdateDrainReturnObjects;
    procedure CreatePhastTimeLists;
    procedure CreatePhastTimeListGroups;
    procedure UpdateUseList(DataIndex: integer; NewUseList: TStringList;
      Item: TCustomModflowBoundaryItem);
    function DefaultArchiveName: string;
    function GetArchiveName: string;
    procedure SetArchiveName(const Value: string);
    procedure GetUnitID(var UnitID: Integer);
    procedure NotifyGridColorsChanged(Sender: TObject);
    procedure SetModelMateProjectFileName(const Value: string);
    procedure SetModelMateProject(const Value: TProject);
    procedure UpdateModelMateParameter(ParameterList: TStringList;
      ModelMuseParam: TModflowParameter; Project: TProject;
      Operation: TModelMateOperation);
    procedure UpdateModelMateFluxObservation(ObservationList: TStringList;
      ModelMuseFluxObsGroup: TFluxObservationGroup; Project: TProject;
      Operation: TModelMateOperation);
    procedure UpdateModelMateHeadObservation(ObservationList: TStringList;
      const OBSNAM: string; ModelMuseHeadObs: THobItem; Project: TProject;
      Operation: TModelMateOperation; Method: TMultiObsMethod);
    procedure HandleModelMateParameters(Operation: TModelMateOperation;
      ParameterList: TStringList; Project: TProject);
    procedure HandleModelMateObservations(Operation: TModelMateOperation;
      ObservationList: TStringList; Project: TProject);
    procedure EnsureModelMateObsGroup(Project: TProject; GroupName: string;
      PlotSymbol: integer);
    function PhastUsed(Sender: TObject): boolean;
    procedure CreateInitialDataSetsForPhastTimeLists;
    procedure SetDisplaySettings(const Value: TDisplaySettingsCollection);
    procedure SetChildModels(const Value: TChildModelCollection);
    function StoreChildModels: Boolean;
    function GetChildModels: TChildModelCollection;
    function MaxChildColumnsPerColumn(ColIndex: Integer): integer;
    function MaxChildRowsPerRow(RowIndex: Integer): integer;
    function MaxChildLayersPerLayer(LayerIndex: Integer): integer;
    function CombinedCount(ViewDirection: TViewDirection): integer;
    function DirectionCount(ViewDirection: TViewDirection): integer;
    function MaxChildDisPerParentDis(ViewDirection: TViewDirection;
      Position: integer): integer;
    procedure UpdateAMapping(var AMapping: TMappingArray;
      ViewDirection: TViewDirection);
    procedure SetCombinedDisplayColumn(const Value: integer);
    procedure SetCombinedDisplayLayer(const Value: integer);
    procedure SetCombinedDisplayRow(const Value: integer);
    procedure SetSomeSegmentsUpToDate(const Value: boolean); override;
    function GetSomeSegmentsUpToDate: boolean; override;
    function GetNeedToRecalculateFrontCellColors: boolean;
    function GetNeedToRecalculateSideCellColors: boolean;
    function GetNeedToRecalculateTopCellColors: boolean;
    procedure SetNeedToRecalculateFrontCellColors(const Value: boolean);
    procedure SetNeedToRecalculateSideCellColors(const Value: boolean);
    procedure SetNeedToRecalculateTopCellColors(const Value: boolean);
    function DoAquiferPropertiesUsed(Sender: TObject): boolean; override;
    function DoKyUsed(Sender: TObject): boolean; override;
    function DoKzUsed(Sender: TObject): boolean; override;
    function DoPorosityUsed(Sender: TObject): boolean; override;
    function DoSpecificStorageUsed(Sender: TObject): boolean; override;
    function DoChemistryUsed(Sender: TObject): boolean; override;
    function DoInitialHeadUsed(Sender: TObject): boolean; override;
    function DoEquilibriumPhasesUsed(Sender: TObject): boolean; override;
    function DoSurfacesUsed(Sender: TObject): boolean; override;
    function DoExchangeUsed(Sender: TObject): boolean; override;
    function DoGasPhaseUsed(Sender: TObject): boolean; override;
    function DoSolidSolutionUsed(Sender: TObject): boolean; override;
    function DoKineticsUsed(Sender: TObject): boolean; override;
    function DoModflowUsed(Sender: TObject): boolean; override;
    function DoRouteUzfDischarge(Sender: TObject): boolean; override;
    function DoModflowInitialHeadUsed(Sender: TObject): boolean; override;
    function DoConfiningBedKzUsed(Sender: TObject): boolean; override;
    function DoVerticalAnisotropyUsed(Sender: TObject): boolean; override;
    function DoHorizontalAnisotropyUsed(Sender: TObject): boolean; override;
    function DoSpecificYieldUsed(Sender: TObject): boolean; override;
    function DoWetDryUsed(Sender: TObject): boolean; override;
    function ModpathUsed(Sender: TObject): boolean; override;
    function DoModpathZonesNeeded(Sender: TObject): boolean; override;
    function DoHufReferenceSurfaceNeeded(Sender: TObject): boolean; override;
    function DoBcfUsed(Sender: TObject): boolean; override;
    function DoConfinedStorageCoefUsed(Sender: TObject): boolean; override;
    function DoZoneBudgetSelected(Sender: TObject): boolean; override;
    function DoSwtSelected(Sender: TObject): boolean; override;
    function DoSwtOffsetsUsed(Sender: TObject): boolean; override;
    function DoSwtSpecifiedUsed(Sender: TObject): boolean; override;
    function UztUsed(Sender: TObject): boolean; override;
    function DoGwtUztUsed(Sender: TObject): boolean; override;
    function DoGwtDispUsed(Sender: TObject): boolean; override;
    function DoLongitudinalDispersionUsed(Sender: TObject): boolean; override;
    function DoHorizontalTransverseDispersionUsed(Sender: TObject): boolean; override;
    function DoVerticalTransverseDispersionUsed(Sender: TObject): boolean; override;
    function DoSeparatedLongitudinalDispersionUsed(Sender: TObject): boolean; override;
    function DoSeparatedHorizontalTransverseDispersionUsed(Sender: TObject): boolean; override;

    function DoLongitudinalDispersionUsedPerSpecies(Sender: TObject): boolean; override;
    function DoHorizontalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; override;
    function DoVerticalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; override;
    function DoSeparatedLongitudinalDispersionUsedPerSpecies(Sender: TObject): boolean; override;
    function DoSeparatedHorizontalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; override;
    function DoCombinedHorizontalTransverseDispersionUsedPerSpecies(Sender: TObject): boolean; override;

    //    function Xt3DUsed(Sender: TObject): boolean; override;
    function DoNpfUsed(Sender: TObject): boolean; override;
    function WettingActive: boolean; override;
    procedure InternalExportModflowLgrFile(const FileName: string);
    function GetCombinedDisplayColumn: integer;
    function GetCombinedDisplayLayer: integer;
    function GetCombinedDisplayRow: integer;
    function SsmIsSelected: Boolean;
    function GetSutraLayerStructure: TSutraLayerStructure;
    procedure SetSutraLayerStructure(const Value: TSutraLayerStructure);
    procedure RenameOldVerticalLeakance; override;
    procedure SetSutraTimeOptions(const Value: TSutraTimeOptions);
    procedure SetColorSchemes(const Value: TUserDefinedColorSchemeCollection);
    procedure SetFishnetMeshGenerator(const Value: TFishnetMeshGenerator);
    procedure SetSutraSettings(const Value: TSutraSettings);
    procedure SetMaxVectors(const Value: TPredefinedVectors);
    procedure SetMidVectors(const Value: TPredefinedVectors);
    procedure SetMinVectors(const Value: TPredefinedVectors);
    procedure SetFmpCrops(const Value: TCropCollection); override;
    procedure SetFmpSoils(const Value: TSoilCollection); override;
    procedure SetFmpClimate(const Value: TClimateCollection); override;
    procedure SetFmpAllotment(const Value: TAllotmentCollection); override;

    procedure PasteModelMuseObjectsFromClipboard(const ClipboardText: string;
      List: TList);
    procedure PasteArgusOneContoursFromClipboard(const ClipboardText: string;
      List: TList);
    procedure SetFarms(const Value: TFarmCollection); override;
    function GetFarms: TFarmCollection; override;
    function GetFmpAllotment: TAllotmentCollection; override;
    function GetFmpClimate: TClimateCollection; override;
    function GetFmpCrops: TCropCollection; override;
    function GetFmpSoils: TSoilCollection; override;
    procedure UpdateModelMateZetaObservation(ObservationList: TStringList;
      const OBSNAM: string; ModelMuseSwiObs: TSwiObsItem; Project: TProject;
      Operation: TModelMateOperation);
    procedure SetRipPlantGroups(const Value: TRipPlantGroups);
    procedure RemoveNonAncillaryFiles;
    procedure FixSpecifyingGridByThreeDObjects;
    procedure SetSvdaPrepProperties(const Value: TSvdaPrepProperties);
    procedure SetSupCalcProperties(const Value: TSupCalcProperties);
    procedure FixScreenObjectNames;
    procedure SetMf6TimesSeries(const Value: TTimesSeriesCollections); override;
    function GetMf6TimesSeries: TTimesSeriesCollections; override;
    procedure UpdateFarmProperties;
    procedure CheckObservationGUIDs;
    // functions used in interfaces in TPhastModel.
    function GetChildModelCount: Integer;
    function GetChildModel(Index: Integer): IModelForTOrderedCollection;
    function GetColorSchemes: TUserDefinedColorSchemeCollection;
    function GetColorSchemesI: IUserDefinedColorSchemeCollection;
    procedure SetColorSchemesI(const Value: IUserDefinedColorSchemeCollection);
    procedure FixMvr;
    property ColorSchemesI: IUserDefinedColorSchemeCollection
      read GetColorSchemesI write SetColorSchemesI;
  protected
    procedure SetFrontDataSet(const Value: TDataArray); override;
    procedure SetSideDataSet(const Value: TDataArray); override;
    procedure SetTopDataSet(const Value: TDataArray); override;
    procedure SetThreeDDataSet(const Value: TDataArray); override;
    procedure InternalExportModflowModel(const FileName: string; ExportAllLgr: boolean); override;
    function GetGlobalVariables: TGlobalVariables; override;
    procedure SetGlobalVariables(const Value: TGlobalVariables); override;
    function GetGlobalVariablesI: IGlobalVariables; override;
    procedure SetGlobalVariablesI(const Value: IGlobalVariables); override;
    function GetSfrStreamLinkPlot: TSfrStreamLinkPlot; override;
    procedure SetSfrStreamLinkPlot(const Value: TSfrStreamLinkPlot); override;
    function GetStrStreamLinkPlot: TSfrStreamLinkPlot; override;
    procedure SetStrStreamLinkPlot(const Value: TSfrStreamLinkPlot); override;
    function GetSfrMf6StreamLinkPlot: TSfrStreamLinkPlot; override;
    procedure SetSfrMf6StreamLinkPlot(const Value: TSfrStreamLinkPlot); override;
    function GetSwrReachConnectionsPlot: TSwrReachConnectionsPlot; override;
    procedure SetSwrReachConnectionsPlot(const Value: TSwrReachConnectionsPlot); override;
    procedure SetFileName(const Value: string); override;
    function GetFormulaManager: TFormulaManager; override;
    function GetLayerStructure: TLayerStructure;override;
    procedure SetLayerStructure(const Value: TLayerStructure);override;
    function GetModflowStressPeriods: TModflowStressPeriods;override;
    function GetSoluteTransport: boolean;override;
    function GetFreeSurface: boolean;override;
    function GetUseWaterTable: boolean;override;
    function GetChemistryOptions: TChemistryOptions;override;
    procedure SetChemistryOptions(const Value: TChemistryOptions);override;
    function GetHufParameters: THufModflowParameters;override;
    function GetModflowFullStressPeriods: TModflowStressPeriods; override;
    function GetModflowOutputControl: TModflowOutputControl;override;
    function GetProgramLocations: TProgramLocations;override;
    function GetObservationPurpose: TObservationPurpose; override;
    procedure SetObservationPurpose(const Value: TObservationPurpose); override;
    procedure SetHufParameters(const Value: THufModflowParameters);override;
//    procedure SetModflowOptions(const Value: TModflowOptions);override;
    procedure SetModflowStressPeriods(const Value: TModflowStressPeriods);override;
    procedure SetModflowOutputControl(const Value: TModflowOutputControl);override;
    procedure SetModflowTransientParameters(
      const Value: TModflowTransientListParameters);override;
    procedure SetProgramLocations(const Value: TProgramLocations);override;
    // See @link(UseWaterTable).
    procedure SetUseWaterTable(const Value: boolean);override;
    // See @link(SoluteTransport).
    procedure SetSoluteTransport(const Value: boolean);override;
    // See @link(FreeSurface).
    procedure SetFreeSurface(const Value: boolean);override;
    function GetModflowTransientParameters: TModflowTransientListParameters; override;
    function GetModelSelection: TModelSelection;override;
    function GetModflowSteadyParameters: TModflowSteadyParameters;override;
    procedure SetModflowSteadyParameters(const Value: TModflowSteadyParameters);override;
//    procedure SetModelSelection(const Value: TModelSelection);override;
    // See @link(ScreenObjectCount).
    function GetScreenObjectCount: integer;override;
    // See @link(ScreenObjects).
    function GetScreenObjects(const Index: integer): TScreenObject;override;
    // @name causes the grid to not be colored by any @link(TDataArray).
    procedure ClearViewedItems; override;
    procedure SetUpToDate(const Value: boolean); override;
    // @name is used to fix up the model after @name is loaded from a file.
    procedure Loaded; override;
    // @name restores the model to its initial state. It gets rid of
    // all @link(TDataArray)s and @link(TScreenObject)s. It initializes
    // @link(Diffusivity) and @link(SolutionOptions).
    procedure InternalClear; override;
    function GetSelectedModel: TCustomModel; override;
    procedure SetSelectedModel(const Value: TCustomModel); override;
    procedure SetFrontTimeList(const Value: TCustomTimeList); override;
    procedure SetSideTimeList(const Value: TCustomTimeList); override;
    procedure SetTopTimeList(const Value: TCustomTimeList); override;
    function GetDisplayName: string; override;
    function GetSaveBfhBoundaryConditions: boolean; override;
    procedure SetSaveBfhBoundaryConditions(const Value: boolean);  override;
    procedure InitializeGages; override;
    procedure InitializeSfrWriter(EvaluationType: TEvaluationType); override;
    procedure FreeSfrWriter; override;
    procedure SetContourFont(const Value: TFont) ; override;
    procedure SetShowContourLabels(const Value: boolean);  override;
    function GetContourFont: TFont;  override;
    function GetShowContourLabels: boolean; override;
    procedure SetMt3dmsOutputControl(const Value: TMt3dmsOutputControl); override;
    function GetMt3dmsOutputControl: TMt3dmsOutputControl; override;
    function GetMt3dmsTimes: TMt3dmsTimeCollection; override;
    procedure SetMt3dmsTimes(const Value: TMt3dmsTimeCollection); override;
    function GetImmobileComponents: TChemSpeciesCollection; override;
    function GetMobileComponents: TMobileChemSpeciesCollection; override;
    procedure SetImmobileComponents(const Value: TChemSpeciesCollection); override;
    procedure SetMobileComponents(const Value: TMobileChemSpeciesCollection); override;
    procedure SetModelSelection(const Value: TModelSelection); override;
    procedure GenerateFishNetMesh(var ErrorMessage: string); override;
    function GetContourLabelSpacing: Integer; override;
    procedure SetContourLabelSpacing(const Value: Integer); override;
    function GetLinkedRasters: TLinkedRasterCollection; override;
    procedure SetLinkedRasters(const Value: TLinkedRasterCollection);  override;
    function GetFootprintProperties: TFootprintProperties; override;
    procedure SetFootprintProperties(const Value: TFootprintProperties); override;
    function GetGeoRef: TGeoRef; override;
    procedure SetGeoRef(const Value: TGeoRef); override;
    function GetContourLegend: TLegend; override;
    function GetUseGsflowFormat: boolean; override;
    procedure SetUseGsflowFormat(const Value: boolean); override;
    function DoMt3dMSBulkDensityUsed(Sender: TObject): boolean; override;
    function DoMt3dMSImmobPorosityUsed(Sender: TObject): boolean; override;
    function DoSftUsed(Sender: TObject): boolean; override;
    procedure SetCtsSystems(const Value: TCtsSystemCollection); override;
    function GetCtsSystems: TCtsSystemCollection; override;
    function GetParamGroups: TPestParamGroups; override;
    procedure SetParamGroups(const Value: TPestParamGroups); override;
    function GetPestProperties: TPestProperties; override;
    procedure SetPestProperties(const Value: TPestProperties); override;
    function GetFilesToDelete: TStrings; override;
    function GetAppsMoved: TStringList; override;
    function GetIrrigationTypes: TIrrigationCollection; override;
    procedure SetIrrigationTypes(const Value: TIrrigationCollection); override;
  public
//    function Mt3dMSUsed(Sender: TObject): boolean; override;
    function DoMt3dMS_StrictUsed(Sender: TObject): boolean; override;
    function Mf6GwtUsed(Sender: TObject): boolean; override;
    procedure RefreshGlobalVariables(CompilerList: TList);
//    procedure RefreshDataArraysVariables;
    procedure CreateGlobalVariables;
    function LakBathymetryUsed: Boolean;
    function TobIsSelected: Boolean;
    procedure DrawHeadObservations(const BitMap: TPersistent;
      const ZoomBox: TQRbwZoomBox2); override;
    // Update relationships of parent grid with child grids.
    procedure UpdateMapping;
    function DoInitialWaterTableUsed(Sender: TObject): boolean; override;
    function DoReservoirLayerUsed(Sender: TObject): boolean; override;
    function DoReservoirPackageUsed(Sender: TObject): boolean; override;
    function DoLakePackageUsed(Sender: TObject): boolean; override;
    function DoUzfPackageUsed(Sender: TObject): boolean; override;
    function DoUzfMf6PackageUsed(Sender: TObject): boolean; override;
    function FarmProcessUsed(Sender: TObject): boolean; override;
    function Farm4ProcessUsed(Sender: TObject): boolean; override;
    function DoFarmProcess4SteadyFarmsUsed(Sender: TObject): boolean; override;
    function FarmProcess4TransientFarmsUsed(Sender: TObject): boolean; override;
    function DoFarmProcess4SteadyCropsUsed(Sender: TObject): boolean; override;
    function FarmProcess4TransientCropsUsed(Sender: TObject): boolean; override;
    function FarmProcess4TransientEfficiencyArrayUsed(Sender: TObject): Boolean; override;
    function DoSoilIDUsed(Sender: TObject): boolean; override;
    function DoUzfUnsatVertKUsed(Sender: TObject): boolean; override;
    function DoUzfInitialInfiltrationUsed(Sender: TObject): boolean; override;
    function DoUzfResidualWaterContentUsed(Sender: TObject): boolean; override;
    function DoUzfSurfKUsed(Sender: TObject): boolean; override;
    procedure InvalidateMapping;
    procedure UpdateChildGrids;
    procedure UpdateDataSetConnections;
    function AddDataSet(const DataSet: TDataArray): Integer; override;
    { TODO -cRefactor : Consider replacing CModel with an interface. }
    //
    function IsChildModelEdgeColRow(Col, Row, Layer: integer;
      out CModel: TBaseModel): boolean;
    { TODO -cRefactor : Consider replacing CModel with an interface. }
    //
    function IsChildModelEdgeCell(Col, Row, Layer: integer;
      out CModel: TBaseModel): boolean;
    procedure AllowChildGridUpdates;
    procedure DisallowChildGridUpdates;
    procedure SaveArchiveList(FileName: string);
    property ImportingModel: boolean read FImportingModel write FImportingModel;
    procedure Assign(Source: TPersistent); override;
    // @name updates and invalidates data sets that may have been calculated
    // incorrectly in previous versions of ModelMuse.
    procedure FixOldModel;
    procedure FixFhbItems;
    // @name is used when determining what data sets or global variables are
    // used when evaluating the formula for a MODFLOW boundary condition.
    // The names of all the @link(TDataArray)s and global variables are added
    // to NewUseList.
    procedure UpdateDisplayUseList(NewUseList: TStringList;
      ParamType: TParameterType; DataIndex: integer; const DisplayName: string); override;
    // @name invalidates all the @link(TModflowBoundaryDisplayTimeList)s.
    procedure InvalidateModflowBoundaries;
    // @name is the event handler for @link(TDataArray.OnDataSetUsed
    // TDataArray.OnDataSetUsed) in MODFLOW models for @link(TDataArray)s
    // that define the top of the model and the bottom of @link(TLayerGroup)s.
    function ModelLayerDataArrayUsed(Sender: TObject): boolean;
    function Mt3dMsInitialConcUsed(Sender: TObject): boolean;
    function ModDispDataArrayUsed(Sender: TObject): boolean;
    function Mt3dMsSorbImmobInitialConcUsed(Sender: TObject): boolean;
    // @name is the event handler for @link(TDataArray.OnDataSetUsed
    // TDataArray.OnDataSetUsed) in MODFLOW models for @link(TDataArray)s
    // related to the SUB and SWT packages.
    function SubsidenceDataArrayUsed(Sender: TObject): boolean;
    // @name fills LayerGroupsDataSets with the @link(TDataArray)s used by
    // @link(LayerStructure).
    procedure GetModflowLayerGroupDataSets(LayerGroupsDataSets: TList);
    procedure GetSutraLayerGroupDataSets(LayerGroupsDataSets: TList);
    // @name finds the @link(TScreenObject) that is closest to the last
    // point in TestScreenObject.
    procedure LocateNearestLakeOrStream(TestScreenObject: TScreenObject;
      var NearestLake, NearestStream: TScreenObject; Tolerance: double = 0);
    procedure LocateNearestStrStream(TestScreenObject: TScreenObject;
      var NearestStream: TScreenObject; Tolerance: double = 0);
    procedure LocateNearestSfrMf6Stream(TestScreenObject: TScreenObject;
      var NearestStream: TScreenObject; Tolerance: double = 0);
    procedure LocateNearestSwrReachObjects(TestScreenObject: TScreenObject;
      var NearestReachObjects: TList<TScreenObject>; Tolerance: double);
    // @name increments @link(FScreenObjectUpdateCount).  While
    // @link(FScreenObjectUpdateCount) is greater than zero the
    // @link(OnScreenObjectsChanged) event is not called.
    procedure BeginScreenObjectUpdate;
    // @name decrements @link(FScreenObjectUpdateCount) and calls
    // @link(ScreenObjectsChanged).  While
    // @link(FScreenObjectUpdateCount) is greater than zero the
    // @link(OnScreenObjectsChanged) event is not called.
    procedure EndScreenObjectUpdate;
    // @name is the number of @link(TScreenObject)s that are selected.
    property SelectedScreenObjectCount: Integer read FSelectedScreenObjectCount;
    // @name is called by @link(TScreenObject)s when they become unselected.
    // @name decrements @link(FSelectedScreenObjectCount) and calls
    // @link(OnScreenObjectUnSelected).
    procedure ScreenObjectUnSelected;
    // See @link(TfrmGoPhast.ScreenObjectSelectionChange).
    property OnScreenObjectSelected: TNotifyEvent read FOnScreenObjectSelected
      write FOnScreenObjectSelected;
    // @name is called by @link(ScreenObjectUnSelected).
    // Then event handler for this is
    // @link(TfrmGoPhast.ScreenObjectSelectionChange)
    property OnScreenObjectUnSelected: TNotifyEvent
      read FOnScreenObjectUnSelected write FOnScreenObjectUnSelected;
    // @name increments @link(FSelectedScreenObjectCount) and then,
    // if assigned, @name calls @link(ScreenObjectSelected).
    procedure ScreenObjectSelected;
    // See @link(TfrmGoPhast.CheckScreenObject).
    property OnCheckScreenObject: TCheckScreenObjectEvent
      read FOnCheckScreenObject write FOnCheckScreenObject;
    // If assigned, @name calls @link(OnCheckScreenObject).
    function IsCurrentScreenObject(ScreenObject: TScreenObject): boolean;
    // @name adds AScreenObject to @link(FScreenObjectList).
    function AddScreenObject(const AScreenObject: TScreenObject): integer;
      virtual;
    // @name removes all @link(TScreenObject)s in @link(FScreenObjectList).
    // This will destroy them unless @link(OwnsScreenObjects) is
    // set to False first.
    procedure ClearScreenObjects;
    // @name are the parameters used in setting the colors of the grid cells.
    property GridColorParameters: TColorParameters read FGridColors;
    // @name are the parameters used in setting the colors of contours.
    property ContourColorParameters: TColorParameters read FContourColors;
    // @name creates an instance of @classname.
    constructor Create(AnOwner: TComponent); override;
    // @name destroys the current instance of @classname.
    // Do not call @name directly.  Call Free instead.
    destructor Destroy; override;
    // @name draws the 3D views of the @link(TScreenObject)s.
    procedure DrawScreenObjects3D;
    // @name removes AScreenObject from @link(ScreenObjects) without freeing it.
    procedure ExtractScreenObject(const AScreenObject: TScreenObject);
    // @name indicates what version of GoPhast last saved the file that is
    // currently open.
    property FileVersion: string read FFileVersion;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the chemistry in specified flux boundaries.
    property FluxBoundaryChemistryGroup: TTimeListGroup read
      FFluxBoundaryChemistryGroup;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the flux in specified flux boundaries.
    property FluxBoundaryFluxGroup: TTimeListGroup read FFluxBoundaryFluxGroup;
    // @name indicates what type of boundary condition (if any)
    // is present on the front face of each grid cell.
    property FrontBoundaryType: TDataArray read FFrontBoundaryType;
    // @name is the @link(TPhastTimeList) that specifies the chemistry
    // for specified flux boundaries on the front view of model cells.
    property FrontFluxBoundaryChemistry: TPhastTimeList
      read FFrontFluxBoundaryChemistry;
    // @name is the @link(TPhastTimeList) that specifies the flux
    // for specified flux boundaries on the front view of model cells.
    property FrontFluxBoundaryFlux: TPhastTimeList read FFrontFluxBoundaryFlux;
    // @name is the @link(TPhastTimeList) that specifies the associated solution
    // for leaky boundaries on the front view of model cells.
    property FrontLeakyAssociatedSolution: TPhastTimeList
      read FFrontLeakyAssociatedSolution;
    // @name is the @link(TPhastTimeList) that specifies the head
    // for leaky boundaries on the front view of model cells.
    property FrontLeakyHead: TPhastTimeList read FFrontLeakyHead;
    // @name increases the number of @link(TScreenObject)s that can be
    // held in @link(ScreenObjects) by the amount Delta.
    // If Delta is less than or equal to zero, @name does nothing.
    procedure IncreaseScreenObjectCapacity(const Delta: integer);
    // @name returns the position of AScreenObject
    // in @link(ScreenObjects).  If AScreenObject is not in
    /// @link(ScreenObjects), @name returns -1.
    function IndexOfScreenObject(const AScreenObject: TScreenObject): integer;
    // @name sets all the times in the model in @link(ModelTimes).
    // @name calls @link(InitializePhastBoundaries) and @link(RecordTimeControl)
    // to do this.
    procedure InitializeTimes;
    // @name inserts AScreenObject into @link(ScreenObjects) at the position
    // specified by Index.
    procedure InsertScreenObject(const Index: integer;
      const AScreenObject: TScreenObject);
    // Calling @name ensures that TScreenObject.Segments.@link(
    // TCellElementSegmentList.UpToDate) is @False for every
    // @link(TScreenObject).
    // @name only does something if @link(SomeSegmentsUpToDate) is @true.
    procedure InvalidateSegments;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the associated solution in leaky boundaries.
    property LeakyAssociatedSolutionGroup: TTimeListGroup
      read FLeakyAssociatedSolutionGroup;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the head in leaky boundaries.
    property LeakyHeadGroup: TTimeListGroup read FLeakyHeadGroup;
    // @name is used to store all the times used in the model.
    // Its contents are set in @link(InitializeTimes).
    property ModelTimes: TRealList read FModelTimes;
    // @name checks all @link(TScreenObject TScreenObject) starting with Root
    // followed by a number and returns the largest number so detected.
    function NumberOfLargestScreenObjectsStartingWith(
      const Root: string): integer;
    // @name is used to get or set @link(FScreenObjectList).OwnsObjects
    property OwnsScreenObjects: boolean read GetOwnsScreenObjects
      write SetOwnsScreenObjects;
    // @name removes AScreenObject from @link(ScreenObjects).
    // AScreenObject is freed unless @link(OwnsScreenObjects) is set to
    // @false first.  At the time this was written @name always freed
    // AScreenObject.
    procedure RemoveScreenObject(const AScreenObject: TScreenObject);
    // @name restores coloring the grid by time-varying data sets.
    // The data sets must already be up to date.
    procedure RestoreColoredDataSets;
    // @name is the @link(TPhastTimeList) that specifies the associated solution
    // for river boundaries.
    property RiverAssociatedSolution: TPhastTimeList
      read FRiverAssociatedSolution;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the associated solution in river boundaries.
    property RiverAssociatedSolutionGroup: TTimeListGroup
      read FRiverAssociatedSolutionGroup;

    // @name is the @link(TPhastTimeList) that specifies the head
    // for river boundaries.
    property RiverHead: TPhastTimeList read FRiverHead;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the head in river boundaries.
    property RiverHeadGroup: TTimeListGroup read FRiverHeadGroup;
    // @name returns the class of @link(TScreenObject) that is normally
    // used with @classname.  @name returns @link(TScreenObject).
    function ScreenObjectClass: TScreenObjectClass;
    // @name indicates what type of boundary condition (if any)
    // is present on the side face of each grid cell.
    property SideBoundaryType: TDataArray read FSideBoundaryType;
    // @name is the @link(TPhastTimeList) that specifies the chemistry
    // for specified flux boundaries on the side view of model cells.
    property SideFluxBoundaryChemistry: TPhastTimeList
      read FSideFluxBoundaryChemistry;
    // @name is the @link(TPhastTimeList) that specifies the flux
    // for specified flux boundaries on the side view of model cells.
    property SideFluxBoundaryFlux: TPhastTimeList read FSideFluxBoundaryFlux;
    // @name is the @link(TPhastTimeList)
    // that specifies the associated solution
    // for leaky boundaries on the front view of model cells.
    property SideLeakyAssociatedSolution: TPhastTimeList
      read FSideLeakyAssociatedSolution;
    // @name is the @link(TPhastTimeList) that specifies the head
    // for leaky boundaries on the side view of model cells.
    property SideLeakyHead: TPhastTimeList read FSideLeakyHead;

    // @name is the @link(TPhastTimeList) that specifies the associated solution
    // for specified head boundaries.
    property SpecifiedHeadAssociatedSolution: TPhastTimeList
      read FSpecifiedHeadAssociatedSolution;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the head in specified head boundaries.
    property SpecifiedHeadGroup: TTimeListGroup read FSpecifiedHeadGroup;
    // @name is the @link(TPhastTimeList) that specifies the specified head
    // for specified head boundaries.
    property SpecifiedHeadHead: TPhastTimeList read FSpecifiedHeadHead;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the solution in specified head boundaries.
    property SpecifiedHeadSolutionGroup: TTimeListGroup
      read FSpecifiedHeadSolutionGroup;
    // @name is the @link(TPhastTimeList) that specifies the specified solution
    // for specified head boundaries.
    property SpecifiedSolution: TPhastTimeList read FSpecifiedSolution;
    function GetTimeListByName(const AName: string): TCustomTimeList;
    // @name indicates what type of 2D boundary condition (if any)
    // is present on the top face of each grid cell.
    property Top2DBoundaryType: TDataArray read FTop2DBoundaryType;
    // @name indicates what type of boundary condition (if any)
    // is present on the top face of each grid cell.
    property TopBoundaryType: TDataArray read FTopBoundaryType;
    // @name is the @link(TPhastTimeList) that specifies the chemistry
    // for specified flux boundaries on the top view of model cells.
    property TopFluxBoundaryChemistry: TPhastTimeList
      read FTopFluxBoundaryChemistry;
    // @name is the @link(TPhastTimeList) that specifies the flux
    // for specified flux boundaries on the top view of model cells.
    property TopFluxBoundaryFlux: TPhastTimeList read FTopFluxBoundaryFlux;
    // @name is the @link(TPhastTimeList)
    // that specifies the associated solution
    // for leaky boundaries on the top view of model cells.
    property TopLeakyAssociatedSolution: TPhastTimeList
      read FTopLeakyAssociatedSolution;
    // @name is the @link(TPhastTimeList) that specifies the head
    // for leaky boundaries on the top view of model cells.
    property TopLeakyHead: TPhastTimeList read FTopLeakyHead;
    // @name is called after reading a @classname to transfer the information
    // about @link(TDataArray)s from @link(DataSetList)
    // to @link(FDataArrayManager).@link(TDataArrayManager.DataSets).
    procedure UpdateDataSets;
    procedure UpdateFrontTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); override;
    // @name is called after reading a @classname to transfer the information
    // about @link(TScreenObject)s from @link(ObjectList) to
    // @link(ScreenObjects).
    procedure UpdateScreenObjects;
    procedure UpdateSideTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); override;
    procedure UpdateThreeDTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); override;
    // @name calls TPhastTimeList.@link(TPhastTimeList.Loaded)
    // for each @link(TPhastTimeList) in @link(TimeLists).
    procedure UpdateTimeLists;
    procedure UpdateTopTimeDataSet(const TimeList: TCustomTimeList;
      const Time: double); override;

    // @name is the @link(TPhastTimeList) that specifies
    // the injection or pumping rate for well boundaries.
    // Positive means flow out of the porous medium.
    property WellInjectionOrPumpingRate: TPhastTimeList
      read FWellInjectionOrPumpingRate;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the injection or pumping rate in well boundaries.
    property WellPumpingRateGroup: TTimeListGroup read FWellPumpingRateGroup;
    // @name is the @link(TPhastTimeList) that specifies
    // the solution for well boundaries.
    // Positive means flow out of the porous medium.
    property WellSolution: TPhastTimeList read FWellSolution;
    // @name is the group of @link(TPhastTimeList)s that are related
    // to the solution in well boundaries.
    property WellSolutionGroup: TTimeListGroup read FWellSolutionGroup;

    // See @link(TfrmGoPhast.GetZoomBox).
    property OnGetZoomBox: TGetZoomBoxEvent read FOnGetZoomBox
      write FOnGetZoomBox;
    // If assigned, @name calls @link(OnGetZoomBox). Otherwise, it returns nil.
    function ZoomBox(VD: TViewDirection): TQrbwZoomBox2;
    // See @link(TfrmGoPhast.ScreenObjectsChanged
    // TfrmGoPhast.ScreenObjectsChanged).
    property OnScreenObjectsChanged: TNotifyEvent read FOnScreenObjectsChanged
      write FOnScreenObjectsChanged;
    // The event handler for this event is @link(TfrmGoPhast.UpdateDisplay
    // TfrmGoPhast.UpdateDisplay).
    // @name is called in @link(RefreshScreenObjects).
    property OnRefreshScreenObjects: TNotifyEvent read FOnRefreshScreenObjects
      write FOnRefreshScreenObjects;
    // If assigned, @name calls @link(OnScreenObjectsChanged).
    // Typically, @link(OnScreenObjectsChanged) is assigned to
    // @link(TfrmGoPhast.ScreenObjectsChanged TfrmGoPhast.ScreenObjectsChanged).
    procedure ScreenObjectsChanged(Sender: TObject);
    // @name calls @link(OnRefreshScreenObjects) if assigned.
    // @name is called by @link(TScreenObject.RefreshGui
    // TScreenObject.RefreshGui).
    procedure RefreshScreenObjects(Sender: TObject);
    // see @link(TfrmGoPhast.GetCurrentScreenObject).
    property OnGetCurrentScreenObject :TGetCurrentScreenObjectEvent
      read FOnGetCurrentScreenObject write FOnGetCurrentScreenObject;
    // If assigned, @name calls @link(OnGetCurrentScreenObject).
    function GetCurrentScreenObject(VD: TViewDirection): TScreenObject;
    // See @link(TfrmGoPhast.Invalidate3DView).
    property On3DViewChanged: TNotifyEvent read FOn3DViewChanged
      write FOn3DViewChanged;
    // If assigned, @name calls @link(On3DViewChanged).
    procedure Notify3DViewChanged;
    // @name sets the @link(TScreenObject.Selected) property of
    // all @link(TScreenObject)s to false.  @name returns true if any
    // of them were selected.
    function ResetSelectedScreenObjects: boolean;
    // see @link(TfrmGoPhast.ConvertPoint).
    property OnConvertPoint: TConvertPointEvent read FOnConvertPoint
      write FOnConvertPoint;
    // @name calls @link(OnConvertPoint).
    function ConvertPoint(VD: TViewDirection;
      const RealPoint: TPoint2D): TPoint;
    procedure InvalidateMfSfrData(Sender: TObject);
    procedure InvalidateMfSfrSegmentReachAndIcalc(Sender: TObject);
    procedure InvalidateMfSfrIprior(Sender: TObject);
    procedure InvalidateMfSfrChannelRoughness(Sender: TObject);
    procedure InvalidateMfSfrBankRoughness(Sender: TObject);
    procedure InvalidateMfSfrDepthCoefficient(Sender: TObject);
    procedure InvalidateMfSfrDepthExponent(Sender: TObject);
    procedure InvalidateMfSfrWidthCoefficient(Sender: TObject);
    procedure InvalidateMfSfrWidthExponent(Sender: TObject);
    property ArchiveName: string read GetArchiveName write SetArchiveName;
    procedure CreateArchive(const FileName: string; const ArchiveCommand: string = '');
    function DefaultHigherElevationFormula(ViewDirection: TViewDirection;
      EvalAt: TEvaluatedAt): string;
    function DefaultLowerElevationFormula(ViewDirection: TViewDirection;
      EvalAt: TEvaluatedAt): string;
    function DefaultElevationFormula(ViewDirection: TViewDirection;
       EvalAt: TEvaluatedAt): string;
    function ParameterDataSetUsed(Sender: TObject): boolean;
    function GetScreenObjectByName(AName: string): TScreenObject; override;
    procedure CopyScreenObjectsToClipboard;
    // Paste ModelMuse objects or Argus ONE Contours into ModelMuse.
    procedure PasteObjectsFromClipboard(List: TList);
    property ModelMateProject: TProject read FModelMateProject
      write SetModelMateProject;
    procedure UpdateModelMateProject;
    procedure ImportFromModelMateProject(Project: TProject);
    procedure RegisterGlobalVariables(Parser: TRbwParser;
      IgnoreDuplicates: Boolean = False);

    property FormulaManager: TFormulaManager read GetFormulaManager;
    procedure ClearScreenObjectCollection;

    property ColorLegend: TLegend read FColorLegend;
    property EndPointLegend: TLegend read FEndPointLegend;

    function FileVersionEqualOrEarlier(TestVersion: string): boolean;
    function CombinedColumnCount: integer;
    function CombinedRowCount: integer;
    function CombinedLayerCount: integer;
    property NeedToRecalculateTopCellColors: boolean
      read GetNeedToRecalculateTopCellColors
      write SetNeedToRecalculateTopCellColors;
    property NeedToRecalculateFrontCellColors: boolean
      read GetNeedToRecalculateFrontCellColors
      write SetNeedToRecalculateFrontCellColors;
    property NeedToRecalculateSideCellColors: boolean
      read GetNeedToRecalculateSideCellColors
      write SetNeedToRecalculateSideCellColors;
    procedure UpdateDataSetDimensions;
    function LgrUsed: boolean;
    function LgrV1Used: boolean;
    function BcfIsSelected: Boolean;
    function ChdIsSelected: Boolean; override;
    function TvkIsSelected: Boolean; override;
    function TvsIsSelected: Boolean; override;
    function ChobIsSelected: Boolean;
    function De4IsSelected: Boolean;
    function DrnIsSelected: Boolean;
    function DrobIsSelected: Boolean;
    function DrtIsSelected: Boolean;
    function EtsIsSelected: Boolean;
    function EvtIsSelected: Boolean;
    function FhbIsSelected: Boolean; override;
    function GbobIsSelected: Boolean;
    function GhbIsSelected: Boolean;
    function GmgIsSelected: Boolean;
    function HfbIsSelected: Boolean;
    function HobIsSelected: Boolean;
    function HufIsSelected: Boolean;
    function HydmodIsSelected: Boolean;
    function LakIsSelected: Boolean;
    function LakMf6IsSelected: Boolean;
    function LpfIsSelected: Boolean;
    function UpwIsSelected: Boolean;
    function Mnw2IsSelected: Boolean;
    function Mnw1IsSelected: Boolean;
    function MvrIsSelected: Boolean;
    function Mnw1LossTypes: TMnw1LossTypes;
    function MODPATHIsSelected: Boolean;
    function Modpath5IsSelected: boolean;
    function Modpath6IsSelected: boolean;
    function Modpath7IsSelected: boolean;
    procedure ModpathHeadWarning;
//    function Mt3dIsSelected: Boolean;
    function Mt3dmsSsmIsSelected: Boolean;
    function Mt3d_UztIsSelected: Boolean;
    function Mt3d_UztEtIsSelected: Boolean;
    function DoMt3d_LktIsSelected(Sender: TObject): Boolean; override;
    function Mt3d_SftIsSelected: Boolean;
    function Mt3dmsTobIsSelected: Boolean;
    function PcgIsSelected: Boolean;
    function RchIsSelected: Boolean;
    function ResIsSelected: Boolean;
    function RivIsSelected: Boolean;
    function RvobIsSelected: Boolean;
    function SfrIsSelected: Boolean;
    function Sfr6IsSelected: Boolean;
    function StrIsSelected: Boolean;
    function SipIsSelected: Boolean;
    function SubIsSelected: Boolean;
    function SwtIsSelected: Boolean;
    function StobIsSelected: Boolean;
    function UzfIsSelected: Boolean;
    function UzfMf6IsSelected: Boolean;
    function WelIsSelected: Boolean;
    function ZoneBudgetIsSelected: Boolean;
    function FarmProcess3IsSelected: Boolean;
    function FarmProcess4IsSelected: Boolean;
    function FarmProcess4TransientFarmIsSelected: Boolean;
    function FarmProcess4TransientRefEtIsSelected: Boolean;
    function FarmProcess4TransientPrecipIsSelected: Boolean;
    function FarmProcess4TransientEfficiencyArrayIsSelected: Boolean; override;
    function FarmProcess4TransientEfficiencyImprovementArrayIsSelected: Boolean; override;
    function FarmProcess4TransientBareRunoffFractionArrayIsSelected: Boolean; override;
    function FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected: Boolean; override;
    function FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected: Boolean; override;
    function FarmProcess4TransientBareEvapArrayIsSelected: Boolean; override;
    function FarmProcess4TransientDirectRechargeArrayIsSelected: Boolean; override;
    function FarmProcess4TransientPrecipPotConsumptionArrayIsSelected: Boolean; override;
    function FarmProcess4TransientNrdInfilLocIsSelected: Boolean; override;
    function FarmProcess4TransientLandUseAreaFractionIsSelected: Boolean; override;
    function FarmProcess4TransientLandUseAreaFractionMultIsSelected: Boolean; override;
    function FarmProcess4TransientCropCoefficientIsSelected: Boolean; override;
    function FarmProcess4TransientCropCoefficientMultIsSelected: Boolean; override;
    function FarmProcess4TransientConsumptiveUseIsSelected: Boolean; override;
    function FarmProcess4TransientConsumptiveUseMultIsSelected: Boolean; override;
    function FarmProcess4TransientIrrigationIsSelected: Boolean; override;
    function FarmProcess4TransientIrrigationMultIsSelected: Boolean; override;
    function FarmProcess4TransientRootDepthIsSelected: Boolean; override;
    function FarmProcess4TransientRootDepthMultIsSelected: Boolean; override;
    function FarmProcess4TransientTranspirationFractionIsSelected: Boolean; override;
    function FarmProcess4TransientTranspirationFractionMultIsSelected: Boolean; override;
    function FarmProcess4TransientEvaporationIrrigationFractionIsSelected: Boolean; override;
    function FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected: Boolean; override;
    function FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected: Boolean; override;
    function FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected: Boolean; override;
    function FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected: Boolean; override;
    function FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected: Boolean; override;
    function FarmProcess4TransientAddedDemandIsSelected: Boolean; override;
    function FarmProcess4TransientAddedDemandMultIsSelected: Boolean; override;
    function FarmProcess4TransientCropHasSalinityDemandIsSelected: Boolean; override;
    function FarmProcess4TransientCropHasSalinityDemandMultIsSelected: Boolean; override;
    function FarmProcess4WellSelected: Boolean;

    function CfpRechargeIsSelected(Sender: TObject): boolean;
    function SwrIsSelected: Boolean; override;
    function RipIsSelected: Boolean;
    function MawIsSelected: Boolean;
    function CSubIsSelected: Boolean;
    function GncIsSelected: Boolean;
    function Mf6ObsIsSelected: Boolean; override;
    function GwtCncIsSelected: Boolean;
    function GwtSrcIsSelected: Boolean;
    function PackageIsSelected(APackage: TObject): Boolean;
    procedure ExportModflowLgrModel(const FileName: string;
      RunModel, ExportModpath, NewBudgetFileForModpath, ExportZoneBudget,
      ShowWarning: boolean);
    procedure AdjustDataArray(ADataArray: TDataArray); override;
    function RchTimeVaryingLayers: boolean;
    function EvtTimeVaryingLayers: boolean;
    function EtsTimeVaryingLayers: boolean;
    procedure BeginGridChange; override;
    procedure EndGridChange; override;
    procedure BeginDataSetUpdate;
    procedure EndDataSetUpdate;
    property DataSetUpdateCount: integer read FDataSetUpdateCount;
    procedure UpdateCombinedDisplayColumn;
    procedure UpdateCombinedDisplayRow;
    procedure UpdateCombinedDisplayLayer;
    function DispersionSelected: boolean;
    function AnyDispersionMultiDiffusion: boolean;
    function AllDispersionMultiDiffusion: boolean;
    function AnyMt3dSorbImmobConc: boolean;
    function AnyMt3dSorbParameter: boolean;
    function AnyMt3dReactions: Boolean;
    function AnyMt3dUsgsMonod: Boolean;
    function AnyMt3dUsgsDualSeparate: Boolean;
    procedure UpdateMt3dmsChemDataSets; override;
    function Mt3dMsFirstSorbParamUsed(Sender: TObject): boolean;
    function Mt3dUsgsMonodUsed(Sender: TObject): boolean;
    function Mt3dUsgsDualSeparateUsed(Sender: TObject): boolean;
    function Mt3dMsSecondSorbParamUsed(Sender: TObject): boolean;
    function Mt3dmsReactionRateDisolvedUsed(Sender: TObject): boolean;
    function Mt3dmsReactionRateSorbedUsed(Sender: TObject): boolean;
    function CombinedLayerSimulated(ALayer: Integer): boolean;
    procedure UpdateDataArrayParameterUsed; override;
    procedure ExportFootprintInput(FileName: string; RunFootprint: boolean);
    procedure ClearModelFiles;
    procedure ClearModpathFiles;
    procedure ClearMt3dmsFiles;
    procedure ClearZonebudgetFiles;
    procedure ClearSwiObsFiles;
    procedure AddModelProgramsToList(FileNames: TStringList);
    procedure ClearBinaryFiles; override;
    procedure GetLayerDataArrays(DataSetList: TDataArrayList);
    property FixingModel: boolean read FFixingModel;
    function UzfSeepageUsed: boolean; override;
    procedure InvalidateContours; override;
    function Mt3dIsSelected: Boolean; override;
    procedure ExportPestInput(FileName: string; RunPest: TPestExportChoice;
      SetNOPTMAX: Boolean = False);
    function ExportParRepInput(FileName: string; RunParRep, RunPest,
      IncludePause: Boolean; New_noptmax: Integer = -1): string;
    procedure ExportSupCalcInput;
    procedure ExportSvdaPrep;
    procedure SetMf2005ObsGroupNames; override;
//    property PilotPoints[Index: Integer]: TPoint2D read GetPilotPoint;
    procedure DrawPilotPoints(BitMap32: TBitmap32);
    function ShouldDrawPilotPoints: Boolean;
//    property PilotPointSpacing: double read GetPilotPointSpacing;
    procedure DisconnectObservers;
    function GetPestName: string;
    function Mf6UzfInitialConcentrationUsed(Sender: TObject): boolean;
    function AnyUzfInitialConcentrationUsed: Boolean;
    function GwtMobileSeparatePorosityUsed(Sender: TObject): boolean;
    function GwePorosityUsed(Sender: TObject): boolean;
    function GwtMobileDecayUsed(Sender: TObject): boolean;
    function GwtMobileSorbedDecayUsed(Sender: TObject): boolean;
    function GwtMobileDistibutionCoefUsed(Sender: TObject): boolean;
    function GwtMobileBulkDensityUsed(Sender: TObject): boolean;
    function GwtMobileFreundlichExponentUsed(Sender: TObject): boolean;
    function GwtMobileSorptionCapacityUsed(Sender: TObject): boolean;
    function GwtImmobileCimUsed(Sender: TObject): boolean;
    function GwtImmobileThetaimUsed(Sender: TObject): boolean;
    function GwtImmobileVolumeFractUsed(Sender: TObject): boolean;
    function GwtImmobileZetaimUsed(Sender: TObject): boolean;
    function GwtImmobileDecayUsed(Sender: TObject): boolean;
    function GwtImmobileDecaySorbedUsed(Sender: TObject): boolean;
    function GwtImmobileBulkDensityUsed(Sender: TObject): boolean;
    function GwtImmobileDistCoefUsed(Sender: TObject): boolean;
    function GwtImmobileFreundlichExponentSp2Used(Sender: TObject): boolean;
    function GwtImmobileSorptionCapacitySp2Used(Sender: TObject): boolean;
    property Mt3d_LktIsSelected;
    function Mf6VTransDispUsed(Sender: TObject): boolean;
    function AnyVTransDispUsed: Boolean;
  published
    property Mf6TimesSeries;

    // @name stores FlowOnly option in PHAST.
    property FlowOnly: boolean write SetFlowOnly stored False;
    { @name is used to store fluid properties in PHAST.}
    { @name is only for backwards compatibility.  It is not used.}
    property FluidProperties: TFluidProperties  read FFluidProperties
      write FFluidProperties stored False;
    // @name stores the height in pixels of the front view of the model.
    property FrontHeight: integer // read GetFrontHeight
      write SetFrontHeight stored False;
    // @name stores the reference X-coordinate for the front view of the model.
    property FrontX: double {read GetFrontX} write SetFrontX stored False;
    // @name stores the reference Y-coordinate for the front view of the model.
    property FrontY: double {read GetFrontY} write SetFrontY stored False;
    // @name is the height of the main form in pixels.
    property Height: integer {read GetHeight} write SetHeight stored False;
    // @name is the X-coordinate of the main form in pixels.
    property Left: integer {read GetLeft} write SetLeft stored False;
    // @name is the magnification of the front view of the model.
    property MagnificationFront: double //read GetMagnificationFront
      write SetMagnificationFront stored False;
    // @name is the magnification of the side view of the model.
    property MagnificationSide: double //read GetMagnificationSide
      write SetMagnificationSide stored False;
    // @name is the magnification of the top view of the model.
    property MagnificationTop: double //read GetMagnificationTop
      write SetMagnificationTop stored False;
    // @name is the width in pixels of the side view of the model.
    property SideWidth: integer //read GetSideWidth
      write SetSideWidth stored False;
    // @name stores the reference X-coordinate for the side view of the model.
    property SideX: double {read GetSideX} write SetSideX stored False;
    // @name stores the reference Y-coordinate for the front view of the model.
    property SideY: double {read GetSideY} write SetSideY stored False;
    // @name is the Y-coordinate of the main form in pixels.
    property Top: integer {read GetTop} write SetTop stored False;
    // @name is the height of the top view of the model in pixels
    property TopViewHeight: integer //read GetTopViewHeight
      write SetTopViewHeight stored False;
    // @name is the width of the top view of the model in pixels
    property TopViewWidth: integer //read GetTopViewWidth
      write SetTopViewWidth stored False;
    // @name stores the reference X-coordinate for the top view of the model.
    property TopX: double {read GetTopX} write SetTopX stored False;
    // @name stores the reference Y-coordinate for the top view of the model.
    property TopY: double {read GetTopY} write SetTopY stored False;
    // @name is the width of the main form in GoPhast in pixels.
    property Width: integer {read GetWidth} write SetWidth stored False;
    // @name stores whether the model is maximized, minimized, or normal.
    property WindowState: TWindowState // read GetWindowState
      write SetWindowState stored False;

    // The following properties are used only in PHAST models.

    // @name is the diffusivity in PHAST.
    property Diffusivity: double read FDiffusivity write SetDiffusivity;
    // @name is used to store options related to the grid in PHAST.
    property GridOptions: TGridOptions read FGridOptions write FGridOptions;
    // @name represents the @link(TPrintFrequencyItem)s in PHAST.
    property PrintFrequency: TPrintFrequencyCollection read FPrintFrequency
      write SetPrintFrequency;
    // @name stores options related to the PRINT_INITIAL data block in PHAST.
    property PrintInitial: TPrintInitial read FPrintInitial write FPrintInitial;
    // @name specifies options related to the solution method in PHAST.
    property SolutionOptions: TSolutionOptions read FSolutionOptions
      write FSolutionOptions;
    // @name is used to store options related to the STEADY_FLOW
    // data block in PHAST.
    property SteadyFlowOptions: TSteadyFlowOptions read FSteadyFlowOptions
      write FSteadyFlowOptions;
    // @name represents a collection of stress periods in PHAST.
    property Times: TTimeCollection read FTimes write SetTimes;
    // @name represents the title associated with the PHAST model.
    property Title: TStrings read FTitle write SetTitle stored True;
    // @name stores the default units in PHAST.
    property Units: TUnits read FUnits write SetUnits;
    // @name represents a series of bitmaps that can be displayed on
    // the top, front, or side view of the model.
    // @name is used in both PHAST and MODFLOW models.
    property Bitmaps: TCompressedBitmapCollection read FBitmaps write
      SetBitmaps;
    // @name is the vertical exaggeration of the front, side, and 3D views
    // of the model in GoPhast.
    // @name is used in PHAST, MODFLOW, and SUTRA models.
    property Exaggeration;
    property RipPlantGroups: TRipPlantGroups read FRipPlantGroups
      write SetRipPlantGroups;
    // @name is used to read or write @link(TScreenObject)s to or from files.
    // @name is used in both PHAST and MODFLOW models.
    property ObjectList: TScreenObjectCollection
      read GetScreenObjectCollection write SetScreenObjectCollection;
    // @name is the version of GoPhast that last saved the model that is being
    // edited.
    // @name is used in both PHAST and MODFLOW models.
    property Version: string read GetVersion write SetVersion;
    // @name specifies the size and appearance of various portions of the
    // ModelMuse main window.
    // @name is used in both PHAST and MODFLOW models.
    property GuiSettings: TGuiSettings read FGuiSettings write FGuiSettings;
    // @name is the ModelMate file associated with this model.
    property ModelMateProjectFileName: string read FModelMateProjectFileName
      write SetModelMateProjectFileName;
    //  see @link(TDisplaySettingsCollection).
    // @name is used in both PHAST and MODFLOW models.
    property DisplaySettings: TDisplaySettingsCollection read FDisplaySettings
      write SetDisplaySettings;
    property ChildModels: TChildModelCollection read GetChildModels
       write SetChildModels stored StoreChildModels;
    property SaveDataSetValues: TSaveDataSetValues read FSaveDataSetValues
      write FSaveDataSetValues default sdsvAlways;

    property ModflowSteadyParameters;
    property ModelSelection;
    property LayerStructure;
    property ModflowStressPeriods;
    property SoluteTransport;
    property UseWaterTable;
    property FreeSurface;
    property ChemistryOptions;
    property HufParameters;
    property ObservationPurpose;
    property ModflowTransientParameters;
    property ModflowOutputControl;
    property Mt3dmsOutputControl;
    property Mt3dmsTimes;
    property DataSetList;
    property CombinedDisplayColumn: integer read GetCombinedDisplayColumn
      write SetCombinedDisplayColumn;
    property CombinedDisplayRow: integer read GetCombinedDisplayRow
      write SetCombinedDisplayRow;
    property CombinedDisplayLayer: integer read GetCombinedDisplayLayer
      write SetCombinedDisplayLayer;
    property SaveBfhBoundaryConditions;
    property ContourFont;
    property ShowContourLabels;
    property SfrStreamLinkPlot;
    property StrStreamLinkPlot;
    property SfrMf6StreamLinkPlot;
    property SutraLayerStructure: TSutraLayerStructure read GetSutraLayerStructure
      write SetSutraLayerStructure;
    property SutraTimeOptions: TSutraTimeOptions read FSutraTimeOptions
      write SetSutraTimeOptions;
    // User defined color schemes for coloring the grid or mesh
    // or for contour lines.
    property ColorSchemes: TUserDefinedColorSchemeCollection read GetColorSchemes write SetColorSchemes;
    property FishnetMeshGenerator: TFishnetMeshGenerator read FFishnetMeshGenerator
      write SetFishnetMeshGenerator;
    property SutraSettings: TSutraSettings read FSutraSettings write SetSutraSettings;
    property MaxVectors: TPredefinedVectors read FMaxVectors write SetMaxVectors;
    property MidVectors: TPredefinedVectors read FMidVectors write SetMidVectors;
    property MinVectors: TPredefinedVectors read FMinVectors
      write SetMinVectors;
    property FmpCrops: TCropCollection read GetFmpCrops write SetFmpCrops;
    property FmpSoils: TSoilCollection read GetFmpSoils write SetFmpSoils;
    property FmpClimate: TClimateCollection read GetFmpClimate write SetFmpClimate;
    property FmpAllotment: TAllotmentCollection read GetFmpAllotment
       write SetFmpAllotment;
    property Farms: TFarmCollection read GetFarms write SetFarms;
    property IrrigationTypes;
  {$IFDEF LinkedRasters}
    property LinkedRasters;
  {$ENDIF}
    property FootprintProperties;
    property GeoRef;
    property UseGsflowFormat;
    property ParamGroups;
    property PestProperties;
    property SvdaPrepProperties: TSvdaPrepProperties read FSvdaPrepProperties
      write SetSvdaPrepProperties;
    property SupCalcProperties: TSupCalcProperties read FSupCalcProperties
      write SetSupCalcProperties;
  end;

  TChildDiscretization = class(TOrderedItem)
  private
    FParentLayerNumber: integer;
    FLayerGroup: TLayerGroup;
    FLayerGroupName: string;
    FDiscretization: integer;
    procedure SetDiscretization(const Value: integer);
    procedure SetLayerGroup(const Value: TLayerGroup);
    procedure SetLayerGroupName(const Value: string);
    procedure SetParentLayerNumber(const Value: integer);
    function GetLayerGroupName: string;
    function GetLayerGroup: TLayerGroup;
    function GetDiscretization: integer;
  protected
    function IsSame(AnotherItem: TOrderedItem): boolean; override;
    procedure Loaded;
  public
    constructor Create(Collection: TCollection); override;
    procedure Assign(Source: TPersistent); override;
    property LayerGroup: TLayerGroup read GetLayerGroup write SetLayerGroup;
  published
    property LayerGroupName: string read GetLayerGroupName
      write SetLayerGroupName;
    // @name refers to the layer within the @link(LayerGroup).
    // @name starts at 0.
    property ParentLayerNumber: integer read FParentLayerNumber
      write SetParentLayerNumber;
    property Discretization: integer read GetDiscretization
      write SetDiscretization default 1;
  end;

  TChildDiscretizationCollection = class(TOrderedCollection)
  private
    FBottomUnitName: string;
    FBottomLayerInUnit: integer;
    FBottomLayerGroup: TLayerGroup;
    FChanged: Boolean;
    function GetBottomUnitName: string;
    procedure SetBottomLayerGroup(const Value: TLayerGroup);
    procedure SetBottomLayerInUnit(const Value: integer);
    procedure SetBottomUnitName(const Value: string);
    function GetItem(Index: integer): TChildDiscretization;
    procedure SetItem(Index: integer; const Value: TChildDiscretization);
    procedure Sort;
    function GetBottomLayerGroup: TLayerGroup;
  protected
    procedure Loaded;
    procedure Update(Item: TCollectionItem); override;
  public
    function IsSame(AnOrderedCollection: TOrderedCollection): boolean; override;
    { TODO -cRefactor : Consider replacing CModel with an interface. }
    //
    constructor Create(Model: IModelForTOrderedCollection);
    procedure Assign(Source: TPersistent); override;
    property BottomLayerGroup: TLayerGroup read GetBottomLayerGroup
      write SetBottomLayerGroup;
    // SubLayer starts at zero.
    function GetAnItemByGroupAndLayer(LayerGroup: TLayerGroup;
      SubLayer: integer): TChildDiscretization;
    // ParentLayer starts at zero.
    function GetAnItemByLayer(Layer: integer): TChildDiscretization;
    property Items[Index: integer]: TChildDiscretization read GetItem
      write SetItem; default;
    procedure SortAndDeleteExtraItems;
    // @name treats the top layer as layer 1 and only counts simulated layers.
    // This is a MODFLOW layer number.
    function BottomModflowParentLayerNumber: integer;
    // @name returns the index of the parent layer at the bottom of the
    // local grid.  The first layer is treated as zero.
    function BottomLayerIndex: integer;
    function ModflowLayerCount: integer;
    function ModflowConfiningBedCount: integer;
    procedure WriteLAYCB(const DiscretizationWriter: TObject); virtual;
  published
    property BottomUnitName: string read GetBottomUnitName
      write SetBottomUnitName;
    // @name indicates the lowermost layer in @link(BottomLayerGroup)
    // that will be part of the child model.
    // @name starts as 0.
    property BottomLayerInUnit: integer read FBottomLayerInUnit
      write SetBottomLayerInUnit;
  end;

  TGridRange = record
    First: integer;
    Last: integer;
  end;

  TStartingHeadSource = (shsSelf, shsParent);
  TLgrPrintChoice = (lpcScreen, lpcListing, lpcNone);
  TCouplingMethod = (cmOneWay, cmTwoWay);

  TChildModel = class(TCustomModel)
  private
    FParentModel: TCustomModel;
    FModelName: string;
    FDiscretization: TChildDiscretizationCollection;
    FChildCellsPerParentCell: integer;
    FHorizontalPositionScreenObject: TScreenObject;
    FCanUpdateGrid: Boolean;
    FShouldUpdateGrid: Boolean;
    FFirstCol: Integer;
    FLastCol: Integer;
    FFirstRow: Integer;
    FLastRow: Integer;
    FCreating: Boolean;
    FStartingHeadSource: TStartingHeadSource;
    FMaxIterations: integer;
    FLgrPrintChoice: TLgrPrintChoice;
    FFluxRelaxationFactor: double;
    FHeadRelaxationFactor: double;
    FFluxClosureCriterion: double;
    FHeadClosureCriterion: double;
    FCouplingMethod: TCouplingMethod;
    function GetSomeSegmentsUpToDate: boolean; override;
    procedure SetSomeSegmentsUpToDate(const Value: boolean); override;
    procedure SetModelName(const Value: string);
    procedure SetDiscretization(const Value: TChildDiscretizationCollection);
    procedure SetChildCellsPerParentCell(const Value: integer);
    procedure SetHorizontalPositionScreenObject(const Value: TScreenObject);
    procedure GetRowColPositions(const StartPosition, EndPosition: integer;
      const ParentPositions: TOneDRealArray; out ChildPostions: TOneDRealArray);
    procedure SetCanUpdateGrid(const Value: Boolean);
    function ParentPositionToChildPositions(ViewDirection: TViewDirection;
      APosition: integer): TGridRange;
    function MaxPosition(ViewDirection: TViewDirection): integer;
    procedure SetStartingHeadSource(const Value: TStartingHeadSource);
    procedure SetMaxIterations(const Value: integer);
    procedure SetLgrPrintChoice(const Value: TLgrPrintChoice);
    procedure SetFluxRelaxationFactor(const Value: double);
    procedure SetHeadRelaxationFactor(const Value: double);
    procedure SetFluxClosureCriterion(const Value: double);
    procedure SetHeadClosureCriterion(const Value: double);
    function ConvertIntegerParentArray(ParentArray: TOneDIntegerArray): TOneDIntegerArray;
    function ConvertRealParentArray(ParentArray: TOneDRealArray): TOneDRealArray;
    procedure SetCouplingMethod(const Value: TCouplingMethod);
    procedure AdjustCellPosition(var Column, Row, Layer: integer); overload;
    function GetSaveBfhBoundaryConditions: boolean; override;
    procedure SetSaveBfhBoundaryConditions(const Value: boolean);  override;
//    function GetUnitNumbers: TUnitNumbers; override;
//    procedure SetUnitNumbers(const Value: TUnitNumbers); override;
  protected
    function GetGlobalVariables: TGlobalVariables; override;
    procedure SetGlobalVariables(const Value: TGlobalVariables); override;
    function GetParentModel: TCustomModel; override;
    function GetGlobalVariablesI: IGlobalVariables; override;
    procedure SetGlobalVariablesI(const Value: IGlobalVariables); override;
    function StoreHydrogeologicUnits: Boolean; override;
    function GetScreenObjects(const Index: integer): TScreenObject; override;
    function GetScreenObjectCount: integer; override;
    function GetModflowSteadyParameters: TModflowSteadyParameters; override;
    function GetLayerStructure: TLayerStructure; override;
    procedure SetLayerStructure(const Value: TLayerStructure); override;
    function GetModflowStressPeriods: TModflowStressPeriods; override;
    procedure SetModflowStressPeriods(const Value: TModflowStressPeriods); override;
    procedure SetSoluteTransport(const Value: boolean); override;
    function GetSoluteTransport: boolean; override;
    procedure SetUseWaterTable(const Value: boolean); override;
    function GetUseWaterTable: boolean; override;
    function GetFreeSurface: boolean; override;
    procedure SetFreeSurface(const Value: boolean); override;
    procedure SetChemistryOptions(const Value: TChemistryOptions); override;
    function GetChemistryOptions: TChemistryOptions; override;
    function GetObservationPurpose: TObservationPurpose; override;
    procedure SetObservationPurpose(const Value: TObservationPurpose); override;
    procedure SetHufParameters(const Value: THufModflowParameters); override;
    function GetHufParameters: THufModflowParameters; override;
    function GetModflowTransientParameters: TModflowTransientListParameters; override;
    procedure SetModflowTransientParameters(
      const Value: TModflowTransientListParameters); override;
    function GetModflowOutputControl: TModflowOutputControl; override;
    procedure SetModflowOutputControl(const Value: TModflowOutputControl); override;
    function GetProgramLocations: TProgramLocations; override;
    procedure SetProgramLocations(const Value: TProgramLocations); override;
    function GetModflowFullStressPeriods: TModflowStressPeriods; override;
    procedure SetModflowSteadyParameters(const Value: TModflowSteadyParameters); override;
    function GetModelSelection: TModelSelection; override;
    function GetSelectedModel: TCustomModel; override;
    procedure SetSelectedModel(const Value: TCustomModel); override;
    function GetFormulaManager: TFormulaManager; override;
    procedure Loaded; override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadFluxRelaxationFactor(Reader: TReader);
    procedure ReadHeadRelaxationFactor(Reader: TReader);
    procedure WriteFluxRelaxationFactor(Writer: TWriter);
    procedure WriteHeadRelaxationFactor(Writer: TWriter);
    procedure ReadHeadClosureCriterion(Reader: TReader);
    procedure ReadFluxClosureCriterion(Reader: TReader);
    procedure WriteHeadClosureCriterion(Writer: TWriter);
    procedure WriteFluxClosureCriterion(Writer: TWriter);
    function GetDisplayName: string; override;
    procedure SetContourFont(const Value: TFont) ; override;
    procedure SetShowContourLabels(const Value: boolean);  override;
    function GetContourFont: TFont;  override;
    function GetShowContourLabels: boolean; override;
    procedure SetMt3dmsOutputControl(const Value: TMt3dmsOutputControl); override;
    function GetMt3dmsOutputControl: TMt3dmsOutputControl; override;
    function GetMt3dmsTimes: TMt3dmsTimeCollection; override;
    procedure SetMt3dmsTimes(const Value: TMt3dmsTimeCollection); override;
    function GetImmobileComponents: TChemSpeciesCollection; override;
    function GetMobileComponents: TMobileChemSpeciesCollection; override;
    procedure SetImmobileComponents(const Value: TChemSpeciesCollection); override;
    procedure SetMobileComponents(const Value: TMobileChemSpeciesCollection); override;
    function GetSfrStreamLinkPlot: TSfrStreamLinkPlot; override;
    procedure SetSfrStreamLinkPlot(const Value: TSfrStreamLinkPlot); override;
    function GetStrStreamLinkPlot: TSfrStreamLinkPlot; override;
    procedure SetStrStreamLinkPlot(const Value: TSfrStreamLinkPlot); override;
    function GetSfrMf6StreamLinkPlot: TSfrStreamLinkPlot; override;
    procedure SetSfrMf6StreamLinkPlot(const Value: TSfrStreamLinkPlot); override;
    function GetSwrReachConnectionsPlot: TSwrReachConnectionsPlot; override;
    procedure SetSwrReachConnectionsPlot(const Value: TSwrReachConnectionsPlot); override;
    function GetContourLabelSpacing: Integer; override;
    procedure SetContourLabelSpacing(const Value: Integer); override;
    function GetFarms: TFarmCollection; override;
    function GetFmpAllotment: TAllotmentCollection; override;
    function GetFmpClimate: TClimateCollection; override;
    function GetFmpCrops: TCropCollection; override;
    function GetFmpSoils: TSoilCollection; override;
    procedure SetFarms(const Value: TFarmCollection); override;
    procedure SetFmpClimate(const Value: TClimateCollection); override;
    procedure SetFmpCrops(const Value: TCropCollection); override;
    procedure SetFmpSoils(const Value: TSoilCollection); override;
    procedure SetFmpAllotment(const Value: TAllotmentCollection); override;
    function GetLinkedRasters: TLinkedRasterCollection; override;
    procedure SetLinkedRasters(const Value: TLinkedRasterCollection);  override;
    function GetFootprintProperties: TFootprintProperties; override;
    procedure SetFootprintProperties(const Value: TFootprintProperties); override;
    function GetGeoRef: TGeoRef; override;
    procedure SetGeoRef(const Value: TGeoRef); override;
    function GetContourLegend: TLegend; override;
    function GetUseGsflowFormat: boolean; override;
    procedure SetUseGsflowFormat(const Value: boolean); override;
    procedure SetCtsSystems(const Value: TCtsSystemCollection); override;
    function GetCtsSystems: TCtsSystemCollection; override;
    function GetParamGroups: TPestParamGroups; override;
    procedure SetParamGroups(const Value: TPestParamGroups); override;
    function GetPestProperties: TPestProperties; override;
    procedure SetPestProperties(const Value: TPestProperties); override;
    function GetFilesToDelete: TStrings; override;
    function GetMf6TimesSeries: TTimesSeriesCollections; override;
    procedure SetMf6TimesSeries(const Value: TTimesSeriesCollections); override;
    function GetAppsMoved: TStringList; override;
    function GetIrrigationTypes: TIrrigationCollection; override;
    procedure SetIrrigationTypes(const Value: TIrrigationCollection); override;
  public
    property CanUpdateGrid: Boolean read FCanUpdateGrid write SetCanUpdateGrid;
    function LayerGroupUsed(LayerGroup: TLayerGroup): boolean; override;
    function LayerFractions(LayerGroup: TCustomLayerGroup): TDoubleDynArray; override;
    function LayerCount: integer;  override;
    function FirstOverlappedLayer: integer;
    procedure UpdateDisplayUseList(NewUseList: TStringList;
      ParamType: TParameterType; DataIndex: integer; const DisplayName: string); override;
    procedure Assign(Source: TPersistent); override;
    constructor Create(AnOwner: TComponent); override;
    destructor Destroy; override;
    procedure DoInvalidate(Sender: TObject); override;
    function GetScreenObjectByName(AName: string): TScreenObject; override;
    procedure UpdateLayerCount;
    property HorizontalPositionScreenObject: TScreenObject
      read FHorizontalPositionScreenObject
      write SetHorizontalPositionScreenObject;
    procedure UpdateGrid;
    procedure UpdateDataSetConnections;
    function ChildColToParentCol(ACol: integer): integer;
    function ChildRowToParentRow(ARow: integer): integer;
    function ChildLayerToParentLayer(ALayer: integer): integer;
    function ParentColToChildCols(ACol: integer): TGridRange;
    function ParentRowToChildRows(ARow: integer): TGridRange;
    function ParentLayerToChildLayers(ALayer: integer): TGridRange;
    function EdgeIndex: integer;
    function Child_NameFile_Name(const Parent_NameFile_Name: string): string;
    property FirstCol: Integer read FFirstCol;
    property LastCol: Integer read FLastCol;
    property FirstRow: Integer read FFirstRow;
    property LastRow: Integer read FLastRow;
    function ModflowLayerCount: integer; override;
    function ModflowConfiningBedCount: integer; override;
    procedure WriteLAYCB(const DiscretizationWriter: TObject); override;
    function IsLayerSimulated(const LayerID: integer): boolean; override;
    function IsLayerConfined(const LayerID: integer): boolean; override;
    Function Laytyp: TOneDIntegerArray; override;
    Function Layavg: TOneDIntegerArray; override;
    function Chani: TOneDIntegerArray; override;
    Function Layvka: TOneDIntegerArray; override;
    function Trpy: TOneDRealArray; override;
    Function TRPT: TOneDRealArray; override;
    function TRPV: TOneDRealArray; override;
    Function DMCOEF: TOneDRealArray; override;
    function GetLayerGroupByLayer(const Layer: integer): TLayerGroup; override;
    function ModflowLayerBottomDescription(const LayerID: integer): string; override;
    Function ModflowLayerToDataSetLayer(ModflowLayer: integer): integer; override;
    function DataSetLayerToModflowLayer(DataSetLayer: integer): integer; override;
    procedure AdjustCellPosition(AValueCell: TValueCell); overload; override;
    procedure AdjustCellPosition(ACellAssignment: TCellAssignment); overload; override;
    procedure AdjustDataArray(ADataArray: TDataArray); override;
    function DefaultModflowOutputFileName: string; override;
    procedure UpdateMt3dmsChemDataSets; override;
    function CfpIsSelected: Boolean; override;
    function ModelNameForDos: string;
    property ParentModel: TCustomModel read FParentModel;
  published
    property ModelName: string read FModelName write SetModelName;
    property Discretization: TChildDiscretizationCollection
      read FDiscretization write SetDiscretization;
    property ChildCellsPerParentCell: integer read FChildCellsPerParentCell
      write SetChildCellsPerParentCell default 3;
    property StartingHeadSource: TStartingHeadSource read FStartingHeadSource
      write SetStartingHeadSource default shsSelf;
    property CouplingMethod: TCouplingMethod read FCouplingMethod
      write SetCouplingMethod stored True;
    property MaxIterations: integer read FMaxIterations
      write SetMaxIterations default 20;
    property LgrPrintChoice: TLgrPrintChoice read FLgrPrintChoice
      write SetLgrPrintChoice default lpcListing;
    property HeadRelaxationFactor: double read FHeadRelaxationFactor
      write SetHeadRelaxationFactor;
    property FluxRelaxationFactor: double read FFluxRelaxationFactor
      write SetFluxRelaxationFactor;
    property HeadClosureCriterion: double read FHeadClosureCriterion
      write SetHeadClosureCriterion;
    property FluxClosureCriterion: double read FFluxClosureCriterion
      write SetFluxClosureCriterion;
  end;

  TChildModelEdit = class(TOrderedItem)
  private
    FModelName: string;
    FDiscretization: TChildDiscretizationCollection;
    FChildCellsPerParentCell: integer;
    { TODO -cRefactor : Consider replacing CModel with an interface. }
    //
    FChildModel: TBaseModel;
    FStartingHeadSource: TStartingHeadSource;
    FMaxIterations: integer;
    FLgrPrintChoice: TLgrPrintChoice;
    FFluxRelaxationFactor: double;
    FHeadRelaxationFactor: double;
    FFluxClosureCriterion: double;
    FHeadClosureCriterion: double;
    FCouplingMethod: TCouplingMethod;
    procedure SetDiscretization(const Value: TChildDiscretizationCollection);
    procedure SetModelName(const Value: string);
    procedure SetChildCellsPerParentCell(const Value: integer);
    procedure SetStartingHeadSource(const Value: TStartingHeadSource);
    procedure SetMaxIterations(const Value: integer);
    procedure SetLgrPrintChoice(const Value: TLgrPrintChoice);
    procedure SetFluxRelaxationFactor(const Value: double);
    procedure SetHeadRelaxationFactor(const Value: double);
    procedure SetFluxClosureCriterion(const Value: double);
    procedure SetHeadClosureCriterion(const Value: double);
    procedure SetCouplingMethod(const Value: TCouplingMethod);
  protected
    function IsSame(AnotherItem: TOrderedItem): boolean; override;
  public
    procedure Assign(Source: TPersistent); override;
    procedure AssignTo(Dest: TPersistent); override;
    Constructor Create(Collection: TCollection); override;
    destructor Destroy; override;
  published
    property ModelName: string read FModelName write SetModelName;
    property Discretization: TChildDiscretizationCollection
      read FDiscretization write SetDiscretization;
    property ChildCellsPerParentCell: integer read FChildCellsPerParentCell
      write SetChildCellsPerParentCell default 3;
    property StartingHeadSource: TStartingHeadSource read FStartingHeadSource
      write SetStartingHeadSource default shsSelf;
    property CouplingMethod: TCouplingMethod read FCouplingMethod
      write SetCouplingMethod stored True;
    property MaxIterations: integer read FMaxIterations
      write SetMaxIterations default 20;
    property LgrPrintChoice: TLgrPrintChoice read FLgrPrintChoice
      write SetLgrPrintChoice default lpcListing;
    property HeadRelaxationFactor: double read FHeadRelaxationFactor
      write SetHeadRelaxationFactor;
    property FluxRelaxationFactor: double read FFluxRelaxationFactor
      write SetFluxRelaxationFactor;
    property HeadClosureCriterion: double read FHeadClosureCriterion
      write SetHeadClosureCriterion;
    property FluxClosureCriterion: double read FFluxClosureCriterion
      write SetFluxClosureCriterion;
  end;

  TChildModelEditCollection = class(TOrderedCollection)
  private
    function GetItems(Index: integer): TChildModelEdit;
    procedure SetItems(Index: integer; const Value: TChildModelEdit);
  public
    constructor Create;
    property Items[Index: integer]: TChildModelEdit read GetItems
      write SetItems; default;
  end;

  TChildModelItem = class(TOrderedItem)
  private
    FChildModel: TChildModel;
    procedure SetChildModel(const Value: TChildModel);
  protected
    function IsSame(AnotherItem: TOrderedItem): boolean; override;
    procedure Loaded;
  public
    constructor Create(Collection: TCollection); override;
    Destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
  published
    property ChildModel : TChildModel read FChildModel write SetChildModel;
  end;

  TChildModelCollection = class(TOrderedCollection)
  private
    function GetItem(Index: integer): TChildModelItem;
    procedure SetItem(Index: integer; const Value: TChildModelItem);
    procedure UpdateUnitNumbers;
  public
    procedure Assign(Source: TPersistent); override;
    procedure Loaded;
    property Items[Index: integer]: TChildModelItem read GetItem
      write SetItem; default;
  published
    { TODO -cRefactor : Consider replacing Model with an interface. }
    //
    constructor Create(Model: IModelForTOrderedCollection);
  end;

  procedure EnableLighting;

  // @name generates a name for a data set that is valid
  // and does not conflict with the names of any existing data sets.
  function GenerateNewName( Root: string = '';
    InvalidNames: TStringList = nil; Connector: string = ''): string;

  {@name is used to generate a valid name from one that may be invalid.
  Valid names must begin with a letter or underscore.  The remaining
  characters must be letters, digits or the underscore character.}
  function GenerateNewRoot(const Root: string): string;

resourcestring
  StrGlobalVariables = 'Global Variables';
  StrPestParamaeters = 'PEST Parameters';
  rsLakeComment = 'All Lake cells are inactive: (' + rsLakeID + ' <> 0)';

const
  StrNotepadexe = 'Notepad.exe';

  StrModelName = 'ModelMuse';


  // version number of ModelMuse.
//  IModelVersion = '4.3.0.7';

  function IModelVersion: string;

  const
  StrPvalExt = '.pval';
  StrJtf = '.jtf';
  StandardLock : TDataLock = [dcName, dcType, dcOrientation, dcEvaluatedAt];
  StrHUF = 'HUF2';
  kTop = '_Top';
  StrZonebudget = 'ZoneBudget';
  StrZonebudgetMf6 = 'ZoneBudget 6';
  StrFhd = '.fhd';
  StrBhd = '.bhd';
  StrConc = '.conc';
  StrFdn = '.fdn';
  StrBdn = '.bdn';
  StrCbcExt = '.cbc';
  StrHuffhd = '.huf_fhd';
  StrHufbhd = '.huf_bhd';
  StrHufflow = '.huf_flow';
  StrSubOut = '.Sub_Out';
  StrSwtOut = '.Swt_Out';
  StrSubSubOut = '.SubSubOut';
  StrSubComMlOut = '.SubComMlOut';
  StrSubComIsOut = '.SubComIsOut';
  StrSubVdOut = '.SubVdOut';
  StrSubNdCritHeadOut = '.SubNdCritHeadOut';
  StrSubDCritHeadOut = '.SubDCritHeadOut';

  StrSubElasCompMLOut = '.SubElasCompMlOut';
  StrSubInelasCompMLOut = '.SubInelasCompMlOut';
  StrSubElasCompIBOut = '.SubElasCompIbOut';
  StrSubInlasCompIBOut = '.SubInelasCompIbOut';

  StrSwtSubOut = '.SwtSubOut';
  StrSwtComMLOut = '.SwtComMLOut';
  StrSwtComIsOut = '.SwtComIsOut';
  StrSwtVDOut = '.SwtVDOut';
  StrSwtPreConStrOut = '.SwtPreConStrOut';
  StrSwtDeltaPreConStrOu = '.SwtDeltaPreConStrOut';
  StrSwtGeoStatOut = '.SwtGeoStatOut';
  StrSwtDeltaGeoStatOut = '.SwtDeltaGeoStatOut';
  StrSwtEffStressOut = '.SwtEffStressOut';
  StrSwtDeltaEffStressOu = '.SwtDeltaEffStressOut';
  StrSwtVoidRatioOut = '.SwtVoidRatioOut';
  StrSwtThickCompSedOut = '.SwtThickCompSedOut';
  StrSwtLayerCentElevOut = '.SwtLayerCentElevOut';
  StrMt3dConcFile = '.ucn';
  StrMtName = '.mt_nam';
  strMtObs = '.mto';
  strZeta = '.zta';
  kSUTRAMeshTop = 'SUTRA_Mesh_Top';
  StrUzfRch = '.UzfRch';
  StrUzfDisch = '.UzfDisch';

  // CSUB output file extensions.
  StrCsubstrncsv = '.csub_strn.csv';
  StrCsubcrsstrncsv = '.csub_crs_strn.csv';
  StrCsubcmpct = '.csub_cmpct';
  StrCsubelstcmpct = '.csub_elst_cmpct';
  StrCsubinelstcmpct = '.csub_inelst_cmpct';
  StrCsubintrbdcmpct = '.csub_intrbd_cmpct';
  StrCsubcrscmpct = '.csub_crs_cmpct';
  StrCsubzdis = '.csub_z_dis';
  StrPtf = '.ptf';
  StrStage = '.stage';
  StrMawhead = '.maw_head';
  StrWatercontent = '.water_content';
  StrMawbud = '.maw_bud';
  StrMawbudCsv = '.maw_bud.csv';
  StrUzfbudget = '.uzf_budget';
  StrSfrbudget = '.sfr_budget';
  StrSftconc = '.sft_conc';
  StrSftbudget = '.sft_budget';
  StrMwtconc = '.mwt_conc';
  StrMwtbudget = '.mwt_budget';
  StrUztconc = '.uzt_conc';
  StrUztbudget = '.uzt_budget';


  MaxString12 = 12;
  MaxString20 = 20;
  MaxString255 = 255;

resourcestring
  StrTop = kTop;

resourcestring
  StrSUTRAMeshTop = kSUTRAMeshTop;
  StrSUTRASpecifiedPres = 'SUTRA Specified Pressure';
  StrSUTRASpecifiedConcTemp = 'SUTRA Specified Concentration or Temperature';
  StrSutraFluidFlux = 'SUTRA Fluid Flux';
  StrMassEnergyFlux = 'SUTRA Mass or Energy Flux';
  StrMultiplierWarning = 'Multiplier <> 1 when UZF or LAK packages used.';
  StrMultiplierFullWarning = 'When using the UZF or LAK packages, it is '
    + 'usually best to set the time step multiplier to 1.';
  StrSutraGeneralizedFlow = 'SUTRA Generalized Flow';
  StrSutraGeneralizedTransport = 'SUTRA Generalized Transport';

  // captions for SFR in MF6.
  StrStatusMf6 = 'Status';
  StrInflowMf6L3 = 'Inflow (L^3/T)';
  StrRainfallMf6L = 'Rainfall (L/T)';
  StrEvaporationMf6L = 'Evaporation (L/T)';
  StrRunoffMf6L3 = 'Runoff (L^3/T)';
  StrUpstreamFractionMf6 = 'Upstream fraction';
  StrDownstreamSegmentsMf6 = 'Downstream Segments (ic)';
  StrStageMf6 = 'Stage';
  StrRoughnessMf6 = 'Roughness';
  StrPriorityCprior = 'Priority (cprior)';
  StrSolutionGroupName = 'Groundwater';

implementation

uses Dialogs, OpenGL12x, Math, frmGoPhastUnit, UndoItems,
  frmColorsUnit, GIS_Functions, ModflowDrtUnit, CustomModflowWriterUnit,
  ModflowDiscretizationWriterUnit, ModflowBasicWriterUnit,
  ModflowMultiplierZoneWriterUnit, ModflowCHD_WriterUnit, ModflowPCG_WriterUnit,
  ModflowGHB_WriterUnit, ModflowWellWriterUnit, ModflowRiverWriterUnit,
  ModflowDRN_WriterUnit, ModflowDRT_WriterUnit, ModflowRCH_WriterUnit,
  ModflowEVT_WriterUnit, ModflowETS_WriterUnit, ModflowRES_WriterUnit,
  IntListUnit, ModflowLAK_Writer, ModflowLPF_WriterUnit,
  ModelMuseUtilities, frmFormulaErrorsUnit,
  ModflowSfrWriterUnit, ModflowSfrUnit,
  ModflowSfrFlows, ModflowSfrChannelUnit,
  ModflowUzfWriterUnit, ModflowGMG_WriterUnit,
  ModflowSIP_WriterUnit, ModflowDE4_WriterUnit, ModflowOC_Writer,
  ModflowGAG_WriterUnit, ModflowHOB_WriterUnit,
  ModflowHFB_WriterUnit, frmProgressUnit, ModpathStartingLocationsWriter,
  ModpathMainFileWriterUnit, ModpathTimeFileWriterUnit,
  ModpathResponseFileWriterUnit, ModpathNameFileWriterUnit, Clipbrd,
  GlobalTypesUnit, DependentsUnit,
  frmErrorsAndWarningsUnit,
  ModflowHUF_WriterUnit, ModflowKDEP_WriterUnit, ModflowLVDA_WriterUnit,
  ModflowMNW2_WriterUnit, ModflowBCF_WriterUnit, ModflowSubsidenceDefUnit,
  ModflowSUB_Writer, ZoneBudgetWriterUnit, MODFLOW_SwtWriterUnit,
  ModflowHydmodWriterUnit, IniFileUtilities,
  ModflowLakUnit, ModflowLgr_WriterUnit, ModflowNWT_WriterUnit,
  ModflowUPW_WriterUnit, frmCustomGoPhastUnit, ModflowSfrParamIcalcUnit,
  BigCanvasMethods, Mt3dmsBtnWriterUnit, Mt3dmsAdvWriterUnit,
  Mt3dmsDspWriterUnit, Mt3dmsSsmWriterUnit, Mt3dmsRctWriterUnit,
  Mt3dmsGcgWriterUnit, Mt3dmsTobWriterUnit, ModflowMt3dmsLinkWriterUnit,
  ModflowPCGN_WriterUnit,
  SutraBoundaryWriterUnit, QuadtreeClass, frmMeshInformationUnit,
  ModflowStrWriterUnit, ModflowFhbWriterUnit,
  ModflowFmpWriterUnit, ModflowCfpWriterUnit, ModflowSwiWriterUnit,
  ModflowSwrWriterUnit, ModflowMnw1Writer,
  FootprintBoundary, FootprintFileUnit, ModflowFhbUnit,
  Modflow2015StartingHeadsWriterUnit, ModflowNPF_WriterUnit,
  ModflowStoWriterUnit, ModflowSmsWriterUnit, ModflowTDisWriterUnit,
  JupiterUnit, PestGridSpecificationWriter, ModflowRipWriterUnit,
  Xml.VerySimple, System.IOUtils, ArchiveNodeUnit, ArchiveNodeInterface,
  ArchiveSaveUnit, GeoRefWriterUnit, ExtensionTypeUnit,
  SutraGeneralFlowWriterUnit, SutraGeneralFlowNodesUnit,
  SutraBoundaryDisplayUnit, SutraGeneralTransportWriterUnit,
  Mt3dUztWriterUnit, ModflowSfr6WriterUnit,
  ModflowMawWriterUnit, ModflowGncWriterUnit, Modflow6ObsWriterUnit,
  ModpathGridMetaDataWriterUnit, ModflowLakMf6WriterUnit,
  ModflowMvrWriterUnit, ModflowUzfMf6WriterUnit, ModflowHfbUnit,
  Mt3dLktWriterUnit, ModflowSfr6Unit, Mt3dSftWriterUnit, ModflowStrUnit,
  Mt3dCtsWriterUnit, ModflowCSubWriterUnit, PestGlobalComparisonScriptWriterUnit,
  ModflowMnw2Unit, PestObsExtractorInputWriterUnit, Modflow6ObsUnit,
  PestControlFileWriterUnit, ModflowInitialConcentrationWriterUnit,
  ModflowDspWriterUnit, ModflowGwtAdvWriterUnit, ModflowGwtSsmWriterUnit,
  ModflowMstWriterUnit, ModflowIstWriterUnit, ModflowCncWriterUnit,
  ModflowGwfGwtExchangeWriterUnit, ModflowFMI_WriterUnit, ModflowFmp4WriterUnit,
  ModflowTimeInterfaceUnit, Modflow6TimeSeriesUnit,
  LockedGlobalVariableChangers, ModflowBuoyancyWriterUnit,
  ModflowViscosityWriterUnit, ModflowMvrUnit, ModflowCndWriterUnit,
  ModflowEstWriterUnit;




const
  StatFlagStrings : array[Low(TStatFlag)..High(TStatFlag)] of string
    = ('VAR', 'SD', 'CV', 'WT', 'SQRWT');
const
  UcodeDelimiter = '@';
  StrMeshElementSize = 'Mesh Element Size';

// '0.5.0.0' is release candidate 1.
// '0.6.0.0' is release candidate 2.
// '1.0.0.0' is initial release version.
// '1.0.1.0' fixed bug that caused access violations if a formula was
//    invalid such as '1 2'.
//    Fixed bug that caused access violations if all the vertices in a
//    contour were deleted when it was first created.
//    Changed the hint in the Working area depending on the selected tool.
// '1.0.2.0' Fixed bug that caused access violations if the user changed
//    an object so that it no longer affected a data set and then tried
//    to edit the object again.
//    Fixed bug that would cause access violations if a new model was started
//    while frmShowHideObjects was visible.
//    Fixed bug that allowed the undo and redo menu items and buttons to
//    remain enabled when starting a new model.
// '1'0.3.0' Fixed the "ObjectIntersectArea" and "ObjectIntersectLength"
//    functions.
// '1'0.4.0' Fixed bug that caused access violations if the user edited
//    the data sets that an object affected and then tried to undo
//    those changes.
//    Fixed bug in reading character fields from Shapefiles.
// '1.0.5.0' Fixed bug that caused object intersections to be evaluated
//    incorrectly if the object was evaluated at nodes.  Fixed bug that
//    could cause access violations when deleting objects.
//    Updated memory manager.
// '1.0.6.0' Fixed bug that caused access violations when closing GoPhast
//    if a dataset had been deleted and then restored. Fixed bug that caused
//    certain formulas to be 'decompiled' incorrectly.
// '1.0.7.0' Fixed bug that caused access violations when editing objects
//    that specified boundary conditions via PHAST-style interpolation.
// '1.0.8.0' Fixed "ObjectIntersectArea" function.
//    Fixed bug in interpolation.
// '1.0.9.0' Fixed bug that prevented adding new wells.
// '1.0.10.0' Final beta version of ModelMuse.
// '2.0.0.0' First release of ModelMuse: Added support for MODFLOW-2005
//    and MODPATH.
// '2.0.0.1' Fixed problem with backwards particle tracking in MODPATH.
//    Automatically updates formulas when the names of data sets and
//    global variables are changed.
// '2.0.0.2' Fixed bug in exporting "Factor" in flow observations.
// '2.0.0.3' Fixed bug that allowed a global variable to have the
//    same name as a TDataArray.
//    Added ability to specify additions to the batch files that run
//    MODFLOW or PHAST.
// '2.0.0.4' Fixed bug exporting LAYWET. Added export of HUF package.
// '2.0.0.5' Fixed bug (introduced in 2.0.0.1) in freeing TScreenObject.
// '2.0.0.6' Added support for a new way of selecting objects for editing.
//    Added support for importing calculated heads for HUF units.
// '2.0.0.7' Fixed bug importing multiplier and zone arrays when "none" or
//    'all" are not in upper case letters.
//    Added support for importing flow files from HUF.
//  '2.0.0.8' Fixed bug: when pasting an TScreenObject from the clipboard,
//    imported values were not pasted too.
//    Fixed bug in Nearest Point interpolation method.
//    Fixed bugs in importing DRN, DRT, and UZF packages.
//    In Show/Hide Objects dialog box, the selected objects are displayed in
//    a bold font.
//    New Data Set Values dialog box.
//    Improved speed of Nearest Point method when point objects are used.
//    Imported flow observations
//  '2.0.0.9' Fixed bug importing elevations formulas when importing
//    Shapefiles.
//  '2.0.0.10' Fixed bug importing gridded data with rotated grid.
//    Improved speed of some interpolation methods. Modified the Rearrange
//    Objects dialog box to allow it to show only the visible or only the
//    selected objects.
//  '2.0.0.11' worked on speeding up importing Shapefiles.
//  '2.0.0.12' Fixed bugs in managing subscriptions.
//  '2.0.0.13' Reduced memory usage.
//  '2.0.0.14' Fixed bug importing Shapefile.
//    Improved display of frmShowHideObjects.
//  '2.0.0.15' Fixed bug reading existing files.
//  '2.0.0.16' Fixed bug determining stress periods.
//  '2.0.0.17' Added capability to export objects as Shapefiles.
//    Added the ability to delete images that have been imported.
//    Deleting all the points in an object in the
//    Object Properties dialog box now results in the object being deleted.
//    When exporting boundary conditions, there is now a warning
//    if no cells are defined.
//    Grid Values dialog box updated to show grid cell dimensions.
//    Transient data after the end of the
//    last defined stress period is now ignored.
//  '2.0.0.18' Fixed problems with exporting Shapefiles.
//    Observations outside the defined model times are no longer exported.
//  '2.0.0.19' Improved export of objects to Shapefiles.
//    Holding down the Shift key when releasing the mouse while creating
//    objects of moving nodes of objects now causes the new or moved vertex
//    to "snap" to the location of a nearby node of another object if it
//    is within 3 pixels of the cursor location.
//  '2.0.0.20' Fixed bug in contouring data.
//    Fixed bug in selecting CHD package
//    (couldn't specify comments for the CHD package even if it was selected.)
//  '2.0.0.21' Added shortcut for displaying the Show/Hide objects dialog
//    box.
//    Fixed bug in reducing the number of items for a MODFLOW boundary
//    condition.
//  '2.0.0.22' Better names for objects when importing model results.
//  '2.0.0.23' When snapping to points is activated, the cursor changes
//    when it is in the vicinity of a point on a different ob
//  '2.0.0.24' Changed the way MODFLOW wells are exported so that if an
//    object has multiple sections in the same cell,
//    the exported pumping rate is the sum of the pumping rate for each
//    section.
//  '2.0.0.25' Fixed bug coloring the grid with parameters
//    after modifying the grid.
//    Fixed bugs in export of MODPATH files.
//  '2.0.0.26' Fixed bug importing points; a blank file name
//    is no longer added to the files to archive.
//  '2.1.0.0' Fixed bug importing EVT, ETS, and RCH packages
//    when parameters were used.
//    Added Save and Clear buttons to Errors and Warnings dialog box.
//    Fixed bug in export of WETDRY in HUF.
//    Fixed bug in export of FACTOR in imported flow observations.
//  '2.1.1.0' Fixed bug importing WETDRY in LPF.
//    Fixed bug setting elevations of objects when importing
//    EVT and ETS packages.
//    Fixed bug importing SFR.
//    Fixed bug importing DIS.
//  '2.1.1.1' Fixed bug in which models that used parameters but not zones
//    were not imported correctly.
//  '2.1.1.2' Changed the way that CHD, DRN, DRT, GHB, and WEL are exported.
//    Now each section of an object will represent a different boundary cell
//    if two or more sections are in the same cell.
//    Fixed bug in TframeSfrParamInstances that prevented some valid
//    parameter instance names from being accepted.
//    Fixed bug in TframeSfrParamInstances that prevented the Delete
//    and insert buttons from being visible.
//  '2.1.1.3' Improved handling of pasting vertex data in the
//    Object Properties form.
//    Fixed bug that sometimes prevented data set comments from being
//    edited properly.
//    Added support for new options in MODFLOW-2005 version 1.7.
//      Added support for Gage type 4 for Lakes in the Gage package.
//      Added support for Gage type 8 for SFR streams in the Gage package.
//      Added support for SURFDEPTH in Lake package.
//    New functionality in the MODFLOW Name File dialog box.  If the input
//    for a package is listed in the Name File dialog box, the input file
//    for that package will not be generated by ModelMuse.  See the help
//    for the MODFLOW Name File dialog box for full details.
//  '2.1.1.4' Fixed saving data for HUF package. This bug was not present in
//    version '2.1.1.0'.
//    Reduced memory usage.
//  '2.1.1.5' Fixed bug that caused non parameter data to appear in the
//    Object Properties dialog box for objects that did not have
//    non-parameter data.  The bug occurred if a previous object which
//    did have non-parameter data was edited first.
//    Fixed bug that caused ModelMuse to hang if there was an error
//    in a data set formula.
//  '2.1.1.6' Added support for MNW2 and MNWI packages.
//    Added new filters for coloring and contouring "Active only" and
//    "Values to Ignore".
//    Added import of ITT when importing head observations from Shapefiles.
//    Fixed bug importing UZF gages.
//    Fixed bug in setting head observation names.  Spaces and quotes are removed.
//  '2.1.1.7' Worked on reading pathlines from MODPATH.
//    Fixed bug that caused COFF to be exported incorrectly if an observation
//    was exactly on a column boundary.
//    Fixed bug in which the display of head observations was not changed
//    when a TScreenObject was moved.
//    Fixed bug that caused head observations imported from an existing
//    MODFLOW model to be imported with the elevation from the wrong cell if
//    ROFF = -0.5 or COFF = 0.5.
//    Fixed bug that could cause access violations when contouring 2D data
//    sets if the selected layer (or row or column) was not the first layer
//    (or row or column).
//    Added import of parameter names when importing RCH from a Shapefile.
//  '2.1.1.8' Added import of parameter names when importing CHD, DRN, DRT,
//    ETS, EVT, GHB, RIV, or WEL from a Shapefile.
//    Fixed bug exporting flow observations when the formula for Factor
//    is complex.
//  '2.1.1.9' Added support for displaying pathlines from MODPATH.
//  '2.1.1.10' Fixed bug that caused too much memory to be used when
//    exporting ETS package.
//  '2.1.1.11' Fixed bug that caused problems editing ETS data for
//    objects.
//    Added support for displaying endpoints from MODPATH.
//  '2.2.0.0' Added support for displaying time-series data from MODPATH.
//    Added support for multiple vertical screens in MNW2.
//    Multiplier and Zone arrays for transient data are tested to see if
//    they are identical to a previous Multiplier or Zone array
//    for transient data. If so, the previous array is reused.  This
//    saves memory in MODFLOW.
//    Fixed bug exporting gridded data to Shapefile.  Duplicate fieldnames
//    are no longer created.
//    Fixed access violation bug in closing TfrmImportGriddedData.
//    When importing points, empty lines
//    and lines starting with "#" are skipped.
//    Ruler settings are now saved with the file.
//    Changed "Select Objects of Editing" dialog box to
//    "Select Objects of Editing or Deletion" dialog box
//    along with a change in functionality to allow objects to be
//    deleted with this dialog box.
//  '2.2.1.0' Fixed bug that prevented RunPhast.bat from executing
//    correctly when it was executed by ModelMuse.
//  '2.2.1.1' When importing model results, heads and drawdowns equal to
//      HDRY and HNOFLO are not used in assigning the minimum and maximum
//      values for the array.
//    In Data Set Values dialog box, the layers are now in a list on the left.
//    Fixed bug that caused the HFB and UZF packages to become
//      deselected whenever the selected flow package was switched.
//    Fixed bug that caused the number of wetting iterations could be saved
//      as zero incorrectly if it should have been a 1.
//      However, MODFLOW would change it back to 1 so it would not affect
//      model computations.
//    Added support for BCF package.
//    When the HUF package is selected, optional data sets will be created
//      that display hydraulic properties that result from applying the
//      HUF parameters to the model.
//    Added support of importing the MNWI package from an existing model.
//    Fixed bug exporting HUF files in which storage parameters were exported
//      in steady-state models.
//  '2.2.1.2' Fixed bug in LPF and HUF package export in which there could
//      be no space between a multiplier array name and a zone array name.
//    Fixed bug in HUF package in which zone and multiplier arrays were not
//      written.
//    Fixed bugs that could cause access violation when opening a new model
//      after having edited objects in the currently opened model.
//  '2.2.1.3' Fixed bug that kept the videos from being played automatically.
//    Added a check of the fractional depth and fractional rates in the ETS
//      package.
//    Fixed bug that caused an error when certain functions were used to
//      assign values to data sets.
//    Improved speed.
//    Fixed bug that caused errors creating temporary files if more than
//      one model was being run at one time.
//    Fixed bug getting temp file names.
//  '2.2.1.4' Added warning when an input file specified in the
//      MODFLOW Name File dialog box does not exist.
//    Files specified in the MODFLOW Name File dialog box are now
//      included in the archive.
//    Fixed export of Shapefiles.
//  '2.2.1.5' The mouse wheel can now be used to zoom in or out in the
//      top, front, or side views of the model.
//    Fixed bug importing ModelMate file.
//    Added support for the SUB package.
//    Fixed bug deleting the last Layer group in a model.
//    Added support for importing binary files generated by the SUB package.
//    Added support for importing the SUB package
//      from existing MODFLOW models.
//    Fixed bug in getting the formula from the Formula Editor.
//  '2.2.1.6' Fixed bug importing models that contain the HUF package when a
//      zone array was not used with a parameter.
//    Fixed bug that allowed invalid formulas to be set for
//      the Z elevation formulas for an object.
//    Fixed bug with access violations when checking the internet.
//    Disabled MODPATH export for PHAST models.
//  '2.2.1.7' Assigned default names to new systems of delay and no-delay beds.
//    Fixed bug in evaluating formulas that contain "ActiveOnLayer" for
//      Z-coordinates
//  '2.2.1.8' When updating ModelMate files, if an observation
//      or prediction group has no associated observations or predictions,
//      and the user has elected to delete unused observations or predictions,
//      the unused observation or prediction groups are deleted too.
//    When importing model results and updating existing data for the results
//      duplicate copies of HDRY and HNOFLO are no longer added to the
//      values to skip.
//    Improved error messages for functions that retrieve imported data.
//    Fixed bug getting names of new temporary files.
//    Fixed bugs in exporting ModelMate files.
//  '2.2.1.9' Added info on associated model input data sets for SUB package.
//    Added support for importing Surfer Grid files.
//  '2.2.1.10' Attempted to fix problem with access violations when
//      accessing the file menu.
//  '2.2.1.11' Added support for Surfer ASCII grid files.
//  '2.2.1.12' Fixed bug with not conserving memory properly in EVT.
//  '2.2.1.13' Worked on conserving memory.
//  '2.2.1.14' Worked on conserving memory. Fixed bug that caused
//      access violations when undoing the setting of a boundary condition.
//  '2.3.0.0' Fixed bug that could cause layer elevations to be set
//      incorrectly after changing the layer structure.
//    Fixed bug that could cause access violation when deleting a data set.
//  '2.3.0.1' Bug fix: Corrected name of the
//      "Select Objects for Editing or Deletion."
//    Enhancement: Added warning messages in export of the
//      MODPATH input files if the required MODFLOW input or
//      output files are missing.
//    Bug fix: when deleting data sets, check that all data set formulas
//      are still OK.
//    Bug fix: the text on the status panel is no longer truncated
//      when it is over 110 characters in length.
//    Bug fix: fixed access violation when closing with the Color Grid
//      or Contour data dialog boxes open.
//    Bug fix: fixed import of rate data in the UZF package when some
//      rates are reused and others are not reused.
//    Change: Boundary condition times prior to the beginning of the first
//      defined boundary condition are now ignored.
//  '2.3.0.2' Enhancement: Added support for sampling DEM files.
//    Bug fix: Fixed access violations that occurred when closing
//      ModelMuse after deleting a data set.
//    Change: When importing character attributes of Shapefiles,
//      blank characters at the beginning or end will be removed.
//    Bug fix: The row width is now displayed correctly on the Grid Values
//      dialog box.
//    Bug fix: When the first time defined in the MODFLOW Time dialog box
//      is after the first time defined in an object, values were not
//      assigned properly. (Bug introduced in version 2.3.0.1.)
//  '2.3.0.3' Change: added pumping rate comment for wells. This can
//      be helpful when using PEST.
//  '2.3.0.4' Bug fix: If attempting to draw a bitmap results in an
//       out-of-resources error, drawing the bitmap will be skipped.
//     Change: menu item caption switches between "Show 2-D Grid"
//       and "Hide 2-D Grid" depending on whether or not the grid lines
//       are visible.
//     Bug fix: Various controls on the Color Grid and
//       Contour Grid dialog boxes now changes position appropriately
//       if the dialog box is changed in size.
//     Bug fix: The beginning and ending times for MODPATH can now be
//       set to non-integer values.
//     Bug fix: The name of a multiplier array would not be exported
//       correctly if it was used in one of the HUF package input files
//       but that input file was not being created by ModelMuse.
//  '2.3.0.5' Change: if a bitmap can not be displayed, it will be hidden
//       and then must be shown again manually after decreasing the
//       magnification.
//     Bug fix: fixed "List index out of bounds" error when deleting
//       a data set.
//     Bug fix: If every cell has gone dry, there is no longer an
//       "List index out of bounds" error when attempting to import
//       the model results.
//     Enhancement: It is now possible to paste multiple data set names in
//       the table on the Data tab of the Import Shapefile dialog box.
//  '2.3.0.6' Bug fix: The labels for the various Z-coordinate formulas
//       in the Import Shapefile dialog box are now enabled when appropriate.
//  '2.3.0.7' - '2.3.0.9' Bug fix: Fixed bug that prevented
//       the Packages and Programs dialog box from being displayed
//       on some computers.
//     Bug fix: Fixed bug that caused an Assertion error when
//       attempting to show the "Select Objects By Name" dialog box
//       in a model that had no objects.
//  '2.3.0.10' Enhancement: The Grid Value dialog box has been changed to
//       display the name of the selected object and to show its 3'rd
//       dimension coordinates for those cells intersected or enclosed
//       by the object.
//  '2.3.0.11' Enhancement: Improved speed of importing data.
//  '2.3.0.12' Bug fix: Saving the ModelMuse file with a new file name now
//       results in the default name for the model input files being
//       changed as well.
//     Bug fix: When importing Shapefiles, if the feature that is being
//       imported must be imported as separate objects, the Import Shapefile
//       dialog box no longer allows them to be combined.
//     Bug fix: When flow observations were used the GHB, DRN, RIV, and CHD
//       packages were not always exported correctly.
//   '2.3.0.13' - '2.3.0.17' Reduced disk usage.
//   '2.3.0.18' Enhancement: Improved speed.
//   '2.3.0.19' Bug fix: fixed bug introduced in '2.3.0.18'.
//   '2.3.0.20' Bug fix: Fixed display of the recharge, EVT, and ETS layers
//       when no parameters were defined.
//     Bug fix: The SFR package input could be generated incorrectly if an
//       object that was supposed to define a stream segment did not
//       intersect the grid.
//   '2.3.0.21' Bug fix: Fixed display of RCH, EVT, and ETS rates when
//       parameters are first defined.
//     Bug fix: Fixed when certain controls related to MODPATH become
//       enabled.
//     Bug fix: There no longer is an access violation if you attempt to
//       create a new model while in the midst of creating a new object.
//     Bug fix: Fixed calculation of HUF_Kx.
//     Bug fix: Fixed export of Reference time in the MODPATH response file.
//   '2.3.0.22' Enhancement: When the MODFLOW Hydrogeologic Units dialog box
//       is closed, it now checks that at least one parameter
//       has been associated with each hydrogeologic unit and that
//       each parameter is associated with at least one hydrogeologic unit.
//     Enhancement: The thickness of HUF units is now constrained to be
//       greater than or equal to zero.
//     Bug fix: Access violations no longer occur when creating a new
//       object after having closed a previous model and starting
//       a new model.
//     Bug fix: fixed export of BeginPeriod and BeginStep.  They must both
//       be set to 1 if any stress period in the model is a steady-state
//       stress period.
//   '2.3.0.23' Bug fix: Fixed Assertion error in evaluation of MNW2 input.
//     Enhancement: Added error message if a MODPATH particle start time was
//       invalid.
//     Bug fix: Fixed import of the RES package from existing models.
//     Enhancement: Added Epsilon when specifying data values to skip.
//     Bug fix: Fixed display of UZF transient data sets.
//     Bug fix: Fixed deletion of vertices in an object when all but one
//       vertices are deleted.
//     Bug fix: Fixed default file names for the MODFLOW name file
//       and for the default output files when the file name has a space
//       in it.
//     Bug fix: Fixed display of MODPATH particle release times.
//     Bug fix: Fixed assignment of color to MODPATH pathlines.
//     Bug fix: Fixed crash when entering multiple times for flow
//       observations.
//     Change: Statistic and Stat-Flag are no longer visible for head
//       observations unless ModelMate interface has been activated.
//     Bug fix: When attempting to import an incomplete Shapefile,
//       ModelMuse now exits the procedure properly.
//     Enhancement: When importing head observations, if the ModelMate
//       interface is active, Statistic and StatFlag are imported too.
//   '2.3.0.24' Bug fix.  Entering a real number for the recharge layer
//       no longer causes ModelMuse to hang. Instead an error message is
//       displayed.
//   '2.3.0.25' Bug fix: If wetting is active but there are no
//       convertible layers a warning is displayed.
//     Bug fix: If wetting is active but there are no
//       convertible layers data set 7 is no longer created in the LPF
//       package and data set 4 is no longer created in the HUF package.
//     Bug fix: When the ET Surface and the ET Depth are undefined
//       in the EVT or ETS packages, an error message is displayed instead of
//       the export failing.
//     Bug fix: Editing an object containing SFR data no longer results in
//       an access violation if the SFR package is not selected.
//     Bug fix: Editing an object that defines data for the SFR, MNW2, HOB
//       or HFB packages no longer results in deletion of data for those
//       packages when those packages are not selected.
//     Bug fix: In the Object Properties dialog box, clicking the
//       "Edit F()..." button on the Data Sets tab would cause
//       an Assertion error when no data set was selected.  The button
//       is now disabled when no data set is selected.
//   '2.3.0.26' Bug fix: When performing coordinate conversions on Shapefiles,
//       you can no longer select a UTM zone until you have chosen to
//       perform the conversion.
//     Enhancement: In the Show or Hide Objects dialog box, any collapsed
//       branch that contains a selected object is shown with a bold font.
//     Bug fix: Fixed access violations when opening a model when a model is
//       already open.
//     Enhancement: If additional vertices are added to an object that
//       defines head observations, an error message is displayed when
//       attempting to export the HOB input file or plot HOB data on the
//       grid.
//     Bug fix: If the flow package corresponding to a flow observation
//       is not selected in the object properties dialog box, attempting
//       to select the flow observation will no longer cause toggling
//       of the selected node.
//     Bug fix: After selecting the item with with to color the grid in
//       the Color Grid dialog box, you can click directly on the Apply
//       button without clicking elsewhere first.
//     Enhancement: When defining a new global variable, default values for
//       the type and value are displayed in the Global Variables dialog box.
//     Enhancement: Bitmaps that were hidden because the magnification was
//       too high, are now displayed again automatically when the
//       magnification is sufficiently reduced.
//     Enhancement: Added new function for use in formulas - PositionInList.
//     Enhancement: Objects now have a comment field that can be used to
//       document what the object does.
//     Enhancement: The Grid Spacing dialog box now allows negative numbers
//       for the default spacing for columns, rows, and layers.  In MODFLOW
//       models, the default spacing for rows is set to -100 instead of 100.
//     Enhancement: When tips are turned off, ModelMuse will tell you when it
//       detects new videos on the ModelMuse web site.
//     Bug Fix: Editing an object that defines an SFR stream with unsaturated
//       properties defined no longer causes an assertion failure if the
//       object is edited again.
//     Bug fix: Importing a model no longer causes an access violation
//       when the previous model had objects that defined an SFR stream
//       with unsaturated properties.
//   '2.4.0.0' No additional changes.
//   '2.4.0.1' Enhancement: It is now possible to copy and paste multiple
//       cells in the parameter grids in the Packages and Programs dialog box.
//     Enhancement: The helpfile has increased functionality.
//     Enhancement: Support for ZONEBUDGET added.
//   '2.4.0.2' Bug fix: The number of observations in the Flow observations
//       packages was calculated incorrectly when both observation and
//       predictions were used.
//   '2.4.0.3' Bug fix: FractionOfObjectLength was calculated incorrectly
//       if an object had more than one section.
//     Enhancement: Added new function InterpolatedVertexValues that allows
//       numeric values associated with individual vertices to be interpolated
//       along the length of the object.
//   '2.4.0.4' Bug fix: ObjectLength was calculated incorrectly if an
//       object had more than one section.
//     Bug fix: ObjectVertexDistance was calculated incorrectly if an
//       object had more than one section.
//     Enhancement: Antialiasing used to improve appearance.
//     Bug fix: Importing a MODFLOW-2005 model failed if LAYVKA in the
//       LPF package was anything besides a zero or one.
//     Bug fix: If there VKA is less than or equal to zero
//       but there is only one layer, ModelMuse no longer reports
//       and error while exporting the LPF package.
//     Bug fix: Unchecking the MODPATH initial particle placement checkbox
//       didn't work.
//     Bug fix: Editing more than one object at a time
//       could result in an assertion failure.
//     Enhancement: When coloring grid only on the active areas, inactive
//       areas are shaded.
//     Enhancement: Additional options for displaying grid lines have been
//       added. It is now possible to show just the outline of the active
//       area or just the grid lines inside the active area.
//   '2.4.0.5' Bug fix; Sample DEM imported data at the wrong
//       locations if the grid angle was not zero.
//   '2.4.0.6' Enhancement: Legends have been added to the Color Grid and
//       Contour Data dialog boxes.
//     Enhancement: Added three new functions ColumnCenter, RowCenter,
//       and LayerCenter.  See help for details.
//   '2.4.0.7' Bug fix: When deleting time-varying data from objects
//       for the RCH, EVT, or ETS packages, sometimes not all the data
//       would be deleted properly.
//     Bug fix: In the LPF package, LAYTYP was not set to a negative
//       value properly when the THICKSTRT option was used.
//   '2.4.0.8' No change
//   '2.4.0.9' Fixed bug editing LPF parameters that could cause an
//       assertion failure.
//   '2.4.0.10' Enhancement: The Export Image dialog box has been added.
//       It allows the user to export an image of the top, front, or
//       side view of the model as an Enhanced Windows Metafile.
//     Enhancement: When a formula results in a value that is infinite or
//       not a number, the maximum double-precision real number is
//       substituted for it.
//   '2.4.0.11' Bug fix for Export Image dialog box.
//   '2.4.0.12' Bug fix: Under certain circumstances extra LPF parameters
//       would be added incorrectly.
//   '2.4.0.13' Bug fix: Attempting to open a model containing a UZF gage
//       caused an access violation.
//   '2.4.0.14' Bug fix: Transient UZF data were not displayed properly.
//       This was not a bug in the released version.
//     Bug fix: If the user edited something in the MODFLOW Packages
//       and Programs dialog box that caused the grid to be recolored,
//       the MODFLOW Packages and Programs dialog box might not close
//       properly. This was not a bug in the released version.
//   '2.4.0.15' Bug fix: closing the model while the Color Grid or
//       Contour Data dialog boxes were visible could result in an
//       access violation.
//       This was not a bug in the released version.
//   '2.4.0.16' Change: Changed default options for ZONEBUDGET.
//   '2.4.0.17' Bug fix: ModelMuse could not always read the budget file
//       if there was only one column in the model.
//   '2.4.0.18' Enhancement: Enabled MadExcept.
//   '2.4.0.19' Second attempt at enabling MadExcept.
//   '2.4.0.20' Bug fix: If a parameter or layer group was renamed, formulas
//       that used data sets related to those parameters were not updated
//       properly.
//   '2.4.0.21' Bug fix: Using the up-down controls on the Color Grid or
//       Contour Data dialog boxes would cause selected data set
//       to change when clicking on another control until the
//       dialog box was closed.
//     Bug fix: When importing MODFLOW models that contained the lake package
//       the Lake_ID data set was not being set properly.
//     Bug fix: Fixed bug that caused access violations when closing a model.
//     Enhancement: Improved speed of opening Object Properties dialog box.
//   '2.4.0.22' Bug fix: Failure to define unsaturated flow properties
//       in the SFR package when they are required now results
//       in an error message instead of an assertion failure.
//     Bug fix: Added support for contour legends with
//       boolean and string data.
//   '2.4.0.23' - '2.4.0.24' Bug fix: Attempted to work around problem
//       that causes range check errors when closing ModelMuse
//       on some machines.
//   '2.4.0.25' Change: Data set values are now saved to file
//       with the data set if the data set values are up to date.
//       This improves the speed of opening some large models.
//   '2.4.0.26' Bug fix: Fixed bug that could cause an access violation
//       when showing the MODFLOW Packages and Programs dialog
//       box if one of the packages in the dialog box had been deactivated
//       and then the cancel button was pressed.
//     Bug fix: Fixed bug that could cause extra parameters to be added
//       when a parameter value was edited.
//     Enhancement: When selecting a MODPATH output file, the most likely
//       name of the output file is selected automatically.
//   '2.5.0.0' No additional changes.
//   '2.5.0.1'  Change: The "Object|Edit|Merge Objects" command now operates when
//       very small differences exist between the endpoints of the objects
//       being merged. Previously, the match had to be exact.
//     Enhancement: In the Object Properties dialog box, if you paste
//       a group of vertices, the table will expand to accommodate the
//       new vertices.
//   '2.5.0.2' Bug fix: Editing an object in a new model after having
//       previously closed a previous model without restarting ModelMuse
//       caused an Assertion failure.
//     Bug fix: Eliminated an assertion failure that occurred under certain
//       circumstances when attempting to draw an object.
//   '2.5.0.3' Bug fix: Eliminated Range Check Error that sometimes
//       occurred when a menu item was selected.
//   '2.5.0.4' Bug fix: Fixed bugs in deleting all print/save choices in the
//       Subsidence package.
//     Bug fix: Fixed layout of Subsidence package controls in
//       MODFLOW Packages and Programs dialog box.
//     Bug fix: The Formula Editor was displaying the ActiveOnLayer function
//       in cases where it wouldn't work.
//     Bug fix: The ActiveOnLayer function sometimes returned
//       an incorrect value.
//   '2.5.0.5' Bug fix: When closing a model, a stack overflow could occur
//       under unusual circumstances.
//   '2.5.0.6' Bug fix: If "Boundary Conditions, Observations,
//       and Other Features" was selected in the "Color Grid" dialog box,
//       an access violation could occur.
//     Bug fix: Fixed problem that sometimes prevented the discretization
//       from begin specified.
//     Enhancement: Added support for SWT package.
//     Bug fix: Export of format codes in SUB package was incorrect.
//     Bug fix: Format codes in SUB package imported incorrectly.
//     Enhancement: Added support for HYDMOD package.
//     Bug fix: When more than one object was being edited in the
//       Object Properties dialog box, switching to the SFR|Network tab and
//       clicking the button under OUTSET and IUPSEG would cause an
//       Assertion failure. Now it gives a more meaningful error message.
//   '2.5.0.7' Bug fix: Changing the discretization when the grid was
//        colored with transient data caused an access violation.
//   '2.5.0.8' Bug fix: Attempting to export the MODPATH input files before
//       MODPATH has been activated now results in a warning message instead
//       of an assertion failure.
//     Bug fix: It is now possible to select the "Edit vertex values" button
//       when the "Select vertices" button is pressed.
//     Bug fix: When exporting the BCF package, sometimes an attempt was made
//       to export data set 8 when it shouldn't have been exported.
//   '2.5.0.9' Bug fix: If a HUF SYTP parameter was defined, attempting to
//       open the MODFLOW packages and programs dialog box would result in an
//       assertion failure.
//     Enhancement: The Manage Parameters dialog box has been added.
//     Enhancement: The Global Variables are now alphabetized.
//     Enhancement: Initial heads can now be read from a binary head file
//       generated by another MODFLOW model.
//   '2.5.0.10' Bug fix: Fixed sorting of global variables
//     (bug was not in released version.)
//   '2.5.0.11' Enhancement: The selection cube now responds
//       to the mouse wheel.
//     Change: When importing model results, the formulas used for the
//       3D data sets have been changed to keep the formulas valid if
//       the number of layers is increased.
//     Bug fix: Attempting to contour a data set that is uniform no longer
//       results in a range-check error.
//     Bug fix: When attempting to export the MODFLOW input files, if a file
//       can't be created because it is in use, an error message will be
//       displayed.
//   '2.5.0.12' Enhancement: The Manage Head Observations dialog box has
//       been added.
//     Change: If an invalid formula is encountered when exporting the MODFLOW
//       input files the Formula Errors dialog box is not displayed until the
//       export is complete.
//   '2.5.0.13' Change: Items in "Search for Objects" dialog box
//       are now listed in a tree component.
//     Bug fix: When parameters are used in the RCH, EVT, and ETS packages,
//       the print codes for the parameters are set correctly.
//   '2.5.0.14' Enhancement: When saving a ModelMate file, the user can
//       choose to have the ModelMate file opened with ModelMate.
//     Bug fix: fixed problem that could make it opening the Object
//       Properties dialog box slow.
//     Bug fix: Attempting to open a Shapefile that is already open
//       now generates an error message but not a bug report.
//     Enhancement: A warning is now issued if an observation name is not
//       valid when used in UCODE.
//     Change: ModelMate program locations are now saved to an ini file.
//     Bug fix: In MODFLOW models, if a data set is evaluated at nodes,
//       the user can no longer attempt to color the grid with the data set
//       values or contour the data set values.
//     Bug fix: MODFLOW models in which the same cells are defined as
//       constant head cells through both the BAS and CHD packages are
//       now imported correctly.
//   '2.5.0.15' Enhancement: ModelMate interaction improved.
//   '2.5.0.16' Enhancement: When the nonparameter data in the CHD, DRN, DRT,
//       EVT, ETS, GHB, RCH, RIV, or WEL packages for one stress period
//       repeat the data from a previous stress period, the package instructs
//       MODFLOW to reuse the data from the previous stress period rather
//       than exporting another copy of the same data.
//   '2.5.0.17' Enhancement: Reduced memory usage when opening files.
//     Enhancement: Attempting to read an invalid DEM now results in an
//       error message instead of generating a bug report.
//   '2.6.0.0' No further changes.
//   '2.6.0.1' Enhancement: When coloring the grid causes a data set to be
//       recalculated, there will be form displaying the steps involved
//       in calculating the values.
//     Bug fix: Postprocessing for Geostatic Stress and changes in Geostatic
//       stress has been fixed.
//     Bug fix: Opening an object in the Object Properties dialog box no
//       longer causes causes transient data to be recalculated.
//     Enhancement: Channel cross sections in the SFR package can now be
//       imported from Shapefiles.
//   '2.6.0.2' Enhancement: When importing SFR data from Shapefiles, formulas
//       can now be used for SLOPE, STRTOP, STRTHICK, STRHC1, THTS, THTI,
//       EPS, and UHC.
//     Enhancement: Improved error handling when importing an image.
//     Bug fix: Attempting to write a locked file or attempting to open a
//       file that doesn't exist now results in an error message instead of
//       a bug report.
//     Bug fix: Exporting locations of MODPATH and ZONEBUDGET sometimes
//       were not enclosed in quotes when quotes were required.
//     Enhancement: Reduced flicker when drawing new objects. This may also
//       have fixed a intermittent bug that caused access violations when
//       coloring the grid.
//     Bug fix: Fixed coloring the grid when integer values were being used
//       to color the grid and limits were used to filter what cells
//       would be colored.
//   '2.6.0.3' -----
//   '2.6.0.4' Bug fix: VertexInterpolate didn't work properly
//       if the grid was rotated.
//   '2.6.0.5' Enhancement: Images can now be exported as .bmp files as
//       well as .emf files.
//     Bug fix: Pasting objects didn't work properly if the object
//       had associated vertex values.
//     Bug fix: Sometimes changing the number of Z formulas
//       could lead to an assertion failure.
//     Enhancement: Improved speed of opening the Global Variables
//       dialog box.
//     Bug fix: Opening the Object Properties dialog box would sometimes
//       cause an access violation if another model had been opened
//       previously.
//     Enhancement: In the Select Objects by Name dialog box, the objects
//       are sorted alphabetically.
//     Bug fix: In the Select Objects by Name dialog box, the objects are
//       now placed on the correct tab instead of always being put on the
//       tab for the top view if the model.
//   '2.6.0.6' Enhancement: In the Color Grid and Contour Data dialog boxes,
//       when the user changes the data set used to color or contour the grid,
//       the same limits as in the data set that is currently displayed
//       can be used with a newly selected data set.
//   '2.6.0.7' Bug fix: in the SFR package, NSTRAIL, ISUZN, and NSFRSETS
//       were written when ISFROPT > 0 instead of when ISFROPT > 1.
//   '2.6.0.8' Bug fix: Deleting the last vertex of an object
//       no longer causes an error.
//     Bug fix: When the grid was colored with horizontal flow barriers,
//       changing an object that defines a horizontal flow barrier
//       now causes the displayed barriers to be updated correctly.
//     Editing multiple objects in a new model no longer causes an error.
//     Bug fix: Inactive cells are no longer included in head observations.
//   '2.6.0.9' Bug fix: on the Import Image dialog box, it is no longer
//       possible to set the number of rows in the table to less than 1.
//     Bug fix: Previously, the MODPATH zone was incorrectly limited to
//       values greater than or equal to zero even for specified head cells.
//   '2.6.0.10' Bug fix: Attempting to import model head or drawdown results
//       from a file in which the number of layers is greater than the number
//       of simulated layers now results in an error message instead of
//       generating an error report.
//   '2.6.0.11' Enhancement: The macros "%SP", "%TS", and "%ET" can now be
//       used in text on the Export Image dialog box.  They will be replaced
//       by the stress period number, time step number, and elapsed time
//       respectively if those data are in the comment for the data set.
//     Change: The elapsed time is now included in the data set comment
//       when importing MODFLOW results.
//   '2.6.0.12' Bug fix: MODPATH results were not cleared when opening
//       a new model.
//   '2.6.0.13' Bug fix: Fixed macros in Import Image dialog box so that
//       they work with the title too. (Bug not in released version.)
//   '2.6.0.14' Enhancement: Contours can now be exported to a Shapefile.
//     Change: All the commands for exporting Shapefiles have been moved to
//       a submenu.
//     Enhancement: Pathlines can now be exported to a Shapefile.
//     Enhancement: Endpoints can now be exported to a Shapefile.
//     Bug fix: Previously, the display of MODPATH times series points was
//       incorrect when there was more than one release time.
//     Enhancement: TimeSeries can now be exported to a Shapefile.
//   '2.6.0.15' Bug fix: when opening a new model, bitmaps from the previous
//       model are now removed.
//     Enhancement: ModelMuse now can create a series of bitmaps that
//       can be used to create a video.
//   '2.6.0.16' Enhancement: ModelMuse now will warn the user if a CHD, DRN,
//       DRT, GHB, RIV, SFR, or WEL cell is in an inactive cell.
//   '2.6.0.17' Enhancement: When coloring the grid with transient data,
//       only the data for the time being used to color the grid is evaluated.
//     Bug fix: Sometimes moving an object did not cause the data sets
//       that depend on it to be updated.
//     Bug fix: When importing a shape file, the interpretation algorithm
//       is now set correctly.
//     Bug fix: When exporting .emf files, sometimes the image size was
//       set to an incorrect value.
//   '2.7.0.0' Change: Updated memory manager to latest version.
//   '2.7.0.1' Bug fix: In the Set Widths of Columns, Rows, and Layers,
//       dialog box, it is no longer possible to specify an invalid
//       column, row, or layer.
//     Bug fix: when exporting a PHAST model multiple times, the name of the
//       file wasn't set appropriately.
//     Bug fix: When exporting a MODFLOW model after previously having
//       exported a different MODFLOW model, the default name for the model
//       is now set correctly rather than being the same name used previously.
//     Bug fix: Fixed access violations when importing model results
//       into a model and contouring those results.
//     Bug fix: When computing the size of the MODPATH composite budget file,
//       file sizes larger than 2 GB can now be computed without causing an
//       error.
//   '2.7.0.2' Enhancement: Data set values can now be exported to a
//       comma-separated value file along with X, Y, Z coordinates.
//   '2.7.0.3' Bug fix: Renaming a data set and then attempting to use that
//       data set in the formula for another data set no longer causes an
//       error.
//   '2.7.0.4' Bug fix: when exporting .emf images, the dimensions of the
//       image were set incorrectly.
//   '2.7.0.5' Enhancement: When data set values can are exported to a
//       comma-separated value file, column, row, and layer numbers are
//       exported too.
//   '2.7.0.6' Bug fix: When a data set is first created, it was treated
//       as being a real number data set in the Formula Editor even if its
//       type had been changed.
//     Bug fix: Pasting data into several of the tables could sometimes cause
//       errors if the data that was being pasted was larger than the table
//       could hold.
//     Bug fix: The ActiveOnLayer function can now only be applied in a
//       context where it will be evaluated on blocks.
//     Enhancement: When importing heads, the water table is imported too.
//   '2.7.0.7' Enhancement: When exporting MODPATH input files, ModelMuse
//        now warns the user if not all time steps have been exported.
//     Enhancement: When a new version of ModelMuse is available,
//        the dialog box that informs the user of the new version has a
//        button that the user can click to go to the ModelMuse web site.
//     Enhancement: The "About" dialog box has a
//        button that the user can click to go to the ModelMuse web site.
//     Bug fix: Eliminated a range check error that could sometimes occur
//        if user moved the mouse while importing model results.
//     Enhancement: If the user specifies a head observation with a blank
//        observation name, an error message is generated during export of
//        the head observations file.
//     Enhancement: The Grid Value dialog box now allows the user to see
//       the value of any data set instead of just the one that is being
//       used to color the grid or whose values have been contoured.
//   '2.7.0.8' Bug fix: When importing model results, the legend on the
//       Color Grid or Contour Data dialog box is updated.
//     Bug fix: When exporting an image of the side view of the model,
//        the horizontal scale now shows the correct values.
//   '2.7.0.9' Bug fix: fixed bug that could cause an access violation when
//       deleting parameter in the Manage Parameters dialog box.
//     Bug fix: If the model runs out of memory when attempting to create
//       a new model, an error message is displayed to the user instead of
//       sending a bug report.
//     Bug fix: In the Start-up dialog box, if the user specifies a layer
//       group but does not give it a name, it is skipped instead of causing
//       and assertion failure.
//     Bug fix: Fixed access violation in Export Object as Shapefile dialog
//       that could occur when unchecking a check box.
//   '2.7.0.10' Bug fix: Interpolated Vertex Value gave incorrect results
//       if the grid was rotated.
//   '2.7.0.11' Bug fix: The main window no longer goes behind the windows
//       of other programs when coloring the grid.
//     Enhancement: The Grid Value dialog box displays the vertex number
//       and section of the selected object. at the cursor location.
//     Bug fix: ModelMuse now displays an error message when exporting or
//       displaying the UZF data if some data has not been defined.
//   '2.7.0.12' Enhancement: The function Get_HufSytp has been added.
//       It evaluates SYTP parameters in HUF.
//   '2.7.0.13' Enhancement: The location of the grid in
//       real world coordinates is written as a comment in the
//       discretization file.
//     Bug fix: Fixed reading shape files from which some shapes have been
//       deleted.
//     Bug fix: Fixed position of Insert and Delete buttons for the table
//       of times for the SFR package in the Object Properties dialog box.
//     Bug fix: Clicking the Insert buttons on the Object Properties dialog
//       box or the MODFLOW Time dialog box could result in errors if no
//       row in the related grid was selected.
//     Enhancement: Reduced memory usage while reading ModelMuse file.
//     Bug fix: Fixed evaluation of the GetHufSytp function.
//   '2.7.0.14' Bug fix: fixed evaluation of GetHufKx when KDEP parameters
//       are used.
//     Bug fix: fixed importing models that use SYTP parameters in the HUF
//       package.
//     Bug fix: fixed evaluation of GetHuf_Interlayer_Kz when KDEP parameters
//       are used.
//     Bug fix: If an object has too many vertices, the Object Properties
//       dialog box now does not display them because attempting to display
//       them caused an access violation.
//     Enhancement: When importing data, less memory may be used in some
//       cases.
//   '2.7.0.15' Bug fix: Fixed editing the head observation purpose.
//     Enhancement: Added Natural Neighbor interpolation.
//   '2.7.0.16' Bug fix: Fixed export of PHAST specified flux
//     associated solution on the X face.
//   '2.7.0.17' Bug fix: A problem with duplicate parameter instance names
//       in MODFLOW models has been fixed.
//   '2.8.0.0' no additional changes.

//   '2.8.0.1' Bug fix: It is no longer possible to show the Manage Head
//       Observations dialog box before any head observations have been
//       defined. Doing so could cause access violations.
//     Bug fix: Under certain circumstances, the "Add point sections",
//       "Add polyline sections", or "Add polygon sections" buttons could
//       be pressed when there is no selected object causing an
//       assertion failure. The buttons now become disabled under those
//       conditions.
//     Enhancement: Grid data can now be exported to 3D Shapefiles.
//   '2.8.0.2' Enhancement: In the Search for Objects dialog box, the
//       tree remains open after changing which checkboxes are
//       checked.
//     Bug fix: Attempting to import an empty or invalid results file
//       now generates an error message for the user instead of a bug report.
//   '2.8.0.3' Enhancement: Improved warning messages when a specified
//       time for a boundary condition is outside of the range of times
//       defined for the stress periods.
//     Bug fix: Removed incorrect warning message generated when the SFR
//       package was used and the starting time was greater than zero.
//     Bug fix: Fixed assignment of custom layer discretization in
//       Layer Groups dialog box.
//     Bug fix: Deleting a layer group and then undoing the deletion no
//       longer causes an assertion failure.
//     Bug fix: Fixed a problem in which operating ModelMuse on a computer
//       for which the language settings specify the decimal point
//       to be something other than a period caused conversion errors.
//   '2.8.0.4' Change: When creating polygon objects or adding
//       polygon sections to existing objects, clicking on the first
//       point of the polygon will close the polygon instead of continuing it.
//     Enhancement: Improved speed of "Select Object by Name" dialog box.
//     Bug fix: the "Set Widths of Columns, Rows, and Layers" dialog box now
//       shows the selected columns, rows, and layers when it is displayed.
//     Bug fix: It is no longer possible to attempt to color or contour
//       the grid before the grid is defined.
//     Bug fix: When sampling a DEM, only one DEM at a time could be selected.
//     Enhancement: Added option to import ASCII raster file.
//   '2.8.0.5' Bug fix: Fixed reversal of imported ASCII raster files.
//     (bug is not in released version.)
//   '2.8.0.6' Enhancement: added additional error checking in MNW2 package.
//     Bug fix: Fixed the importing of world files in "Import Bitmap"
//       dialog box. Previously, attempting to import some world files
//       would fail because of extra spaces before the beginning of a number.
//   '2.8.0.7' Change: When exporting Shapefiles attribute names with
//       an ending trailing underscore have the underscore removed.
//     Bug fix: When exporting Shapefiles of contours or MODPATH data,
//       the bounding boxes of each shape are now set correctly.
//   '2.8.0.8' Bug fix: Exporting contour Shapefiles when the specify contour
//        option is checked and contour values are copied from another
//        data set no longer causes an error.
//      Bug fix: Previewing or exporting a series of images containing
//        contours no longer causes an error when the range of values
//        varies among the images.
//   '2.8.0.9' Bug fix: Attempting so save a model archive on a disk with
//        insufficient space now generates an error message instead of a
//        bug report.
//      Enhancement: There is a new way to display the Vertex Values dialog
//        box. If no objects are selected on the view of the model
//        with which the user is working, the user can double-click on a
//        vertex of any object to display the Vertex Values dialog box.
//      Enhancement: When importing model results, the default choice for
//        how the imported results should be displayed now depends on the
//        user's past choices on how the results should be displayed.
//      Enhancement: There is now a button on the tool bar for importing
//        model results.
//      Enhancement: Vertex values can now be edited in the Object Properties
//        dialog box.
//      Bug fix: Previously, it you contoured a data set, closed the file,
//        opened another one without closing ModelMuse and attempted to
//        contour a data set, an access violation would occur. That access
//        violation has been eliminated.
//      Bug fix: When importing existing MODFLOW models, ModelMuse will now
//        check that in all the inactive cells, the top of the layer is above
//        the bottom of the layer. The elevations will be fixed in
//        any inactive cells that do not meet this criterion.
//   '2.8.0.10' Bug fix: ModelMuse can no longer enter an infinite loop when
//        generating parameter instance names.
//   '2.8.0.11' Bug fix: Eliminated an integer overflow error that could
//        occur when exporting the RCH, EVT, or EVT packages.
//   '2.8.0.12' Bug fix: Creating a new integer, Boolean, or text data set no
//        longer fails.
//      Enhancement: The user can now choose whether or not to save data set
//        values when those values are up-to-date.
//      Change: When data sets are deleted, the user is now prompted
//        to delete unused objects.
//      Change: The column, row and layer displayed in on the Grid Value
//        dialog box is now the column row, and layer of the cell under the
//        cursor even if a 2D data set is used to color the grid or
//        is being contoured.
//      Bug fix: In the SFR package, a warning about SFR segments circling
//        back on themselves was sometimes generated when it should not have
//        been generated and the segments involved would not be included in
//        in the SFR package input file.
//    '2.8.0.13' Enhancement: The speed of exporting the input files has
//        increased
//      Bug fix: Deleting all the vertices of the last section of an object
//        when that section was a polygon caused an error.
//      Bug fix: Making a background image too big now causes it to be
//        hidden rather than generating an error message.
//      Change: When defining CHD boundaries, an object with multiple
//        sections will not define separate boundaries for each section.
//    '2.8.0.14' Enhancement: In the SFR package, a warning is generated
//        if the stream segment numbers are in strict numerical order but a
//        segment with a higher number provides flow to one with a lower
//        segment number.
//      Enhancement: The Grid Value dialog box now displays information
//        about the closest MODPATH pathline if it is within 1 cell or
//        five pixels of the cursor.
//    '2.8.0.15' Bug fix: Attempting to export a model without first
//        defining a grid now results in an error message instead of
//        generating a bug report.
//      Bug fix: invalid formulas for river conductance and other, similar
//        data no longer causes an access violation.
//    '2.8.0.16' Bug fix: Fixed bug that prevented data for SFR data for a
//        time period from being deleted.
//    '2.8.0.17' It is now possible for the recharge from several sources to
//        be added together.
//    '2.8.0.18' reduced memory usage when recharge from several sources is
//        added together.
//    '2.8.0.19' It is now possible for the infiltration in the UZF package
//        from several sources to be added together.
//    '2.8.0.20' Bug fix: In some models, the SFR package could not be
//        exported correctly.
//      Bug fix: In some models, the Lake_ID numbers were not set incorrectly.
//    '2.8.0.21' Bug fix: the selected layer wasn't being restored properly
//        when opening a model (not in released version).
//      Bug fix: Changing a data set orientation could cause error messages
//        to be incorrectly generated for other data sets.
//    '2.8.0.22' Bug fix: Fixed error messages for stream segments that
//        are out of order.  (Bug was not in released version.)
//    '2.8.0.23' ---
//    '2.8.0.24' Bug fix: Object used to define the return location in the
//        DRT package are now displayed in the Show or Hide Objects
//        dialog box under an appropriate heading.
//      Bug fix: If you undo and then redo the creation of parameters,
//        objects that use those parameters will no longer lose them.
//      Change: It is now possible to select multiple cells in all tables.
//    '2.8.0.25' Enhancement: When importing Shapefiles, the numbers of any
//        shapes with multiple parts will be displayed.
//    '2.8.0.26' ModelMonitor has been updated to work with LGR.
//    '2.8.0.27' Enhancement: The export image dialog box now has a "Copy
//        image" button that copies the image to the clipboard.
//      Enhancement: The Data Set Values dialog box now shows 2D Front and
//        2D Side data sets in a single table instead of one table for each
//        layer.
//      Bug fix: The Object Properties dialog box no longer shows times
//        related to time-varying layers in the RCH, EVT, and ETS packages
//        unless time-varying layers have been selected in the corresponding
//        package.
//    '2.8.0.28' Bug fix: Multiplier and zone array names are now
//        no longer than 10 characters in length.
//      Enhancement: Improved speed of importing model results.
//    '2.8.0.29' Bug fix: Fixed reading heads. Bug not in released version.
//    '2.8.0.30' Bug fix: Fixed bug that caused access violations when
//        editing packages with the HFB package selected. Bug not
//        in released version.
//    '2.8.0.31' Bug fix: Fixed LGR related bug that could cause, wells,
//        drains, etc to be exported incorrectly (not in released version).
//    '2.8.0.32' Bug fix: Fixed bug in editing the objects that control
//        the horizontal placement of LGR Grids.
//    '2.8.0.33' Bug fix: Fixed bug that would cause range check errors or
//        access violations when animating contours.
//      Enhancement: When deleting vertices of an object with imported data,
//        the corresponding imported data will be deleted too.
//      Enhancement: New command "Object|Edit|Edit|Invert Selected Vertices"
//        to invert the selected nodes.
//      Enhancement: New command "Object|Edit|Split Selected Objects"
//        to convert each part of an object to a separate object.
//      Enhancement: New command "Object|Edit|Make Selected Vertices
//        a Separate Object" converts the selected vertices of an object to
//        a new object while deleting them from the existing object.
//      Enhancement: New command "Object|Edit|Split Object at Selected
//        Vertices" to convert split an object into two separate objects.
//        The objects will be split at the location(s) of any selected
//        vertices with both objects sharing the selected vertices.
//      Bug fix: Adding recharge, evapotranspiration, or ETS parameters
//        formerly could lead to access violations later on.
//      Enhancement: added support for running a single model with BFH data
//        with MODFLOW-LGR.
//      Bug fix: Fixed an assertion failure in specifying
//        zero flow observations.
//      Bug fix: When reversing the order of vertices in an object, the
//        order of any imported data is reversed too.
//    '2.8.0.34' Bug fix: new commands for editing objects were never
//        enabled. (not in released version).
//    '2.8.0.35' Enhancement: In the Import Gridded Data dialog box, data
//        for a single grid row may not be spread over several lines when
//        pasting data into the grid for arrays.
//    '2.8.0.36' Enhancement: Three new functions added:
//        ObjectCurrentSegmentAngle, ObjectCurrentSegmentAngleDegrees, and
//        ObjectCurrentSegmentAngleLimitedDegrees. See help for
//        descriptions.
//    '2.9.0.0' Enhancement: Added support for MODFLOW-LGR.
//      Change: When importing head observations from a Shapefile, a default
//        value for the observation name is used if the user has not
//        assigned a name.
//      Enhancement: Improved responsiveness in the Manage Flow Observations
//        dialog box.
//      Enhancement: Decreased time required to display the
//        MODFLOW Time dialog box.
//      Bug fix: Fixed bug that could cause access violations when displaying
//        the Object Properties dialog box.
//      Bug fix: Fixed a bug that caused the multiplier and zone array names
//        for the LPF package to change each time the model was exported.
//      Bug fix: Fixed bug that could cause range check errors when coloring
//        the grid with the RCH, EVT, or ETS packages.
//    '2.9.0.1' Bug fix: Fixed bug in which a change in a vertex value of
//        an object failed to cause the data sets dependant on that value
//        to be updated.
//      Bug fix: It is no longer possible to create an object with no
//        vertices by starting creating an object and then deleting all the
//        vertices by pressing the ESC key.
//      Bug fix: It is no longer possible to generate an assertion failure by
//        attempting to import a results file by typing the name of a file
//        with an extension not recognized by ModelMuse.
//      Bug fix: The STORAGECOEFFICIENT option in the LPF package can now
//        be edited and stored properly.
//      Bug fix: Fixed a bug in which the selected column, row, or layer
//        was not always displayed properly by the ModelCube.
//      Bug fix: Attempting to import gridded data before defining the grid
//        now results in an error message instead of generating a bug report.
//      Bug fix: When editing Flow observations, some observations
//        were not saved.
//    '2.9.1.0' Bug fix: Entering an unreasonable value for the grid origin
//        when creating a new model no longer causes an access violation.
//      Bug fix: Sampling a DEM is now possible when the language setting on
//        the computer specify a comma as the decimal separator.
//      Bug fix: If a ModelMuse file can not be saved to the disk, a warning
//        message is displayed rather than generating a bug report.
//      Bug fix: If there are no valid stress periods defined, in the
//        MODFLOW Time dialog box, the dialog box does not save the stress
//        periods.
//      Bug fix: It is no longer possible to edit the cell in the table
//        of the start-up dialog box for MODFLOW by tabbing to the cell.
//      Bug fix: The variables in the LPF package are now initialized
//        properly in a new model.
//      Bug fix: Importing values from ModelMate now works properly when
//        a decimal separator other than a period is used.
//      Bug fix: When exporting an or updating ModelMate files where the
//        user has not previously specified a the ModelMate location,
//        the file is still correctly opened by ModelMate.
//      Bug fix: Fixed a bug that could cause access violations when
//        ModelMuse was closing.
//      Bug fix: Fixed bug that would cause access violations when closing
//        the Object Properties dialog box.
//      Bug fix: Incorrect error messages are no longer generated when
//        coloring the grid with the Head observations.
//    '2.9.1.1' Fixed bug that could cause the incorrect text to be replaced
//         in the formula editor when editing a formula.
//      Bug fix: If the selected object is hidden, the dotted box that
//         sometimes surrounds the selected object is also hidden.
//      Enhancement: Added support for MODFLOW-NWT.
//      Change: when importing Surfer grid files, the "files of type" is
//        set to the value at which it was set the previous time a Surfer
//        grid file was imported since the program was started.
//    '2.9.1.2' Bug fix: "Objects|Hide All Objects" didn't work if only
//        one object was visible.
//    '2.9.1.3' ---
//    '2.9.1.4' Change: The reference stress period for head and flow
//        observations will now be exported as the stress period containing
//        the observation instead of the first stress period.
//      Change: ModelMuse is now compiled with Delphi XE instead of
//        Delphi 2006. Small changes in the model input changes may occur
//        due to the change in compiler.
//      Enhancement: When exporting the MODFLOW input files, the user also
//        has an opportunity to export the MODPATH or ZONEBUDGET input files
//        too.
//      Enhancement: It is now possible to import CHD, DRN, GHB, RIV, and WEL
//        MODFLOW boundaries from the Import Points dialog box.
//    '2.9.1.5' Enhancement: In the Object Properties dialog box, times
//        for MODFLOW boundary conditions are automatically filled in when
//        a previous time is selected.
//      Bug fix: When importing an existing MODFLOW model, Vertical anisotropy
//        in the LPF package was not imported correctly if vertical anisotropy
//        was used in all layers.
//    '2.9.1.6' Bug fix: The ObjectCurrentSegmentAngle,
//        ObjectCurrentSegmentAngleDegrees, and
//        ObjectCurrentSegmentAngleLimitedDegrees functions did not return
//        values that were relative to the grid.
//      Bug fix: Fixed a problem with setting an HFB parameter name
//        that caused access violations when closing the MODFLOW Packages
//        and Programs dialog box.
//    '2.9.1.7' Enhancement: ModelMuse can now import and display the
//        head observation output.
//    '2.9.1.8' ----
//    '2.9.1.9' Bug fix: In the GMG solver, the maximum number of iterations
//        could not be edited.
//    '2.9.1.10' Bug fix: Fixed export of head observations with LGR child
//        models.
//      Bug fix: In some cases, ModelMuse files in which the HFB package
//        was used could not be read.
//      Bug fix: Renaming a global variable that is used in the formula
//        for the HFB package will now cause the formula to be updated.
//      Bug fix: Fixed reading binary result files. (Bug not in released
//        version of ModelMuse.)
//    '2.9.1.11' Bug fix. When opening a browser, ModelMuse no longer
//        attempts to delete files that don't exist.
//    '2.9.1.12' ----
//    '2.9.1.13' ----
//    '2.9.1.14' Enhancement: It is now possible to import CHD, DRN, GHB,
//        RIV, and WEL MODFLOW boundaries as well as head observations
//        from the Import Points dialog box.
//    '2.9.1.15' ----
//    '2.9.1.16' Fixed naming of objects when importing head observations
//        from the Import Points dialog box. (Bug not in released
//        version of ModelMuse.)
//    '2.9.1.17' ----
//    '2.10.0.0' No additional changes.
//    '2.10.0.1' Bug fix: Importing a feature that allows for a MODFLOW
//        parameter from a Shapefile no longer causes a range check error
//        if no parameter is being imported.
//    '2.10.1.0' Change: When a message about a new version is displayed,
//        the version numbers of the new version as well as the version
//        that is being used are both displayed.
//    '2.10.2.0' Bug fix: Undoing certain operations no longer results
//        in a range check error.
//      Enhancement: Attempting to import a formatted head file that
//        contains "NaN" no longer results in a bug report.
//    '2.10.2.1' Bug fix: SYTP parameters in the HUF package are now written
//        to the PVAL and UCODE template files.
//    '2.10.2.2' Bug fix: If the HFB package was selected, using the
//        MODFLOW Packages and Programs dialog box no longer causes access
//        violations.
//      Bug fix: When the HFB package was selected, exporting a model that
//        uses zone arrays no longer causes an Assertion failure.
//    ''2.10.2.3' Bug fix: Fixed a problem in which deleting vertices of an
//        object that included imported text data, more of the text data was
//        deleted than should have been deleted.
//      Bug fix: Fixed bugs that could cause access violations when
//        ModelMuse was closed.
//      Bug fix: Reading World Files on computers where the decimal separator
//        is set to a value other than '.' now works correctly.
//      Bug fix: When importing points, it is no longer possible to
//        attempt to define an invalid object name.
//    '2.10.3.0' No further changes.
//    '2.10.3.1' Bug fix: Fixed bug that could cause a
//        "List index out of bounds" error when exporting Shapefiles.
//    '2.10.3.2' Bug fix: fixed bug that could ModelMuse to hang when
//        starting a new model.
//      Bug fix: When reading MODPATH pathline files, negative values of time
//        were not handled properly.
//      Bug fix: Attempting to export a model in which the reservoir package
//        is selected but no reservoirs have been defined now results in
//        an error message instead of a bug report.
//    '2.10.3.3' Enhancement: Error or warning messages are now issued when
//        a boundary condition package has been activated but no boundaries
//        for it have been defined.
//      Change: When closing a model, the prompt asking the user if they
//        wish to save the model now includes the file name if the file name
//        has been specified.
//      Enhancement: ModelMuse now warns the user if duplicate SFR
//        parameter instances are being used.
//      Bug fix: Fixed export of TBEGIN in MODPATH main file.
//      Enhancement: In LGR models, Streams in the SFR package are now linked
//        between grids.
//    '2.10.3.4' Bug fix: Fixed bug with selecting and drawing objects when
//        zoomed in a great deal.
//    '2.10.3.5' Bug fix: In LGR models, the selected column, row, and layer
//        are now read correctly when opening a ModelMuse file.
//      Bug fix: Fixed bug that could cause an access violation if the number
//        of columns or rows was set to zero.
//    '2.10.3.6' Bug fix: In PHAST models, switching an object between being
//        evaluated at nodes and elements no longer causes a bug report to
//        be generated.
//    '2.10.3.7' Change: The most recent version of PHAST no longer supports
//        specifying an initial water table. However, you can still use
//        the initial water table option in ModelMuse. ModelMuse will use
//        the data in the Initial_Water_Table data set to specify the
//        initial head in a vertical column of nodes.
//      Enhancement: The Grid Value dialog box can now display data about
//        the nearest visible MODPATH end point.
//      Bug fix: When attempting to import model results, trying to import
//        from a file that is being used by another program now results in an
//        error message to the user instead of a bug report.
//    '2.11.0.0' Enhancement: Added support for GOFAIL option in MODFLOW-NWT.
//    '2.11.0.1' Enhancement: When importing an existing MODFLOW model,
//        .mfn is now recognized as a valid extension for a MODFLOW name file.
//      Bug fix: Previously some erroneous error or warning messages were
//        generated for data set values in inactive cells.
//      Bug fix: When a background image was replaced with a new one, the
//        name of the image stored in ModelMuse is now updated.
//      Enhancement: It is now possible to import multiple ASCII raster files
//        at one time.
//    '2.11.0.2' Enhancement: Added a measurement function that allows the
//        user to measure distances easily.
//      Enhancement: Contours are now labeled.
//      Change: "GOFAIL" option in MODFLOW-NWT has been renamed "CONTINUE".
//    '2.11.0.3' Bug fix: In the Object Properties dialog box,
//        a "no parameter" checkbox has been added to the beginning of the
//        list of parameters for MODFLOW features that allow multiple
//        parameters to be used with a single object. The "no parameter"
//        check box can be unchecked to turn off the definition of a boundary
//        that does not use parameters.
//      Bug fix: When a data set defines the multiplier or zone array of a
//        MODFLOW parameter, it now is possible to delete the data set if
//        the associated parameter is deleted.
//      Enhancement: The positions of objects can now be locked so that they
//        can't be moved accidentally.
//      Change: The multiplier and zone arrays used by the RCH, EVT, and ETS
//        packages are now exported to separate files that are accessed
//        using the OPEN/CLOSE option. This allows the zone and multiplier
//        arrays in other packages to be changed without the need to
//        export the RCH, EVT, and ETS packages. The files are stored in
//        a subdirectory named "arrays."
//      Bug fix: When importing the UZF package from an existing MODFLOW
//        model, NUZTOP is now imported correctly.
//      Change: The following dialog boxes have been deleted and their
//        functionality has been moved to the new Data Visualization
//        dialog box: Color Grid, Contour Data, MODPATH Pathline Display,
//        MODPATH Endpoint Display, MODPATH Time Series Display, and
//        Head Observation Results.
//      Enhancement: In the Data Visualization dialog box, it is now possible
//        to display linkages between streams in the stream package.
//      Bug fix: When editing objects that define SFR streams, the controls
//        for editing multiple cells in tables are now positioned properly.
//      Bug fix: Fixed a bug that caused access violations when the system
//        color was changed.
//    '2.11.0.4' Bug fix. Exporting a grid data to a shape file for data sets
//        whose names are longer than 10 characters now works properly.
//    '2.11.0.5' Change: The zone and multiplier arrays files for
//        RCH, EVT, and ETS are stored in a subdirectory named "arrays."
//    '2.12.0.0' Change: In the NWT solver, the default value for flux
//        tolerance has been increased from 0.006 to 0.06
//      Bug fix: Deleting data sets and then opening another ModelMuse project
//        no longer results in an assertion failure.
//      Bug fix: Fixed a problem with invalid cast errors in PHAST models
//        when creating or editing objects.
//      Enhancement: In the Manage Head Observations dialog box, the user
//        can now select multiple rows and then click the "Highlight selected
//        objects" button to select all the objects that define objects
//        on the selected rows.
//      Enhancement: In the Head Observation Results pane of the
//        Data Visualization dialog box, the data can be sorted by clicking
//        on the column headers
//      Enhancement: In the Head Observation Results pane of the
//        Data Visualization dialog box, the objects that define the
//        observations in the selected row of the results table can be
//        selected by clicking the "Highlight selected objects" button.
//      Bug fix: Attempting to read an invalid ModelMate file now generates
//        a warning message instead of a bug report.
//      Bug fix: Attempting to open a ModelMuse file with a length of zero
//        now results in an error message to the user rather than a bug
//        report.
//      Bug fix: In the PHAST Print Frequency dialog box, it is no longer
//        possible to delete all the columns in the table.
//    '2.12.0.1' Enhancement: ModelMuse now checks the file date for MODFLOW
//        and related models and warns the user if a more recent version has
//        been released.
//      Bug fix: ModelMuse again responds to the mouse wheel.
//    '2.12.0.2' Bug fix: ModelMuse now only allows a ModelMuse file to be
//        saved if it has one of the correct extensions.
//      Bug fix: Access violations that sometimes occurred when changing
//        the names of layer groups have been fixed.
//      Bug fix: In the MODFLOW Program Locations dialog box, "ModelMuse.exe"
//        is no longer accepted as a valid name for any of the programs.
//      Bug fix: Undo/Redo capability added for changes to the output control.
//      Bug fix: ModelMuse can now import the gage package correctly when
//        a lake gage has an OUTTYPE of 4 or a stream gage has an OUTTYPE
//        of 8.
//      Bug fix: ModelMuse now updates user-entered real numbers to the
//        proper format when the the user changes the language settings.
//      Bug fix: (bug not in released version) In MODFLOW-NWT models,
//        switching to use the NWT or UPW packages no longer causes a stack
//        overflow.
//      Bug fix: Fixed in bug in which attempting to delete a row from a
//        table in which no row was selected caused an exception.
//      Bug fix: Fixed bug in which SFR data was corrupted if ICALC was not
//        specified.
//    '2.12.0.3' Enhancement: Reduced memory usage when importing MODFLOW
//        models that use the UZF package.
//      Enhancement: When importing MODFLOW features from Shapefiles,
//        most features can be imported into a single, multi-part object.
//      Bug fix: Fixed bug importing the MNWI package from an existing
//        MODFLOW-2005 model.
//      Bug fix: Fixed bug that could sometimes prevent the Object Properties
//        dialog box from being displayed when attempting to edit
//        multiple objects.
//      Bug fix: In the MODFLOW Time dialog box, attempting to use the
//        Time Step Length Calculator without first specifying the Stress
//        period length and multiplier now generates a warning message to the
//        user instead of a bug report.
//      Change: When running MODFLOW from ModelMuse, the lines in the batch
//        file to display the listing file now occurs immediately after
//        MODFLOW has finished instead of after the lines to run MODPATH
//        and Zonebudget.
//    '2.12.0.4' Bug fix: When the user has customized the regional settings
//        to use a decimal separator that is different from the usual one,
//        this no longer causes an error when converting text to
//        floating point values.
//    '2.12.0.5' Enhancement: The user can now specify the precision with
//        which contour labels are written.
//    '2.12.0.6' Bug fix: The menus and buttons are now disabled while
//        opening a file.
//      Bug fix: Fixed bug importing model results.
//        (bug not in released version.)
//    '2.12.0.7' Bug fix: When a message box is displayed, the mouse will
//        move to the default button if the user has specified that option
//        in the Windows Control Panel.
//    '2.12.0.8' Bug fix: When importing Shapefiles, failing to specify
//        an attribute name or value no longer results in a range check error.
//    '2.12.0.9' Failing to completely specify information streams in the
//        SFR package now results in an error message instead of a bug report.
//      Bug fix: Fixed bug in setting data for SFR when multiple objects
//        are being edited at once.
//    '2.12.0.10' Enhancement: added support for MT3DMS.
//      Bug fix: Fixed bugs relating to display of data in MODFLOW-LGR models.
//    '2.12.0.11' Bug fix: Fixed another bug relating to display of data in
//        MODFLOW-LGR models.
//    '2.12.0.12' Bug fix: Fixed another bug relating to display of data in
//        MODFLOW-LGR models.
//      Change: Added option to write SFR package input in the format used
//        by GSFLOW.
//    '2.12.0.13' Bug fix: fixed export of SFR in MODFLOW-NWT or for GSFLOW.
//    '2.12.0.14' Enhancement: Added help for MT3DMS.
//    '2.12.0.15' Fixed bugs in generation of MT3DMS files.
  //      Bug not in released version.
//    '2.12.0.16' Fixed MT3DMS bugs.  Bugs not in released version.
//    '2.12.0.17' Bug fix: Fixed bug with setting multiple flux observation
//        values at once not working.
//      Bug fix: Fixed bug in storing imported values when splitting objects.
//    '2.12.0.18' Enhancement: Added new macro for exporting images; %TrS
//        will be replaced by the transport step.
//    '2.12.0.19' Bug fix: When reading an exporting a file from the command
//        line, the "arrays" directory will be created as a subdirectory
//        of the directory containing the file even if the full file path
//        is not specified.
//    '2.12.0.20' Bug fix: attempting to animate a series of data sets in
//        the Export Image dialog box without first displaying the
//        Display Data dialog box no longer causes access violations.
//    '2.12.0.21' Bug fix:  Fixed bug with reading .ini file when multiple
//        copies of ModelMuse are running.
//    '2.12.0.22' Bug fix: When more than one instance of ModelMuse was
//        running, sometimes one copy would not detect that another copy
//        was running and would try to delete it's temporary files. That
//        should no longer happen.
//    '2.12.0.23' Bug fix: (second attempt) When more than one instance of
//        ModelMuse was running, sometimes one copy would interfere with the
//        other's temporary files.
//      Bug fix: fixed export of OC file when the defaults are selected.
//    '2.12.0.24' Bug fix: (third attempt) When more than one instance of
//        ModelMuse was running, sometimes one copy would interfere with the
//        other's temporary files.
//    '2.12.0.25' Enhancement: The "Run model" button now has a drop down
//        menu next to it which can be used to run MODPATH, ZONEBUDGET or
//        MT3DMS.
//      Enhancement: It is now possible to import parameter values from a
//        MODFLOW PVAL file. This can be done either from the
//        Manage Parameters dialog box or from the command line. To import
//        a PVAL file from the command line, add -p "Filename" to the
//        command line where Filename
//        is the full path of the PVAL file. If the path contains any spaces,
//        Filename should be enclosed in double quotes.
//      Enhancement: It is now possible to import global variables from a
//        text file. This can be done either from the
//        Global Variables dialog box or from the command line. To import
//        a global variables file from the command line, add -g "Filename"
//        to the command line where Filename
//        is the full path of the global variables file. If the path contains
//        any spaces, Filename should be enclosed in double quotes.
//        Each line of the global variables files must be either empty,
//        start with the # character to identify the line as a comment or
//        list the name and value of an existing global variable.
//        On a line defining a new value for a global variable, the name
//        of the global variable must be at the beginning of the line
//        must be first followed by one or more spaces followed by the value.
//        A period must be used as the decimal separator. For boolean
//        global variables, the value must be either "True" or "False"
//        (without the quotes). For text variables, the value may optionally
//        be enclosed in quotes.  A global variables may also be saved from
//        the Global Variables dialog box.
//    '2.12.0.26' Bug fix: Contour lines are now drawn at the correct
//        positions on the front and side views when the grid is rotated.
//      Bug fix: (fourth attempt) When more than one instance of
//        ModelMuse was running, sometimes one copy would interfere with the
//        other's temporary files.
//      Bug fix: Fixed a bug in which the Data Sets dialog box sometimes
//        did not prevent the user from setting up a formula that caused
//        a data set to depend on itself.
//    '2.12.0.27' Bug fix: Fixed bug that could cause an assertion failure
//        when coloring the grid with transient data such as the recharge
//        rate.
//      Bug fix (not in released version); global variable and .pval files
//        weren't being imported correctly.
//    '2.12.0.28' Fixed bug in exporting MT3DMS BTN data set A6 when there
//        are more than 40 layers.
//    '2.13.0.0' No additional changes.
//    '2.13.0.1' Bug fix: Fixed a bug that would cause interpolation to fail
//        if an object did not intersect the grid.
//    '2.13.0.2' Enhancement: added support for running MODPATH with
//        a child model in MODFLOW-LGR.
//    '2.13.0.3' Enhancement: added support for visualizing MODPATH output
//        with a child model in MODFLOW-LGR.
//    '2.13.0.4' Bug fix: Fixed labeling of contours when contouring
//        data sets whose data type is Text.
//      Bug fix: fixed labels for TRPT and TRPV in MT3DMS.
//      Bug fix: fixed export of SSM package when no source or sink
//        concentrations have been defined.
//    '2.13.0.5' Bug fix: Fixed bug that would cause an error if the user
//        attempted to display data set values before generating the grid.
//       Bug fix: Fixed a bug that would cause an error if the user attempted
//         to give an aquifer a name that started with a number or a name
//         that was too similar to the name of another aquifer.
//    '2.13.0.6' Change: In the hydmod package, The name of each observation
//         has a unique number added to the end of the label.
//    '2.13.0.7' Bug fix: fixed bug that prevented the LPF options
//         STORAGECOEFFICIENT and CONSTANTCV from being used simultaneously.
//       Enhancement: Added support for the new STOPERROR option in the
//         MODFLOW Basic package.
//       Enhancement: Added support for the new NOPARCHECK option in the
//         MODFLOW LPF package.
//       Enhancement: Added support for the PCGN solver.
//       Change: Changed SFR package to use new SFR format for MODFLOW-2000.
//       Enhancement: Added IFACE to SFR input.
//       Bug fix: fixed a bug that would cause range-check errors in certain
//         MODFLOW-LGR models.
//    '2.13.0.8' Bug fix: Fixed bug that would sometimes cause invalid SFR
//         input files to be created when unsaturated flow was simulated
//         beneath streams.
//       Enhancement: When importing ASCII raster files into a MODFLOW-LGR
//         model, it is now possible to specify the grid to use
//         for the imported data.
//       Bug fix: fixed bug that would sometimes cause the assigning data
//         set values to fail in a MODFLOW-LGR model.
//    '2.13.0.9' Change: Reduced memory usage.
//       Bug fix: Checking elevations in MODFLOW-LGR child models no longer
//         results in a range check error.
//       Bug fix: Fixed problem with reading invalid files.
//    '2.13.0.10' Bug fix: Previously, attempting to display the
//         "Show or Hide Objects" dialog box would sometimes cause an error.
//       Bug fix: In MODFLOW-LGR models, the legend displayed when
//         coloring or contouring would not reflect more extreme values
//         displayed in a child grid.
//       Enhancement: You can now export grid data to a Shapefile for
//         MODFLOW-LGR child grids.
//    '2.13.0.11' Bug fix: Fixed export of IFMTCN, IFMTNP, IFMTRF,
//         and IFMTDP in the MT3DMS basic transport package.
//       Enhancement: You can now use the command line option -mte to export
//         just the MT3DMS input files.
//    '2.13.0.12' Bug fix: when importing a Shapefile to a multipart object,
//         formulas for the Z-coordinate can now be imported properly.
//    '2.14.0.0' No additional changes.
//    '2.14.0.1' Enhancement: Added the ability to export
//         .png and .jpg images.
//       Bug fix: Importing model results for MODFLOW-LGR model and
//         contouring them no longer causes a range-check error.
//    '2.14.0.2' Bug fix: Fixed bug that caused access violations when
//         importing results from a MODFLOW-LGR child model but not the
//         MODFLOW-LGR parent model.
//       Bug fix: Fixed bug in which the Kz data set was not created when
//         a MODFLOW model was first created.
//       Bug fix: Fixed bug that sometimes caused invalid elevation formulas
//         in objects created by importing Shapefiles.
//    '2.14.1.0' Change: Date for the current version of MODFLOW-2005
//         changed to the date for MODFLOW-2005 version 1.9.01.
//    '2.14.1.1' Bug fix: In order to prevent range check errors, it is no
//         longer possible to display the Manage Flux Observations dialog box
//         when MT3D has been selected unless at least one chemical species
//         has been defined.
//       Enhancement: The "Data Sets" dialog box can now remain open
//         while the user works with other parts of ModelMuse. However, it
//         can not remain open when the Object Properties dialog box is open
//         so if the user attempts to open the Object Properties dialog box,
//         The Edit Data Sets dialog box will automatically close.
//       Bug fix: Specifying values of Stress period length,
//         time step multiplier, and initial time step size that would cause
//         the number of time steps to exceed the limits of a 32-bit signed
//         integer causes an error message to the user rather than a bug
//         report.
//       Bug fix: In the object properties dialog box, clicking the button
//         for the formula editor when editing the formula for the Factor
//         in an MT3DMS Flux observation, no longer causes an
//         Assertion failure.
//       Bug fix: In the MODFLOW Packages and Programs dialog box, changing
//         the number of parameters in the UPW package no longer causes an
//         Assertion failure.
//       Enhancement: Tab ordering has been improved.
//    '2.14.1.2' Bug fix: Importing models containing the UZF package
//         in which ET is not simulated, now works properly.
//       Enhancement: X, Y, and Z axes are now drawn in the 3D view.
//       Bug fix: Fixed bug that caused empty .bfh_head and .bfh_flux files
//         to be created in MODFLOW-LGR models when one-way coupling is used.
//       Bug fix: Merely selecting a data set in the Data Visualization
//         dialog box no longer causes the data set values to be calculated.
//         The user must now click "Apply" to cause the data set values to be
//         calculated.
//       Bug fix: Fixed bug importing the Subsidence package
//         from existing models.
//    '2.14.1.3' no real change.
//    '2.14.1.4' Enhancement: Added support for importing the concentration
//         in MT3DMS associated with a sink or source package.
//       Change: In MODFLOW models using the BCF package, the
//         "Vertical_Conductance" data set is renamed "Vertical_Leakance".
//       Enhancement: Reduced the time required to open the Edit Data Sets
//         dialog box in models with large numbers of data sets.
//    '2.15.0.0' Bug fix: Fixed bug in importing Shapefiles that could
//         allow an object to have one or more Z-formulas when setting
//         the value of a layer definition data set.
//       Enhancement: Added partial support for Unicode. Complete support
//         is not possible because the groundwater models do not currently
//         support Unicode.
//       Change: The extension for MT3DMS configuration file changed from
//         ._cnf to .cnf to facilitate viewing the output in Model Viewer.
//    '2.15.0.1' Bug fix: Importing a Global Variables file was from the
//         command line now works properly.
//    '2.15.0.2' Bug fix: fixed a bug that would sometimes cause contouring
//         to fail.
//       Bug fix: Certain shapefiles that were previously rejected by
//         ModelMuse as self-intersecting are now accepted.
//       Enhancement: When importing images .pgw files are now accepted as
//         a valid world file type.
//       Bug fix: Fixed bug in which observation names were allowed
//         to include the '/' character even though that character would
//         not be processed by MODFLOW correctly.
//     '2.15.0.3' Bug fix: Fixed a bug in which attempting to import gridded
//         data using an invalid layer caused an error. Invalid layers can no
//         longer be specified.
//       Enhancement: MT3DMS simulations can now have fewer stress periods
//         than the corresponding MODFLOW model.
//     '2.15.0.4' Bug fix: Fixed bug that caused incorrect stress periods to
//         be exported if the stress periods were changed and the SFR package
//         was in used.
//       Bug fix: Fixed a bug that could cause interpolation to fail.
//     '2.16.0.0' Enhancement: Added 64-bit version for 64-bit operating
//         systems.  TIFF and PCX files are not supported in the 64-bit
//         version.
//       Change: The red background for missing files in the Files to Archive"
//         dialog box has been changed to a red font.
//       Change: The light blue background for a parenthesis and it's
//         match in the formula editor has been changed to a light blue font.
//     '2.16.1.0' Bug fix: Fixed bug that caused importing model results to
//         fail.
//     '2.16.1.1' Bug fix: When exporting ModelMate files, ModelMuse now
//         specifies the correct version of MODFLOW to use.
//       Bug fix: The "Function Help" button on the Formula editor works again.
//     '2.16.1.2' no real change. Converted some text to make it easier to
//         translate.
//     '2.16.1.3' Bug fix: Fixed export and import of head change
//         observations to ModelMate.
//     '2.16.1.4' no change.
//     '2.16.1.5' Bug fix: Fixed bug in export of gages for the Lake package.
//       Bug fix: Fixed bug in export of Shapefiles in which the last
//         character of the last field was not written to the file.
//       Bug fix: Fixed export of unit numbers for lake gages.
//     '2.16.1.6' (Changed version of GLScene used to 5991.)
//     '2.16.1.7' no real change.
//     '2.16.1.8' Bug fix: Renaming parameters for the HUF package now
//         causes any formulas based on data arrays for those parameters
//         to be updated.
//       Enhancement: Added support for MODPATH version 6.
//       Change: Head observations that are at the end of a steady-state
//         stress period now have their reference stress period set to that
//         stress period rather than the beginning of the following
//         stress period.
//     '2.16.1.9' Change: Updated link for model archiving policy.
//       Bug fix: Fixed display of file names in the Files to Archive
//         dialog box.
//       Bug fix: The name file for MODFLOW models is now included in
//         archives.
//       Bug fix: Fixed import of binary Surfer grid files.
//     '2.16.1.10' Enhancement: Added support for exporting data set values
//         for display in Model Viewer.
//     '2.16.1.11' Bug fix: Fixed coloring the grid for certain PHAST data
//         sets.
//     '2.16.1.12' Bug fix: Fixed display of layer numbers on the status bar
//         for the front and side views. {Bug not in released version.}
//       Bug fix: fixed bug in export of MODPATH version 6 input
//         (Bug not in released version.)
//     '2.16.1.13' Bug fix: Fixed how the "Child Models" dialog box for
//         MODFLOW-LGR models responds to the user entering an invalid number
//         for NCPP.
//       Bug fix: Fixed bug that could cause some MODFLOW budget files to
//         be incorrectly identified as invalid.
//     '2.16.1.14' Bug fix: Fixed detecting the version number of MODPATH
//         used to create a pathline file. (Bug not in released version.)
//       Bug fix: Fixed display of endpoints, pathlines and time series data
//         from MODPATH on the front and side views when the grid is rotated.
//     '2.16.1.15' Bug fix: Fixed bug that caused too much memory to be used
//         when exporting the SSM package in MT3DMS.
//     '2.16.1.16' Bug fix: Fixed bug that caused exporting the SSM file in
//         MT3DMS to take more time than it should have.
//     '2.16.1.17' Enhancement: The Selection Cube for the top view of the
//         model draws the grid outline only for simulated layers.
//       Bug fix: Fixed bug that could cause an error in the export of the
//         MT3DMS TOB package if duplicate times were specified.
//     '2.17.0.0' No further changes.
//     '2.17.1.0'  Bug fix: Fixed bug in which objects were not drawn as
//         selected after clicking the OK button in the Object Properties
//         dialog box.
//       Bug fix: The tree control in the Show Or Hide Objects dialog box
//         no longer collapses all its nodes just because there has been a
//         change in which object is selected.
//       Bug fix: The display of the data for the RCH, EVT and ETS packages
//         has been fixed.
//     '2.17.1.1' Enhancement: Added support for PHIRAMP in the
//         Well package of MODFLOW-NWT.
//       Bug fix: Fixed export of starting locations file for MODPATH version
//         6 when no starting locations have been defined for some objects.
//       Bug fix: Fixed export of MODPATH with MODFLOW-LGR child models
//         when the MODPATH options differ between the parent and child
//         models.
//     '2.17.1.2' Bug fix: Fixed problem with editing objects in
//        translated version of ModelMuse.
//     '2.17.1.3' No real change.
//     '2.17.1.4' Bug fix: Attempting to read a head observation file in
//         which some of the numbers are invalid now results in an error
//         message to the user instead of a bug report.
//       Enhancement: When exporting objects as Shapefiles, you can now export
//         the formulas for many but not all MODFLOW Features.
//     '2.17.1.5' Bug fix: In the MODFLOW Layers dialog box, deleting
//         sublayers graphically now works correctly.
//       Bug fix: Fixed bug in importing the MNW2 package from existing
//         models.
//     '2.17.1.6' Bug fix: If a pathline just has a single point, it is now
//         drawn as a single point instead of being skipped.
//       Bug fix: In the grid value dialog box, data for MODPATH pathlines
//         and endpoints are now displayed for child models in MODFLOW-LGR
//         models.
//       Bug fix: When exporting images with MODFLOW-LGR models, MODPATH
//         pathlines and other data can now be displayed for child models.
//       Bug fix: Streamlinks of MODFLOW-LGR child models are now displayed.
//       Bug fix: Fixed export of locations of pval and jtf file names to
//         ModelMate when the model files are in a different directory from
//         the ModelMuse file. (More changes in version 2.17.1.7.)
//       Enhancement: Added support for exporting head observations to
//         Shapefiles. (This is an extension of the enhancement in version
//         2.17.1.4.)
//     '2.17.1.7' Bug fix: Fixed export of ModelMate files when the model
//         files are in a different directory from the ModelMuse file.
//     '2.17.1.8' Enhancement: The Grid Value dialog box was modified to
//         allow multiple tabs to be displayed simultaneously.
//     '2.17.1.9' Bug fix: In the MODFLOW Layers dialog box, setting custom
//         sub discretizations for layer groups now works properly.
//     '2.17.1.10' Bug fix: Added support for IUNITRAMP in data set 2B of the
//         well package of MODFLOW-NWT. (Bug not in released version.)
//     '2.17.1.11' Bug fix: Fixed bug in exporting Shapefiles. Each record
//         for the shapefile in the .dbf file now includes a space for
//         indicating whether a record is deleted or not.
//     '2.17.1.12' Bug fix: Fixed bug in exporting the TOB file for MT3DMS
//         when no concentration observations are defined.
//     '2.17.1.13' Bug fix: Fixed updating of the initial NWT values.
//         (Bug not in released version.)
//       Bug fix: Fixed bug that caused ModelMuse to crash when it
//         first starts on some systems. (Bug in GLScene fixed by updating
//         GLScene to the latest version from SVN.)
//       Bug fix: Fixed bug displaying 3D view on Windows 8.
//     '2.17.1.14' Enhancement: Added new function for use in Formulas:
//         Closest. See the ModelMuse help for details.
//       Enhancement: Added the ability to import binary grid files created
//         by T-PROGS.
//     '2.17.1.15' Bug fix: Fixed bug that caused ModelMuse to crash when
//         changing the number of rows, columns or layers in the grid.
//     '2.17.1.16' Bug fix: Fixed bug in adding new data sets when child
//         models from a MODFLOW-LGR model have been created but the
//         model is no longer a MODFLOW-LGR model.
//       Enhancement: Changes to the file format of the MNW2 package in
//         MODFLOW-NWT are now supported.
//     '2.18.0.0' Bug fix: Fixed bug that would cause divide-by-zero errors
//         when calculating Interlayer Kz in the HUF package if some of the
//         data was not properly defined.
//     '2.18.0.1' Bug fix: Fixed bug that caused ModelMuse to hang on
//         some computers when using the search function in the ModelMuse
//         help.
//       Bug fix: Fixed bug that allowed an attempt to be made to export the
//         PHAST input file even if the grid was not yet defined.
//       Bug fix: Fixed bug that sometimes incorrectly prevented the user
//         from importing the shapes in a Shapefile as a single multipart
//         object.
//     '2.18.0.2' Bug fix: Fixed bug in export of RCH package when parameters
//         are used but the layer is not time-varying.
//     '2.18.0.3' Change: the user can now cut and paste data from the
//         Imported Data tab of the Object Properties dialog box.
//     '2.18.0.4' Bug fix: Fixed a bug that would cause an error opening a
//         ModelMuse file if an object used in the definition of a flux
//         observation had been deleted.
//     '2.18.1.0' Bug fix: Fixed bug that allowed MT3DMS to have zero stress
//         periods defined.
//     '2.18.1.1' Bug fix: Attempting to import a file as a Surfer Grid file
//         when it really is not one now results in an error message to the
//         user instead of a bug report.
//       Change: ModelMuse will no longer use the XSECTION option in the
//         Basic package if MODPATH is active because MODPATH version 6
//         does not support the XSECTION option.
//       Bug fix: If the user attempts to import a TProgs file before
//         creating a grid, an error message is displayed to the user instead
//         of generating a bug report.
//       Bug fix: The following functions all had bugs which have been
//         corrected: ObjectCurrentVertexX, ObjectCurrentVertexY,
//         ObjectCurrentVertexZ, ObjectCurrentSegmentAngle,
//         ObjectCurrentSegmentAngleDegrees,
//         ObjectCurrentSegmentAngleLimitedDegrees,
//         ObjectCurrentSegmentLength
//       Bug fix: Fixed bug in checking parameters in the SFR package that
//         could cause ModelMuse to crash or to incorrect error messages.
//     '2.18.1.2' Bug fix: Fixed bug that could cause math errors when
//         coloring data sets by the logarithm of their values.
//       Failed Bug fix: Fixed bug that could cause extra stress periods of
//         negligible length to be generated when exporting from the 64-bit
//         version of ModelMuse.
//     '2.18.1.3' Bug fix: Fixed evaluating objects on rotated cross sections
//         in SUTRA. Bug not in released version.
//     '2.18.1.4' Made changes for SUTRA.
//     '2.18.1.5' Failed Bug fix: Fixed bug that could cause extra stress
//         periods of negligible length to be generated when exporting from
//         the 64-bit version of ModelMuse.
//     '2.18.1.6' Change: When importing Shapefiles, if the number of
//         Z-Formulas is set to 1 or 2, any new data sets that are created
//         will be 3D data sets.
//       Bug fix: Fixed bug that could cause extra stress periods of
//         negligible length to be generated when exporting from the 64-bit
//         version of ModelMuse.
//     '2.18.1.7' Bug fix: Fixed sampling of DEM data.
//     '2.18.1.8' No real change.
//     '2.18.1.9' Bug fix: When saving ModelMuse projects to text files
//         such as .gpt or .xml files, real numbers that were close to but
//         not equal to zero were saved as zero.
//       Bug fix: If the user enters an invalid formula for the Z coordinates
//         of an object, ModelMuse will now display an error message to the
//         user instead of generating a bug report.
//       Bug fix: Editing objects that defined streams in the SFR package
//         when SFR parameters are defined works properly now.
//     2.18.1.10' Bug fix: If ModelMuse is unable to save an ini file, it
//         displays a warning message to the user instead of generating a
//         bug report.
//       Bug fix: Attempting to merge point objects no longer results in
//         a bug report. However, point objects can not be merged.
//       Bug fix: Fixed a bug that sometimes caused an error when ModelMuse
//         was shutting down.
//    '2.18.1.11' Bug fix: Fixed bug that prevented layer elevations from
//         being updated correctly.
//    '2.18.1.12' Bug fix: Fixed bug that caused an error if two components
//         in MT3DMS were given the same name. Now if the user attempts to
//         assign the same name to more than one component in MT3DMS,
//         only the first one is accepted. The others are deleted.
//    '2.18.1.13' Enhancement: Added new contouring method based on
//         the Association for Computing Machinery (ACM) algorithm 651.
//       Enhancement: Added the ability for the user to add a custom
//         coloring scheme for coloring the grid or for contour lines.
//       Enhancement: Added support for the NOPRINT option in observation
//         files.
//    '2.18.1.14' Change: When drawing contour lines, a white background is
//         now drawn behind the contour labels.
//    '2.19.0.0' No additional changes.
//    '2.19.0.1' Bug fix: Attempting to import a .dxf file that is locked
//         by another program will result in an error message to the user
//         instead of generating a bug report.
//       Bug fix: Fixed bug that caused problems on computers in which the
//         decimal symbol is not a period when closing the "MODFLOW
//         Packages and Programs" dialog box.
//       Bug fix: When reading an empty endpoint file, ModelMuse now displays
//         a warning message to the user instead of generating a bug report.
//    '2.19.0.2' Bug fix: When an object is defining multiple values at the
//         same cell or element, holes in the object no longer define such
//         values. An example would be an object that defines wells in MODFLOW
//         with an object that contains multiple sections and in which some
//         of those sections define holes.
//       Change: A new checkbox has been added to the "Object Properties"
//         dialog box labeled "Duplicates <cells/elements> allowed. It is
//         checked by default. Under some conditions, a single object can
//         allow multiple values to be assigned at a single cell.
//         For example, in MODFLOW models, an object might define two or
//         more wells at a single cell by having two separate point sections
//         that are in the same cell. This ability can be turned off by
//         unchecking this check box.
//    '2.19.0.3' Bug fix: Fixed bug that could cause ModelMuse to hang when
//         importing an existing MODFLOW-2005 model.
//    '2.19.0.4' Bug fix: Fixed bug introduced in '2.19.0.2'. Not in released
//         version.
//    '2.19.0.5' Bug fix: Fixed bug in limiting display of MODPATH end points
//         with tracking time.
//       Change: On some computers, bugs are encountered related to
//         the 3D view. The 3D view is hidden on such computers to allow the
//         program to continue running.
//    '2.19.0.6' Bug fix: Fixed bug that would cause access violations when
//         generating the input file for the UZF package if a flow package
//         other than the LPF or UPW was used.
//    '2.19.1.0' No additional changes.
//    '2.19.1.1' Bug fix: Changes to the "Print input cell lists" option
//         in the MODFLOW Output Control dialog box were not saved.
//    '2.19.1.2' Bug fix: Fixed handling of the RCH, EVT, and ETS package
//         in cases where parameters are defined but no parameters are used
//         for one or more stress periods.
//       Bug fix: Fixed handling of attempts to read DEMs that are in the
//         wrong format.
//       Bug fix: fixed bug in importing head and drawdown results from
//         profile models.
//    '2.19.1.3' Enhancement: The "Show or Hide Objects" dialog box now
//         displays the cell or element size that an object specifies.
//       Bug fix: A bug report is no longer generated if when attempting
//         to finish adding a new closed section to an object the final
//         edge of the new section crosses one of the earlier edges of the
//         same section of the object. Instead an error message is displayed
//         to the user.
//       Bug fix: Attempting to import an empty results file for MODFLOW
//         should no longer generate an I/O error.
//       Enhancement: The menu item Data|Delete Model Results has been added.
//         It deletes all the data sets and objects for the model results.
//       Bug fix: ModelMuse now displays an error message in the
//         Formula Errors dialog box when a data set formula is invalid
//         in some cases where it would previously generate a bug report.
//    '2.19.1.4' Bug fix: Fixed creating child models in which global
//         variables are used in some data sets.
//    '2.19.1.5' Same bug fix as in '2.19.1.4' -- Correct this time.
//    '2.19.1.6' Bug fix: Fixed bug with Natural Neighbor Interpolation that
//         could cause ModelMuse to enter an infinite loop.
//       Bug fix: Fixed a bug that caused inconsistencies in data set values
//         between parent and child models if the values were assigned by
//         interpolation. Previously, data points outside the grid might
//         not be assigned the correct values.
//    '2.19.1.7' Enhancement: When contouring data, the user can now specify
//         the contour interval easily.
//       Bug fix: When specifying contour values, the user no longer has to
//         specify the values in the correct order.
//    '2.19.1.8' Enhancement: Sorting of observation names in the
//         Data Visualization dialog box has been improved.
//       Enhancement: There is now a button for copying the observations
//         in the Data Visualization dialog box to the clipboard.
//    '2.19.1.9' Bug fix: Fixed bugs that resulted in invalid file names when
//         MT3DMS component names contained non-alphanumeric characters.
//    '2.19.1.10' Bug fix: If after importing data, the imported data becomes
//         corrupted, it is now possible to save the file although the
//         imported data will not be saved.
//    '2.19.1.11' Enhancement: The default value for the grid cell size shown
//         in the object properties dialog box is now set to a reasonable
//         value based on the dimensions of the model area.
//       Bug fix: Fixed bug in the "Delete Model Results" command
//         that invalidated formulas incorrectly. Not in released version.
//    '2.19.1.12' Bug fix: Fixed bug in displaying the Show/Hide Objects
//         dialog box when drain return objects were not defined properly.
//    '2.19.1.13' Change: Changing the name of a "Model Results" data set
//         will now cause it to be listed under "User Defined" data sets.
//       Enhancement: Added ArcTan function.
//       Bug fix: When saving the settings for an image, specified contour
//         intervals are now saved properly.
//       Bug fix: Selecting "Data|Delete Models Results" for a model that
//         contains no model results no longer results in an error.
//       Bug fix: Displaying pathline or time series files from MODPATH with
//         very large coordinate values no longer causes ModelMuse to crash.
//         (The large coordinate values may indicate that the particle is
//         trapped in a dry cell.)
//       Bug fix: When creating contours with the ACM 626 contouring
//         method, contouring values of head in models in which some cells
//         have gone dry no longer causes and error.
//    '2.19.1.14' Bug fix: ModelMuse no longer displays an error message
//         about no parameters being used in a stress period unless recharge
//         parameters have been defined.
//       Enhancement: Added ability to use concentrations from a previous run
//         as initial concentrations for new run in MT3DMS.
//    '2.19.1.15' Bug fix: If an object has no vertices, ModelMuse no longer
//         attempts to use it in interpolation.
//    '2.19.1.16' Bug fix: Under rare circumstances, ModelMuse would
//         sometimes generate a bug report when a model was first opened
//         due to a variable not yet having been updated.
//       Bug fix: Fixed a bug sometimes encountered when a user attempts
//         to import an invalid DEM.
//       Bug fix: When a model contains non-simulated layers, the layer
//         numbers in multilayer head observations are now assigned correctly.
//       Enhancement: It is now possible to export MNW2 data for objects
//         to Shapefiles.
//    '2.19.1.17' Bug fix: Fixed editing of lake bathymetry file.
//    '2.19.1.18' Bug fix: fixed bug that caused access violations when
//         opening the MODFLOW Packages and Programs dialog box.
//       Enhancement: ModelMuse can now import MODFLOW-NWT models.
//    '2.19.1.19' Bug fix: Fixed bug importing Horizontal Flow Barrier
//         package from existing models that could result in the extra
//         flow barriers being included in the model.
//    '2.19.1.20' Enhancement: ModelMuse now compares drain elevation,
//         river stage and GHB head to the cell bottom elevation and
//         generates a warning or error message if the cell bottom elevation
//         is higher than the boundary value.
//    '2.19.1.21' Enhancement: Added support for STR and STOB packages.
//       Bug fix: Fixed bug that caused errors when editing the grid so that
//         it had only one grid line.
//    '2.19.1.22' Bug fix: Fixed bug in displaying Data Visualization
//         dialog box.
//    '2.19.1.23' Change: In the HYDMOD package, ModelMuse no longer
//         generates repeated data if two SFR reaches are in the same cell.
//       Enhancement: when exporting objects to shapefiles that contain
//         data for the MNW2 package, the time-varying data can now be
//         exported.
//    '2.19.1.24' Enhancement: Improved handling of errors in importing
//         DXF files.
//       Enhancement: MODFLOW Program Locations dialog box redesigned to
//         show only the programs used in the model.
//       Bug fix: fixed bug that caused an error when undoing a change
//         in the MODFLOW Packages and Programs dialog box when horizontal
//         flow barriers had already been defined.
//    '2.19.1.25' Enhancement: Added support for MODFLOW-LGR version 2.
//    '2.19.1.26' Bug fix: Fixed bug that caused errors when editing
//         objects that define SFR boundaries.
//    '2.19.1.27' Change: When importing existing models, the elevations
//         used to assign boundary conditions cells to layers are now
//         set to a value close to the top of the layer instead of the
//         center of the layer to facilitate converting the model to
//         a MODFLOW-LGR model.
//       Change: When importing existing models, objects used to define
//         boundaries in the CHD, RIV, DRN, DRT, and GHB packages now consist
//         of polygon sections rather than point sections to facilitate
//         converting the model to a MODFLOW-LGR2 model.
//       Bug fix: Fixed a bug that could cause access violation when coloring
//         the grid or exporting MODFLOW input files.
//       Enhancement: Speed up export of model input
//       Bug fix: Fixed bug that could cause errors when displaying values
//         for the Drain, GHB, or River boundaries if the corresponding
//         observation package is used.
//       Bug fix: Fixed bug that could cause circular reference errors when
//         interpolating data.
//       Bug fix: fixed bug in Natural Neighbor interpolation method that
//         could cause divide by zero errors.
//    '2.19.1.28' Change: Objects are now only allowed to assign data set
//         properties by interpolation if they have zero elevation formulas.
//    '2.19.1.29' Bug fix: Fixed import of multiplier and zone array names
//         when the name listed in a cluster is longer than 10 characters.
//    '2.19.1.30' Bug fix: Fixed bug that caused data for the SFR package to
//         be lost if multiple objects were edited and some of them were
//         defining streams in the SFR package and others were polygon
//         objects.
//    '2.19.1.31' Change: the Object Properties dialog box to uses fewer
//         Windows resources.
//    '2.19.1.32' Bug fix: Improved drawing of pathlines from MODPATH
//         version 6. Pathline segments are now drawn if segments that end at
//         the edge of either the previous or next column, row, or layer so
//         long as the segment crosses the current column, row, or layer.
//         This change also applies to MODPATH version 5 with respect to
//         layers but not rows or columns.
//    '2.19.1.33' Enhancement: Added support for the FHB package.
//       Bug fix: Divide by zero errors should now result in an error
//         message instead of a bug report.
//       Bug fix: Fixed importing MNW2 package from existing models when the
//         model contains non-simulated layers.
//       Bug fix: Fixed export of UZF package input when output to the
//         listing file is specified.
//    '2.19.1.34' Bug fix: Fixed export of MNW2 package in models with
//         non-simulated layers.
//    '2.19.1.35' Bug fix: Fixed bug that could cause exporting the SFR
//         package input file to fail.
//       Bug fix: Fixed bug that could make it impossible to open the
//         Object Properties dialog box with large models.
//       Bug fix: Fixed bug that could make it impossible to open objects
//         that define streams in the SFR package in the Object Properties
//         dialog box.
//    '2.19.1.36' Change: ModelMuse now will only generate up to 1000
//         error or warning messages of any one type.
//    '2.19.1.37' Enhancement: When importing a Surfer Grid file, the
//         imported data points can be filtered to reduce the number of
//         points imported.
//       Bug fix: Fixed backwards compatibility issue with SUTRA
//         (not in released version)
//    '2.19.1.38' Bug fix: Fixed display of legend for contour lines
//         when the contour colors are not specified directly.
//    '2.19.1.39' No Change.
//    '3.0.0.0' Bug fix: Fixed bug in interpolating.
//       Enhancement: Added support for SUTRA.
//    '3.0.0.1' Bug fix: Fixed using .ucn files to specify the initial
//         concentration in MT3DMS.
//    '3.0.0.2' Change: If the Application Directory on a computer is blocked,
//         ModelMuse will attempt to use the directory in which the program
//         is installed instead.
//    '3.0.0.3' no real change.
//    '3.0.0.4' Fixed reading certain real numbers when opening a file on
//         a computer in which the decimal separator is not a period.
//    '3.0.0.5' Fixed Checkbox bug in TRbwDataGrid4. Not in released version.
//    '3.0.0.6' No released changes.
//    '3.0.0.7' Enhancement: If the initial step size for MT3DMS is larger
//         than the maximum step size, the backgrounds of the cells in the
//         table on the MODFLOW Times dialog box are colored in red.
//       Bug fix: Fixed bug in display of assigned layer in the RCH, EVT,
//         and ETS packages.
//    '3.0.0.8' No released changes.
//    '3.0.0.9' Enhancement: The length of a MODPATH pathline is
//         now displayed in the Grid or Mesh Value dialog box.
//    '3.0.0.10' Bug fix: Fixed linkage to help system for the
//         SUTRA Fluid Sources pane of the Object Properties dialog box.
//       Bug fix: Fixed resizing panels on the Export Image dialog box.
//       Bug fix: The Manage Parameters dialog box now enforces the
//         10 character limit on parameter names instead of generating a
//         bug report if the number of characters in a parameter name is
//         greater than 10 characters.
//       Enhancement: ModelMuse can now paste contours from Argus ONE as
//         objects in ModelMuse. Only the geometry is transferred; contour
//         values are not transferred.
//    '3.0.0.11' Enhancement: ModelMuse can now use and online version of
//         the help.
//    '3.0.0.12' Bug fix: Fixed bug that could cause assertion failures
//         when interpolating.
//    '3.0.0.13' Bug fix: Fixed bug that resulting in X_Prime and Y_Prime
//         being exported to Shapefiles and CSV files instead of X and Y.
//    '3.0.0.14' bug not in released version. Bug fix: Fixed bug in labeling
//         headers when exporting CSV files.
//    '3.0.0.15' Bug fix: fixed bug that could cause an access violation when
//         opening one of the recently opened files listed in the File menu.
//    '3.0.0.16' Change: The starting unit number for GAGE, MNWI, and UZF
//         output files has been changed from 205 to 20205 to avoid potential
//         conflicts with the COC package.
//    '3.0.0.17' Enhancement: Added support for MODFLOW CFP.
//    '3.0.0.18' Bug fix: not in released version. Fixed pasting Argus ONE
//         contours into ModelMuse when not all the contours on a layer
//         were copied to the clipboard.
//    '3.0.0.19' Bug fix: Fixed bug that would cause and access violation if
//         The Mesh Information dialog box was displayed for a 3D SUTRA
//         mesh before any layer groups had been defined.
//    '3.0.0.20' Enhancement: The display of head observation residuals can
//         now be limited by layer.
//       Enhancement: The Head observation can now be exported to Shapefiles.
//    '3.1.0.0' Bug fix: Specifying a file of the wrong type on the command
//         line when starting ModelMuse no longer leads to the generation
//         of a bug report.
//    '3.1.1.0' Bug fix: Fixed bug that could cause an access violation when
//         opening the Object Properties dialog box.
//       Bug fix: Fixed using objects on the front or side views to define
//         pipes in MODFLOW-CFP.
//    '3.1.1.1' Bug fix: In the Manage Head Observations dialog box, the
//         Statistic was set incorrectly.
//       Bug fix: Fixed bug in import of 1 layer model that used parameters
//         in the LPF package.
//       Bug fix: Fixed bug in displaying the MODFLOW Packages and Programs
//         dialog box.
//       Bug fix: Fixed bug in displaying the Object Properties dialog box.
//       Bug fix: fixed bug that would cause access violations when
//         contouring data.
//       Change: Whenever a new version of ModelMuse is used, it will attempt
//         to also use the newest version of ModelMonitor.
//    '3.2.0.0' Enhancement: Added support for SWI2 package.
//    '3.2.0.1' Bug fix: In MODFLOW-LGR and MODFLOW-LGR2 models, the display
//         of data set values for child models when those values should be
//         set using parameters has been fixed.
//    '3.2.1.0' No additional changes.
//    '3.2.1.1' Bug fix: fixed bug in determining tributaries in the STR
//         package.
//       Bug fix: Fixed display of transient data when the specified time
//         is the first time in a stress period.
//       Bug fix: fixed bug that could cause ModelMuse to enter an infinite
//         loop when using the ACM 626 method to draw contour lines.
//       Bug fix: ModelMuse can now handle a data set that has an invalid
//         formula when first opening the model.
//       Bug fix: Fixed bug importing MODFLOW models containing specified
//         heads defined by both the CHD package and negative IBOUND values.
//    '3.2.1.2' Bug fix: Fixed bugs related to editing and exporting CFP
//         information.
//       Bug fix: Fixed bug the could cause and access violation when
//         switching to a SUTRA model.
//    '3.2.1.3' Bug fix: Fixed generation of time schedules in SUTRA when
//         one or more of the times is larger than the largest possible
//         single precision number.
//       Bug fix: Fixed export of time information for MT3DMS.
//       Bug fix: Fixed export of MODFLOW flow observation factors when the
//         formula for the factor uses the layer, row, or column number.
//       Enhancement: When displaying data or head observation results,
//         the root mean square residual is displayed in the
//         Data Visualization dialog box.
//       Enhancement: In the Show and Hide Objects, dialog box, the head
//         observation group name is displayed with head observations.
//     '3.2.1.4' Bug fix: Fixed display of Data Visualization dialog box.
//         (not in released version.)
//     '3.2.1.5' Change: The formula used for 3D data sets when importing
//         model results has been changed;
//     '3.2.1.6' Bug fix: Entering an invalid maximum or minimum value to
//         display in the Data Visualization dialog box no longer results
//         in a bug report.
//       Bug fix: Fixed importing model results with MODFLOW-LGR
//         and MODFLOW-LGR2 models.
//       Bug fix: If a formula for the pumping rate in a MODFLOW well results
//         in a math error such as a division by zero error, An error
//         message is displayed in the Errors and Warnings dialog box
//         instead of generating a bug report.
//     '3.2.1.7' Bug fix: ModelMuse now saves the location of MODFLOW-LGR2.
//     '3.2.1.8' Bug fix: Fixed bug related to editing data for
//         conduit recharge.
//     '3.2.1.9' Change: In MODFLOW-LGR and MODFLOW-LGR2 models, child
//         models are now only displayed on the front and side views if the
//         selected row or column of the parent model intersects the child
//         model.
//       Enhancement: When importing model results from MODFLOW-LGR2 models,
//         ModelMuse now does a better job of selecting default names for
//         the model result files for the child models.
//     '3.2.1.10' Bug fix: Fixed the process of deleting and undoing the
//         deletion of child models in MODFLOW-LGR and MODFLOW-LGR2.
//     '3.2.1.11' Bug fix: Fixed reading Shapefiles with 32-bit version of
//         ModelMuse. (Not broken in 64-bit version.)
//     '3.2.1.12' Bug fix: In the Global Variables dialog box, clicking
//         where there isn't a cell, no longer causes an error.
//       Bug fix: Fixed drawing fishnet mesh elements in SUTRA models.
//       Bug fix: Fixed drawing objects in 2D SUTRA models.
//     '3.2.1.13' Enhancement: VertexValue function added.
//       Bug fix: Fixed export of FHB package input file when only flows
//         or only heads were specified in the package.
//       Bug fix: Fixed specification of FHB flow and head values to allow
//         formulas to be used for the flows or heads.
//     '3.2.1.14' Bug fix: Fixed import of models in which routing to
//         steams or lakes is defined in the UZF package but the lake and SFR
//         packages are not active.
//       Enhancement: added a method for importing multiple gridded data
//         files at one time.
//       Bug fix: fixed a bug that incorrectly prevented the deletion of
//         selected points from complicated polygon objects.
//     '3.2.1.15' Enhancement: Added the capability to import quadrilateral
//         meshes generated by Argus ONE for use in SUTRA.
//     '3.2.1.16' Bug fix: (not in released version) Fixed enabling import
//         of SUTRA mesh.
//     '3.2.1.17' Bug fix: Fixed import of MODFLOW models containing the
//         SFR input files that use external flow files.
//     '3.2.1.18' Bug fix: Fixed visualization of boundary conditions in
//         SUTRA models.
//     '3.2.1.19' Enhancement: Added ability to display labels with objects.
//       Enhancement: Added a plot of simulated versus observed values for
//         head observation results.
//     '3.2.1.20' Bug fix: in some cases creating a contour plot of SUTRA
//         data caused ModelMuse to crash.
//       Enhancement: Creating contour plots of SUTRA data is faster.
//     '3.2.1.21' Bug fix: Fixed display of vectors in SUTRA.
//       Bug fix: Fixed generation of error message is an invalid formula
//         is used with SUTRA boundary conditions.
//     '3.2.1.22' Bug fix: Cross sections no longer plot heads equal to HDRY
//         in MODFLOW models.
//     '3.2.1.23' No real change.
//     '3.2.1.24' Bug fix: not in released version. Fixed plotting
//         cross sections for 2D data sets.
//     '3.2.1.25' Bug fix: Fixed vertical exaggeration in top view when
//         switching from a SUTRA profile model to any other sort of model.
//       Bug fix: Fixed range check error when editing SUTRA boundary
//         conditions.
//     '3.2.1.26' Bug fix: Fixed bug that could cause an assertion failure
//         when assigning values to a data set.
//     '3.2.1.27' Bug fix: Attempting to export a Shapefile when the
//         database file is in use, now results in an error message to the
//         user instead of a bug report.
//     '3.2.1.28' Bug fix: Fixed bug that could cause a range check error
//         in SUTRA models with large numbers of nodes.
//     '3.2.1.29' Enhancement: Improved speed of displaying object properties
//         for SUTRA models in the Object Properties dialog box.
//     '3.2.1.30' Change: ModelMuse no longer checks for certain
//         discrepancies in the SFR package input files when importing
//         existing models. The change allows such models to be imported
//         for the purpose of visualizing them. However, it will not be
//         possible to run such models from ModelMuse until the discrepancies
//         are resolved.
//     '3.2.1.31' Enhancement: Added support for importing model results data
//         from .bcof, .bcos, .bcop, or .bcou SUTRA output files into
//         ModelMuse.
//     '3.2.1.32' Enhancement: Added support for the Surface Water Routing
//         process (SWR).
//     '3.2.1.33' Minor bug fixes not in released version.
//     '3.2.1.34' Bug fix: not in released version. Fixed import
//         from .bcof, .bcos, .bcop, or .bcou SUTRA output files
//         when more than one time step was selected.
//     '3.2.1.35' Bug fix: Attempting to import a locked Shapefile now
//         results in an error message to the user rather than a bug report.
//     '3.2.1.36' Bug fix: When importing existing models, cell top and
//         bottom elevations are now imported correctly.
//     '3.2.1.37' Enhancement: When importing model results for a MODFLOW
//         model, it is now possible to select all the data of a certain
//         type or a certain time step by checking a single check box.
//     '3.2.1.38' Enhancement: When importing existing MODFLOW models that
//         have invalid tributary numbers in the STR package, ModelMuse
//         now generates a warning message to the user instead of a bug
//         report.
//     '3.2.1.39' Bug fix: Importing stream observations from existing models
//         now works correctly when the same segment is part of more than
//         one observation.
//     '3.2.1.40' Enhancement: If there is an error importing and existing
//         MODFLOW model, the error message dialog box will show the console
//         lines generated by MODFLOW importing program as an aid to
//         diagnosing the problem.
//       Bug fix: Fixed editing of SFR channel data when a cross section
//         was not required.
//     '3.2.1.41' Bug fix: Fixed bug in importing existing models with
//         multilayer head observations.
//       Bug fix: Fixed bug that could cause ModelMuse to crash because of
//         a stack overflow.
//     '3.2.1.42' Enhancement: Improved checking of layer heights in MODFLOW
//         models.
//       Bug fix: Fixed a bug that could cause a stack overflow when closing
//         ModelMuse.
//       Bug fix: Sometimes it is impossible to save a very large model as
//         a ModelMuse text file (.gpt). Now, if an error occurs in
//         converting the file from the binary to the text format, the user
//         is prompted to save the file as a binary file.
//       Bug fix: Output files from MODPATH version 5 are now archived.
//     '3.3.0.0' Enhancement: The Global variables dialog box has been
//         converted to a non-modal dialog box.
//     '3.3.0.1' Bug fix: It is now possible to paste data from the clipboard
//         into a table in the "Import Gridded Data" dialog box when the
//         data set into which the data is imported is a boolean data set.
//       Bug fix: A corrupted name for MODFLOW or another model no longer
//          prevents the MODFLOW Program Locations dialog  box from being
//          opened.
//     '3.3.0.2' Bug fix: (Not in released version). Fixed bug in setting
//         formulas for objects that define SFR streams and MNW2 wells.
//     '3.3.0.3' Bug fix: When the user imports a mesh, the mesh may have
//         errors in it such as nodes that are not part of any element or
//         elements whose nodes are in a clockwise rather than
//         counterclockwise orientation. ModelMuse now fixes such errors.
//       Bug fix: ModelMuse now displays an error message instead of
//         generating a bug report when attempting to import a raster
//         file before generating a grid or mesh.
//     '3.3.0.4' Bug fix: Fixed bug that could cause the SUTRA mesh to be
//         corrupted if it was renumbered.
//       Bug fix: Fixed bug that could cause an access violation when
//         clicking on the graph of head observation results.
//     '3.3.0.5' Bug fix: fixed bug that could cause an assertion failure
//         when editing an object with corrupted or missing imported values.
//     '3.3.0.6' Bug fix: Fixed bug when attempting to import a model from a
//         directory in which the user does not have write privileges.
//     '3.3.0.7' Bug fix: Fixed bug that would cause an access violation in
//         the Global Variables dialog box if it wasn't closed after
//         clicking the Apply button.
//     '3.3.0.8' Bug fix: Fixed bug that could cause and assertion failure
//         in models with a stress period with a length of zero.
//       Bug fix: During grid generation, if the number of cells is too large,
//         an error message will be displayed and grid generation will be
//         canceled.
//       Enhancement: During grid generation, if the number of cells in
//         the new grid will be larger than 1,000,000, a warning message
//         will be displayed and the user will be give an opportunity to
//         cancel grid generation.
//     '3.3.0.9' Enhancement: The user can now specify the spacing between
//         contours labels.
//       Enhancement: The user can now control the spacing of contour labels.
//       Enhancement: In the Export Image dialog box, the font used for the
//         scale can be changed.
//       Bug fix: In the Export Image dialog box, contour labels are now
//         drawn over the entire image.
//     '3.3.0.10' Enhancement: Added support for generating meshes for SUTRA
//         using Gmsh.
//     '3.3.0.11' Bug fix: Fixed bug importing the the reach length in the
//         SFR package in models in which some reaches in segments with
//         multiple reaches were on a different layer from other reaches.
//       Bug fix: Fixed a bug that could cause access violations when
//         exporting the SFR input file.
//       Bug fix: Fixed a bug that could cause data set values to be
//         calculated incorrectly  or a variety of other errors due to
//         mishandling of temporary files.
//       Enhancement: ModelMuse now warns about linkages between SFR
//         segments that are separated by more than one row or column.
//       Bug fix: Fixed bug that could cause program locations to incorrectly
//         revert to their default values.
//    '3.4.0.0' Enhancement: ModelMuse will now warn the user if no values
//         are assigned for some types of data that vary with time.
//       Bug fix: Fixed bugs that could cause access violation in the
//         Object Properties dialog box when editing streams in the SFR
//         package in MODFLOW.
//      Enhancement: Support for the MNW1 package added.
//      Bug fix: If values are entered in the time step length calculator
//        that result in a math error, the time step length is now set to
//        zero and an error message is displayed instead of a bug report
//        being generated.
//    '3.4.0.1' Change: Internally, the export of the RES package was changed
//        to improve the time required to export it in models with multiple
//        stress periods.
//    '3.4.0.2' Bug fix: Sometimes it was impossible to edit objects that
//        defined SFR stream boundaries because of extra information included
//        in the stream boundaries.
//      Bug fix: Selecting "File|New|MODFLOW Model" after importing an
//        existing model no longer causes an access violation.
//    '3.4.0.3' Bug fix: Fixed bug that would occasionally  cause access
//        violations when contouring data.
//    '3.4.0.4' Bug fix: ModelMuse can now handle SUTRA models with more
//        than 1,000,000 nodes.
//      Enhancement: ModelMuse can now import MODFLOW models in which
//        the U2DREL subroutine reads a value of NAN. The NAN is converted
//        to zero.
//      Enhancement: ModelMuse can now export a 2D SUTRA mesh for use in
//        other programs. To export the mesh, select
//        "File|Export|SUTRA 2D Mesh."
//      Enhancement: When importing a mesh from Gmsh that contains triangular
//        elements, the locations of the triangular elements is reported in
//        the Errors and Warnings dialog box.
//    '3.4.0.5' Bug fix: Fixed bug that could sometimes cause an access
//        violation when drawing the grid.
//    '3.4.0.6' Bug fix: ModelMuse can not run MODFLOW properly when the
//        model file name or directory contains non-ASCII characters.
//      Enhancement: ModelMuse will prompt you to save your file once each
//        hour.
//      Enhancement: When the user edits the times in the MODFLOW Time
//        dialog box, the times defined by MODFLOW boundary conditions
//        will be modified to match those times.
//      Bug fix: Fixed import of existing models that use the SFR package
//        with parameters and external flow files.
//      Bug fix: Fixed import of MNW1 input file when a unix-style path
//        name is specified for an output file.
//      Bug fix: Fixed import of SWR input files with structure observations
//        or when certain transient data are reused.
//      Bug fix: Fixed bug in exporting
//        Shapefiles that could cause exported Shapefiles to have duplicate
//        attribute names.
//      Bug fix: Fixed bug in contouring or coloring the grid with a text
//        data set in a SUTRA model.
//      Bug fix: Fixed bug in generating contours with SUTRA.
//      Bug fix: Fixed bug in exporting mesh data Shapefiles with SUTRA
//        that would prevent attribute values from being assigned.
//    '3.4.0.7' Enhancement: When a data set value is assigned using the
//        "Nearest" or "Nearest Point" interpolation methods, the
//        explanation of the data set value will identify the object that
//        is used to assign the value.
//      Bug fix: Fixed bug in generating finite element mesh.
//    '3.4.0.8' Bug fix: Fixed bug importing the STR package when invalid
//        stream tributaries are assigned.
//      Enhancement: If ModelMuse runs out of memory when trying to save
//        a .gpt or .xml file, the user will be instructed to save the file
//        as a .mmZlib or .bin file.
//      Enhancement: When evaluating data for the Stream (STR) package,
//        ModelMuse will now issue a warning if adjacent reaches in a segment
//        are separated by more than one cell or if the last reach in a
//        tributary segment is separated by more than one cell from the
//        first reach in the segment into which it flows.
//    '3.4.0.9' Bug fix: Fixed bug that would cause access violations when
//        deleting nodes from SUTRA meshes.
//    '3.4.0.10' Bug fix: Fixed bug importing the STR package when the
//        locations of the streams changed between stress periods.
//    '3.4.0.11' Bug fix: Fixed bug with manually drawing new SUTRA elements.
//    '3.4.0.12' Bug fix: Fixed bug that would cause an error if the mouse
//        wheel is used
//      Bug fix: In SUTRA models, times for boundary conditions or
//        observations that are after the final time are no longer included
//        in the TIME_STEPS time schedule.
//      Bug fix: Fixed bug that would occasionally cause access violations
//        when drawing the selected row and column with the
//        "Select Column, Row, or Layer" tool selected.
//    '3.4.0.13' Enhancement: In the "Show or Hide Objects" dialog box,
//        a "Go to" menu item has been added to the popup menu. Selecting
//        will move the view to the object.
//      Bug fix: Fixed export to ModelMate when STR parameters are defined.
//    '3.4.0.14' Enhancement: Improved error checking in SFR and STR packages.
//      Enhancement: ModelMuse can now import many MODFLOW-2000 models.
//        However, MODFLOW-2000 models that use the Observation process
//        generally can not be imported until all the files for the
//        Observation process are commented-out in the name file.
//      Bug fix: Multinode wells in the MNW2 package were not placed in the
//        correct cell if the LOSSTYPE was set to None.
//    '3.4.0.15' Bug fix: Fixed import of MODFLOW models using the SFR
//        package when the option to simulate unsaturated flow beneath a
//        stream is selected.
//    '3.4.0.16' Bug fix: Fixed export of SWR input files when tab files are
//        not used.
//    '3.4.0.17' Bug fix: Fixed bug that would sometimes cause data set
//        values not to be updated when they needed to be.
//    '3.5.0.0' Enhancement: Support for the Farm Process in MODFLOW-OWHM
//        added.
//    '3.5.1.0' Bug fix: Support for the Farm Process in MODFLOW-OWHM
//        activated.
//      Enhancement: LSTLVL option in MODFLOW-OWHM added.
//      Enhancement: PROPPRINT option in MODFLOW-OWHM added.
//      Enhancement: Support for Internal Coordinate System" option
//        in MODFLOW-OWHM added.
//      Bug fix: Fixed access violation that occurred when coloring the
//        initial water table data set in PHAST.
//      Bug fix: Fixed access violation that occurred with SUTRA models when
//        changing the selected layer with the keyboard.
//    '3.5.1.1' Bug fix: In steady-state PHAST models, the minimum and
//        maximum step sizes can now be less than 1.
//      Bug fix: When exporting 3D grid data to a Shapefile, data for the
//        last layer was saved as the data for the first layer and no other
//        data was saved. This has been fixed.
//    '3.5.1.2' Bug fix: Renaming a child model caused an access violation
//        if the child model used MT3DMS.
//    '3.5.1.3' Bug fix: Use LMG7 instead of LMG6 for the link to MT3DMS in
//        MODFLOW-LGR version 2.
//    '3.5.1.4' Bug fix: Fixed a bug setting the layer in a model in which
//        a child model has been defined but the model selection is no longer
//       one that includes child models.
//    '3.5.1.5' Enhancement: When exporting the MODPATH data sets, and error
//        message will be displayed if a reference is before the beginning
//        of the model or after the end.
//      Enhancement: In the Errors and Warnings dialog box, a context menu
//        has been added allowing the user to select, edit or go to
//        objects related to an error or warning message.
//      Enhancement: In the Manage Flow Observations dialog box, a context
//        menu has been added allowing the user to select, edit or go to
//        objects related to a particular observation.
//    '3.5.1.6' Bug fix: Fixed bug related to attempts to access directories
//        that don't exist.
//      Bug fix: ModelMuse no longer prompts the user to save the
//        file once an hour because it was causing ModelMuse to hang.
//    '3.5.1.7' Bug fix: When importing the LPF or UPW package input,
//        parameters that use multiple clusters for the same layer are now
//        imported correctly.
//      Enhancement: In the two Stream links panes of the Data Visualization
//        dialog box, a new control "Square size" has been added. It controls
//        the sizes of squares used to represent links between segments when
//        the two ends of the link are both in the same cell.
//      Bug fix: When importing Shapefiles of MODFLOW boundary conditions,
//        there is no longer an access violation if there are solutes defined
//        in Mt3DMS but the Source and Sink Mixing package has not been
//        activated.
//    '3.5.1.8' Bug fix: Attempting to read a MODPATH pathline file that
//        lacks a proper heading line now results in an error message instead
//        of causing ModelMuse to hang.
//      Bug fix: Fixed bug that would cause an assertion failure when
//        generating a finite element mesh in SUTRA.
//      Bug fix: Fixed bug that would cause an access violation error in
//        SUTRA models when attempting to edit multiple objects when captions
//        should be visible for the objects.
//      Change: When importing Cell-by-cell flow files, ModelMuse will ask
//        the modeller what the precision is used in the files is if it can't
//        determine that by itself.
//    '3.5.1.9' Bug fix: Fixed bug that would allow the user to define a
//        lake with a Lake ID of zero.
//   '3.5.1.10' Bug fix: Fixed bug that caused an error when withdrawing
//        water from a well.
//   '3.6.0.0' Bug fix: Attempting to use an empty .ucn file to assign
//        initial concentration will now result in an error message instead
//        of a bug report.
//      Bug fix: When importing an existing model, the import of diversions
//        in the STR package has been fixed.
//      Bug fix: Attempting to edit farms in MODFLOW-OWHM before defining
//        at least one crop is no longer allowed.
//   '3.6.0.1' Bug fix: Prevent objects from setting layer data sets in
//        MODFLOW models if they are 3D objects.
//      Bug fix: Fixed import of t-progs integer data.
//   '3.6.0.2' Bug fix: Because Infiltration and evapotranspiration in the
//        UZF package can only be defined on the top view of sthe model, the
//        Object Properties dialog box will no longer present UZF as an
//        option for objects on the front or side view of the model.
//      Change: The labeling of flow the the object properties dialog box
//        for the FHB package has been improved.
//      Bug fix: In the Object Properties dialog box, the images for MODPATH
//        are hidden if the Microsoft OpenGL driver is used. This avoids
//        causing an exception which will crash ModelMuse.
//      Bug fix: Fixed warning messages when importing an existing MODFLOW
//         model using parameters and instances in the SFR package.
//   '3.6.0.3' Bug fix: Fixed a bug that could sometimes cause a stack
//        overflow.
//      Bug fix: Fixed bug that would cause an access violation if the
//        Stream package was activated but no streams had been defined.
//      Bug fix: When attempting to open ModelMuse file fails, a more
//        appropriate error message is displayed to the user.
//      Bug fix: Fixed bug that could cause divide by zero errors when
//        using the Fishnet Mesh method to generate a mesh in SUTRA.
//      Bug fix: The starting locations of MODPATH particles were reversed
//        from front to back.
//      Enhancement: Enhanced error checking in the Stream (STR) package.
//      Enhancement: Improved import of MODFLOW-2000 and SEAWAT models.
//      Bug fix: Fixed labeling of MXACTW IWELCB in comments in the WEL
//        package.
//      Bug fix: Fixed bug in specifying the location of head observations
//        when the object defining the observation extends over multiple
//        layers and includes inactive cells.
//      Enhancement: When importing the STR package, stream connections from
//        segments with higher segment numbers to segments with lower
//        segment numbers are imported.
//   '3.6.0.4' Enhancement: Added additional error checking for the GHB, RIV,
//        DRN, DRT, STR, SFR, LPF, UPW, BCF and HUF packages.
//      Bug fix: Fixed bug that could cause ModelMuse to crash when drawing
//        contour lines using the ACM 626 method.
//   '3.6.0.5' Bug fix: Fixed bug in editing the times in MODFLOW models if
//        initial time step size is specified.
//      Bug fix: (bug not in released version.) Fixed access violation when
//        checking GHB, RIV, DRN, and DRT packages that use parameters.
//   '3.6.0.6' Bug fix: Improved work-around to prevent the Microsoft OpenGl
//        driver from causing the 64-bit version of ModelMuse to crash.
//   '3.6.0.7' Enhancement: In the Export Image dialog box, it is now possible
//        to copy the the current settings to the clipboard and paste them
//        from the clipboard into the dialog box. This allow the settings
//        to be transfered from one model to another.
//      Bug fix: Fixed bug that would cause a a bug report to be generated
//        when changing the number of Z formulas to use with an object and
//        one of the new Z formulas was invalid.
//   '3.6.0.8' Enhancement. Attempting to read an empty results file will
//        result in an error message rather than a bug report.
//      Bug fix: Fixed bug that could cause a range check error if no grid
//        had been created and the mouse was moved or the front or side
//        view of the model.
//   '3.6.0.9' Bug fix: ModelMuse can now read the zeta surface if only
//        one zeta surface has been calculated.
//   '3.6.0.10' Updated VirtualStringTree and MadExcept.
//   '3.6.0.11' Bug fix: Fixed export of ModelMate file when the ModelMate
//        file of the model is in a different directory from the ModelMuse
//        file.
//   '3.6.0.12' Bug fix: Fixed appearance of the Import Ascii Raster File
//        dialog box.
//      Bug fix: Fixed import of pump location in the MNW2 package.
//   '3.6.0.13' Enhancement: Added ability to visualize Transport observations
//        in MT3DMS.
//   '3.6.0.14' Bug fix: Duplicate segment numbers in the SFR package will
//        now result in an error message to the user instead of a bug report.
//   '3.6.1.0' Bug fix: Fixed renumbering the SUTRA mesh when using the Gmsh
//        to create the mesh with 3D models.
//   '3.6.1.1' Bug fix: When checking whether an updated version of ModelMuse
//        exists, ModelMuse now clears the related cache entry before
//        attempting to read the file from the internet.
//      Enhancement: ModelMuse will now issue an error message if a flow
//        observation is defined but no flow boundary conditions are part
//        of the flow observation.
//      Bug fix: Fixed bug in drawing contours in data sets with very
//        large values.
//   '3.6.1.2' Bug fix: Fixed a bug that could cause access violations when
//        drawing selected rows or columns in the front or side views.
//   '3.6.1.3' Bug fix: Fixed a bug that could cause values to be assigned
//        to the wrong cells in MODFLOW models with polygon objects that
//        set values of assigned cells and that use formulas to set the
//        bottom or top elevations to a value that is different from the
//        elevations of the bottom of a layer group or the top of the model.
//      Enhancement: Added the ability to import mesh data for SUTRA from
//        a list of values associated with node or element numbers.
//      Enhancement: In the "Specify Mesh" dialog box, it is now possible
//        to drag the rows for the elements into new positions to change
//        the element order.
//   '3.6.1.4' Enhancement: In the Manage Head Observations dialog box, it is
//        now possible to copy multiple cells from a spread sheet and paste
//        into the table of observations.
//   '3.6.1.5' Bug fix: Fixed bug in checking certain boundary conditions when
//        parameters are defined.
//   '3.6.1.6' Enhancement: Added a dialog box to convert values from
//        one time unit to another.
//      Bug fix: It is no longer possible to name a data set the same name
//        as one of the functions supported by ModelMuse.
//   '3.6.1.7' Bug fix: Fixed bug that could cause incorrect values to be
//        assigned with the ObjectIntersectLength function on the edge of a
//        SUTRA mesh.
//   '3.6.1.8' Bug fix: Fixed bug that could cause intersections between
//        objects and the cell around a node to not be recognized if the
//        object was perfectly vertical or horizontal.
//      Enhancement: The Edit Feature Formula dialog box can now be used to
//        assign a new formula to the selected property of a model feature
//        in multiple objects.
//   '3.6.1.9' Enhancement: Added method for plotting well "footprint".
//   '3.6.1.10' Enhancement: Additional error checking in several MODFLOW
//        packages.
//      Enhancement: New interpolation method "Point Average" added. The
//        new interpolator returns the mean of all the points in a cell
//        or element. If no points are in the cell or element, it returns
//        zero.
//   '3.6.1.11' Enhancement: It is now possible to label object vertices.
//   '3.6.1.12' Bug fix: Fixed import of Recharge package when multiple
//        clusters are used with a parameter.
//   '3.6.1.13' Bug fix: Fixed bug in Natural Neighbor interpolator when
//        a data point is at a location just slightly different
//        from the location where a value is required.
//   '3.6.1.14'
//   '3.6.1.15'
//   '3.6.1.16' Bug fix: Fixed bug in enabling the export of MODPATH
//        results to Shapefiles.
//   '3.6.1.17' Bug fix: Fixed selecting column, row, or layer with
//        Model Cube.
//      Bug fix: Fixed bug that caused an error if the user attempted to
//        activate an MNW1 well without defining any pumping periods.
//      Bug fix: Fixed a bug in which undoing the deletion of a parameter
//        did not work correctly.
//    '3.6.1.18' Bug fix: Fixed reading formatted head and drawdown files
//        that contain values less than or equal to 1e-100 or greater than
//        or equal to 1e100;
//      Enhancement: When exporting Shapefiles of pathlines or endpoints,
//        the particle number is now one of the fields exported.
//    '3.6.1.19' Bug fix: Fixed export of SWR channels when a single object
//        enters a cell twice.
//    '3.6.1.20' Bug fix: not in released version. Fixed export of pathline
//        particle index
//    '3.6.1.21' Bug fix: Fixed access violation if the user attempted to
//        paste more rows of data into the "Imported Data" tab of the Object
//        properties dialog box than there were rows in the table.
//      Bug fix: Fixed bug that prevented a child model from being run
//        independently from the parent model in MODFLOW-LGR2
//        and MODFLOW-OWHM.
//    '3.6.1.22' Failed Bug fix: Fixed bug that could cause and assertion
//        failure when interpolating data set values with an anisotropy
//        not equal to 1.
//      Enhancement: When exporting data to CSV files, exporting the location
//        and cell, node, or element is now optional.
//    '3.6.1.23' Bug fix: Fixed export of SWR when a reach geometry is unused.
//    '3.6.1.24' Bug fix: when edit the SUTRA mesh in the Specify Mesh dialog
//        box, nodes that are not used are now deleted.
//      Bug fix: Fixed bug that could cause and assertion failure
//        when interpolating data set values with an anisotropy not equal
//        to 1.
//    '3.6.1.25' Bug fix: Fixed a bug in the export of data sets to
//        Shapefiles that would cause an access violation.
//    '3.6.1.26' Bug fix: Fixed bug that caused the SSM file to be written
//        incorrectly in models using the MNW1 or MNW2 packages.
//      Bug fix: Fixed bug in ModelMonitor that caused access violations
//        when used with SWR.
//      Bug fix: Fixed bug that caused the explanations for some data assigned
//        for the SWR package to be incomplete.
//    '3.6.2.0' No additional changes.
//    '3.6.2.1' Bug fix: Zonebudget composite zone names are no longer allowed
//        to be more than 10 characters long.
//      Bug fix: Fixed bug that could cause incorrect drain, river, DRT,
//        or GHB boundaries to be exported for MODFLOW-NWT if observations
//        were used with them.
//    '3.6.2.2' Bug fix: Fixed export of MT3DMS SSM data set 7 for MNW2 wells
//        with vertical screens defined.
//    '3.6.2.3' Bug fix: Fixed import of FHB package when only a single time
//        is defined.
//      Bug fix: fixed ability to use global variable in formulas with
//        child models in MODFLOW-LGR models.
//      Enhancement: Added two new functions related to MODFLOW_LGR:
//        Horizontal_Subdivision and Vertical_Subdivision. The return
//        values of NCPP and NCPPL respectively for the child models
//        and 1 for parent models.
//    '3.6.2.4' Enhancement: When exporting an image, all elements of the
//        image except background images can now be exported as vector
//        graphics by selecting "Pure Vector Graphics (*.emf)" as the
//        image type when saving the image. Such images do not support
//        partial transparency, line thicknesses different from 1, and dashed
//        lines so the resulting images will typically not be identical
//        with what would be seen in ModelMuse.
//    '3.6.2.5' Enhancement: In the LPF and UPW packages, a warning is issued
//        for most properties if a zero value is encountered in an
//        active cell.
//      Bug fix: Fixed an bug in drawing the 3D view that could cause a
//        divide by zero error.
//      Enhancement: ModelMuse now issues an error message if an SWR structure
//        is defined between reaches that are not connected.
//    '3.6.2.6' Bug fix: Fixed deletion of SWR structures.
//      Bug fix: Fixed evaluation of objects in MODFLOW and PHAST models that
//        have two elevation formulas and assign cell values of both enclosed
//        and intersected cells.
//    '3.6.2.7' Enhancement: The Grid and Mesh Values dialog box now can
//        display data regarding the SWR reaches and structures at the
//        cursor location.
//      Enhancement: When importing SWR model results, the data sets
//        now display the average of all the reach values in the cell.
//        The individual values for reaches are displayed in the
//        explanation in the Grid and Mesh Values dialog box.
//    '3.6.2.8' Bug fix: Fixed bug that could cause access violations when
//        the Grid or Mesh Value dialog box was being used with an LGR model.
//      Enhancement: Added SelectedCount function. It returns the number
//        of cells, nodes, or elements intersected or enclosed by an
//        object.
//      Bug fix: Incorrect manual SWR reach numbering now results in an
//        error message displayed to the user instead of a bug report.
//    '3.6.2.9' Enhancement: A new method (Overlapping reaches) for defining
//        links between SWR reaches has been added. With this method, the
//        user selects another object. Links will be created between reaches
//        defined by the other object that are in the same cell as reaches
//        defined by the current object.
//    '3.6.2.10' Bug fix: Using SWR data sets that do not have a value
//        defined for every cell in the formula for another data set no
//        longer causes an assertion failure. For locations where no value
//        is defined, the value used will be the formula if the formula
//        is a number or zero if the formula is not a number.
//    '3.6.2.11' Enhancement: ModelMuse can now import existing MODFLOW models
//        in which the grid origin is in the lower left corner instead of
//        the upper left corner.
//    '3.6.2.12' Bug fix: Fixed bug that could cause access violations when
//        opening a ModelMuse file while another file is already open.
//      Bug fix: When the Formula editor is displayed from the Import
//        Shapefile dialog box, the data sets are now classified instead
//        of listed alphabetically.
//      Enhancement: You can now use the middle mouse button to pan the
//        model view while in the middle of doing something else.
//      Bug fix: Fixed bug that caused duplicate time steps to be included
//        in SUTRA time schedules.
//    '3.6.2.13' Change: Stack size increased from 1048576 to 8388608.
//    '3.6.2.14' Bug fix: Fixed writing SUTRA transient data when nothing
//        has changed between two times.
//    '3.6.2.15' Bug fix: Fixed a bug in which a math error occurred when
//        attempting to display an object.
//    '3.6.2.16' Bug fix: (not in released version). Fixed bug in calculation
//        of SWR connections between overlapped reaches.
//    '3.6.2.17' Bug fix: Fixed bug that could cause the
//        ObjectIntersectLength function to return the wrong value if called
//        more than once in the same formula.
//    '3.6.2.18' Bug fix: Fixed bug that could cause an access violation when
//        editing an object in which gages were defined.
//    '3.6.2.19' Bug fix: Fixed bug that did not specify the initial values
//        of the boundary condition variables correctly in the main input
//        file when time varying boundaries were used.
//    '3.6.2.20' Enhancement: A new command line option has been added:
//        "-il <filename>" will cause ModelMuse import the last data set
//        in filename. This option will only work with MODFLOW models.
//        The data in filename must be consistent with the discretization
//        in the MODFLOW model.
//    '3.6.2.21' Enhancement: A new command line option has been added:
//        "-ia <filename>" will cause ModelMuse import all the data sets
//        in filename. This option will only work with MODFLOW models.
//        The data in filename must be consistent with the discretization
//        in the MODFLOW model.
//    '3.6.3.0' Bug fix: Fixed bug that could cause importing data from
//        cell-by-cell flow files to take a long time.
//    '3.6.3.1' Enhancement: Added options to import gridded data to a child
//        grid in the "File|Import|Gridded Data" and the
//        "File|Import|Gridded Data Files"
//        dialog boxes.
//    '3.6.3.2' Bug fix: Attempting to import a Surfer grid file in a model
//        that lacks a grid no longer causes an access violation.
//      Bug fix: Fixed bug that could cause floating point overflows when
//        changing the layer type in a MODFLOW-LGR model.
//      Bug fix: Fixed bug that could cause a circular reference
//        error when editing the grid.
//    '3.6.3.3' Bug fix: Fixed bug that could cause an access violation
//        when displaying the MODFLOW Packages and Programs dialog box.
//      Enhancement: It is now possible to hide everything except the legend
//        on the Data Visualization dialog box and then resize the dialog
//        box to a smaller size.
//      Enhancement: Objects now have a "Minimum cell fraction" property.
//        Objects with a total length greater than zero that assign properties
//        of intersected cells will only do so if the length of intersection
//        is greater than the specified fraction of the cell or element size.
//      Bug fix: Fixed bug in evaluation of SpecifiedHeadOnLayer function
//        when no specified head package is active.
//    '3.6.3.4' Bug fix: Fixed bug that caused an error if an invalid formula
//        was used in a SUTRA boundary condition.
//      Enhancement: When importing MODFLOW model results, the user can now
//        specify the name of the group containing the data sets and can
//        specify a prefix for the data sets names. If this option is used,
//        the "Delete Model Results" command will not affect the newly
//        imported data sets.
//      Bug fix: Fixed classification of data set created by importing a
//        Surfer grid file.
//    '3.6.3.5' Bug fix: Fixed bug that caused access violations if FHB
//        times were specified that were after the last time in the model.
//      Enhancement: It is now possible to change the order of the imported
//        images in the Show or Hide Images dialog box by dragging the image
//        to a new position in the list.
//    '3.6.3.6' Enhancement: Added error checking for SWR tab files that are
//        missing a file name.
//      Change: Real numbers and integers in printed by ModelMuse in MODFLOW
//        and SUTRA input files now have consistent spacing.
//      Enhancement: Additional error checking for SFR segments that are on
//        multiple layers in the same row and column or that are in
//        confined layers when unsaturated flow beneath streams is simulated.
//    '3.6.3.7' Enhancement: In the MODFLOW Packages and Programs dialog box,
//        expanding one of the nodes in the tree-view control automatically
//        causes the first selected package or program under that node to be
//        the selected node in the tree-view control.
//      Change: (not in released version) In footprint code, the user can
//        specify a minimum depth-rate index.
//    '3.6.3.8' Bug fix: Fixed bug that caused an assertion failure when
//        attempting to generate a fishnet mesh using a triangular
//        fishnet-mesh quadrilaateral.
//    '3.6.3.9' Bug fix: Fixed bug that caused access violations when editing
//        SUTRA boundary conditions.
//    '3.6.3.10' Bug fix: Fixed bug that would cause importing a MODFLOW
//        model to fail if a multiplier array calculated as a function of
//        other mulitplier arrays resulted in a divide-by-zero or other error
//        when calculating a multiplier array value.
//    '3.6.3.11' Bug fix: Fixed bug that could cause and access violation
//        when starting a new model after already having had another model
//        open already.
//      Bug fix: If an error occurs when importing multiple gridded data
//        files because of invalid data in one of the files, an error message
//        is displayed instead of a bug report being generated.
//      Bug fix: ModelMuse now prevents the user from assigning the same
//        name to two or more layer groups when creating a new MODFLOW model.
//      Bug fix: ModelMuse now prevents the user from assigning the same name
//        to two or more Hydrogeologic units.
//      Bug fix: In the SFR package, NUMTIM, WEIGHT, and FLWTOL can now
//        be edited.
//    '3.6.3.12' Enhancement: ModelMuse now issues an error message if the
//        lowest elevation in a SFR 8-point cross section is not zero.
//      Change: The Trunc and Round functions were changed so that if the
//        real number passed to the function is outside the range
//        -(2^31-1) to +(2^31-1), the result returned will be whichever of
//        those numbers is closest.
//      Bug fix: Fixed link to help for the MNW2 package.
//      Enhancement: In the Sink and Source Mixing package of MT3DMS, the
//        full recharge and ET concentration arrays are only printed if
//        they have non-zero values.
//      Bug fix: In the Head observations pane of the Data Visualization
//        dialog box, double-clicking on on a point no longer causes some
//        values in the grid from being hidden.
//    '3.6.3.13' Bug fix: ModelMuse no longer generates a warning message
//        in the STR package for stages below the bottom of the stream if
//        the stage is calculated.
//      Bug fix: The ElevationToModelLayer function now works in child models.
//      Enhancement: Opening the Object Properties dialog box with objects
//        that define SFR boundaries with numerous stress periods is no longer
//        so slow.
//    '3.6.3.14' Enhancement: ModelMuse now create a a batch file named
//        "RunModel.bat" that is suitable for use with automated parameter
//        estimation programs.
//    '3.6.3.15' Bug fix: Fixed bug in opening files in which some objects
//        have line segments that intersect.
//      Bug fix: Fixed display of error messages regarding undefined
//        parameters.
//      Bug fix: Fixed bug that could cause access violations when moving
//        dragging with the mouse over the 3D view under certain rare
//        circumstances.
//    '3.6.3.16' Enhancement: ModelMuse can now import CFP pipes from
//        Shapefiles.
//      Enhancement: ModelMuse now warns if the ET depth is less than zero
//        in the EVT or ETS packages.
//    '3.6.3.17' Enhancement: ModelMuse can now export objects that define
//        SFR boundaries to Shapefiles.
//      Enhancement: When importing Shapefiles, ModelMuse can now import
//        Z and measured values for each Shape if they are included in the
//        Shapefile. The values will be imported as Vertex Values.
//      Enhancement: The following new functions have been added:
//        LowestVertexValue, HighestVertexValue, MeanVertexValue,
//        MedianVertexValue, FirstVertexValue, and LastVertexValue.
//        See the ModelMuse help for descriptions of these new functions.
//        They are typically used when there is vertex value at every
//        vertex of an object and every cell intersected by an object
//        contains at least one vertex.
//    '3.6.3.18' Bug fix: The filters for limiting the display of head
//        observation results by time were reversed.
//      Bug fix: In the MODFLOW STR package, a single object now defines
//        more than a single reach in a cell if it intersects the cell
//        more than once.
//      Bug fix: In the MODFLOW Layer Groups dialog box, pasting layer
//        boundaries now works correctly.
//    '3.6.3.19' Bug fix: Fixed bug that would cause values of some boundary
//        conditions to be evaluated incorrectly.
//    '3.6.3.20' Bug fix: Fixed bug that prevented a model from being opened
//        when a global variable and data set have the same name. In such
//        cases, the global variable is deleted.
//      Bug fix: If the default name of a data set for a hydrogeologic unit
//        conflicts with a preexisting global variable name, the name for the
//        data set will be modified to avoid the conflict.
//    '3.6.3.21' Enhancement: When changing stream linkages in
//        the SFR or STR packages, ModelMuse can now renumber any duplicate
//        stream numbers.
//    '3.6.3.22' Bug fix: Fixed a resource leak.
//    '3.6.3.23' Enhancement: In the "Manage Flow Observations" dialog box,
//        a new tab has been added in which the user can edit multiple
//        observation group names. A list of names can be pasted into the
//        table on this tab to change the observation group names.
//    '3.6.3.24' Bug fix: When updating a ModelMate file with more than
//        ten or more observation times for the same observation group, some
//        of the observation names were not passed to ModelMate correctly.
//      Enhancement: Linking SFR and STR streams with the Link Streams
//        dialog box was made faster.
//      Bug fix: Attempting to export a shape file of contours will now
//        generate a warning message if the user attempts to export contours
//        for a data set that is uniform.
//      Bug fix: Duplicate Lake ID numbers now results in a error message
//        for the user instead of a bug report.
//      Bug fix: Fixed a bug that could cause an access violation when editing
//        objects.
//      Bug fix: ModelMuse can now read MODPATH endpoint files in which some
//        endpoint lavels contain spaces.
//    '3.6.3.25' Bug fix: Deleting a MODFLOW stress period no longer causes
//        the times of MODFLOW boundary conditions to change.
//      Bug fix: Fixed a bug that prevented some files created by a beta
//        version of ModelMuse from being opened by more recent versions.
//    '3.6.3.26' Enhancement: the PEST Grid Specification File is now
//        automatically created when exporting MODFLOW models. the file has
//        the extension ".gsf".
//    '3.6.3.27' Bug fix: Fixed bug in the export of the SSM file in MT3DMS
//        when the ETS package is used.
//    '3.6.3.28' Bug fix: Fixed bug that could cause an access violation in
//        SUTRA models if the left, right, up, or down arrow keys on the
//        keyboard were used.
//      Enhancement: When saving the input files for MODFLOW model, the
//        project description is included in the Save dialog box. The
//        project description will be saved as comments in the Basic
//        package input file.
//      Enhancement: The log of tracking time can now be used to color
//        MODPATH endpoints.
//      Bug fix: It is no longer possible to delete all the Layer Groups
//        in a MODFLOW model.
//      Bug fix: Zooming in while a background bitmap is present no longer
//        causes a range check error.
//    '3.6.3.29' Enhancement: The log of tracking time can now be used to
//        color MODPATH pathlines.
//      Enhancement: Added support for the RIP package in MODFLOW-OWHM.
//    '3.6.3.30' Enhancement: Added support for writing the Summary budget
//        to a separate file.
//    '3.6.3.31' Bug fix: Fixed a bug that could cause a bug report to be
//        generated if the user tries to import a background image that is
//        too large.
//      Bug fix: Fixed a bug that could cause an access violation if the user
//        deleted a parameter and then attempted to edit an object that used
//        that parameter.
//      Bug fix: When adding new layer groups in MODFLOW models, each layer
//        group automatically gets a name different from any other existing
//        layer group.
//    '3.7.0.0' Bug fix: Fixed a bug that prevented the user from defining
//        ETS boundaries properly on the first attempt.
//      Bug fix: Fixed a bug that caused access violations when exporting the
//        ETS package input file if the ETS boundaries were not defined
//        properly.
//    '3.7.0.1' Bug fix: Fixed a bug in the generation of an error message
//        in the MODFLOW CFP process when the node elevation is too high
//        or to low.
//    '3.7.0.2' Bug fix: Fixed another bug that caused access violations when
//        exporting the ETS package input file if the ETS boundaries were not
//        defined properly.
//    '3.7.0.3' Bug fix: Fixed a bug that made it impossible to delete a flow
//        observation.
//    '3.7.0.4' Bug fix: Fixed a bug that could cause an access violation in
//        the Import Points dialog box when a boundary condition was first
//        selected and then unselected.
//    '3.7.0.5' Bug fix: If an attempt is made to save an archive from the
//        files to Archive dialog box and an unsupported archive type is
//        selected, an error message will be displayed instead of a bug report
//        being generated.
//      Bug fix: Fixed bug that could cause access violations when opening
//        the object properties dialog box.
//    '3.7.1.0' Bug fix: Fixed  display of some controls after resizing the
//        "Select Results to Import" dialog box.
//      Bug fix: Fixed hints for adding, inserting, and deleting
//        plant groups in the Riparian ET Plant Groups dialog box.
//      Bug fix: Fixed access violation when drawing contours after importing
//        model results.
//    '3.7.1.1' Bug fix: Fixed export of FMP package when formulas give
//        results of the wrong type. Now a warning of an invalid formula will
//        be displayed.
//      Bug fix: Fixed export of FMP package when some required time varying
//        data is undefined. Now ModelMuse issues an error message to the
//        user instead of generating a bug report.
//      Bug fix: Fixed bug that prevented the user from specifying data set
//        15 in the FMP process when it was needed.
//    '3.7.1.2' Bug fix: Fixed bugs that could cause invalid meshes to be
//        created with the fishnet mesh algorithm if one or more fishnet
//        elements was invalid.
//      Bug fix: Fixed how ModelMuse handles certain invalid formulas.
//      Enhancement: When importing objects, a comment is included in each
//        object with the date the object was created and (if applicable)
//        the file from which it was imported.
//      Bug fix: Failing to specify an elevation for a model layer in the
//        Start Up dialog box for MODFLOW will no longer cause an error.
//      Change: When importing gridded data for 3D data sets, the Z-coordinate
//        of the data points is now determined by a formula related to the
//        grid structure.
//      Bug fix: Fixed bug that could cause an access violation in the
//        Import Gridded Data dialog box in PHAST models.
//    '3.7.1.3' Bug fix: Fixed bug that could cause an assertion failure
//        when exporting the FHB package input.
//      Bug fix: Fixed bug that prevented valid FMP input files from being
//        created if no Farm wells were defined.
//    '3.7.1.4' Enhancement: The Import Points dialog box was modified to
//        allow the user to specify column and row instead of X and Y when
//        importing data for models with grids on the top view of the model.
//    '3.7.1.5' Enhancement: Added legend for MODPATH Endpoint colors.
//      Enhancement: In tables containing checkboxes, it is now possible
//        to check a check box by typing or pasting a value into the cell
//        containing the check box. Typing "True", "T", "Yes", or "Y" will
//        cause the check box to be checked. Any other text will cause it to
//        be unchecked. Case is not important in the text that is typed.
//    '3.7.1.6' Bug fix: (not in released version). Fixed bug that made it
//        impossible to import model results.
//    '3.7.1.7' Bug fix: Fixed export of SWI input files with MODFLOW-OWHM.
//    '3.7.1.8' Bug fix: Fixed import of SWR package.
//      Bug fix: Fixed import of UZF package when SWR package is also used.
//    '3.7.1.9' Bug fix: Fixed export of SWR ISTRORCH in data set 13b.
//    '3.7.1.10' Bug fix: Fixed bug in deleting Custom color scheme.
//      Enhancement: ModelMuse now exports a usgs.model.reference file
//        each time the model input files are exported. When starting a new
//        model, the user is now prompted to specify the information for
//        the usgs.model.reference file that ModelMuse can not determine
//        automatically. The information can also be edited by selecting
//        "Model|Edit Geo Reference".
//      Enhancement: ModelMuse now exports an .axml file each time the model
//        input files are exported. The files lists the input and output files
//        for the model in XML format. These files can be used to help archive
//        a model.
//      Enhancement: When creating an archive, ModelMuse now saves it in
//        in a form that meets more of the USGS model archiving requirements.
//      Bug fix: Fixed bug that prevented users from deactivating the
//        UZF boundary in an object except by deleting the object.
//    '3.7.1.11' Bug fix: Fixed bug in export of Data set 16 in the
//        Farm Process.
//    '3.7.1.12' Bug fix: Fixed bug that prevented the export of the SWR input
//        file in MODFLOW-OWHM.
//    '3.7.1.13' Bug fix: Fixed bug in which data set 2 of the SWR package
//        took up more space than was allowed.
//    '3.7.1.14' Bug fix: Fixed bug in display of the data sets in the
//        Edit Data Sets dialog box and other dialog boxes if the model had
//        been switched from a SUTRA 3D model to a MODFLOW model.
//    '3.7.1.15' Bug fix: Fixed bug so that models with incomplete transient
//        data will display an error message to the user identifying the
//        problem instead of generating a bug report.
//      Bug fix: In the "Files to Archive" dialog box, file names referring
//        to drives that do not exist or are not open no longer cause errors.
//    '3.7.1.16' Enhancement: Added the ability to export an outline of the
//        grid or mesh to a Shapefile. When exporting a grid, the user
//        has the option to export the outline of the entire grid, just
//        the active cells in the grid or both the active and inactive cells.
//      Change: The "SWR_Reach_Number" data set has been changed from a 3D
//        data set to a 2D data set. This allows it to be used in a formula
//        for the reach number in SWR direct runoff. A suitable formula
//        might be "Round(SWR_Reach_Number)". However, the data set
//        displays the average reach number for all the reaches at a
//        particular row and column. Thus if there is more than one reach in
//        a cell, the reach number in the data set might not be appropriate.
//    '3.7.1.17' Enhancement: Added function "ObjectBasisFunction" which can
//        return a value interpolated from the values at the corners of an
//        object section that is triangular or quadrilateral in shape.
//    '3.8.0.0' Enhancement: When importing Shapefiles, the minimum and
//        maximum X, Y, and Z coordinates of the object can be used in the
//        formula that determines whether or not an object is imported.
//      Enhancement: When exporting the CHD package, ModelMuse now checks
//        whether the specified heads are below the bottom of the layer.
//    '3.8.0.1' Enhancement: In the Display Data dialog box, the SFR links
//        and STR links now have an option to display invalid links.
//      Bug fix: Fixed deletion of global variables that were added in some
//        previous versions of ModelMuse.
//    '3.8.0.2' Bug fix: Fixed bug in display of MODPATH time series.
//    '3.8.0.3' Bug fix: Fixed bug in archiving models so that the batch
//        files would work correctly in the archive.
//      Bug fix: Fixed evaluation of the DischargeRouting data set (IRUNBND
//        in the UZF package) when the SFR streams are not in strict
//        numerical order.
//      Enhancement: Added support for new options in MODFLOW-NWT
//        version 1.1.
//      Bug fix: Fixed and access violation when opening a model after having
//        previously a MODFLOW-LGR model.
//    '3.8.0.4' Bug fix: Fixed a bug that caused an access violation when
//        deleting all the global variables.
//      Bug fix: Fixed check of MT3DMS file name size. The size checked was
//        5 when it should have been 50.
//    '3.8.1.0' No additional changes.
//    '3.8.1.1' Bug fix: Fixed bug in limiting display of pathlines to the
//        current column, row, or layer when other criteria are also used
//        to limit the display.
//      Bug fix: Fixed bug in saving model archive list when the ModelMuse
//        file has not already been saved.
//      Enhancement: Added support for SWR  version 1.04 in MODFLOW-NWT
//        version 1.1.1.
//      Bug fix: Fixed saving the the names of model input and output files
//        to be archived when the names are relative file names.
//      Change: In the CHD, DRN, DRT, ETS, EVT, GHB, RCH, RIV,
//        and WEL packages, parameter instances will only be defined for
//        parameters that have different values in different stress periods.
//      Bug fix: Fixed bug in updating display of SUTRA boundary conditions
//        when coloring the grid.
//      Change: When exporting the model outline as a shapefile, there is
//        now a single character attribute named "Area" which will contain
//        "Active" for the outline of the active area, "Inactive" for the
//        outline of the inactive area or "Grid Outline" for the outline
//        of the model grid.
//      Enhancement: Improved display of imported images at high
//        magnifications.
//    '3.8.1.2' Bug fix (not in released version) Fixed bug in
//        improved display of imported images.
//    '3.8.1.3' Bug fix: fixed bug that prevented some old model files from
//        being opened.
//    '3.8.1.4' Enhancement: Improved the quality of contours in SUTRA
//        profile models by taking into account the vertical exaggeration.
//    '3.8.1.5' Bug fix: Fixed paths assigned to .bcs files in SUTRA.FIL file.
//    '3.8.1.6' Bug fix: Fixed specification of NORDER in the NWT package.
//        Previously, specifying NORDER = 2 would result in a corrupt file.
//    '3.8.1.7' Bug fix: Fixed a bug that could cause the option to export
//        MODPATH endpoints to Shapefiles to be disabled incorrectly.
//    '3.8.1.8' Enhancement: added new dialog box that can display the
//        file extensions for the input and output model files and the
//        type of file associated with each extension.
//      Enhancement: Support for SUTRA 3.0 added.
//    '3.8.1.9' Enhancement: Added support for displaying vertex values in
//        vertex labels.
//      Enhancement: The items in the Show or Hide Objecte dialog box that are
//        expanded, remain expanded after editing objects.
//      Bug fix: Checking or unchecking as checkbox in
//        the "Select Objects for Editing or Deletion" now will now cause
//        all the related checkboxes to change state appropriately.
//      Enhancement: The Edit Feature Formula dialog box can now be used with
//        SUTRA features.
//    '3.8.1.10' Bug fix: Fixed bug that could cause out for range errors if
//        an error or warning messge is too big to fully display in the
//        Errors and Warnings dialog box.
//    '3.8.1.11' Bug fix: Fixed bug in export of the MT3D Transport
//        Observations Package (TOB) that could cause invalid TOB input files
//        to be created if observations of different species at the same
//        time were specified.
//    '3.8.1.12' Bug fix: Fixed bug that could cause access violations if a
//        MT3D component was deleted and a new component was later added.
//      Enhancement: Support was added for the modified SUB package in
//        MODFLOW-OWHM.
//    '3.8.1.13' Bug fix: Fixed bug that caused an assertion failure if a
//        Layer group was given the same name as an existing layer group.
//      Enhancement: Added support for importing SUTRA restart files.
//    '3.8.1.14' Bug fix: (Not in released version.) Fixed import of SUTRA
//        restart file.
//    '3.8.1.15' Bug fix: In MODFLOW-LGR models that use the MNW1 package,
//        the WEL1, BYNODE, and QSUM will be given names different from the
//        names used in the parent model.
//      Bug fix: Fixed bug that could cause access violations when editing
//        SUTRA Fishnet Meshes.
//    '3.8.1.16' Bug fix: When importing certain invalid Shapefiles,
//        ModelMuse will now generate an error mesage to the user instead of
//        a bug report.
//    '3.8.1.17' Bug fix: If duplicate times are specified in a MODFLOW
//        feature, ModelMuse will now display an error message to the user
//        when attempting to evaluate the feature instead of generating a
//        bug report.
//    '3.8.1.18' Bug fix: Fixed bug that caused an assertion failure when
//        exporting the BCF package if the limited convertible option was
//        used for a layer or when importing an existing model with that
//        same option.
//      Enhancement: In models with grids such as MODFLOW, if the grid
//        cell or element size is set by an object on the top view of the
//        model and the default formula for the Active data set is "True",
//        the active data set will be set to false outside any such objects.
//      Enhancement: When importing Shapefiles, Surfergrid files, or
//        ASCII Raster files, there is now an option to convert the units of
//        the X and Y coordinates.
//    '3.8.1.19' Bug fix: not in released version. Fixed assignment of
//        Active data set.
//    '3.8.1.20' Bug fix: not in released version. Fixed bug in display of
//        Withdrawals in Footprint model.
//    '3.8.1.21' Bug fix: Rmoved spurious warnings about SFR reach bottom
//        elevations for models in which reach elevations are specified
//        at the beginning and ending of a segment.
//    '3.8.1.22' Bug fix: Fixed bug that caused an infinite loop in updating
//        the grid elevations in MODFLOW-LGR child models.
//    '3.8.1.23' Bug fix: Fixed bug in export of SFR in LGR version 1 that
//        could cause an assertion failure.
//    '3.8.1.24' Bug fix: Fixed another bug in export of SFR in LGR version 1
//        that could cause an assertion failure.
//    '3.8.1.25' Bug fix: Fixed bug in export of SFR in LGR version 2
//        that could cause incorrect values for the values at the upstream
//        and downstream ends of segments that cross the subgrid boundary.
//    '3.8.1.26' Enhancement: When animating a display in the Export Image
//        dialog box, ModelMuse will give priority the data sets being
//        animated when applying macros to text.
//      Enhancement: When importing MODFLOW-2000 model, parameter
//        values from the Sensitivity file are imported.
//      Bug fix: Exporting a shapefile of contours in a MODFLOW-LGR child
//        model now works.
//      Bug fix: Changing the contour interval for contours in a MODFLOW-LGR
//        model now applies to both parent and child models.
//    '3.8.1.27' Bug fix: It is now possible to run MODPATH or ZONEBUDGET in
//        either child or parent model with MODFLOW-LGR.
//    '3.8.1.28' Bug fix: Fixed bug that could cause access violations when
//        setting up an animation in the Export Image dialog box.
//      Bug fix: Fixed export of parent model or child model in MODFLOW-LGR
//        model when either just the parent or just the child is to be run.
//    '3.8.1.29' Bug fix: Fixed export of usgs.model.reference file in
//        MODFLOW-LGR when only the parent model is run.
//    '3.8.1.30' Change: Made ajustments to support input file format changes
//        in MODFLOW-2005 version 1.12.
//      Bug fix: Fixed bug that allowed 3D objects to set the values of
//        data sets that define the grid elevations.
//    '3.8.1.31' (Bug fix: not in released version) Fixed a bug that caused
//        stack overflow when fixing an existing model.
//    '3.8.1.32' Bug fix: Fixed bug that could cause incorrect values to
//        be printed for certain SFR variables when LGR is used and the
//        formula should apply different values in the parent and child
//        models.
//    '3.8.1.33' Enhancement: when exporting a model outline to a
//        Shapefile, the outlines of child models in LGR models can be
//        exported.
//      Bug fix: In the Object Properties dialog box, if an attempt is made
//        to specify an invalid vertex value, the value is left unchanged.
//      Bug fix: Fixed a bug in deleting and then adding an Mt3DMS components
//        that could cause an access violation.
//      Bug fix: Fixed bug that could cause an assertion failure if the
//        starting time defined in FHB was before the first time in the model.
//      Change: Added export of a 7th value in record 3 of the MT3D-USGS
//        Basic package.
//    '3.8.1.34' Bug fix: Fixed bug that caused a math error when contouring
//        if the user choose to log transform the data and specified an
//        upper or lower limit less than or equal to zero.
//    '3.8.1.35' Bug fix: Set the "Range" property of all scrollbars to 0.
//        This has no effect when compiled with Delphi XE2 but it cause
//        problems with the form size in Delphi 10.1 Berlin.
//      Enhancement: The user can now specify the size at which MODPATH
//        endpoints and time series points are drawn in 2D views.
//      Bug fix: Fixed bug that could cause an error when attempting to
//        get values for data sets for data sets evaluated at nodes in
//        MODFLOW models.
//      Bug fix: In the MODFLOW Lake package, values of THETA and SSCNCR
//        that were equal to 0 were not saved when saving a ModelMuse file.
//    '3.8.1.36' Enhancement: When exporting grid data to Shapefiles, it is
//        now possible to filter the data that is exported.
//      Bug fix: Fixed bug in specifying the starting date in the Georeference
//        dialog box in countireis where the convention for specifying dates
//        is something other than Month/Day/Year.
//      Bug fix: Fixed bug in exporting FMP input where evaporation fraction
//        has not been specified.
//    '3.8.1.37' Bug fix:  Specifying a formula in an object that gives the
//        wrong data type for the data set now result in an error message in
//        the Formula Errors dislog box instead of generating a bug report.
//    '3.8.1.38' Bug fix: Fixed bug in Export of Shapefiles caused an error
//        when exporting head observations to a Shapefile.
//      Bug fix: Fixed bug that could cause an assertion failure when opening
//        a model that uses the Subsidence package.
//    '3.8.1.39' Bug fix: Fixed bug that would cause an incorrect unit number
//        to be assigned when direct runoff is used in the SWR package.
//    '3.9.0.0' No additional changes.
//    '3.9.0.1' Bug fix: When opening a ModelMuse file in which the EVT, ETS,
//        or RCH data in objects were defined using parameters, the data
//        would not always be read.
//    '3.9.0.2' Change: If the FirstVertexValue, HighestVertexValue,
//        LastVertexValue, LowestVertxValue, MeanVertexValue,
//        and MedianVertexValue functions is used and a cell to
//        which it applies has no vertex values, a warning message will only
//        be displayed if the optional default value has not been supplied.
//      Bug fix: Fixed drawing of background bitmaps.
//    '3.9.0.3' Change: In the Errors and Warnings dialog box, right-clicking
//        a group of errors or warnings will now allow the user to select all
//        the objects related to that group even if the error message for
//        some of the objects have not been displayed.
//      Bug fix: Fixed bug that could cause an infinite loop if the segments
//        in the STR package could not be put in the correct order and
//        parameters were used.
//      Bug fix: Fixed a bug in the export of structure information in data
//        set 13a of the SWR package that would result in MODFLOW halting with
//        an error message.
//    '3.9.0.4' Change: When importing objects from shape files, functions
//        related to objects can now be used to define object elevations.
//    '3.9.0.5' Bug fix: In the MODFLOW Layer Groups dialog box, attempting
//        to enter a value of 0 for the growth rate on the Discretization
//        tab no longer results in a math error.
//      Bug fix: Fixed a bug that could cause a conversion error in the
//        SUTRA Options dialog box in computers that do not use a period as
//        the decimal separator.
//      Bug fix: Fixed bug in "FractionOfObjectLength" function that caused
//        it to give incorrect values in models with grids in which the grid
//        angle was not zero.
//      Bug fix: fixed bug that could cause incorrect values to be assigned
//        by objects if the first or last vertex of an object was only a
//        short distance from the edge of a cell.
//    '3.9.0.6' bug fix: (not in released version). Fixed a bug that caused
//        problems with interpolation.
//    '3.9.0.7' Bug fix: Fixed bug that could cause a divide by zero error
//        when plotting MODPATH pathlines.
//      Bug fix: Fixed export of Zonebudget data for MODFLOW-LGR child models.
//      Bug fix: Fixed bug that could cause imported images to be drawn at
//        the incorrect locations.
//    '3.9.0.8' bug fix: Fixed bug that would cause an error when specifying
//        farm diversions in MODFLOW-OWHM if incomplete information was
//        entered.
//      Bug fix: Fixed bug that caused an error if exporting data set 33 of
//        the farm process without defining the precipitation.
//      Bug fix: Fixed a bug that could prevent ModelMuse from launching a
//        web browser.
//    '3.9.0.9' Enhancement: It is now possible to specify that the starting
//        locations of MODPATH particles are at the exact location of a point
//        object with a single Z formula.
//   '3.9.0.10' Enhancement: The user can now specify the thickness of lines
//        used to draw cross sections in the "Data|Display Data" dialog box.
//      Bug fix: Fixed bug that caused errors when attempting to read
//        shapefiles containing null shapes.
//   '3.9.0.11' Bug fix: Opening a ModelMuse file that has lines to be added
//        to the MODFLOW name file in the parent model no longer results in
//        those same lines being added to the child model.
//      Bug fix: In MODFLOW-LGR version 1 models in which child models have
//        one layer, boundary conditions in that layer will stay in that
//        layer.
//   '3.9.0.12' Change: When ModelMuse starts and creates a new model,
//        it will be maximized if it was maximized the last time it was
//        closed.
//      Enhancement: When importing an Ascii raster a warning will be
//        issued if some cells have no data points in them.
//      Enhancement: In the Object Properties dialog box, you can now copy
//        imported data to the clipboard.
//      Change: When importing Shapefiles, the default choice will be to join
//        the shapes into a single object if they can be joined.
//      Enhancement: When importing Shapefiles, it is now possible to cancel
//        the import process.
//      Bug fix: When importing head observations from a shapefile, ModelMuse
//        will now ensure that each head observation has a unique name.
//      Enhancement: When importing an existing MODFLOW model, the user now
//        has the option of importing just a subarea of the model and using
//        the stored heads or flows from the original model as boundary
//        conditions on the edge of the imported model area.
//   '3.9.0.13' Enhancement: It is now possible to export the grid lines from
//        the "File|Export|Shapefile|Model Outline or Grid Lines..." dialog
//        box.
//   '3.9.0.14' Bug fix: Fixed bug that could cause an error when setting
//        the names of the chemical components used in MT3D.
//   '3.9.0.15' Enhancement: When importing DXF files, they now can be
//        imported as a single object.
//   '3.9.0.16' Bug fix: Fixed bug that caused a bug report to be generated
//        if certain files that should have been present were absent. Instead
//        an error report is generated explaining how the user can fix the
//        problem.
//      Enhancement: When importing Shapefiles, "Comma-separated value" (.csv)
//        files can be used to include additional data which are treated
//        as Shapefile attributes.
//   '3.9.0.17' Bug fix: (not in released version). Fixed export of grid
//        lines to shape file.
//   '3.9.0.18' Bug fix: (not in released version). Fixed export of grid
//        lines to shape file.
//   '3.9.0.19' Enhancement: ModelMuse now warns the user if the starting or
//        ending stage in the RES package are too low.
//      Bug fix: Fixed bug that caused objects that defined FHB boundaries
//        to have extra times added when opening some existing models.
//   '3.9.0.20' Enhancement: When exporting images, the user can now specify
//        the caption for the color legend and contour legend.
//      Bug fix: Fixed bug in export of Data sets 7-10 in MT3D-USGS if no
//        associated concentration have been defined.
//      Bug fix: When exporting MT3DMS files, spaces are replaced with
//        underscore characters in input and output files.
//   '3.9.0.21' Enhancement: ModelMuse can not run models on network drives.
//   '3.9.0.22' No real change.
//   '3.9.0.23' Bug fix: Importing models using the HYDMOD package in which
//        the number of observation locatins exceeds the user specified
//        number no longer causes an error.
//      Enhancement: The Show or Hide Objects dialog box now allows the user
//        to show or select objects whose names contain a specified search
//        term.
//   '3.9.0.24' Enhancement: The user can now use buttons to check or uncheck
//        a group of items in the "Select Objects for Editing or Deletion"
//        dialog box.
//      Enhancement: Added warnings about models that have too many stress
//        periods or time steps to use with formatted head or drawdown output
//        files.
//      Bug fix: When writing the input for the reaction package in MT3D-USGS,
//        a default value of zero is now written for IREACTION.
//   '3.9.0.25' No real change
//   '3.9.0.26' Bug fix: Fixed bug that could cause an assertion failure when
//        exporting contours to a Shapefile.
//   '3.9.0.27' Bug fix: Fixed bug that could cause an assertion failure
//        when attempting to import a MODFLOW binary head file that was
//        created by a model with fewer layers than the current MODFLOW
//        model.
//   '3.9.0.28' Bug fix: Fixed bug in export of SWR input data sets 5 and 6.
//   '3.9.0.29' Bug fix: Fixed a bug that could cause an access violation
//        when the user changed the symbol used as the decimal character.
//      Enhancement: Added support for WellFootprint program.
//      Enhancement: In the DRN, DRT, GHB, RIV, and WEL packages, if no
//        boundary cells are defined in the package, the package is not
//        included in the model.
//      Bug fix: Fixed renaming model results data sets prior to closing
//        the model.
//      Enhancement: When importing Shapefile attributes as new data sets
//        with names that match existing data sets, the user is given options
//        about how to treat those attributes.
//      Bug fix: "Restart Model" button in ModelMonitor now works.
//   '3.9.0.30' Bug fix: If the PVAL file is listed in the MODFLOW Name File
//        dialog box, it will no longer be generated by ModelMuse.
//   '3.9.0.31' Bug fix: Modified export of SWR input file so that the
//        data values in data set 13 did not exceed 200 characters.
//   '3.10.0.0' Enhancement: Vertex value names are now sorted in a better
//        way then before.
//   '3.10.0.1' Bug fix: Fixed deletion of MODPATH release times in the
//        Object Properties dialog box.
//      Bug fix: If a MODPATH 5 pathline, time-series or endpoint file
//        contains invalid data such as "-NaN", ModelMuse stops reading the
//        file and displays an error message instead of generating a bug
//        report.
//   '3.10.0.2' Bug fix: Fixed bug that caused a range check error if the
//        Reservoir package is activated but no reservoirs have been defined.
//      Bug fix: Fixed bug that would cause an error when undoing the import
//        of a shape file.
//   '3.10.0.3' Bug fix: Fixed bug in which times were not updated correctly
//        in objects defining EVT, ETS, RCH, or UZF boundaries.
//   '3.10.0.4' Enhancement: When importing head observations from Shapefiles,
//        missing time or head values will be skipped.
//      Bug fix: Fixed a bug that would cause a bug report to be generated
//        under certain circumstances if the user specified an invalid
//        formula. Now an error message is displayed instead.
//   '3.10.0.5' Bug fix: Fixed bug that could cause parameter instance names
//        to be omitted in some input files.
//   '3.10.0.6' Bug fix: Fixed a bug that could cause assertion failures when
//        exporting SUTRA time schedules.
//   '3.10.0.7' Bug fix: Fixed a bug that would cause access violations if
//        the number of segments in the ETS package was reduced.
//      Bug fix: Fixed LastVertexValue function to give correct result.
//      bug fix: When starting a new model, clicking the "No Grid" button
//        now allows the georeference information to be included in the model.
//   '3.10.0.8' Bug fix: Fixed bug that caused an assertion failure when
//        attempting to create a new HFB parameter.
//   '3.10.0.9' Bug fix: Fixed bug that caused the Well package input file
//        to be invalid if WEL parameters were defined in a MODFLOW-NWT model.
//   '3.10.0.10' Bug fix: Fixed a bug that caused MODFLOW to receive invalid
//                elevation values for drain, river, or GHB cells when flow
//                observations were defined but the boundaries were not
//                defined for the entire simulation period.
//   '3.10.0.11' No released changes.
//   '3.10.0.12' Enhancement: Added ability to import net recharge and net
//                discharge files saved by the UZF package.
//   '3.10.0.13' Bug fix: Fixed creating Kz data set when starting up a new
//                model without a grid.
//               Enhancement: Cross section plots of 2D and 3d data sets are
//                now enabled with SUTRA models.
//   '3.10.0.14' Bug fix: When writing the input for the STR package in
//                MODFLOW-LGR models, ModelMuse now writes them using
//                the fixed format required by MODFLOW-LGR rather than the
//                free format used by MODFLOW-2005.
//               Bug fix: When writing the MODFLOW-LGR LGR file, if no objects
//                define the position of the child grid but a child grid
//                does exist, the LGR file now specifies the location of the
//                LGR grid within the parent grid correctly.
//   '3.10.0.15' ----------
//   '3.10.0.16' Bug fix: Fixed exporting contours to shapefiles when the
//                the "Data|Display Data" window has not yet been displayed.
//               Bug fix: not in released version Fixed updating dimensions
//                of multiplier zone data sets in DISV grids.
//               Bug fix: not in released version. Fixed export of Point
//                Shapefiles with DISV grids.
//   '3.10.0.17' Enhancement: •	By default, when importing well footprint
//                results, Values of 0 and 1 for Footprint code and 0 for
//                distributed withdrawals will not be used for coloring
//                the grid.
//               Bug fix: Warning message about MODFLOW-NWT version 1.0.9
//                has been fixed.
//   '3.10.0.18' Bug fix: Fixed bug that could allow semi routed deliveries
//                and return flow to be included in the Farm Process input
//                after disabling the SFR and SWR packages.
//   '3.10.0.19' Bug fix: Fixed bug that could cause an access violation when
//                displaying data in the "Data|Data Set Values" dialog box.
//               Bug fix: Fixed bug that could cause an access violation
//                when attempting to manually define a legend.
//               Bug fix: The tables on the Print/Save tabs of the SUB and
//                SWT packages in the MODFLOW Packages and Programs dialog
//                box are now fully visible.
//   '3.10.0.20' Enhancement: Added support for running MODPATH 7.
//               Bug fix: Fixed bug that could cause the FHB package to cause
//                an error if large time values are used.
//   '3.10.0.21' Bug fix: When plotting contour lines of a data set using
//                the log-transform option, data set values less than or
//                equal to zero will no longer cause an error unless all the
//                values in the data set are less than or equal to zero.
//               Enhancement: Contour data sets in models that don't use
//                regular grids can no longer allow contour lines that extend
//                beyond the spatial limits of the data even when the outline
//                of the active area of the model is concave.
//               Bug fix: Fixed bug that could cause errors when importing
//                model results from the .cbc file in models with
//                non-simulated layers.
//   '3.10.0.22' Bug fix: Fixed bug that caused access violations in
//                the Object Properties dialog box if ModelMuse was inactive
//                for a long time.
//   '3.10.0.23' Enhancement: It is now possible to export STR to
//                Shapefiles.
//               Bug fix: Fixed bug that could cause a range check error when
//                interpolating using the Inverse Distance Squared method.
//   '3.10.0.24' Enhancement: In MODFLOW-OWHM, the option to prorate
//                semirouted deliveries over multiple streams has been
//                implemented.
//   '3.10.0.25' Bug fix: When creating an archive file for MT3D, the
//                directory for the .ftl file was specified incorrectly.
//               Bug fix: Fixed import of flow or head boundaries when
//                importing a subarea model.
//   '3.10.0.26' Bug fix: Fixed bug that prevented users from entering some
//                real-number values
//   '3.10.0.27' Bug fix: Fixed bug that prevented writing dBASE files larger
//                than 2 gigabytes.
//               Enhancement: When exporting Shapefiles, there is now a
//                warning if the size of the dBASE file will exceed two
//                gigabytes.
//   '3.10.0.28' Fixed a bug that prevented GSFLOW from using discretization
//                files created by ModelMuse.
//   '3.10.0.29' Enhancement: The new command "Grid|Rotate Grid Around Grid
//                Origin" allows the user to specify a grid angle and have
//                the grid rotate to that angle with the center of rotation
//                set to the grid origin. For MODFLOW models, the grid origin
//                is the upper left corner. For PHAST models the grid origin
//                is the lower left corner.
//               Enhancement: The new command "Grid|Move Grid" allows the
//                user to move the grid origin to a new position.
//   '3.10.0.30' Bug fix: Fixed bug in display of prorate option in
//                the return flow from farms in MODFLOW-OWHM.
//               Bug fix: Fixed bug that could cause an assertion failure
//                when exporting the input for the FHB package.
//   '3.10.0.31' Bug fix: Fixed bug in importing sub-area models from
//                MODFLOW that would cause boundary conditions to be imported
//                with incorrect values.
//               Bug fix: Fixed bug that could cause an error when displaying
//                the Georef dialog box or when exporting Georef data.
//   '3.10.0.32' Bug fix: Fixed bug that incorrectly checked the farm, crop
//                and soil IDs in MODFLOW-OWHM.
//               bug fix: Fixed bug that could cause the FHB file to be
//                created incorrectly.
//   '3.10.0.33' Bug fix: Fixed bug that could cause an access violation when
//                pasting data into the "Manage Head Observations" dialog box.
//               Bug fix: Fixed bug that could cause an assertion failure
//                when exporting data sets evaluated at nodes to a Shapefile
//                from a MODFLOW model.
//   '3.10.0.34' Bug fix: Fixed bug that could cause an error when attemping
//                to import data from a Shapefile in which one of the
//                attributes had the same name as a global variable.
//   '3.10.0.35' bug fix: not in releasaed version, Fixed bug that could
//                cause the FHB file to be created incorrectly and to delete
//                FHB data.
//   '3.10.0.36' bug fix: Fixed bug that could cause dependent data sets to
//                fail to be updated properly when global variables are
//                changed.
//               Bug fix: Fixed bug that could cause the UZF package input
//                file to specify its options incorrectly.
//   '3.10.0.37' Bug fix: In the Grid and Mesh Values dialog box, values for
//                pathlines and endpoints for the currently selected column,
//                row, or layer are now displayed correctly.
//   '3.10.0.38' Bug fix: fixed bug that could cause contours to be exported
//                to be exported incorrectly to Shapefiles.
//               Change: ModelMuse now works with GMSH version 4.
//   '3.10.0.39' Bug fix: Fixed bug that prevented PRODF1 and PRODS1 from
//                being set to negative values in SUTRA models.
//   '3.10.0.40' Change: If the UZF_Layer data set has an invalid value,
//                ModelMuse now identifies the cells that have invalid values.
//               Bug fix: Fixed bug in export of data set 4b in the UZF
//                package.
//               Bug fix: When writing arrays, real number values between
//                -2^-37 and +2-37 will be written as 0.0 to prevent
//                underflow errors in MODFLOW when reading single precision
//                arrays.
//               Bug fix; When saving .gpt files, memory usage is reduced
//                which can prevent out of memory errors for some large
//                files.
//   '3.10.0.41' Enhancement: It is now possible to export the formula for
//                the concentration specified for the MT3DMS SSM in an
//                object to a Shapefile.
//   '3.10.0.42' Bug fix; Fixed a bug that could cause an access violation
//                when attempting to import a shapefile with a
//                self-intersecting shape.
//               Bug fix: Fixed a bug that could cause a stack overlfow when
//                ModelMuse is closed.
//   '3.10.0.43' Enhancement: Added a warning to use a iterative solver in
//                SUTRA models with over 1000 nodes.
//               Bug fix: If an attempt is made to use an undefined STR
//                parameter, an error message will be generated instead of
//                sending a bug report.
//               Bug fix: Fixed a bug that prevented Vertex valeus from being
//                used to set elevation formulas.
//   '3.10.0.44' Bug fix: If the user attempts to create a MODFLOW model with
//                a number of cells larger than the largest 32-bit signed
//                integer, an error message will be displayed instead of
//                generating a bug report.
//   '3.10.0.45' No real change.
//   '3.10.0.46' Bug fix: Fixed bug with creating invalid mesh with Fishnet
//                Mesh.
//   '3.10.0.47' Bug fix: Not in released version. Fixed use of parameters
//                in MODFLOW 6.
//   '3.10.0.48' Bug fix: If an object whose number of Z formualas is not
//                equal to zero sets the elevations of the grid or mesh, it's
//                number of Z formulas is automatically reset to zero.
//               Bug fix: If the number of values of a data set cached in
//                a file is too large, the data set will be recalculated when
//                next accessed
//               Bug fix: Deleting an HFB parameter now changes any existing
//                HFB boundaries to no longer use the deleted parameter.
//   '3.10.0.49' Enhancement: When importing Shapefiles, the imported objects
//                will have their positions locked by default.
//               Enhancement: When importing Shapefiles, it is now possible
//                to use a text attribute to assign the names of the
//                imported object.
//               Bug fix: If the distance between all the points in a section
//                of an object is small enough so that all the vertices map
//                to the same pixel, the object or section of an object will
//                be displayed as if it were a point object.
//               Bug fix: Not in released version. Drawing selected objects
//                that have vertex values is fixed.
//   '3.10.0.50' Bug fix: "Snap to vertex" now works as described in the
//                ModelMuse help. Previously, it would snap to the same
//                pixel as the one containing the target vertex but not
//                necessarily to the exact same location.
//   '3.10.0.51' Enhancement: When using an MT3D starting concentration file,
//                the user can now select to use just the first data set in
//                the file regardless of which time step it represents.
//   '3.10.0.52' Bug fix: Fixed export of data set 2 in the SWT package so
//                that more layer numbers can be printed without exceeding
//                the maximum line length of 200.
//   '3.10.0.53' Enhancement: (not in released version). ModelMuse now warns
//                the user if all the cells in the model are either inactive
//                or pass-through cells.
//   '3.10.0.54' ---
//   '3.10.0.55' Change: When automatically generating a legend when
//                coloring or contouring the grid with a real-number data set
//                and the user has specified the limits to be colored. Those
//                same limits are applied when generating the legend.
//   '3.10.0.56' Bug fix: Fixed bug in importing Shapefiles in which the
//                conductance interpretation was specified on a per shape
//                basis using a text attribute of the shape.
//               Bug fix: Fixed bug in numbering SFR segments when the UZF
//                package is used and excess infiltration is redirected to
//                SFR segments.
//   '3.10.0.57' Bug fix: Fixed bug that could cause access violations if the
//                FHB package was being used.
//   '3.10.0.58' Change: ModelMuse updated to work with Gmsh version 4.3
//               Bug fix: Fixed a bug that would make the import of
//                Shapefiles slower than it needed to be.
//   '3.10.0.59' Change: The SelectionCount function was changed to avoid
//                counting the same cells more thatn once.
//               Change: Functions related to Vertex Values are now classified
//                under "Object_VertxValue".
//               Change: In the "Import Points" dialog box, data sets that
//                are used to define the vertical elevation of the grid or
//                mesh are now only allowed to be specified by objects that
//                have zero Z-formulas.
//  '3.10.0.60'  Bug fix: Fixed bug that could cause objects to be drawn
//                incorrectly.
//               Bug fix: Fixed bug that could cause assertion failures
//                when drawing vectors in SUTRA models.
//               Bug fix: Fixed bug that could cause access violations
//                when changing between boundary condition times with
//                PHAST models.
//               Enhancement: When importing groundwater flows frim the left,
//                front, and bottom of a cell, the same data is used to also
//                import data fort the right, back and top of the cell.
//   '3.10.0.61' Bug fix: The Flow-Transport-link file is no longer included
//                in the MODFLOW name file.
//   '3.10.0.62' Bug fix: (not in released version) Fixed minor bugs related
//                to MODFLOW 6
//   '3.10.0.63' Bug fix: Fixed a bug that could cause access violation
//                while closing ModelMuse.
//   '3.10.0.64' Bug fix: Fixed a bug that could cause an access violation
//                when exporting the FHB package.
//   '3.10.0.65' Bug fix: Fixed a bug that cause an access violation
//                when exporting SUTRA node data to a Shapefile.
//   '3.10.0.66' Change: The appearance of the tool tip used for measuring
//                lines has changed.
//               Bug fix: Fixed bug that could cause formulas to be evaluated
//                incorrectly if the formulas involved both 2D and 3D data
//                sets.
//   '4.0.0.0'   Bug fix: Modified export of the FMP package input files so
//                that many lines are written more compactly in order to
//                make it less likely that MODFLOW-OWHM will truncate a line
//                prematurely.
//               Bug fix: Fixed import of HYDMOD from existing models when
//                SFR is selected.
//               Enhancement: Added support for MODFLOW 6 and MODPATH 7.
//   '4.0.0.1'   Bug fix: Fixed bug that could cause division by zero errors
//                when drawing the top, front, or side views.
//               Bug fix: Fixed bug that could cause errors in determining
//                which cells were inside objects with multiple parts.
//               Bug fix: Fixed bug that could cause access violations when
//                deactivating SFR in objects.
//               Enhancement: In SUTRA boundary conditions, "Used" can now
//                be set using a formula.
//   '4.0.0.2'   Bug Fix: fixed bug that could cause access violations when
//                exporting the SFR package input in MODFLOW 6.
//               bug fix: Fixed bug that could cause the wrong identifier
//                to be displayed for an invalid formula in a model feature.
//   '4.0.0.3'   bug fix: Fixed a bug that could cause divide by zero errors
//                when drawing the top, front or side views.
//               bug fix: Fixed a bug that could cause an assertion failure
//                when generating the input for the SFR package.
//               bug fix: Fixed bug that could cause an error when attempting
//                to create a fishnet mesh.
//   '4.0.0.4'   Bug fix: Fixed bug that could cause an access violation when
//                the "ObjectIntersectArea" function is evaluated.
//   '4.0.0.5'   Change: If the user has not specified the location of one
//                of the modeling programs and the program is not found at
//                the default location, ModelMuse will strip "C:\" off the
//                beginning of the default location and append that to the
//                name of the subdirectory where ModelMuse is located and
//                will check to see if the program is located there. This
//                makes it simpler to bundle ModelMuse with the models using
//                WineBottler to run it on the Mac.
//   '4.0.0.6'   Bug fix: Fixed bug that prevented the user from specifying
//                the MVR package information.
//   '4.0.0.7'   Enhancement: In the SFR package for MODFLOW 6, there is now
//                a check that the sum of the upstream fractions of the
//                downstream reaches of a reach add up to 1.
//               Bug fix: MODFLOW 6 files can now be exported from the command
//                line using command-line parameters.
//   '4.0.0.8'   Bug fix: Fixed bug that could cause a range check error when
//                Creating a DISV grid in MODFLOW 6.
//   '4.0.0.9'   Bug fix: Fixed bug in reading SFR6 data from file.
//               Bug fix: Fixed bug in writing idiv in MODFLOW 6 SFR6
//                input file.
//               Bug fix: not in released version. Fixed getting vertex
//                values.
//   '4.0.0.10'  bug fix: Fixed bug in which mxiter in the MODFLOW 6
//                Simulation Name File was not exported correctly.
//   '4.0.0.11'  Bug fix: Fixed bug in identifying MVR sources when
//                the UZF package is used.
//   '4.0.0.12'  Bug fix: Fixed bug that could cause an access violation
//                when editing and SFR stream in MODFLOW 6.
//               Bug fix: The data sets for Angle1, Angle2, and Angle3 were
//                only created and used if the XT3D option was selected
//                instead of whenever the NPF package was selected.
//    '4.0.0.13' Enhancement: ModelMuse now warns if the bottom of the
//                stream bed in an SFR reach in MODFLOW 6 is below the bottom
//                of the cell.
//               Bug fix: Fixed bug that could cause an error if a lake outlet
//                was a source for the MVR package in MODFLOW 6.
//               bug fix: Fixed bug in specifying lake outlets that could
//                cause them not to be saved properly.
//               Bug fix: The MODPATH_Zone data set was sometimes improperly
//                marked as required with MODPATH 7 when in reality it wasn't
//                used.
//               Enhancement: Support for SUTRA 3.0 added.
//               Bug fix: Fixed bug that could cause an error if the user
//                tried to rename a data set.
//               Bug fix: Fixed a bug that could cause a bug report to be
//                generated if the mouse wheel was moved over the NPF options
//                grid in the MODFLOW Packages and Programs dialog box.
//               Bug fix: Fixed a bug that could cause an error if the number
//                of time steps in a stress period was greater than or equal
//                to 100,000.
//               Bug fix: Fixed bug that could cause an error if multiple
//                copies of ModelMuse are being run from the command line at
//                the same time.
//               Bug fix: Fixed a bug that could case an error if the last
//                time defined for a stream in a MODFLOW 6 model was earlier
//                than the last time in the model.
//               Bug fix: Transient data for the MVR package was not displayed
//                properly in the Object Properties dialog bos if the number
//                of times was not equal to 1.
//    '4.0.0.14' Bug fix: Fixed coloring pathlines with the Z coordinate when
//                DISV is used.
//    '4.0.0.15' Bug fix: Fixed bug that could cause an error when assigning
//                values to a data set using interpolation.
//    '4.0.0.16' bug fix: Fixed export of Step Schedules in SUTRA. Previously,
//                the exported time steps were smaller than then should have
//                been by one time step.
//               bug fix: Fixed bug that could cause an error when deleting
//                a custom color scheme.
//               Enhancement. MT3D can now be used with child models in
//                MODFLOW-LGR.
//    '4.0.0.17' Bug fix: Fixed a bug that could cause an access violation
//                importing a MODFLOW model containing the MNW2 package.
//    '4.0.0.18' Bug fix: Fixed the conversion of diversions from the
//                the MODFLOW-2005 version of SFR and STR to the MODFLOW 6
//                version of SFR.
//               Bug fix: Fixed bug in export of the MODPATH input files
//                for models with DISV grids.
//    '4.0.0.19' Bug fix: Fixed bug that could cause an access violation
//                when coloring the grid.
//    '4.0.0.20' Bug fix: Fixed bug that could cause EVT and RCH cells to
//                be defined in the wrong layers in MODFLOW 6 models.
//               Enhancement: ModelMuse now warns about grid columns and
//                rows that vary in size in MODFLOW 6 models that use
//                MODPATH.
//               Change: The UZF input file has been changed so that
//                infiltration and unsaturated zone ET are always saved to
//                the cell-by-cell budget file.
//    '4.0.0.21' Bug fix; Fixed bug that could cause some cells that are
//                intersected by an object to not be recognized as being
//                intersected by that object.
//               Bug fix: Fixed bug that could cause an access violation
//                when converting a structured grid to a DISV grid.
//    '4.1.0.0'  No additional changes.
//    '4.1.0.1'  Enhancement: The user can now specify that BCTime has
//                been programmed in SUTRA.
//               Bug fix: Fixed bug that could cause an error if a data set
//                type is changed after some data has been assigned.
//    '4.1.0.2'  Bug fix: Fixed a bug that could cause an integer overflow
//                when attempting to import an ascii raster that contains
//                a larger number of points.
//    '4.1.0.3'  Bug fix: Fixed a bug that could cause a range check error
//                when undoing or redoing the addition of new vertices to
//                the object.
//               Bug fix: Fixed a bug that could cause the BTN package input
//                to include an incorrect option with MT3D-USGS.
//               Bug fix: Fixed a bug that could cause an access violation
//                if the user attempts to open a ModelMuse file while the
//                Edit Data Sets dialog box is open.
//               Bug fix: Fixed a bug that could cause an access violation
//                in the "Show Grid or Mesh Values" dialog box when the
//                selected objecte is changled.
//               Bug fix: Fixed a bug that could cause MXSS to be calculated
//                incorrectly in the MT3D SSM package when the MNW2 package
//                is used.
//    '4.1.0.4'  Bug fix: Fixed bug that could cause ModelMuse to fail to
//                create the MVR file correctly when the UZF package was used
//                as a source.
//    '4.1.0.5'  Change: If ModelMuse attempts to copy an image to the
//                clipboard and fails because the clipboard is locked. it
//                will now try three times before giving up.
//    '4.1.0.6'  Bug Fix: Fixed bug that could cause access violations when
//                exporting MODFLOW boundary conditions.
//    '4.1.0.7'  Bug fix: Fixed bugs in archiving MODFLOW 6 and
//                MODPATH 7 files.
//               Bug fix: If HDRY and HNOFLO are set to zero, those values
//                are saved to the file when a ModelMuse file is saved.
//    '4.1.0.8'  Enhancement: Time-series file interpolation methods in
//                MODFLOW 6 are now supported.
//               Change: The description of SIGMAS in SUTRA has been changed
//                in the SUTRA Options dialog box.
//               Change: When writing time-series files for MODFLOW 6, lines
//                are now kept less than 2000 characters wide.
//               Bug fix: Fixed a bug that could cause an error when
//                converting an existing model to MODFLOW 6.
//    '4.1.0.9'  Bug fix: Fixed a bug that could prevent SFR boundaries from
//                being accepted as MVR sources.
//    '4.1.0.10' Change: The menu items used to select the type of model
//                have been moved out of "Model" and into "Model Selection".
//               Enhancement: Support for the SFT, LKT, UZT and CTS packages
//                in MT3D-USGS has been added.
//               Bug fix: Fixed writing the status of the first MAW well in
//                a stress period.
//               Enhancement: A "Paste Data" button was added to the "Import
//                Gridded Data dialog box.
//               Bug fix: The MT3D_Active data setcorresponding to MT3D input
//                data set ICBUND set is no longer set to False if the
//                Active data set is set to false.
//    '4.1.0.11' Bug fix: Fixed saving Lake outlet width in MODFLOW 6.
//    '4.1.0.12' Bug fix: Fixed specifying recharge and evapotranspiration
//                layer with MODFLOW 6 models when the top layer option is
//                selected.
//    '4.1.0.13' Bug fix: Fixed bug that could cause and assertion failure
//                while generating the input for the Reservoir package.
//    '4.1.0.14' Bug fix: Fixed bug that could cause an error when displaying
//                the Data Visualization dialog box.
//    '4.1.0.15' Enhancement: The "File|Import Gridded Data Files" command
//                now works with DISV MODFLOW 6 models and SUTRA models.
//    '4.1.0.16' Enhancement: The operators "^" and "**" have been added.
//                Both allow one number to be raised to the power of another
//                number.
//               Bug fix: Fixed a bug that could cause an access violation
//                in the "Data|Display Data Set Values" dialog box.
//               Bug fix: Fixed a bug that could cause an access violation
//                when exporting the CHD input file.
//               Bug fix: Fixed a bug that could cause ModelMuse to enter
//                and infinite loop when evaluating a data set using an
//                object on the front view of the model.
//    '4.1.0.17' Enhancement: Added support for NOCHECK, MEMORY_PRINT_OPTION,
//                and MAXERRORS in mfsim.nam options.
//               Enhancement: Added support for INFLOW, in the MODFLOW 6 Lake
//                package.
//               Enhancement: Added support for NO_PTC, in the MODFLOW 6 IMS
//                package.
//               Enhancement: Added support for K22OVERK and K33OVERK
//                in the the MODFLOW 6 NPF package.
//    '4.1.0.18' Bug fix: Fixed bug that prevented MNW1 wells from being
//                edited correctly.
//               Bug fix: Not in released version. Fixed evaluataion of Ky
//                in non MF6 models.
//               Bug fix: fixed bug that prevented well screens in MAW wells
//                from being edited correctly.
//               Enhancement: Added additional error checking for MAW wells.
//    '4.1.0.19' Enhancement: ModelMuse can now convert the UZF package for
//                MODFLOW-2005 to the UZF package for MODFLOW 6.
//    '4.1.0.20' Bug fix: ModelMuse now allows the user to specify a return
//                location in DRT as a Farm in the Farm process or a SWR
//                reach with MODFLOW-OWHM models.
//    '4.1.0.21' Bug fix: Fixed a bug that prevented some DXF files from
//                being imported correctly.
//    '4.1.0.22' Enhancement: Improved display of actions during export of
//                MAW package.
//    '4.1.0.23' Enhancement: The Edit Feature Formula dialog box can now be
//                used with the MAW package.
//    '4.1.0.24' Bug fix: ModelMuse now assigns IFACE values for recharge
//                and evapotranspiration in MODFLOW 6.
//               Bug fix: Fixed assignment of UZF6 package data.
//    '4.1.0.25' Enhancement: If no data has been assigned to a data set,
//                the legend tab in the Data Visualization dialog box will
//                be empty.
//               Bug fix: Fixed import of Surfer Grid files into a
//                DISV MODFLOW 6 model.
//    '4.1.0.26' Bug fix: Fixed a bug that could cause the Point Average
//                Interpolation method to fail if a point was at the edge
//                of two cells.
//    '4.1.0.27' Bug fix: Fixed option to select all the data from a single
//                time step whem importing results.
//               Bug fix: Added OUTER_RCLOSEBND to variables in that can be
//                edited in the IMS solver.
//               Bug fix: If the values of INNER_HCLOSE, INNER_MAXIMUM,
//                INNER_MAXIMUM,LINEAR_ACCELERATION, OUTER_HCLOSE,
//                OUTER_MAXIMUM, and BACKTRACKING_NUMBER are not overriden,
//                the values that are written to the IMS input file are the
//                values suggested in the MODFLOW 6 input instructions based
//                on the complexity of the problem.
//               Bug fix: Fixed a bug in importing Shapefiles in which
//                two or more Shapefile Attributes have the same name.
//    '4.1.0.28' Bug fix: Fixed bug in export of MAW. FLOWING_WELL now
//                exported correctly.
//               Bug fix: ModelMuse will now generate an error message
//                instead of sending a bug report if no valid times have
//                been defined in the HFB package in MODFLOW 6.
//    '4.1.0.29' Bug fix: Fixed export of grid lines for the active area
//                to a Shapefile.
//               Bug fix: Fixed display of active cells in MODFLOW 6 to
//                IDOMAIN > 0.
//               Bug fix: Fixed specifying overirdes of nonlinear variables
//                in IMS package in MODFLOW Packages and Programs dialog box.
//    '4.1.0.30' Bug fix: Fixed bugs in specifying backtracking_tolerance
//                and outer_rclosebnd in the IMS package.
//    '4.1.0.31' Bug fix: Fixed bug in the "Show Grid or Mesh Values" dialog
//                box that could cause an access violation.
//    '4.1.0.32' Bug fix: when converting to a MODFLOW 6 model, the Storage
//                package is now automatically activated if the model is
//                transient.
//               Bug fix: Fixed bug that could cause an error when exporting
//                the UZF input file.
//    '4.2.0.0'  Bug fix: When converting MNW2 wells to MAW wells, the SKIN
//                option in MNW2 is now converted to the CUMULATIVE option
//                in MAW instead of the SKIN option in MAW.
//               Bug fix: Fixed a bug that could cause issues with evaluating
//                formulas that involve only integers.
//    '4.2.0.1'  Bug fix: Fixed a bug that caused an assertion failure if
//                MODFLOW 6 SFR streams were not assigned for every stress
//                period.
//               Bug fix: Fixed position of buttons for no-delay beds in the
//                MODFLOW Layers dialog box.
//               Bug fix: Fixed position of buttons for the SF6, MAW,
//                and MT3D SSM packages in the Object Properties dialog box.
//               Bug fix: Fixed a bug that could cause a bug report to create
//                when attempting to export an object to a Shapefile.
//    '4.2.0.2'  Bug fix: When importing a Shapefile, ModelMuse gives the
//                option to convert from decimal degrees to UTM coordinates.
//                However, this may result in an invalid operation if the
//                actual coordinates are not in decimal degrees. ModelMuse
//                now displays an error message rather than sending a bug
//                report in such cases.
//    '4.2.0.3'  Enhancement: Added support for CSUB package in MODFLOW 6.
//               Bug fix: Fixed bug that could cause an assertion failure if
//                an object that defined a MAW well was in a cell that was
//                inactive in the top layer.
//    '4.2.0.4'  Bug fix: Fixed display of pump capacity table in the MNW2
//                package.
//               Enhancement: Added "Object|Edit|Anonymize Selected Point
//                Objects command.
//    '4.2.0.5'  Bug fix: Fixed bug that could cause a range check error
//                when using the UZF package in MODFLOW 6.
//               Bug fix: If ModelMuse encounters and error when trying to
//                back up an initialization file, it no longer generates a
//                bug report.
//               Bug fix: Fixed bug that could cause range check errors when
//                editing MNW2 wells.
//               Bug fix: Fixed bug importing an existing MODFLOW model.
//               Bug fix: Fixed editing of stream gages.
//               Bug Fix: Fixed bug in opening ModelMuse file for
//                WellFootprint models.
//    '4.2.0.6'  Bug Fix: Fixed bug in saving ModelMuse file for
//                WellFootprint models.
//               Bug fix: Fixed bug that allowed the user to import
//                Shapefiles that directly set the withdrawal rate in
//                WellFootprint models.
//               Bug fix: Fixed bug that allowed the user to import
//                points that directly set the withdrawal rate in
//                WellFootprint models.
//               Bug fix: Fixed bug that could cause the model selection
//                to be set to the wrong value when creating a new model.
//               Bug fix: Fixed bug that could cause ModelMuse to have an
//                Input/Output error when importing a model.
//               Bug fix: Fixed bug that could cause importing points to
//                fail if the values being imported had extra spaces before
//                or after any value.
//    '4.2.0.7'  Enhancement: ModelMuse now uses less memory when importing
//                existing models.
//               Bug fix: If the user attempts to plot a MODPATH, pathline,
//                end-point, or time-series file that contains invalid layer
//                numbers, ModelMuse will display an error message instead of
//                generating a bug report.
//    '4.2.0.8'  Bug fix: Fixed a bug that could make it impossible to open
//                a ModelMuse file.
//               Enhancement:Custom color schemes can now be used when
//                plotting MODPATH data.
//    '4.2.0.9'  No real change.
//    '4.2.0.10' Bug fix: Fixed using binary head file for initial heads in
//                MODFLOW 6.
//               Enhancement: When importing an existing model that uses the
//                BCF package, specific storage is calculated from
//                the confined storage coefficient and hydraulic conductivity
//                is calculated from transmissivity.
//               Bug fix: When converting to MODFLOW 6 from earlier versions
//                of MODFLOW the user can now convert the FHB package to the
//                CHD and WEL packages.
//               Bug fix: When converting to MODFLOW 6 from a model in which
//                the NWt package is selected, the Newton option in
//                MODFLOW 6 is now selected automatically.
//               Bug fix: Fixed using binary head file in MODFLOW 6 for
//                starting heads.
//    '4.2.0.11' Bug fix: Fixed export of "NO_PTC" option in MODFLOW 6.
//               Change: The NEWTON and UNDER_RELAXATION options in MODFLOW 6
//                can now be specified in the MODFLOW Packages and Programs
//                dialog box as well as the MODFLOW Options dialog box.
//    '4.2.0.12' Bug fix: Fixed bug that caused an error if the user attempted
//                to rename a layer group with an invalid name.
//               Bug fix: Fixed bug that could cause an error when drawing
//                contours.
//    '4.2.0.13' Bug fix: Fixed bug that could cause an assertion failure
//                when drawing contours using the ACM 626 method.
//    '4.2.0.14' Bug fix: Fixed but that cause a conversion error if the
//                user failed to specify the properties of a lake outlet
//                correctly.
//    '4.2.0.15' Change: Modified export of the MODFLOW-2005 Lake package
//                input to allow for periods in which no lakes are active.
//               Bug fix: Fixed a bug that could cause an access violation
//                when updating the legend for the colors displayed in
//                the Data Visualization dialog box.
//               Bug fix: Fixed a bug that could cause an access violation
//                in the Global Variables dialog box.
//    '4.2.0.16' Change: Modified export of the MODFLOW-2005 Lake package
//                input to allow for periods in which no lakes are active.
//    '4.2.0.17' Bug fix: Fixed bug that resulted in a bug report being
//                generated if ModelMuse attempted to import SUTRA results
//                containing "NaN".
//               Bug fix: Fixed export of SUTRA data sets 21A and 21B when
//                they are inactive initially.
//               Bug fix: Fixed a bug that caused issues with opening files
//                that contained very large or very small real number values.
//    '4.2.0.18' Bug fix: Fixed a bug that could cause an assertion failure
//                when exporting SUTRA models.
//               Enhancement: ModelMuse now warns the user if any specified
//                head cells are cells for which Kx, Ky, and Kz are all zero.
//               Bug fix: Fixed a bug in inserting or deleting well screens
//                in the MNW2 package.
//               Bug fix: When importing Shapefiles that contained measured
//                values, values less than -1E38 are treated as no-data
//                values.
//               Bug fix: Fixed bug that could cause an assertion failure
//                if identical starting and ending times were specified for
//                the RCH package.
//               Bug fix: Fixed bug in reading binary MT3D model results
//                that could cause a bug report to be generated.
//               Bug fix: Fixed bug in inserting a new composite zone for
//                Zone Budget in the "Model|MODFLOW Packages and Programs"
//                dialog box.
//               Enhancement: ModelMuse now prints the number of active cells
//                in a MODFLOW model as a comment either in the Basic package
//                input file for pre-MODFLOW6 models or in the DIS or DISV
//                files in MODFLOW 6 models.
//    '4.2.0.19' Bug fix: When exporting MT3D model input files, ModelMuse
//                will now check whether any .ucn files that will be created
//                by the model already exist. If they do exist, ModelMuse
//                will delete them.
//    '4.2.0.20' Bug fix: Fixed bug that could cause an access violation when
//                manually specifying the SUTRA mesh.
//               Bug fix: Fixed a bug that could cause the MAW observations
//                to be written incorrectly.
//               Change: With MODFLOW 6 observations, a prefix is added before
//                each observation name to ensure that all the observation
//                names are unique.
//               Bug fix: It is now possible to inactivate a STR boundary by
//                deleting all the times at which the boundary is defined.
//               Bug fix: Fixed export of grid data to Shapefile with DISV
//                grids. Formerly, the cells boundaries could be exported in
//                counterclockwise direction instead of clockwise direction.
//               Bug fix: Fixed drawing active area outline to avoid access
//                violations.
//    '4.2.0.21' Bug fix: Changing the times of the MODFLOW Stress periods
//                will now result in the times of MNW2 wells being updated to
//                the same times.
//    '4.2.0.22' Bug fix: In MODFLOW 6 models, the CHD ending head can no
//                longer be specified without using a parameter.
//               Bug fix: When converting to a MODFLOW 6 model, CHD boundaries
//                that don't use parametes are converted to CHD boundaries
//                that use a parameter.
//    '4.2.0.23' Bug fix: When attempting to read an invalid .nod or .ele
//                SUTRA output file, ModelMuse will now generate an error
//                message for the user instead of issuing  a bug report.
//    '4.2.0.24' Bug fix: When attempting to read an invalid
//                MODPATH output file, ModelMuse will now generate an error
//                message for the user instead of issuing  a bug report.
//               Bug fix: Fixed bug that could cause objects to fail to
//                intersect all the correct cells in MODFLOW DISV models.
//    '4.2.0.25' Change: ModelMuse no longer produces times series files for
//                parameters in the DRN and RCH packages.
//    '4.2.0.26' Change: ModelMuse no longer produces times series files for
//                parameters. Instead, parameter values are incorporated
//                into the values in the package input file.
//               Bug fix: Fixed a bug that could cause an assertion failure
//                if recharge or evapotranspiration was used in
//                some of the stress periods but not in others.
//    '4.2.0.27' Bug fix: With MODFLOW 6 models in which the "Top Active Cell"
//                option in the Recharge and Evapotransipiration packages
//                is selected, ModelMuse will automatically specify the
//                layer as the top active layer at a particular location.
//    '4.2.0.28' Enhancement: Added new function: HighestActiveLayer. It
//                returns the highest layer at a particular location that is
//                active.
//               Change: The ActiveOnLayer function was changed for MODFLOW 6
//                models to return True in the IDOMAIN data set is greater
//                than 0.
//               Bug fix: Fixed bug in export of the MODFLOW-2005 Lake package
//                input file that could prevent data set 9 from being written
//                for some stress periods after the first stress period.
//    '4.2.0.29' Bug fix: Fixed a bug that could cause an access violation
//                when displaying the Object Properties dialog box.
//               Bug fix: Corrected spelling of CUPBGO in the Object
//                Properties dialog box the the SUTRA Generalized Flow
//                Boundary
//               Bug fix: Fixed allowing multiple "Used" formulas to be
//                edited at once for SUTRA boundaries.
//               Bug fix: Fixed "Navigation|Go To" dialog box to work more
//                easily with SUTRA 2D models.
//               Enhancement: Not in released version. PEST Beta 1.
//    '4.2.0.30' No real change
//    '4.2.0.31' Enhancement: In 3D SUTRA models, there is a new data set
//                named Active_Node. Setting that data set to False at any
//                node makes the node inactive.
//    '4.2.0.32' Bug fix: Fixed bug that could cause assertion failures when
//                exporting boundary conditions in SUTRA.
//    '4.2.0.33' Bug fix: Fixed a bug that could cause the UZF input file to
//                be created incorrectly.
//    '4.2.0.34' Bug fix: Fixed bug in animating contours.
//               Enhancement: added SUTRA_MeshEdgeNode function.
//    '4.2.0.35' Bug fix: If the user attempts to import a mesh that is not
//                in the correct format, ModelMuse now displays an appropriate
//                error message instead of generating a bug report.
//    '4.2.0.36' Bug fix: When creating a new MODFLOW model, the user
//                specified length and time units were not applied if the user
//                clicked the "No Grid" button.
//               Bug fix: Fixed a bug that could cause an invalid warning to
//                be issued about transient SFR items with a duration of zero.
//               Bug fix: Changing a time in the MODFLOW Time dialog box now
//                causes corresponding times defined for SFR package to be
//                updated.
//               Change: When exporting a MODFLOW-OWHM model containing
//                parameters, the user is given the opportunity to turn off
//                printing cell lists.
//    '4.2.0.37' Enhancement: In MT3DMS models, ISSGOUT is now
//                specified if the MNW1 package is active. In MT3D-USGS
//                models, ISSGOUT is now specified if the MNW1 or MNW2
//                packages are active. The output file will have the extension
//                .mt_mnw_out.
//    '4.2.0.38' no real change.
//    '4.3.0.0'  Bug fix: Fixed a bug that could cause some formulas to fail
//                if a data set is renamed.
//               Enhancement: ModelMuse can now display specific discharge
//                vectors for MODFLOW 6 models.
//    '4.3.0.1'  Bug fix: If not MODFLOW stress periods are defined when the
//                user attempts to generate the MODFLOW input files, one will
//                now be created automatically.
//               Bug fix: It is no longer possible to define two parameters
//                with the same name in the Manage Parameters dialog box.
//               Bug fix: Fixed bug that could cause an access violation when
//                drawing contours with a MODFLOW DISV model.
//               Bug fix: In some cases where a circular reference error would
//                have resulted in a bug report, a message to the user will be
//                displayed instead.
//               Bug fix: Fixed bug in importing specific storage from the BCF
//                package when importing an existing MODFLOW-2005 or
//                MODFLOW-NWT model.
//    '4.3.0.2'  Bug fix: Fixed a bug that could cause a range-check error
//                when drawing contours if the cross section does not
//                intersect the mesh.
//    '4.3.0.3'  Bug fix: Fixed a bug that could cause a bug report to be
//                generated when opening an existing model.
//    '4.3.0.4'  Bug fix: Fixed defining CSUB observations for
//                csub, inelastic-csub, elastic-csub, sk, ske,
//                interbed-compaction, inelastic-compaction,
//                elastic-compaction, and thickness observation types.
//    '4.3.0.5'  Beta bug fix: Fixed export of head calibration observation.
//    '4.3.0.6'  Beta bug fix: Fixed export of template files.
//               Beta bug fix: Fixed export of boundname for flow observations
//    '4.3.0.7'  Bug fix: Fixed import of the MODFLOW-2005 lake package in
//                models with only one layer.
//               Bug fix: Fixed the ^ operator so that it will accept two
//                real-number arguments.
//    '4.3.0.8' Bug fix: Fixed bug in the Manage Head Observations dialog
//                box when the user clicked the Highlight Selected Object
//                button without first selecting any objects in the table.
//               Bug fix: ModelMuse now creates UCN file in MT3D-USGS for the
//                sorbed phase when the sorbtion choice is linear.
//    '4.3.0.9   Beta bug fix: Fixed export of head observations when no
//                calibration observations are defined.
//   '4.3.0.10'  Bug fix: ModelMuse now longer generates a bug report if the
//                user specifies more than one contour value for a boolean
//                data set.
//               Bug fix: When writing real number array values, real numbers
//                close to zero will be written as zero if they require more
//                precision than is provided by a single precision real number.
//   '4.3.0.11'  Bug fix: Fixed bug that could cause an assertion failure when
//                accessing vertex values.
//   '4.3.0.12'  Bug fix: Fixed bug that could cause access violations when
//                evaluating the RCH or ETS packages after disabling MODFLOW 6
//                observations.
//   '4.3.0.13'  Bug fix: When drawing a fishnet mesh, it is no longer possible
//                to add the same node to a fishnet mesh element twice.
//               Bug fix: Fixed bug that could cause range check error if
//                exporting an image of a 2D data set and restoring the image
//                settings from the saved settings.
//               Bug fix: Fixed a bug so that in MODLFOW 6 lakes the lake bottom
//                elevation is never too low and the lake top elevation is never
//                too high in horizontal lake connections.
//               Bug fix: ModelMuse can now display vectors for MODFLOW 6 models
//                in the Export Image dialog box.
//   '4.3.0.14'  Bug fix: Fixed bug that would cause an error when importing
//                data in the Import Points dialog box if the decimal separator
//                was not a period.
//   '4.3.0.15'  Bug fix: When attempting to read or save a global variables
//                file, ModelMuse will now show an error message to the user
//                instead of issuing a bug report if there is an error reading
//                the file.
//               Bug fix: Fixed a bug that could cause ModelMuse to encounter
//                an error when evaluating the IDOMAIN data set in MODFLOW 6
//                models.
//               Bug fix: When importing UZF data from shapefiles in models in
//                which the UZT package is active, UZT will also be imported
//                too.
//   '4.3.0.16'  Bug fix: Fixed bug that could cause WellFootprint models to
//                fail when exporting withdrawals.
//   '4.3.0.17'  Bug fix: Fixed bug that could cause a range check error when
//                deleting an item in the SWR Range Geometry dialog box.
//               Bug fix: If the user attempts to edit CSUB data for an object
//                without first defining any interbeds, ModelMuse will display
//                a warning message for the user instead of generating a bug
//                report.
//               Bug fix: Fixed a bug that prevented the functions for
//                identifying the highest active layer from working with DISV
//                MODFLOW 6 models.
//    '4.3.0.18' Bug fix: Fixed a bug that could cause access violations if a
//                formula started with a comma.
//               Bug fix: Fixed a bug that could cause access violations when
//                shutting down ModelMuse.
//               Enhancement: Added support for importing Lake for the MODFLOW 6
//                Lake package from Shapefiles.
//    '4.3.0.19' Bug fix: When moving vertices of an object to the location of
//                a vertex in another object, there could be a slight error in
//                the location to which the vertex was moved. This has been
//                corrected.
//    '4.3.0.20' Bug fix; Not in released version.  Error displaying the Manage
//                parameters dialog box.
//    '4.3.0.21' Bug fix: Fixed a bug that could cause an access violation if
//                opening a model the model that is already open had contours
//                displayed or a data set used to color the grid or mesh.
//               Bug fix: Fixed a bug that could cause an error when exporting
//                SUTRA model if not time schedule has been defined.
//    '4.3.0.22' Bug fix: Fixed import of multiple ASCII grid files
//                simultaneously.
//               Bug fix: Fixed bug in export of Shapefile mesh data from SUTRA
//                2D models that could cause a  range check error.
//    '4.3.0.23' Bug fix: Fixed a bug in the Errors and Warnings dialog box
//                that could cause an Invalid class typecast error when right
//                clicking in the dialog box.
//               Enhancement: The user can now customize ModelMuse to specify
//                whether or not a model archive will be created.
//               Bug fix: Fixed bug that could cause an assertion failure when
//                working with the Object Properties dialog box.
//               Bug fix: Fixed a bug that could cause an access violation in
//                the SUTRA Time Controls dialog box.
//               Bug fix: Fixed a bug that could cause an access violation in
//                the Manage Parameters dialog box.
//               Bug fix: Fixed a bug with renaming MODFLOW parameters when the
//                only change was a change in the capitalization of the
//                parameter name.
//               Bug fix: Fixed a bug that caused an access violation when
//                pasting data from one model to another.
//               Bug fix: Fixed setting default exaggeration with SUTRA 2D
//                models.
//               Bug fix: Fixed a bug in exporting the Basic Package input file
//                in models that contain nonsimulated layers.
//    '4.3.0.24' Bug fix: Fixed export of MAW package when flowing wells were
//                used.
//    '4.3.0.25' Bug fix: Fixed a bug that could cause an access violation in
//                the Export Image dialog box if the user attempts to generate
//                a side view image of a MODFLOW 6 DISV model.
//               Bug fix: Fixed bug in export of MAW package input that could
//                cause MODFLOW 6 to stop with an error message for inactive
//                wells.
//    '4.3.0.26' Bug fix: If an SWR Reach boundary did not define data for some
//                stress periods, ModelMuse now defines inactive reaches for
//                those stress periods.
//               Enhancement: In the Rearrange Objects dialog box, it is now
//                possible to specify the order of objects by entering a new
//                position in a new third column in the grid.
//    '4.3.0.27' Bug fix: Fixed bug in drawing contours that could cause a
//                range check error.
//               Bug fix: If there is an out of memory error when drawing the
//                3D view, the 3D view will be hidden until ModelMuse is
//                restarted.
//               Bug fix: Fixed a bug pasting objects from the clipboard when
//                the clipboard can not be accessed.
//               Bug fix: Fixed a bug that could cause an error when exporting
//                data to a CSV file.
//               Enhancement: ModelMuse can now read concentration files
//                generated by MODFLOW 6.
//    '4.3.0.28' Bug fix: When importing data from a file,  ModelMuse now
//                only allows you to specify files that actually exist.
//               Bug fix: Fixed a bug that could cause an access violation
//                when exporting the ETS package if EVT depth or rate fractions
//                have not been assigned.
//    '4.3.0.29' Bug fix: In the Geo Reference dialog box, the model start date
//                now displays the format for dates used in the computer in which
//                which the starting date is being edited.
//    '4.3.0.30' Bug fix: Fixed a bug that caused panning the model or resizing
//                the main form to be unnecessarily slow.
//    '4.3.0.31' Enhancement: Added a "Deselect" option to the popup menu in
//                the Show or Hide Objects dialog box.
//               Bug fix: Fixed bug that would cause a bug report to be
//                generated if the Used item of a SUTRA boundary condition did
//                not evaluate to true or false. Now an error message is
//                displayed.
//    '4.3.0.32' Bug fix: In MODFLOW 6 models, including lines for the RCH or
//                EVT packages in the MODFLOW Name File dialog box will now
//                prevent ModelMuse from exporting the input files for those
//                packages.
//    '4.3.0.33' Bug fix: Fixed bug in coloring the grid with a data set in
//                a MODFLOW-LGR model that could cause a circular reference
//                error.
//    '4.3.0.34' Bug fix: Fixed bug that could cause MODFLOW 6 observation
//                files to be misnamed if the model file name had a period
//                within the base as well as one separating the base from the
//                extension.
//    '4.3.0.35' Bug fix: Fixed a bug that could cause an access violation when
//                closing a MODFLOW LGR model.
//    '4.3.0.36' Bug fix: Fixed a bug in the "File|Import|Grid Data Files"
//                dialog box in which the "Open files" button did not work
//                unless more than one file was selected.
//    '4.3.0.37' Bug fix: Fixed bug in exporting the UZF input in MODFLOW 6 that
//                caused the convergence history file to be misnamed.
//    '4.3.0.38' Enhancement: When contour a data set in a MODFLOW-LGR model,
//                the user can now choose which models should be contoured
//                on the filter tab of the contour pane of the Data
//                Visualization dialog box.
//    '4.3.0.39' Bug fix: not in released version. ModelMuse no longer
//                Generates PEST control file if PEST is not activated.
//               Bug fix: Fixed bug in implementation of the K22OVERK and
//                K33OVERK options in the NPF package.
//    '4.3.0.40' Bug fix: Fixed a bug that could cause some cells to be
//                incorrectly selected two or more times fy the same object
//                when the object selects both enclosed and intersected cells.
//    '4.3.0.41' Bug fix: Fixed a bug that prevented MT3D concentration results
//                from being imported.
//    '4.3.0.42' Enhancement: ModelMuse now checks for MNW2 well screens
//                that are below the bottom of the grid.
//    '4.3.0.43' Bug fix: Fixed bug in deleting Subsidence-related interbeds.
//    '4.3.0.44' Bug fix: Not in released version. Fixed export of PLPROC
//                script.
//    '4.3.0.45' Enhancement: Allowed the user to choose how to assign gridded
//                data when importing existing MODFLOW models.
//    '4.3.0.46' Bug fix: Not in released version. Fixed double export of drain
//                elevation.
//    '4.3.0.47' Bug fix: Fixed a bug that could cause an access violation if
//                the name of a global variable that was used in a model feature
//                was changed.
//               Bug fix: Fixed bug moving the first vertex of a closed object
//                section.
//               Bug fix: Fixed bug that could cause an assertion failure when
//                writing the UZF file in MODFLOW 6.
//               Bug fix: Fixed bug that would cause an access violation if the
//                UZF package in MODFLOW-2005 was converted to the UZF package
//                in MODFLOW 6 and the model was exported without saving and
//                closing the model first.
//               Bug fix: Fixed bug that could cause a range check error if
//                an object defining a stream in the MODFLOW 6 SFR package did
//                not intersect any cells.
//               Change: ModelMuse now creates a file named
//                "usgs.model.reference." for the groundwater flow model.
//                Previously, the "model" part of the
//                file name would be the name of the model. A file with the
//                model name as part of the file name is still created.
//               Added support for features in RCT package in MT3D-USGS that
//                are not in MT3DMS.
//               Fixed check for connectivity in DISV grids in MODFLOW 6.
//    '4.3.0.48' Bug fix: Fixed bug with exporting MVR package.
//               Bug fix: Fixed bug in importing Shapefiles if unnamed CSV
//                attributes are included.
//               Change: file extension for the Reservoir package input file
//                change from ".res" to ".resv" to avoid conflict with a PEST
//                output file.
//               Enhancement: When importing an existing model, imported arrays
//                for transient data include the stress period as part of the
//                comment.
//    '4.3.0.49' Bug fix: Fixed reading TProgs binary data files containing
//                byte-sized integer data.
//    '4.3.0.50' Bug fix: Fixed a bug that could cause an exception to be
//                raised in models with large grids.
//    '4.3.0.51' No real change.
//    '4.3.0.52' Not in released version. Bug fix: fixed reading
//                existing models.
//    '4.3.0.53' Enhancement: In the Show or Hide Objects dialog box,
//                double-clicking on a category heading will expand or collapse
//                that category.
//               Bug fix: ModelMuse will now correct the data type, orientation,
//                and where the data set is evaluated for any required data set
//                if those values are incorrect.
//               Bug fix: ModelMuse will no longer attempt to export MNWI model
//                input files in MODFLOW 6 models.
//    '4.3.0.54' Bug fix: Fixed display of MODPATH output in MODFLOW DISV models
//                in which the cross section angle is not zero.
//    '4.3.0.55' Bug fix: Fixed bug in resetting velocity vectors to not used.
//               Bug fix: Fixed bug that could cause MODFLOW stress period
//                starting and ending times to be saved with small rounding
//                errors.
//    '4.3.0.56' Bug fix: Fixed bug in displaying contour values.
//    '4.3.0.57' Bug fix: Fixed renaming of data sets associated with MODFLOW
//                parameters when the parameters are renamed.
//               Bug fix: (not in released version) Fixed renaming transient
//                parameters in the Manage Parameters dialog box.
//               Bug fix: Fixed a bug in exporting SUTRA time schedules for
//                BCS files in which the time steps were one greater than they
//                should have been.
//               Bug fix: Fixed a bug importing SUTRA BCOF, BCOP, BCOS, and BCOU
//                files in which inactive boundaries were not handled correctly.
//               Bug fix: Fixed a bug that could cause errors when exporting
//                files if object names were not unique.
//               Bug fix: Fixed a bug that could cause ModelMuse to enter an
//                infinite loop when using triangle interpolation.
//               Enhancement: Added some error checking when exporting the
//                MAW input file.
//    '4.3.0.58' Bug fix (not in released version) Fixed a bug in copying the
//                starting and ending points of object sections.
//    '4.3.0.59' No changes in released version.
//    '4.3.0.60' Enhancement: Added new function MaxSutraNodeValueInElement
//    '4.3.0.61' No real change.
//    '4.3.0.62' Change: When reading pathline, endpoint, or time-series files
//                from MODPATH 7, ModelMuse will skip lines that contain NaN
//                instead of numbers.
//    '4.3.0.63' Enhancement: When exporting MT3D and MODPATH files, ModelMuse
//                issues an error message if the porosity is less than or equal
//                to zero in any active cell.
//               Enhancement: Added the functions ObjectVerticalLength and
//                ObjectVerticalIntersectLength.
//    '4.3.0.64' Bug fix: If a MODFLOW 6 Lake outlet has no transient data
//                assigned, ModelMuse now issues an error message instead of
//                failing.
//    '4.3.0.65' Bug fix: Fixed bug that would cause MODFLOW 6 MVR receivers
//                to sometimes not be found if the receiver was a lake.
//    '4.3.0.66' Bug fix: Fixed assigning values to nodes or elements in SUTRA
//                and cells in MODFLOW 6 DISV models when both intersected and
//                enclosed items are to be assigned values when there are two
//                elevation formulas.
//    '4.3.0.67' Change: ModelMuse now creates backups of several files such as
//                the RunModel file for use in tests of ModelMuse.
//               Bug fix: not in released version. Fixed upper and lower bounds
//                of pilot points.
//    '4.3.0.68' Bug fix: Fixed saving CREFT in SUTRA models.
//               Bug fix: Fixed a bug where the LakeID was not set properly.
//    '4.3.0.69' Bug fix: Fixed the ability to define recharge solute flux
//                observations in MT3D.
//    '4.3.0.70' Bug fix: Attempting to insert a new layer group when more than
//                one layer group is selected no longer causes an access
//                violation.
//               Bug fix: Changing the layer size multiplier in the MODFLOW
//                Layer Groups dialog box now causes DISV grids to be updated
//                correctly.
//    '4.3.0.71' Bug fix: Fixed the display of a warning message while exporting
//                Shapefiles.
//    '4.3.0.72' Bug fix: Fixed export of Zonebudget files for archive.
//               Bug fix: Fixed export of contours to shapefile in MODFLOW DISV
//                models so that the contours were restricted to the active part
//                of the current layer.
//    '4.3.0.73' Enhancement: The initial dialog box now appears on the taskbar.
//               Enhancement: Adaptive time stepping in MODFLOW 6 is supported.
//               Bug fix: Fixed bug that could cause the lake package in
//                MODFLOW 6 to be created incorrectly if the lake only had
//                vertical connections.
//    '4.3.0.74' No change
//    '4.3.0.75' Change: Changed the formula for the initial head in MODFLOW
//                models to Model_Top.
//               Bug fix: Fixed the Import Gridded Data dialog box so that it
//                no longer automatically changes the number of ignored values
//                to 1 when a data set is selected.
//               Bug fix: The specify Contours dialog box no longer allows
//                the users to attempt to set the number of contours to a
//                value less than 1.
//    '4.3.0.76' Bug fix: Fixed bug that could cause extra LPF or HUF parameters
//                to be generated when switching among parameter types in the
//                MODFLOW Packages and Programs dialog box.
//               Enhancement: Added new functions HGU_HK, HGU_HANI, HGU_VK,
//                HGU_VANI, HGU_SS, HGU_SY, and HGU_KDEP which return the value
//                of the corresponding data for a particular hydrogeologic unit.
//               Enhancement: Added new function GetValueFromLayer that allows
//                a 2D data set to retrieve a value from a specific layer of a
//                3D data set.
//    '4.3.0.77' Bug fix: Fixed a bug that could cause an assertion failures
//                when importing shapefiles data from CSV files, if one or more
//                columns did not have column headers.
//    '4.3.0.78' Bug fix: not in released version. Fixed list index out of
//                bounds while RCH and MT3D were active.
//    '4.3.0.79' Enhancement: When writing the reservoir layer, ModelMuse now
//                checks for invalid layer numbers and layers that are beneath
//                non-simulated layers.
//               Bug fix: Fixed export of SFT when no SFT boundaries are
//                defined.
//    '4.3.0.80' Change: ModelMuse no longer includes RCH, EVT, or ETS among
//                the point sources in MT3D-USGS in non MODFLOW 6 models.
//    '4.3.0.81' Bug fix: Fixed export of SFT package in MT3D-USGS when
//                there is more than one chemical species.
//               Bug fix: Fixed a bug that caused an access violation if 
//                the InterpolatedVertexValues function was used without an 
//                argument.
//    '4.3.0.82' Bug fix: Fixed display of XT3D data in the Grid or Mesh Values
//                dialog box.
//               Bug fix: When saving the MODFLOW Name file, the Byte Order Mark
//                should no longer be written.
//    '4.3.0.83' Bug fix: Fixed bug that could cause an error when merging
//                objects.
//               Bug fix: Fixed bug that could cause incorrect values to be
//                exported when exporting contours to Shapefiles.
//    '4.3.0.84' Bug fix: Fixed export of SSM in MT3D-USGS when the DRT package
//                is used.
//               Bug fix: Fixed evaluation of node outlines in the front view of
//                3D SUTRA models.
//    '4.3.0.85' Bug fix: Fixed bug that resulted in an invalid SUTRA fishnet
//                mesh when the "increase backwards" option was used.
//    '4.3.0.86' Bug fix: Fixed bug that could result in Assertion failures when
//                creating BCS files.
//    '4.3.0.87' Bug fix: Fixed bug that resulted in an invalid SUTRA fishnet
//                mesh when the "increase forward" option was used.
//    '4.3.0.88' Bug fix: Fixed export of MT3D-USGS lake transport package for
//                models with more than one chemical species.
//     '5.0.0.0' Enhancement: Added support for PEST with MODFLOW and SUTRA
//                models.
//     '5.0.0.1' Bug fix: PLPROC Krigging is now only used when the PLPROC
//                executable is found.
//               Bug fix: Fixed a bug that could cause an access violation
//                when importing the Recharge, EVT, or ETS packages in an
//                existing MODFLOW model.
//     '5.0.0.2' Enhancement: The Edit Data Sets and Show/Hide Objects dialog
//                boxes retain their positions, size, and the expanded status
//                of their nodes after closing and reopening.
//     '5.0.0.3' Enhancement: Changing the MT3D times in the MODFLOW Time
//                dialog box causes those times to also be change in the
//                MT3D boundaries.
//               Change: Made changes throughout ModelMuse to account for a
//                change in TJvImageComboBox.
//               Bug fix: ModelMuse no longer identifies the formula for the
//                IDOMAIN data set as invalid when creating a new model with
//                no grid.
//     '5.0.0.4' Bug fix: Fixed running PEST on computers in which the decimal
//                separator is not a period.
//               Bug fix: Fixed a bug that could cause access violations when
//                editing Lakes in MODFLOW 6 models.
//     '5.0.0.5' Bug fix: In the MODFLOW 6 lake package if the bottom of a lake
//                cell with a horizontal connection is above the top of the lake
//                cell, the lake cell bottom is reduced to be equal to the lake
//                cell top.
//               Bug fix: The text on the MODFLOW Name package checkboxes
//                now reflects the flow and solver packages in MODFLOW 6 for
//                MODFLOW 6 models.
//     '5.0.0.6' Bug fix: fixed bug in displaying cross section data in
//                MODFLOW 6 models.
//     '5.0.0.7' Enhancement: An "Ignore this" option has been added to the
//                pop-up menu in the Errors and Warnings dialog box.
//               Bug fix: If no grid has been defined in a structured grid model
//                attempting to restore the default 2D view results in nothing
//                happening instead of generating an error.
//     '5.0.0.8' Bug fix: Fixed bug that could cause an error when adding or
//                removing PEST observations groups.
//               Enhancement: Added an option to plot PEST direct observations,
//                prior information, or both in the Data Visualization dialog
//                box.
//               Bug Fix: Fixed bug that could sometimes cause interior edges
//                of SUTRA meshes to be treated like the edge of the mesh.
//     '5.0.0.9' Bug fix: ModelMuse now only exports the UNSAT_ETWC or
//                UNSAT_ETAE options in the MODFLOW 6 UZF package if
//                evapotranspiration is simulated. In addition, the ET rate
//                in the MODFLOW 6 UZF package is automatically set to zero
//                if evapotranspiration is not simulated.
//    '5.0.0.10' Bug fix: Fixed export of prior-information groups in PEST.
//               Change: Changed the export of SUTRA template files for PEST.
//    '5.0.0.11' No real change
//    '5.0.0.12' SUTRA 4 BETA
//    '5.0.0.13' Enhancement: The line thicknesses of vectors can now be
//                specified.
//               Bug fix: Fixed bug in export of PEST prior information
//                equations and prior information groups that resulted in
//                invalid PEST control files.
//    '5.0.0.14' Bug fix: Fixed bug in export of PEST prior information
//                equations and prior information groups that caused an access
//                violation if the model input was exported more than once
//                after opening the model in ModelMuse.
//    '5.0.0.15' Bug fix: Fixed bug in specifying yields in the MT3D-USGS
//                reaction package.
//    '5.0.0.16' Bug fix: Fixed bug that could cause access violations due
//                to deleted parameters.
//    '5.0.0.17' Bug fix: Fixed bug that could cause access violations when
//                evaluating the Ky and Kz data sets in MODFLOW 6 models when
//                anisotropy was used.
//    '5.0.0.18' Bug fix: Fixed bug in changing the number of times specified
//                for MAW wells.
//               Change: ModelMuse now prevents the user from exporting a
//                model with a period in the file name root if PEST is
//                activated.
//    '5.0.0.19' Enhancement: ModelMuse can now import interim residual files
//                generated by PEST.
//    '5.0.0.20' Bug fix: Fixed drawing objects when they are first being
//                created.
//               Bug fix: Fixed drawing grid when the active data set is
//                changed.
//               Enhancement: It is not possible to undo importing, editing
//                hiding, or displaying an image.
//               The points used to geolocate an image can now have an
//                associated ID.
//               Enhancement: When importing or editing an image, the user can
//                now specify the coordinates and an ID for each point without
//                first specifying the pixel location of the points.
//               Enhancement: The user can now import some types of MODFLOW 6
//                observations in the "Import Points" dialog box.
//               Enhancement: ModelMuse can now import the flow data from models
//                that have multiple packages of the same type.
//    '5.0.0.21' Bug fix: Fixed bug that caused unneeded pilot points to be
//                defined in PEST.
//               Enhancement: ModelMuse can now import simulated values
//                directly from the Observation Extractor utility program
//                output files.
//    '5.0.0.22' Bug Fix: not in released version
//                Fixed range error when activating MT3D and fixed used
//                designation for some GWT data sets.
//    '5.0.0.23' Enhancement: When importing Shapefiles, it is now possible
//                to use the label of a CSV attribute to indicate the data
//                represent real numbers, integers, Booleans, or text.
//    '5.0.0.24' Bug fix: Fixed bug in evaluating ActiveOnLayer function
//                that could lead to circular dependencies.
//    '5.0.0.25' Bug fix: When extracting simulated values for observation
//                times before the first simulated time, the value for the
//                first simulated time is now used by Mf6ObsExtractor and
//.               SutraObsExtractor.
//               Bug fix: Fixed bug in editing SFT head water concentrations.
//    '5.0.0.26' Enhancement: Instead of activating or deactivating PEST, there
//                is now a third option to allow users to define
//                calibration observations but without activating PEST.
//               Bug fix: The batch files for creating covariance files for PEST
//                now enclose the commands in quotation marks so that the
//                programs will run even if the paths contain spaces.
//    '5.0.0.27' Bug fix: Fixed bug that could cause ModelMuse to encounter an
//                an error when drawing contours.

//    '5.0.0.28' Bug fix: Fixed bug in specifing MVR receivers.
//               Enhancement: Added support for the SAVE SATURATION option in
//                the NPF package.:
//               Bug fix: Changed calculation of connlen in the MODFLOW 6 lake
//                package.
//               Bug fix: Fixed bug that could cause some PEST parameters to
//                not be written to the PVAL file when needed.
//    '5.0.0.29' Enhancement: ModelMonitor now displays budgets for MODFLOW 6
//                advanced packages.
//               Enhancement: After running a MODFLOW 6 file, the mfsim.lst file
//                is displayed in addition to the model .lst file.
//               Bug fix: Fixed bug in assigning PEST Concentration methods
//                when MT3D but not GWT is selected.
//    '5.0.0.30' Bug fix: ModelMuse no longer exports head observations that
//                are outside the grid to ModelMate.
//    '5.0.0.31' --
//    '5.0.0.32' Bug fix: Fixed bug in writing PEST prior information equations.
//               Bug fix: Fixed bug in editing objects specifying MVR
//                boundaries.
//               Enhancement: Added two new methods of distributing sources to
//                SFR reaches.
//               Enhancement: Added support for the Groundwater Transport
//                Process in MODFLOW 6.
//               Enhancement: Added support for MODFLOW 6 Time Series files.
//    '5.0.0.33' Bug fix: Fixed writing tied parameter data in PEST control
//                file.
//    '5.1.0.0'  --
//    '5.1.0.1'  Bug fix: Fixed bug that caused a conversion error when closing
//                the Object Properties dialog box.
//    '5.1.1.0'  Bug fix: Fixed bug that caused importing SUTRA model results
//                to fail when importing X, Y, and Z velocities.

//    '5.1.1.1'  Bug fix: Fixed bugs in Observation extractor programs that
//                could sometimes prevent them from being able to read the
//                output files correctly.
//               Bug fix: Fixed bug that prevent PEST from working correctly
//                with GWT in MODFLOW 6.
//    '5.1.1.2'  Bug fix: Fixed bug that would cause ModelMuse to fail in
//                creating the SFR input files for MODFLOW 6 models with
//                diversions in the SFR packages.
//    '5.1.1.3'  Bug fix: Fixed bug that would cause the batch file for running
//                a model to be created incorrectly in some cases.
//               Bug fix: Added a test for ensuring that MODFLOW 6 did not use
//                the Save Saturation option when used with MT3D-USGS.
//    '5.1.1.4'  Bug fix: Fixed bug that would cause the ETS package to be
//                imported incorrectly if the evaporation segments were reused.
//               Bug fix: Fixed importing UZF data from a Shapefile.
//    '5.1.1.5'  Bug fix: Fixed a bug that could cause an access violation
//                when activating MODFLOW-LGR.
//    '5.1.1.6'  Enhancement: ModelMuse can now import FHB boundaries from
//                Shapefiles.
//    '5.1.1.7'  Enhancement:The Show and Hide Objects dialog  box now has
//                "Calibration Data Sets" as a new category.
//               Enhancement: ModelMuse can now export FHB data to shapefiles
//                in the "File|Export|Shapefile|Objects to Shapefile" dialog
//                box.
//               Enhancement: The RunModel.bat file used by PEST now has code
//                to show the elapsed time for generating the input files,
//                running the model, and extracting the model results.
//    '5.1.1.8'  Enhancement: In the PEST Observations results graph, clicking
//                on an observation point will cause that point to be labeled
//                on the graph and in the ModelMuse main window.
//               Enhancement: The Export Objects to Shapefile dialog box now
//                has an button to toggle all the times to export.
//    '5.1.1.9'  Enhancement: The Export Objects to Shapefile dialog box now
//                allows data to be exported to a CSV file instead of to
//                an XBase file.
//    '5.1.1.10' Bug fix: Partially fixed bug in creating PLPROC scripts for
//                modifying data sets with large number of layers.
//    '5.1.1.11' Bug fix: Completed fixing bug in creating PLPROC scripts for
//                modifying data sets with large number of layers.
//               Bug fix: Fixed a bug that could cause a stack overflow when
//                displaying data.
//    '5.1.1.12' Bug fix: ModelMuse does not include parameters in the model
//                if they are not needed.
//    '5.1.1.13' Enhancement: When converting the SFR package in MODFLOW-2005
//                to the SFR package in MODFLOW 6, the formula for the top
//                of the stream bed now ensures that the top of the stream
//                bed minus the bed thickness is always higher than the bottom
//                of the cell.
//    '5.1.1.13' Enhancement: When converting the SFR package in MODFLOW-2005
//                to the SFR package in MODFLOW 6, the upstream fraction for
//                any diversion segments is set to zero.
//    '5.1.1.14' Bug fix: Fixed bug that would prevent elevations from being
//                updated if the front and side views were hidden.
//    '5.1.1.15'
//
//               Enhancement: ModelMuse can now import Vertex values based on
//                vertex locations in the Object Properties dialog box.
//    '5.1.1.16' Bug fix: Fixed bug that could cause head observations in
//                the Head Observation package to be skipped if their times
//                were at the beginning or end of the simulation.
//    '5.1.1.17' Bug fix: Fixed a bug in exporting contours to Shapefiles
//                that would cause an assertion failure.
//    '5.1.1.18  Bug fix: Fixed importing of MODFLOW-NWT models in which
//                the UZF variable NUZTOP is set to 4.
//    '5.1.1.19' Enhancement: When exporting contours to Shapefiles,
//                ModelMuse can now export contours for multiple layers.
//    '5.1.1.20' Bug fix: Fixed exporting grid data for boundary conditions
//                to Shapefiles.
//    '5.1.1.21  Bug fix: When pasting objects from the clipboard into
//                ModelMuse, the unique identifier of HOB observations and
//                SUTRA state calibration observations are now reassigned to
//                prevent potential conflicts with existing calibration
//                observations.
//    '5.1.1.22' Bug fix: Fixed bug exporting SRF in MODFLOW LGR models if
//                unsaturated flow was enabled in SFR.
//               Bug fix: If some observations have duplicate GUIDs, ModelMuse
//                reassigns the GUID.
//    '5.1.1.23' Bug fix: Fixed bug that could cause an exception when drawing
//                the horizontal ruler in SUTRA profile models.
//    '5.1.1.24'
//    '5.1.1.25' Enhancement: Added support for exporting the outline of the
//                current layer to a Shapefile.
//    '5.1.1.26' Enhancement: Added dynamic time series for MODFLOW 6.
//               Bug fix: Fixed bug in assigning UZF as a MVR source in MODFLOW 6.
//    '5.1.1.27'
//    '5.1.1.28' Bug fix: Fixed bug in which the SUTRA data sets for regions
//                were not properly renamed when opening old ModelMuse files
//                containing data sets for regions.
//    '5.1.1.29'
//    '5.1.1.30' Bug fix: Fixed pasting of GWT concentrations in the
//                Object Properties dialog box.
//    '5.1.1.31' Bug fix: Fixed pasting data into the Observation Comparisons
//                dialog box.
//    '5.1.1.32' Bug fix: Fixed a bug that could cause an access violation when
//                opening the MODFLOW Packages and Programs dialog box.
//               Bug fix: Fixed loss of data when editing multiple MNW2 wells
//                simultaneously.
//    '5.1.1.33' Bug fix: Fixed bugs in assigning data for MODFLOW 6 IST package.
//               Enhancement: When importing Shapefiles, ModelMuse now checks
//                to see if the grid or mesh overlaps with the shapes in the
//                shapeFile.
//    '5.1.1.34' Enhancement: Improved conversion of SFR package from MODFLOW-
//                2005 to MODFLOW 6.
//               Enhancement: It is now possible to import multiple Surfer grid
//                files simultaneously.
//               Enhancement: Improved conversion of SFR package when switching
//                to MODFLOW 6 from earlier versions of MODFLOW.
//               Bug fix: ModelMuse no longer generates an error message for the
//                MVR package if the MVR input in an object does not include
//                all stress periods.
 //   '5.1.1.35' Bug fix: Fixed bug that caused an access violation when editing
//                evapotranspiration bounddaries in MODFLOW 6 models in which
//                the groundwater transport process was active.
//               Bug fix: Fixed bug in defining SUTRA step TIME CYCLE time
//                schedules whent the initial time for the time schedule is not
//                zero.
//               Bug fix: Fixed exporting SUTRA input files when BCTIME has been
//                modified.
//    '5.1.1.36' Bug fix: Fixed editing of ETS information in the Object
//                Properties dialog box.
//               Bug fix: Fixed editing of MAX information in the Object
//                Properties dialog box.
//               Bug fix: Fixed export of UPSTREAM_FRACTION in MODFLOW 6 SFR
//                packages for diversion reaches.
//               Bug fix: Fixed importing MODFLOW-2005 and MODFLOW-NWT models
//                in which the number of segments in the ETS package was set
//                to 1.
//    '5.1.1.37' Bug fix: Fixed bug in Mf2005ObsExtractor that caused simulated
//                from the HOB package to be incorrectly read as zero.
//    '5.1.1.38' Bug fix: Switching from a MODFLOW-NWT to a MODFLOW-OWHM model
//                no longer results in the NWT and UPW packages being
//                deactivated.
//    '5.1.1.39' Enhancement: The "Edit Feature Formula" dialog box has been
//                modified to allow the user to specify a different formula for
//                each edited object.
//    '5.1.1.40' Enhancement: The Import Points dialog box has been changed to
//                allow more more flexibility in import model features.
//    '5.1.1.41' Bug fix: Fixed a bug that could cause an assertion failure when
//                exporting the MVR package input file.
//    '5.1.1.42' Enhancement: The Mesh|Specify Mesh dialog box has been modified
//                to allow the user to specify a 3D mesh.
//    '5.1.1.43' Enhancement: The Import Points dialog box has been changed to allow
//                allow importing GWT concentrations and UZF boundaries for
//                MODFLOW 6.
//    '5.1.1.44' Not in released version. Bug Fix. Fixed editing of calibration
//                observation comparisons.
//    '5.1.1.45' Enhancement: ModelMuse can now import data from binary output
//                files created by the MAW, MWT, SFR, SFT, UZF, and UZT
//                packages in HODFLOW 6.
//    '5.1.1.46' Bug fix: Fixed export of PEST input files on computers in
//                which a character other than the period is used as a
//                decimal separator.
//               Bug fix: Fixed export of shapefiles of contours for MODFLOW
//                DISV models in which the active area varies among layers.
//    '5.1.1.47' Enhancement: In MODFLOW 6 models, the BICGSTAB solver option
//                will be used automatically for models that use the XT3D option
//                in the NPF package or DISV models in which the GNC package is
//                used and the EXPLICIT option is not used in the GNC package.
//               Bug fix: Fixed bug in importing Shapefiles that contain null
//                shapes.
//    '5.1.1.48' Bug fix: Fixed a bug that could cause an error when assigning
//                data with objects that have a large number of cells.
//    '5.1.1.49' Enhancement: Added support for exporting CSV budget files in
//                MODFLOW 6 models.
//               Bug fix: Fixed a bug that would cause an error when attempting
//                to read an empty .Values file from PEST.
//    '5.1.1.50' Not in released version Bug fix: fixed import of GWT data in
//                the Edit Feature Formula dialog box.
//    '5.1.1.51' Change: When editing the TVK and TVS package data in the Object
//                Properties dialog box, it is now possible to specify an
//                empty formula for Kx, Ky, or Kz in TVK or for SS or SY in TVS.
//               Bug fix: Fixed drawing contours on the side view for DISV
//                meshes.
//    '5.1.1.52' Bug fix: Fixed export of flow observations in the CHD, DRN,
//                 GHB, and RIV, packages in MODFLOW 6 models.
//               Enhancement: Added support for the wel-reduction observation
//                type in the MODFLOW 6 Observation Utility.
//               Bug fix: Fixed export of to-mvr observation types for the
//                for WEL, DRN, RIV, and GHB packages.
//               Enhancement: When the MVR package receiver is a group of UZF
//                cells. there is now an option to distribute the MVR flow
//                equally to the UZF receiver cells.
//               Enhancement: Added support for BUDGETCSV, FLOWCORRECTION,
//                and MAW_FLOW_REDUCE_CSV options in MAW.
//               Bug fix: Fixed bug in editing the format of text in the rulers
//                that could cause a bug report to be issued if the text
//                for the sample number was not a number.
//    '5.1.1.53' Enhancement: Added an error message for calibration observations
//                with observation times equal to the start of the simulation.
//               Enhancement: A "Sum" function has been added to the functions
//                supported in the Formula Editor.
//    '5.1.1.54' Enhancement: Added a check that the MAW radius is the cell
//                effective radius.
//               Bug fix: Fixed error message issued  when all downstream
//                MODFLOW 6 SFR segments are inactive.
//               Enhancement: When editing layer group names, potentially
//                duplicate layer group names are handled without displaying
//                a warning message.
//               Change: When any dialog box is minimized, the main form of
//                ModelMuse is minimized too.
//               Change: ModelMuse does not draw a image of an SFR 8-point
//                cross section in the Object Properties dialog box unless
//                the 8-point cross section is in use.
//    '5.1.1.55' Enhancement: Time-varying cross sections are now supported in
//                 the MODFLOW 6 SFR package.
//    '5.1.1.56' Bug fix: Fixed a bug that could cause some cells to not be
//                displayed correctly on the front view of DISV models.
//               Change: If a MODFLOW 6 lake only has vertical connections,
//                it is treated as being above the bottommost layer intersect
//                by the object defining the lake. This means a lake can be
//                above layer 1. A lake that has horizontal connections is
//                treated as being in all the layers intersected by the object.
//    '5.1.1.57' Enhancement: Added support for discharge scaling in the
//                DRN package.
//    '5.2.0.0'  Enhancement: Added support for Buoyancy package for MODFLOW 6.
//               Enhancement: Added support for Viscosity package for MODFLOW 6.
//               Enhancement: Added support for Transient Hydraulic Conductivity package for MODFLOW 6.
//               Enhancement: Added support for Transient Storage package for MODFLOW 6.
//               Enhancement: Added support for FMP4 package MODFLOW-OWHM version 2.
//               Enhancement: Added support for CFP2 package MODFLOW-OWHM version 2.
//               Enhancement: Added support for SUTRA version 4.
//               Enhancement: Added support for SFR cross sections in MODFLOW 6.
//               Change: SFR in MODFLOW 6 reaches are now allowed outside of
//                the grid.
//               Bug fix: Canceling the Time Series dialog box no longer causes
//                an access violation.
//               bug fix: Fixed bug in exporting Dispersion package in MODFLOW 6.
//               Enhancement: Added support for defining observations of input
//                data in arrays.
//    '5.2.0.1'  Enhancement: Added a new "Active Specified Head" field that
//                allows the user to make some cells active or inactive based
//                on a formula.
//               bug fix: Fixed a bug editing formulas that could cause
//                the formula to be specified incorrectly.
//    '5.2.0.2'  bug fix: Fixed a bug that could cause an access violation
//                when shutting down ModelMuse while the Show or Hide Objects
//                dialog box is displayed.
//               bug fix: Fixed a bug that could cause access violations when
//                editing objects while the Show or Hide Objects dialog box
//                is displayed and Calibration data sets have been defined.
//    '5.2.0.3'  Change: In the MNW2 package, ZTOP and ZBOTM are now exported
//                with slightly different values to ensure that MNW2 wells are
//                not connected to the wrong layers. This change compensates
//                for a bug in MODFLOW-2005.
//    '5.2.0.4'  bug fix: Fixed bug that can cause an access violation when
//                shutting down ModelMuse.
//    '5.2.0.5'  bug fix: fixed a bug in the display of objects with one
//                elevation formula in the front and side views.
//               bug fix: Fixed bug opening MODFLOW 6 model with ETS package.
//               bug fix: Fixed a bug in the MVR package, in which the FACTOR
//                was divided among UZF reciver cells even that option was not
//                selected.
//               bug fix: Fixed bug in MVR package in which the flow could be
//                directed to the wrong SFR receiver if more than one SFR
//                receiver was used with the same MVR source.
//               bug fix: Fixed bug that causes an assertion failure when using
//                pilot points with data sets that do not have values at every
//                cell.
//    '5.2.0.6'  bug fix: Fixed bug in the display of data from the TVK and TVS
//                packages so that the data is now displayed on the correct
//                layer.
//    '5.2.0.7'  bug fix: Fixed bug in exporting the DIS input file for
//                MODFLOW-OWHM version 2 when the Farm package is not selected.
//    '5.2.0.8'  bug fix: Fixed bug in assigning properties to SUTRA nodes
//                with objects that should intersect the cell around nodes.
//               bug fix: using lake tables with lakes didn't work if PEST
//                was active.
//    '5.2.0.9'  bug fix: With MODPATH 7, extra values were previously included
//                with the particle locations.
//               bug fix: Fixed export of budget CSV file with the UZT package.
//    '5.2.0.10' bug fix: fixed bug in exporting MAW and UZF package input
//                files in MODFLOW 6 when observations have been defined but
//                the observation utility is not active.
//    '5.2.0.11' bug fix: Fixed export of RCH package in MODFLOW 6 when objects
//                are to be summed.
//    '5.2.0.12' no real change.
//    '5.2.0.13' bug fix: Fixed export of h0 in CSUB package data.
//               bug fix: Fixed export of MVR when the source doesn't change
//                over time.
//               bug fix: Fixed export of some flow boundary packages when the
//                only change between stress periods was the boundary
//                concentration in the transport package.
//               Enhancement: The scale factor for a dynamic time series can
//                now be a formula.
//    '5.2.0.14' Bug fix: Fixed reading some ModelMuse files on systems that
//                us comma as the decimal separator.
//    '5.2.0.15  bug fix: Fixed export of GWT DSP file that would cause an
//                assertion failure.
//    '5.2.0.16'
//    '5.2.0.17' bug fix: The EVT package is now included in the MODFLOW 6
//                grounddwater transport source and sink mixing package as
//                an AUXMIXED source.
//               (not in released version) bug fix: Fixed bug in saving GWT CNC
//                and GWT SRC boundaries when multiplier are not used.
//    '5.2.0.18' bug fix: fixed export of SFR package for MODFLOW 6 after
//                disabling solute transport.
//    '5.2.0.19' Enhancement: ModelMuse now checks that PEST Observation Group
//                names and Prior Information Group names are assigned.
//               bug fix: Fixed bug in exporting groundwater allotments in
//                MODFLOW-owhm version 2.
//               bug fix: fixed export of SFR, SFT, MAW, MWT, LAK, LKT, UZF, and UZT
//                packages when both the flow package and the associated
//                transport package used time-series files.
//    '5.2.0.20' Enhancement: Added a new
//                "Specified Concentration Active"  and "Mass Loading Active"
//                fields that allows the user to make some Constant
//                Concentration and Mass Loading cells active or inactive based
//                on a formula.
//    '5.2.0.21' Change: The extension of the binary file generated by the MT3D
//                Transport Observation file containing the calculated
//                concentrations and mass fluxes at user defined
//                observation points and mass-flux objects has been changed from
//                .pst to ._pst to avoid conflicts with PEST.
//               Enhancement: ModelMuse can now plot results from the MT3D
//                Transport Observation package.
//               Bug fix: Editing an object no longer causes the Boundary to be
//                recalculated just becaue the Object Properties dialog box
//                has been displayed.
//    '5.2.0.22' Bug fix: Fixed interpolation in display of time series values.
//    '5.2.0.23' Bug fix: Fixed export of concentration observations when some
//                concentration observations are used for parameter estimation
//                and some are not.
//    '5.2.0.24' Bug fix: not in released version. fixed import of MF6 and SUTRA
//                results from MF6ObsExtractor and SUTRA ObsExtractor
//    '5.2.0.25' Bug fix: fixed bug in writing ASCII characters with codes
//                greater than or equal to 128.
//    '5.3.0.0'  Enhancement: Added the ability to import MODFLOW 6 models.
//    '5.3.0.1'  Bug fix: Fixed bug in saving files that had MT3D Observation
//                results in a way that prevented the files from being opened
//                again.
//    '5.3.0.2'  Enhancement: ModelMuse now issues a warning for objects that
//                are intended to define head or drawdown observation locations
//                but do not because they are outside the grid.
//               Bug fix: The nodes in the "Model|MODFLOW Output Control" dialog
//                box have been restored.
//    '5.3.0.3'
//    '5.3.1.0'  Change: ModelMuse now ensures that IDOMAIN is never set to -1
//                on the top and bottom layers.
//    '5.3.1.1'  Bug fix: Fixed bug that could cause the input to the MVR
//                package to be incorrect when the specification of a Lake
//                source did not completely match the time discretization.
//    '5.3.1.2'  Bug fix: Fixed bug that could cause the input to the MVR
//                package to be incorrect when a lake source was connected
//                to the nearest reach in an SFR receiver.
//    '5.3.1.3'  Bug fix: Fixed display of MODPATH version 7 output in grids
//                with non-zero grid angles.
//    '5.3.1.4'  Bug fix: Fixed bug in saving binary head input file to a
//                model archive.
//               Bug fix: Fixed a bug that could cause an assertion failure
//                when changing the model selection.
//               Bug fix: Fixed bug in assigning the depth PEST modifier and
//                PEST method for ETS boundaries.
//    '5.3.1.5'  Enhancement: ModelMuse can now import SUTRA meshes from
//                Shapefiles.
//    '5.3.1.6'  Bug fix: Fixed export of objects as shapefiles for certain
//                MODFLOW 6 features.
//    '5.3.1.7'  Enhancement: Added support for new sorption options in
//                the IST package of MODFLOW 6.6.
//               Enhancement: Added support for SORBATE option in MST and IST
//                packages in MODFLOW 6.
//               Enhancement: Added support for ATS_PERCEL option in ADV
//                package in MODFLOW 6.
//               Bug fix: Fixed assigning properties of DRT boundaries.
//    '5.3.1.8'  Enhancement: Added support for STORAGE option and INITIALSTAGES
//                blocks in the SFR package in MODFLOW 6.
//               Bug fix: Fixed saving "EXPORT_ARRAY_ASCII" option in the
//                MODFLOW Output Control dialog box.
//    '5.3.1.9   Bug fix: Fixed bug in importing WellFootprint results.
//    '5.3.1.10' Bug fix: Fixed bug importing MODFLOW-2005 and MODFLOW-NWT
//                models in which the listing file was enclosed in single quotes.
//    '5.3.1.11' Bug fix: Fixed importing RCH, EVT, and ETS packages from
//                MODFLOW-2005 and MODFLOW-NWT models when parameters are used
//                in them.
//               Bug fix: Fixed importing MODFLOW-6 models that include GWE models.
//    '5.3.1.12' Bug fix: Fixed export of MT3D-USGS SSM input file with
//                non-MODFLOW 6 model.
//    '5.3.1.13' Bug fix: Fixed bug in importing ETS package.
//    '5.3.1.14' Change: When importing the MAW package, the BOUNDNAME is now
//                used as the object name if BOUNDNAME is specified.

//               Enhancement: The Grid and Mesh Values dialog box now can
//                display the face numbering used in IFLOWFACE.

const
  // version number of ModelMuse.
  IIModelVersion = '5.3.1.14';

{ TODO : Add support for time-varying conductance in MF6 version of SFR }
{ TODO : Support MODFLOW 6 Particle Tracking Model. }
{ TODO : Support MODFLOW 6 Energy Transport Model. }
{ TODO : Add support for model splitting for use with parallel MODFLOW }
{ TODO : Support PEST++. }
{ TODO : Support SENSAN from the PEST suite of programs. }
{ TODO : Support analytical element model(s). }

function IModelVersion: string;
begin
  result := IIModelVersion
end;

function DefaultModflowOwhmPath: string;
begin
  if IsWOW64 then
  begin
    result := StrMFOwhmDefaultPath64;
  end
  else
  begin
    result := strModflowOwhmDefaultPath;
  end;
end;

function DefaultPhastPath: string;
begin
  if IsWOW64 then
  begin
    result := StrPhastDefaultPath64;
  end
  else
  begin
    result := StrPhastDefaultPath
  end;
end;

function GenerateNewRoot(const Root: string): string;
  function Alpha(C: Char): Boolean; inline;
  begin
//    Result := TCharacter.IsLetter(C) or (C = '_');
    Result := C.IsLetter or (C = '_');
  end;

  function AlphaNumeric(C: Char): Boolean; inline;
  begin
//    Result := TCharacter.IsLetterOrDigit(C) or (C = '_');
    Result := C.IsLetterOrDigit or (C = '_');
  end;
var
  Index: integer;
begin
  result := Trim(Root);
  Assert(result <> '');
  IsValidIdent(result, False);
  if not Alpha(result[1]) then
  begin
    if AlphaNumeric(result[1]) then
    begin
      result := '_' + Result;
    end
    else
    begin
      result[1] := '_';
    end;
  end;

  for Index := 2 to Length(result) do
  begin
    if not AlphaNumeric(result[Index]) then
    begin
      result[Index] := '_';
    end;
  end;
end;

function GenerateNewName(Root: string = '';
  InvalidNames: TStringList = nil; Connector: string = ''): string;
var
  Names: TStringList;
  Index: integer;
  DataArrayManager: TDataArrayManager;
  GlobalVariable: IGlobalVariable;
  Compiler: TRbwParser;
begin

  Root := Trim(Root);
  if Root = '' then
  begin
    Root := StrNewDataSet;
  end;
  Root := GenerateNewRoot(Root);
  result := Root;
  if frmGoPhast = nil then
  begin
    Exit;
  end;
  if csDestroying in frmGoPhast.ComponentState then
  begin
    Exit;
  end;

  // This function generates a name for a data set that is valid
  // and does not conflict with the names of any existing data sets.
  Names := TStringList.Create;
  try
    if InvalidNames <> nil then
    begin
      Names.AddStrings(InvalidNames);
    end;

    DataArrayManager := frmGoPhast.PhastModel.DataArrayManager;
    DataArrayManager.AddNamesOfAllDataSets(Names);

    // Names now includes the names of all the data sets.

    // don't allow the name to be the same as a global variable.
    for Index := 0 to frmGoPhast.PhastModel.GlobalVariablesI.Count -1 do
    begin
      GlobalVariable := frmGoPhast.PhastModel.GlobalVariablesI[Index];
      Names.Add(GlobalVariable.Name);
    end;

    // don't allow data sets to be named the same as any function.
    Compiler := frmGoPhast.PhastModel.rpThreeDFormulaCompiler;
    Names.AddStrings(Compiler.Functions);

    // Generate a new name.
    if Names.IndexOf(Root) < 0 then
    begin
      result := Root;
    end
    else
    begin
      Index := 1;
      result := Root + Connector + IntToStr(Index);
      while Names.IndexOf(result) >= 0 do
      begin
        Inc(Index);
        result := Root + Connector + IntToStr(Index);
      end;
    end;
  finally
    Names.Free;
  end;
end;



function StrToStatFlag(const StatFlagString: string): TStatFlag;
var
  Index: TStatFlag;
begin
  if StatFlagString = '' then
  begin
    result := Low(TStatFlag);
  end
  else
  begin
    result := Low(TStatFlag);
    for Index := Low(TStatFlag) to High(TStatFlag) do
    begin
      if StatFlagString = StatFlagStrings[Index] then
      begin
        result := Index;
        Exit;
      end;
    end;
    Assert(False);
  end;
end;

  { TPhastModel }

function TPhastModel.AddDataSet(const DataSet: TDataArray): Integer;
var
  ChildIndex: Integer;
  ChildItem: TChildModelItem;
  ChildDataArray: TDataArray;
begin
  result := inherited AddDataSet(DataSet);
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildItem := ChildModels[ChildIndex];
    if ChildItem.ChildModel <> nil then
    begin
      ChildDataArray := TDataArrayType(DataSet.ClassType).Create(ChildItem.ChildModel);
      ChildDataArray.AssignProperties(DataSet);
      ChildItem.ChildModel.DataArrayManager.AddDataSet(ChildDataArray);
      ChildDataArray.Formula := DataSet.Formula;
      DataSet.TalksTo(ChildDataArray);
    end;
  end;
end;

function TPhastModel.AddScreenObject(const AScreenObject: TScreenObject):
  integer;
begin
  result := FScreenObjectList.Add(AScreenObject);
  DoInvalidate(self);
end;

procedure TPhastModel.AdjustDataArray(ADataArray: TDataArray);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ColIndex: Integer;
  LayerIndex: Integer;
  AnnotationList: TStringList;
  NewAnnotation: string;
  AnnotationPosition: integer;
  RowIndex: Integer;
begin
  if LgrV1Used then
  begin
    if ADataArray.DataType = rdtBoolean then
    begin
      Exit;
    end;
    Assert(ADataArray.DataType = rdtDouble);
    Assert(ADataArray.ColumnCount >= 3);
    Assert(ADataArray.RowCount >= 3);
    AnnotationList := TStringList.Create;
    try
      AnnotationList.Sorted := True;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if (ChildModel <> nil) and (ChildModel.FirstRow >= 0)
          and (ChildModel.LastRow >= 0)
          and (ChildModel.FirstCol >= 0) and (ChildModel.LastCol >= 0) then
        begin
          for LayerIndex := 0 to ADataArray.LayerCount - 1 do
          begin
            if ADataArray.IsValue[LayerIndex,
              ChildModel.FirstRow, ChildModel.FirstCol] then
            begin
              NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                LayerIndex, ChildModel.FirstRow, ChildModel.FirstCol];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation);
              end;
              ADataArray.Annotation[LayerIndex,
                ChildModel.FirstRow, ChildModel.FirstCol] := NewAnnotation;
              ADataArray.RealData[LayerIndex,
                ChildModel.FirstRow, ChildModel.FirstCol]
                := ADataArray.RealData[LayerIndex,
                ChildModel.FirstRow, ChildModel.FirstCol] * 0.75;
            end;

            if ADataArray.IsValue[LayerIndex,
              ChildModel.FirstRow, ChildModel.LastCol] then
            begin
              NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                LayerIndex, ChildModel.FirstRow, ChildModel.LastCol];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation);
              end;
              ADataArray.Annotation[LayerIndex,
                ChildModel.FirstRow, ChildModel.LastCol] := NewAnnotation;
              ADataArray.RealData[LayerIndex,
                ChildModel.FirstRow, ChildModel.LastCol]
                := ADataArray.RealData[LayerIndex,
                ChildModel.FirstRow, ChildModel.LastCol] * 0.75;
            end;

            if ADataArray.IsValue[LayerIndex,
              ChildModel.LastRow, ChildModel.FirstCol] then
            begin
              NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                LayerIndex, ChildModel.LastRow, ChildModel.FirstCol];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation);
              end;
              ADataArray.Annotation[LayerIndex,
                ChildModel.LastRow, ChildModel.FirstCol] := NewAnnotation;
              ADataArray.RealData[LayerIndex,
                ChildModel.LastRow, ChildModel.FirstCol]
                := ADataArray.RealData[LayerIndex,
                ChildModel.LastRow, ChildModel.FirstCol] * 0.75;
            end;

            if ADataArray.IsValue[LayerIndex,
              ChildModel.LastRow, ChildModel.LastCol] then
            begin
              NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                LayerIndex, ChildModel.LastRow, ChildModel.LastCol];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation);
              end;
              ADataArray.Annotation[LayerIndex,
                ChildModel.LastRow, ChildModel.LastCol] := NewAnnotation;
              ADataArray.RealData[LayerIndex,
                ChildModel.LastRow, ChildModel.LastCol]
                := ADataArray.RealData[LayerIndex,
                ChildModel.LastRow, ChildModel.LastCol] * 0.75;
            end;

            for ColIndex := ChildModel.FirstCol + 1 to ChildModel.LastCol - 1 do
            begin
              if ADataArray.IsValue[LayerIndex, ChildModel.FirstRow, ColIndex] then
              begin
                NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                  LayerIndex, ChildModel.FirstRow, ColIndex];
                AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
                if AnnotationPosition >= 0 then
                begin
                  NewAnnotation := AnnotationList[AnnotationPosition];
                end
                else
                begin
                  AnnotationList.Add(NewAnnotation);
                end;
                ADataArray.Annotation[LayerIndex,
                  ChildModel.FirstRow, ColIndex] := NewAnnotation;
                ADataArray.RealData[LayerIndex, ChildModel.FirstRow, ColIndex]
                  := ADataArray.RealData[LayerIndex, ChildModel.FirstRow, ColIndex] /2;
              end;
              if ADataArray.IsValue[LayerIndex, ChildModel.LastRow, ColIndex] then
              begin
                NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                  LayerIndex, ChildModel.LastRow, ColIndex];
                AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
                if AnnotationPosition >= 0 then
                begin
                  NewAnnotation := AnnotationList[AnnotationPosition];
                end
                else
                begin
                  AnnotationList.Add(NewAnnotation);
                end;
                ADataArray.Annotation[LayerIndex,
                  ChildModel.LastRow, ColIndex] := NewAnnotation;
                ADataArray.RealData[LayerIndex, ChildModel.LastRow, ColIndex]
                  := ADataArray.RealData[LayerIndex, ChildModel.LastRow, ColIndex] /2;
              end;
            end;
            for RowIndex := ChildModel.FirstRow +1 to ChildModel.LastRow - 1 do
            begin
              if ADataArray.IsValue[LayerIndex, RowIndex, ChildModel.FirstCol] then
              begin
                NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                  LayerIndex, RowIndex, ChildModel.FirstCol];
                AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
                if AnnotationPosition >= 0 then
                begin
                  NewAnnotation := AnnotationList[AnnotationPosition];
                end
                else
                begin
                  AnnotationList.Add(NewAnnotation);
                end;
                ADataArray.Annotation[LayerIndex, RowIndex,
                  ChildModel.FirstCol] := NewAnnotation;
                ADataArray.RealData[LayerIndex, RowIndex, ChildModel.FirstCol]
                  := ADataArray.RealData[LayerIndex, RowIndex, ChildModel.FirstCol] /2;
              end;
              if ADataArray.IsValue[LayerIndex, RowIndex, ChildModel.LastCol] then
              begin
                NewAnnotation := ' Adjusted for LGR: ' + ADataArray.Annotation[
                  LayerIndex, RowIndex, ChildModel.LastCol];
                AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
                if AnnotationPosition >= 0 then
                begin
                  NewAnnotation := AnnotationList[AnnotationPosition];
                end
                else
                begin
                  AnnotationList.Add(NewAnnotation);
                end;
                ADataArray.Annotation[LayerIndex, RowIndex,
                  ChildModel.LastCol] := NewAnnotation;
                ADataArray.RealData[LayerIndex, RowIndex, ChildModel.LastCol]
                  := ADataArray.RealData[LayerIndex, RowIndex, ChildModel.LastCol] /2;
              end
            end;
          end;
        end;
      end;
    finally
      AnnotationList.Free;
    end;
  end;
end;


function TPhastModel.AllDispersionMultiDiffusion: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := not ModflowPackages.Mt3dmsDispersion.IsSelected
    or ModflowPackages.Mt3dmsDispersion.MultiDifussion;
  if Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := not ChildModel.ModflowPackages.Mt3dmsDispersion.IsSelected
          or ChildModel.ModflowPackages.Mt3dmsDispersion.MultiDifussion;
        if not result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.AllowChildGridUpdates;
var
  ChildModel: TChildModel;
  Index: Integer;
begin
  Dec(FChildGridUpdateCount);
  if FChildGridUpdateCount = 0 then
  begin
    for Index := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[Index].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.CanUpdateGrid := True;
      end;
    end;
  end;
end;

function TPhastModel.AnyDispersionMultiDiffusion: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsDispersion.IsSelected
    and ModflowPackages.Mt3dmsDispersion.MultiDifussion;
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsDispersion.IsSelected
          and ChildModel.ModflowPackages.Mt3dmsDispersion.MultiDifussion;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.AnyMt3dReactions: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.KineticChoice <> kcNone);
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsChemReact.IsSelected
          and (ChildModel.ModflowPackages.Mt3dmsChemReact.KineticChoice <> kcNone);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.AnyMt3dSorbImmobConc: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.OtherInitialConcChoice = oicUse);
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsChemReact.IsSelected
          and (ChildModel.ModflowPackages.Mt3dmsChemReact.OtherInitialConcChoice = oicUse);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.AnyMt3dSorbParameter: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.SorptionChoice <> scNone);
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsChemReact.IsSelected
          and (ChildModel.ModflowPackages.Mt3dmsChemReact.SorptionChoice <> scNone);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.AnyMt3dUsgsDualSeparate: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.SorptionChoice = scDualWithDifferingConstants);
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsChemReact.IsSelected
          and (ChildModel.ModflowPackages.Mt3dmsChemReact.SorptionChoice = scDualWithDifferingConstants);
        if result then
        begin
          Exit;
        end;
      end;
      end;
  end;
end;

function TPhastModel.AnyMt3dUsgsMonod: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.KineticChoice = kcMonod);
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsChemReact.IsSelected
          and (ChildModel.ModflowPackages.Mt3dmsChemReact.KineticChoice = kcMonod);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.AnyUzfInitialConcentrationUsed: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.UzfMf6Package.IsSelected and GWTUsed;
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.UzfMf6Package.IsSelected
          and ChildModel.GWTUsed;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.AnyVTransDispUsed: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  GwtDspUsed: Boolean;
  GweDspUsed: Boolean;
begin
  result := (ModelSelection = msModflow2015);
  if result then
  begin
    GwtDspUsed := ModflowPackages.GwtDispersionPackage.IsSelected and GWTUsed
      and ModflowPackages.GwtDispersionPackage.UseTransverseDispForVertFlow;
    GweDspUsed := ModflowPackages.GweConductionAndDispersionPackage.IsSelected
      and GweUsed;
    result := GwtDspUsed or GweDspUsed;
  end;
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        GwtDspUsed := ChildModel.ModflowPackages.GwtDispersionPackage.IsSelected
          and ChildModel.GWTUsed
          and ChildModel.ModflowPackages.GwtDispersionPackage.UseTransverseDispForVertFlow;
        GweDspUsed := ChildModel.ModflowPackages.GweConductionAndDispersionPackage.IsSelected
          and ChildModel.GweUsed;
        result := GwtDspUsed or GweDspUsed;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.DoAquiferPropertiesUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoAquiferPropertiesUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoAquiferPropertiesUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.Assign(Source: TPersistent);
var
  SourceModel: TPhastModel;
begin
  if Source is TPhastModel then
  begin
    SourceModel := TPhastModel(Source);
    Diffusivity := SourceModel.Diffusivity;
    GridOptions := SourceModel.GridOptions;
    PhastGrid := SourceModel.PhastGrid;
    PrintFrequency := SourceModel.PrintFrequency;
    PrintInitial := SourceModel.PrintInitial;
    SolutionOptions := SourceModel.SolutionOptions;
    SteadyFlowOptions := SourceModel.SteadyFlowOptions;
    Times := SourceModel.Times;
    Title := SourceModel.Title;
    Units := SourceModel.Units;
    PathLines := SourceModel.PathLines;
    EndPoints := SourceModel.EndPoints;
    TimeSeries := SourceModel.TimeSeries;
    Bitmaps := SourceModel.Bitmaps;
    Exaggeration := SourceModel.Exaggeration;
    ObjectList := SourceModel.ObjectList;
    Version := SourceModel.Version;
    GuiSettings := SourceModel.GuiSettings;
    ModelMateProjectFileName := SourceModel.ModelMateProjectFileName;
    DisplaySettings := SourceModel.DisplaySettings;
    ModflowSteadyParameters := SourceModel.ModflowSteadyParameters;
    ModelSelection := SourceModel.ModelSelection;
    LayerStructure := SourceModel.LayerStructure;
    ModflowGrid := SourceModel.ModflowGrid;
    ModflowStressPeriods := SourceModel.ModflowStressPeriods;
    SoluteTransport := SourceModel.SoluteTransport;
    UseWaterTable := SourceModel.UseWaterTable;
    FreeSurface := SourceModel.FreeSurface;
    ChemistryOptions := SourceModel.ChemistryOptions;
    HufParameters := SourceModel.HufParameters;
    ObservationPurpose := SourceModel.ObservationPurpose;
    ModflowTransientParameters := SourceModel.ModflowTransientParameters;
    ModflowOutputControl := SourceModel.ModflowOutputControl;
    Mt3dmsOutputControl := SourceModel.Mt3dmsOutputControl;
    Mt3dmsTimes := SourceModel.Mt3dmsTimes;
    MobileComponents := SourceModel.MobileComponents;
    ImmobileComponents := SourceModel.ImmobileComponents;
    DataSetList := SourceModel.DataSetList;
    SfrStreamLinkPlot := SourceModel.SfrStreamLinkPlot;
    StrStreamLinkPlot := SourceModel.StrStreamLinkPlot;
    SfrMf6StreamLinkPlot := SourceModel.SfrMf6StreamLinkPlot;
    SwrReachConnectionsPlot := SourceModel.SwrReachConnectionsPlot;
    SutraSettings := SourceModel.SutraSettings;
    FmpCrops := SourceModel.FmpCrops;
    FmpSoils := SourceModel.FmpSoils;
    FmpClimate := SourceModel.FmpClimate;
    FmpAllotment := SourceModel.FmpAllotment;
    Farms := SourceModel.Farms;
    LinkedRasters := SourceModel.LinkedRasters;
    FootprintProperties := SourceModel.FootprintProperties;
    RipPlantGroups := SourceModel.RipPlantGroups;
    GeoRef := SourceModel.GeoRef;
    CtsSystems := SourceModel.CtsSystems;
    ParamGroups := SourceModel.ParamGroups;
    SvdaPrepProperties := SourceModel.SvdaPrepProperties;
    SupCalcProperties := SourceModel.SupCalcProperties;
    IrrigationTypes := SourceModel.IrrigationTypes;
  end;
  inherited;

end;

function TPhastModel.BcfIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.BcfPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.BcfPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoBcfUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoBcfUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoBcfUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.BeginDataSetUpdate;
begin
  Inc(FDataSetUpdateCount);
end;

procedure TPhastModel.BeginGridChange;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  if ChildModels <> nil then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.BeginGridChange;
      end;
    end;
  end;
end;

procedure TPhastModel.BeginScreenObjectUpdate;
begin
  Inc(FScreenObjectUpdateCount);
end;

constructor TPhastModel.Create(AnOwner: TComponent);
var
  ChangeNotifier: IChangeNotifier;
begin
  FFormulaManager:= TFormulaManager.Create(self);
  inherited;
  FTimesSeries:= TTimesSeriesCollections.Create(self);
//  FUnitNumbers := TUnitNumbers.Create(self);
  FContourLabelSpacing := 100;

  FGlobalVariables := TGlobalVariables.Create(self);
  FFishnetMeshGenerator := TFishnetMeshGenerator.Create(self);
  FColorSchemes := TUserDefinedColorSchemeCollection.Create(DoInvalidate);
  FSaveBfhBoundaryConditions := True;
  FSaveDataSetValues := sdsvAlways;
  FSelectedModel := self;
  UpdateCurrentModel(self);
  FChildModels := TChildModelCollection.Create(self);
  FDisplaySettings := TDisplaySettingsCollection.Create(self);
  FColorLegend := TLegend.Create(nil);
  FColorLegend.ValueAssignmentMethod := vamAutomatic;
  FContourLegend := TLegend.Create(nil);
  FContourLegend.ValueAssignmentMethod := vamAutomatic;

  FEndPointLegend := TLegend.Create(nil);
  FEndPointLegend.ValueAssignmentMethod := vamAutomatic;

  FHufParameters := THufModflowParameters.Create(self);
  FUpdatingFullStressPeriods := False;

  FGridColors := TColorParameters.Create;
  FGridColors.OnChange := NotifyGridColorsChanged;

  FContourColors := TColorParameters.Create;

  FSelectedScreenObjectCount := 0;
  FClearing := False;

  FProgramLocations := TProgramLocations.Create;

  FCachedScreenObjectIndex := -1;

  FLayerStructure := TLayerStructure.Create(self);
  FBitmaps := TCompressedBitmapCollection.Create;
//  ThreeDGridObserver.OnUpToDateSet := DiscretizationChangedEvent;

  FDiffusivity := 1E-9;
  FModelTimes := TRealList.Create;
  FFileVersion := IModelVersion;

  FTopBoundaryType := TIntegerSparseDataSet.Create(self);
  FTopBoundaryType.Name := 'FTopBoundaryType';
  FTopBoundaryType.Orientation := dso3D;
  FTopBoundaryType.EvaluatedAt := eaNodes;
  (FTopBoundaryType as TIntegerSparseDataSet).BoundaryTypeDataSet :=
    FTopBoundaryType;

  FFrontBoundaryType := TIntegerSparseDataSet.Create(self);
  FFrontBoundaryType.Name := 'FFrontBoundaryType';
  FFrontBoundaryType.Orientation := dso3D;
  FFrontBoundaryType.EvaluatedAt := eaNodes;
  (FFrontBoundaryType as TIntegerSparseDataSet).BoundaryTypeDataSet :=
    FFrontBoundaryType;

  FSideBoundaryType := TIntegerSparseDataSet.Create(self);
  FSideBoundaryType.Name := 'FSideBoundaryType';
  FSideBoundaryType.Orientation := dso3D;
  FSideBoundaryType.EvaluatedAt := eaNodes;
  (FSideBoundaryType as TIntegerSparseDataSet).BoundaryTypeDataSet :=
    FSideBoundaryType;

  FTop2DBoundaryType := TIntegerSparseDataSet.Create(self);
  FTop2DBoundaryType.Name := 'FTop2DBoundaryType';
  FTop2DBoundaryType.Orientation := dsoTop;
  FTop2DBoundaryType.EvaluatedAt := eaNodes;
  (FTop2DBoundaryType as TIntegerSparseDataSet).BoundaryTypeDataSet :=
    FTop2DBoundaryType;

  FScreenObjectList := TObjectList.Create;
  FPhastGrid := TPhastGrid.Create(self);
  FDataSetCollection := TDataSetCollection.Create;
  FScreenObjectCollection := TScreenObjectCollection.Create(self);
  FFluidProperties := TFluidProperties.Create(self);
  FFluidProperties.SetSubComponent(True);
  FSolutionOptions := TSolutionOptions.Create(self);
  FSolutionOptions.SetSubComponent(True);
  FPrintFrequency := TPrintFrequencyCollection.Create(DoInvalidate);
  FPrintInitial := TPrintInitial.Create;
  FGridOptions := TGridOptions.Create;
  FSteadyFlowOptions := TSteadyFlowOptions.Create;
  FChemistryOptions := TChemistryOptions.Create;

  FPrintFrequency.Add;
  FTitle := TStringList.Create;
  FTitle.Add('PHAST input generated by ' + StrModelName + '.');
  FUnits := TUnits.Create;
  FTimes := TTimeCollection.Create(DoInvalidate);
  FTimes.Add;

  FModflowStressPeriods := TModflowStressPeriods.Create(DoInvalidate);
  FModflowFullStressPeriods := TModflowStressPeriods.Create(nil);
  with FModflowStressPeriods.Add as TModflowStressPeriod do
  begin
    StartTime := -1;
    PeriodLength := 1;
    TimeStepMultiplier := 1;
    MaxLengthOfFirstTimeStep := 1;
    DrawDownReference := False;
  end;

  FModflowOutputControl := TModflowOutputControl.Create(DoInvalidate);
  FMt3dmsOutputControl := TMt3dmsOutputControl.Create(DoInvalidate);
  FMt3dmsTimes:= TMt3dmsTimeCollection.Create(DoInvalidate);

  FModflowSteadyParameters:= TModflowSteadyParameters.Create(Self);
  FModflowTransientParameters := TModflowTransientListParameters.Create(self);

  FDataArrayManager.CreateInitialDataSets;
  FDataArrayManager.CreateInitialBoundaryDataSets;

  CreatePhastTimeLists;
  CreateInitialDataSetsForPhastTimeLists;
  CreatePhastTimeListGroups;

  FDataArrayManager.CreateInitialDataSets;

  FContourFont := TFont.Create;
  ChangeNotifier := TFontChangeNotifier.Create(DoInvalidate, FContourFont);
  FContourFont.FontAdapter := ChangeNotifier;
  FShowContourLabels := True;

  FSfrStreamLinkPlot := TSfrStreamLinkPlot.Create(self);
  FStrStreamLinkPlot := TSfrStreamLinkPlot.Create(self);
  FSfrMf6StreamLinkPlot := TSfrStreamLinkPlot.Create(self);
  FSwrReachConnectionsPlot := TSwrReachConnectionsPlot.Create(self);

  FImmobileComponents := TChemSpeciesCollection.Create(Self);
  FMobileComponents := TMobileChemSpeciesCollection.Create(Self);

  FSutraLayerStructure:= TSutraLayerStructure.Create(Self);
  FSutraTimeOptions := TSutraTimeOptions.Create(DoInvalidate);
  FSutraSettings := TSutraSettings.Create(Self);
//  LayerGroup := FSutraLayerStructure.Add as TSutraLayerGroup;
//  LayerGroup.AquiferName := 'SUTRA_Mesh_Top';
  FMaxVectors := TPredefinedVectors.Create(self);
  FMidVectors := TPredefinedVectors.Create(self);
  FMinVectors := TPredefinedVectors.Create(self);

  FMaxVectors.VectorDirection := pvdMax;
  FMaxVectors.Color := clRed;
  FMidVectors.VectorDirection := pvdMid;
  FMidVectors.Color := clGreen;
  FMinVectors.VectorDirection := pvdMin;
  FMinVectors.Color := clBlue;
  FFmpCrops := TCropCollection.Create(self);
  FFmpSoils := TSoilCollection.Create(self);
  FFmpClimate := TClimateCollection.Create(self);
  FFmpAllotment := TAllotmentCollection.Create(self);
  FFarms := TFarmCollection.Create(self);
  FIrrigationTypes := TIrrigationCollection.Create(self);;

  FLinkedRasters := TLinkedRasterCollection.Create(DoInvalidate);

  FFootprintProperties := TFootprintProperties.Create(self);
  FFootprintProperties.SetSubComponent(True);

  FRipPlantGroups := TRipPlantGroups.Create(self);

  FGeoRef := TGeoref.Create(self);

  FCtsSystems := TCtsSystemCollection.Create(self);
  FParamGroups := TPestParamGroups.Create(DoInvalidate);
  FPestProperties := TPestProperties.Create(self);
  FFilesToDelete := TStringList.Create;
  FFilesToDelete.Sorted := True;
  FFilesToDelete.Duplicates := dupIgnore;

  FSvdaPrepProperties := TSvdaPrepProperties.Create(DoInvalidate);
  FSupCalcProperties := TSupCalcProperties.Create(DoInvalidate);
  FAppsMoved := TStringList.Create;
end;

procedure TPhastModel.CreateArchive(const FileName: string;
  const ArchiveCommand: string = '');
var
  DeletedFiles: TStringList;
  ErrorMessage: string;
  ArchiveNodeObjectList: TObjectList;
  ArchiveNodeList: TArchiveNodeList;
  ArchiveSaver: TArchiveSaver;
  ProgramFiles: TStringList;
  FileNames: TList<TStrings>;
  ChildIndex: Integer;
  ModelDirectory: string;
  ModelRootName: string;
  Mt3dVersion: TMt3dVersion;
  Mt3dPrefix: string;
  ChildModel: TChildModel;
  procedure RemoveProgramFilesFromList;
  var
    ProgramIndex: Integer;
    FileIndex: Integer;
    FileList: TStrings;
    FileListIndex: integer;
  begin
    for ProgramIndex := 0 to ProgramFiles.Count - 1 do
    begin
      for FileListIndex := 0 to FileNames.Count - 1 do
      begin
        FileList := FileNames[FileListIndex];
        FileIndex := FileList.IndexOf(ProgramFiles[ProgramIndex]);
        if FileIndex >= 0 then
        begin
          FileList.Delete(FileIndex);
        end;
      end;
    end;
  end;
  procedure AddFiles(const Category, ModelName: string; FileNames: TList<TStrings>);
  var
    RootNode: TArchiveNode;
    ChildNode: TArchiveNode;
    FileIndex: Integer;
    NoDuplicatesList: TStringList;
    ListIndex: Integer;
    RootIndex: Integer;
    ModelRoot: TArchiveNode;
    ChildIndex: Integer;
  begin
    if FileNames.Count > 0 then
    begin
      NoDuplicatesList := TStringList.Create;
      try
        NoDuplicatesList.Duplicates := dupIgnore;
        NoDuplicatesList.Sorted := True;
        for ListIndex := 0 to FileNames.Count -1 do
        begin
          NoDuplicatesList.AddStrings(FileNames[ListIndex]);
        end;

        for FileIndex := NoDuplicatesList.Count - 1 downto 0 do
        begin
          if not TFile.Exists(NoDuplicatesList[FileIndex]) then
          begin
            DeletedFiles.Add(NoDuplicatesList[FileIndex]);
            NoDuplicatesList.Delete(FileIndex);
          end;
        end;

        if NoDuplicatesList.Count > 0 then
        begin
          RootNode := nil;
          ModelRoot := nil;

          for RootIndex := 0 to ArchiveNodeList.Count - 1 do
          begin
            if ArchiveNodeList[RootIndex].NodeText = Category then
            begin
              RootNode := ArchiveNodeList[RootIndex] as TArchiveNode;
            end;
          end;

          if RootNode = nil then
          begin
            RootNode := TArchiveNode.Create;
            RootNode.NodeText := Category;
            RootNode.NodeType := ntCategory;
            RootNode.ModelDirectory := ModelDirectory;
            ArchiveNodeList.Add(RootNode);
            ArchiveNodeObjectList.Add(RootNode);
          end;

          if (Category <> ModelName)  then
          begin
            for ChildIndex := 0 to RootNode.Count - 1 do
            begin
              ChildNode := RootNode.Children[ChildIndex] as TArchiveNode;
              if (ChildNode.NodeType = ntModel) and (ChildNode.NodeText = ModelName) then
              begin
                ModelRoot := ChildNode;
                break;
              end;
            end;

            if (ModelRoot = nil) then
            begin
              ModelRoot := RootNode.AddChild;
              ModelRoot.NodeText := ModelName;
              ModelRoot.NodeType := ntModel;
              ModelRoot.ModelDirectory := ModelDirectory;
            end;
          end;

          for FileIndex := 0 to NoDuplicatesList.Count - 1 do
          begin
            if ModelRoot <> nil then
            begin
              ChildNode := ModelRoot.AddChild;
            end
            else
            begin
              ChildNode := RootNode.AddChild;
            end;
            ChildNode.NodeText := NoDuplicatesList[FileIndex];
            ChildNode.NodeType := ntFile;
            ChildNode.ModelDirectory := ModelDirectory;
          end;
        end;
      finally
        NoDuplicatesList.Free;
      end;
    end;
  end;
begin
  if ModelFileName = '' then
  begin
    ModelRootName := FileName;
  end
  else
  begin
    ModelRootName := ModelFileName;
  end;
  ModelRootName := ExtractFileName(ModelRootName);
  ModelRootName := ChangeFileExt(ModelRootName, '');
  ModelDirectory := ExtractFileDir(ModelFileName);
  ModelDirectory := IncludeTrailingPathDelimiter(ModelDirectory);
  DeletedFiles := TStringList.Create;
  ArchiveNodeObjectList := TObjectList.Create;
  ArchiveNodeList := TArchiveNodeList.Create;
  FileNames := TList<TStrings>.Create;
  try
    ProgramFiles := TStringList.Create;
    try
      ProgramFiles.Duplicates := dupIgnore;
      ProgramFiles.Sorted := True;
      AddModelProgramsToList(ProgramFiles);
      FileNames.Add(ProgramFiles);
      AddFiles(StrBinary, StrBinary, FileNames);

      FileNames.Clear;
      FileNames.Add(FilesToArchive);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.FilesToArchive);
        end;
      end;
      RemoveProgramFilesFromList;
      AddFiles(StrAncillary, StrAncillary, FileNames);

      FileNames.Clear;
      FileNames.Add(ModelInputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.ModelInputFiles);
        end;
      end;
      RemoveProgramFilesFromList;
      AddFiles(StrModelInputFiles, ModelRootName, FileNames);

      FileNames.Clear;
      FileNames.Add(ModelOutputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.ModelOutputFiles);
        end;
      end;
      AddFiles(StrModelOutputFiles, ModelRootName, FileNames);

      FileNames.Clear;
      FileNames.Add(ModpathInputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.ModpathInputFiles);
        end;
      end;
      RemoveProgramFilesFromList;
      AddFiles(StrModelInputFiles, ModelRootName + '_MODPATH', FileNames);
//      AddFiles('Modpath_Input_Files', FileNames);

      FileNames.Clear;
      FileNames.Add(ModpathOutputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.ModpathOutputFiles);
        end;
      end;
      AddFiles(StrModelOutputFiles, ModelRootName + '_MODPATH', FileNames);
//      AddFiles('Modpath_Output_Files', FileNames);

      FileNames.Clear;
      FileNames.Add(ZoneBudgetInputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.ZoneBudgetInputFiles);
        end;
      end;
      RemoveProgramFilesFromList;
      AddFiles(StrModelInputFiles,ModelRootName + '_ZoneBudget', FileNames);
//      AddFiles('ZoneBudget_Input_Files', FileNames);

      FileNames.Clear;
      FileNames.Add(ZoneBudgetOutputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.ZoneBudgetOutputFiles);
        end;
      end;
      AddFiles(StrModelOutputFiles, ModelRootName + '_ZoneBudget', FileNames);
//      AddFiles('ZoneBudget_Output_Files', FileNames);

      Mt3dVersion := mvUSGS;
      if ModflowPackages.Mt3dBasic.IsSelected then
      begin
        Mt3dVersion := ModflowPackages.Mt3dBasic.Mt3dVersion;
      end
      else
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          ChildModel := ChildModels[ChildIndex].ChildModel;
          if (ChildModel <> nil)
            and ChildModel.ModflowPackages.Mt3dBasic.IsSelected then
          begin
            Mt3dVersion := ChildModel.ModflowPackages.Mt3dBasic.Mt3dVersion;
            break;
          end;
        end;
      end;

      case Mt3dVersion of
        mvUSGS:
          begin
            Mt3dPrefix := '_MT3D-USGS';
          end;
        mvMS:
          begin
            Mt3dPrefix := '_MT3DMS';
          end;
      end;

      FileNames.Clear;
      FileNames.Add(Mt3dmsInputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.Mt3dmsInputFiles);
        end;
      end;
      RemoveProgramFilesFromList;
      AddFiles(StrModelInputFiles, ModelRootName + Mt3dPrefix, FileNames);
//      AddFiles('Mt3dms_Input_Files', FileNames);

      FileNames.Clear;
      FileNames.Add(Mt3dmsOutputFiles);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          FileNames.Add(ChildModel.Mt3dmsOutputFiles);
        end;
      end;
      AddFiles(StrModelOutputFiles, ModelRootName + Mt3dPrefix, FileNames);
//      AddFiles('Mt3dms_Output_Files', FileNames);
    finally
      ProgramFiles.Free;
    end;

    if DeletedFiles.Count > 0 then
    begin
      if DeletedFiles.Count > 10 then
      begin
        ErrorMessage := Format(StrDOfTheFilesThat, [DeletedFiles.Count])
          + sLineBreak + sLineBreak + StrTheRemainingFiles;
      end
      else
      begin
        ErrorMessage := 'The following files that '
          + 'were to be archived can not be found: ' + sLineBreak + sLineBreak
          + DeletedFiles.Text
          + sLineBreak + 'The remaining files will be archived.';
        if ArchiveCommand <> '' then
        begin
          ErrorMessage := ErrorMessage + ' Select "' + ArchiveCommand
            + '" to see or change the files for the archive.';
        end;
      end;
      MessageDlg(ErrorMessage, mtWarning, [mbOK], 0);
    end;

    ArchiveSaver := TArchiveSaver.Create;
    try
      ArchiveSaver.RootNodes := ArchiveNodeList;
      try
        ArchiveSaver.SaveArchive(FileName);
      except on E: Exception do
        begin
          Beep;
          MessageDlg(Format(StrErrorSavingArchive, [E.message]), mtWarning,
            [mbOK], 0);
        end;
      end;
    finally
      ArchiveSaver.Free;
    end;
  finally
    ArchiveNodeList.Free;
    ArchiveNodeObjectList.Free;
    DeletedFiles.Free;
    FileNames.Free;
  end;
end;

procedure TPhastModel.GetSutraLayerGroupDataSets(LayerGroupsDataSets: TList);
var
  DataSet: TDataArray;
  LayerGroup: TCustomLayerGroup;
  Index: Integer;
begin
  if (SutraLayerStructure <> nil) and (SutraLayerStructure.Count > 0)
    and (SutraMesh <> nil) and (SutraMesh.MeshType = mt3D) then
  begin
    for Index := 0 to SutraLayerStructure.Count - 1 do
    begin
      LayerGroup := SutraLayerStructure.LayerGroups[Index];
      DataSet := FDataArrayManager.GetDataSetByName(LayerGroup.DataArrayName);
      Assert(DataSet <> nil);
      LayerGroupsDataSets.Add(DataSet);
    end;
  end;
end;


procedure TPhastModel.GetModflowLayerGroupDataSets(LayerGroupsDataSets: TList);
var
  DataSet: TDataArray;
  LayerGroup: TCustomLayerGroup;
  Index: Integer;
begin
  if (LayerStructure <> nil) and (LayerStructure.Count > 0) then
  begin
    for Index := 0 to LayerStructure.Count - 1 do
    begin
      LayerGroup := LayerStructure.LayerGroups[Index];
      DataSet := FDataArrayManager.GetDataSetByName(LayerGroup.DataArrayName);
      Assert(DataSet <> nil);
      LayerGroupsDataSets.Add(DataSet);
    end;
  end;
end;

function TPhastModel.GetLayerStructure: TLayerStructure;
begin
  result := FLayerStructure;
end;

function TPhastModel.GetLinkedRasters: TLinkedRasterCollection;
begin
  result := FLinkedRasters;
end;

type
  TScreenObjectCrack = class(TScreenObject);

procedure TPhastModel.UpdateScreenObjects;
var
  Index: integer;
  AScreenObject: TScreenObjectCrack;
begin
  FScreenObjectCollection.UpdateScreenObjects;
  FScreenObjectCollection.Clear;
  for Index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := TScreenObjectCrack(ScreenObjects[Index]);
    AScreenObject.Loaded;
  end;

  UpdateDrainReturnObjects;
end;

procedure TPhastModel.UpdateSideTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildList: TCustomTimeList;
begin
  inherited;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildList := ChildModel.GetTimeListByName(TimeList.Name);
        ChildModel.UpdateSideTimeDataSet(ChildList, Time);
      end;
    end;
  end;
end;

destructor TPhastModel.Destroy;
var
  Index: Integer;
//  DataArray: TDataArray;
  Variable: IGlobalVariable;
  ScreenObject: TScreenObject;
//  TempI: IGlobalVariables;
begin
  SetGlobals(nil);
  frmFileProgress:= TfrmProgressMM.Create(nil);
  try
    FAppsMoved.Free;
    DataArrayManager.UnlinkDeletedDataSets;
    FClearing := True;
    try
      InternalClear;
    finally
      FClearing := False;
    end;

    FTimesSeries.Free;
    FSupCalcProperties.Free;
    FSvdaPrepProperties.Free;
    FFilesToDelete.Free;
    FPestProperties.Free;
    FParamGroups.Free;
    FCtsSystems.Free;
    FGeoRef.Free;
    FRipPlantGroups.Free;
    FMaxVectors.Free;
    FMidVectors.Free;
    FMinVectors.Free;
    FSutraSettings.Free;
    FImmobileComponents.Free;
    FMobileComponents.Free;

    FSwrReachConnectionsPlot.Free;
    FStrStreamLinkPlot.Free;
    FSfrStreamLinkPlot.Free;
    FSfrMf6StreamLinkPlot.Free;
    FChildModels.Free;
    FHufParameters.Free;

    FModelMateProject.Free;

    FreeAndNil(FSortedObjectList);

    FModflowTransientParameters.Free;
    FModflowSteadyParameters.Free;
    FMt3dmsTimes.Free;
    FMt3dmsOutputControl.Free;
    FModflowOutputControl.Free;
    FModflowFullStressPeriods.Free;
    FModflowStressPeriods.Free;
    FLinkedRasters.Free;

    frmFileProgress.pbProgress.Position := 0;
    frmFileProgress.pbProgress.Max := FDataArrayManager.DataSetCount + GlobalVariables.Count
      + ScreenObjectCount;
    frmFileProgress.Show;




    FTopBoundaryType.StopTalkingToAnyone;
    FFrontBoundaryType.StopTalkingToAnyone;
    FSideBoundaryType.StopTalkingToAnyone;
    FTop2DBoundaryType.StopTalkingToAnyone;


    for Index := 0 to GlobalVariables.Count - 1 do
    begin
      Variable := GlobalVariables[Index];
      Variable.StopTalkingToAnyone;
      frmFileProgress.pbProgress.StepIt;
      // calling Application.ProcessMessages during
      // destuction of TPhastModel can cause access violations
      // because the program attempts to draw the model
      // while it is partially destroyed.
//      Application.ProcessMessages;
    end;

    for Index := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObject := ScreenObjects[Index];
      ScreenObject.StopTalkingToAnyone;
      frmFileProgress.pbProgress.StepIt;
//      Application.ProcessMessages;
    end;
    AllObserversStopTalking;
    FFootprintProperties.Free;

    FIrrigationTypes.Free;
    FFarms.Free;
    FFmpAllotment.Free;
    FFmpClimate.Free;
    FFmpSoils.Free;
    FFmpCrops.Free;


    FreeHufNotifiers;
    FGlobalVariables.Free;


    FLayerStructure.Free;
    FScreenObjectList.Free;
    FreeGridNotifiers;

    PhastGrid.Free;
    FDataSetCollection.Free;

    FScreenObjectCollection.Free;

    FPrintFrequency.Free;
    FPrintInitial.Free;
    FGridOptions.Free;
    FFluidProperties.Free;
    FSolutionOptions.Free;
    FSteadyFlowOptions.Free;
    FChemistryOptions.Free;
    FTitle.Free;
    FUnits.Free;
    FTimes.Free;

    FTopFluxBoundaryFlux.Free;
    FFrontFluxBoundaryFlux.Free;
    FSideFluxBoundaryFlux.Free;
    FTopFluxBoundaryChemistry.Free;
    FFrontFluxBoundaryChemistry.Free;
    FSideFluxBoundaryChemistry.Free;

    FTopLeakyHead.Free;
    FTopLeakyAssociatedSolution.Free;

    FFrontLeakyHead.Free;
    FFrontLeakyAssociatedSolution.Free;

    FSideLeakyHead.Free;
    FSideLeakyAssociatedSolution.Free;

    FRiverAssociatedSolution.Free;
    FRiverHead.Free;

    FSpecifiedHeadHead.Free;
    FSpecifiedHeadAssociatedSolution.Free;

    FSpecifiedSolution.Free;
    FWellInjectionOrPumpingRate.Free;
    FWellSolution.Free;
    FModelTimes.Free;

    FTopBoundaryType.Free;
    FFrontBoundaryType.Free;
    FSideBoundaryType.Free;
    FTop2DBoundaryType.Free;

    FWellSolutionGroup.Free;
    FSpecifiedHeadGroup.Free;
    FSpecifiedHeadSolutionGroup.Free;
    FRiverHeadGroup.Free;
    FLeakyAssociatedSolutionGroup.Free;
    FRiverAssociatedSolutionGroup.Free;
    FWellPumpingRateGroup.Free;
    FFluxBoundaryChemistryGroup.Free;
    FLeakyHeadGroup.Free;
    FFluxBoundaryFluxGroup.Free;

    FBitmaps.Free;

    FGuiSettings.Free;

    FProgramLocations.Free;



    FContourColors.Free;
    FGridColors.Free;


    FFormulaManager.Free;
    FColorLegend.Free;
    FContourLegend.Free;
    FEndPointLegend.Free;
    FDisplaySettings.Free;
    FContourFont.Free;

    FSutraLayerStructure.Free;
    FSutraTimeOptions.Free;
    FColorSchemes.Free;
    FFishnetMeshGenerator.Free;

  finally
    FreeAndNil(frmFileProgress);
  end;

  inherited;
end;

procedure TCustomModel.FinalizeActive(Sender: TObject);
var
  LakeIdArray: TDataArray;
  ActiveArray: TDataArray;
begin
  LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
  ActiveArray := FDataArrayManager.GetDataSetByName(rsActive);
  if (LakeIdArray <> nil) and (ActiveArray <> nil) then
  begin
    LakeIdArray.StopsTalkingTo(ActiveArray);
  end;
end;

procedure TCustomModel.FinalizeLakeId(Sender: TObject);
begin
  FinalizeActive(Sender);
  FinalizeWetDry(Sender);
end;

function TPhastModel.GetParamGroups: TPestParamGroups;
begin
  result := FParamGroups;
end;

function TPhastModel.GetPestProperties: TPestProperties;
begin
  result := FPestProperties;
end;

function TCustomModel.GetPilotPoint(Index: Integer): TPoint2D;
begin
  result := PestProperties.PilotPoints[Index];
end;

function TCustomModel.GetPilotPointBuffer: double;
begin
  result := PestProperties.PilotPointBuffer;
end;

function TPhastModel.GetProgramLocations: TProgramLocations;
begin
  result := FProgramLocations;
end;

procedure TCustomModel.FinalizeWetDry(Sender: TObject);
var
  LakeIdArray: TDataArray;
  WetDryArray: TDataArray;
begin
  LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
  WetDryArray := FDataArrayManager.GetDataSetByName(rsWetDryFlag);
  if (LakeIdArray <> nil) and (WetDryArray <> nil) then
  begin
    LakeIdArray.StopsTalkingTo(WetDryArray);
  end;
end;

function TPhastModel.GetScreenObjectCount: integer;
begin
  if FScreenObjectList = nil then
  begin
    result := 0
  end
  else
  begin
    result := FScreenObjectList.Count;
  end;

end;

function TPhastModel.GetScreenObjects(const Index: integer): TScreenObject;
begin
  result := FScreenObjectList[Index];
end;

function TPhastModel.GetSelectedModel: TCustomModel;
begin
  result := FSelectedModel
end;

function TPhastModel.GetSfrMf6StreamLinkPlot: TSfrStreamLinkPlot;
begin
  result := FSfrMf6StreamLinkPlot;
end;

function TPhastModel.GetSfrStreamLinkPlot: TSfrStreamLinkPlot;
begin
  Result := FSfrStreamLinkPlot;
end;

function TPhastModel.GetShowContourLabels: boolean;
begin
  result := FShowContourLabels
end;

function TCustomModel.HufDataArrayUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  DataArrayNames: TStringList;
begin
  if (not (ModelSelection in ModflowSelection))
    or (ModelSelection = msModflow2015)
    or (not ModflowPackages.HufPackage.IsSelected)
    then
  begin
    result := False;
    Exit;
  end;
  DataArray := Sender as TDataArray;
  DataArrayNames := TStringList.Create;
  try
    HydrogeologicUnits.FillDataArrayNames(DataArrayNames);
    DataArrayNames.CaseSensitive := False;
    result := DataArrayNames.IndexOf(DataArray.Name) >= 0;
  finally
    DataArrayNames.Free;
  end;
end;

function TPhastModel.HufIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.HufPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.GmgPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoHufReferenceSurfaceNeeded(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoHufReferenceSurfaceNeeded(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoHufReferenceSurfaceNeeded(Sender);
      end;
    end;
  end;
end;

function TPhastModel.HydmodIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.HydmodPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.HydmodPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.ModelLayerDataArrayUsed(Sender: TObject): boolean;
var
  Index: Integer;
  Group: TCustomLayerGroup;
  DataArray: TDataArray;
begin
  Result := False;
  case ModelSelection of
    msUndefined, msPhast, msFootPrint: Exit;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
      begin
        DataArray := Sender as TDataArray;
        for Index := 0 to LayerStructure.Count - 1 do
        begin
          Group := LayerStructure[Index];
          result := (Group.DataArrayName = DataArray.Name);
          if result then
          begin
            Exit;
          end;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        result := (SutraMesh <> nil) and (SutraMesh.MeshType = mt3D);
        if result then
        begin
          DataArray := Sender as TDataArray;
          for Index := 0 to SutraLayerStructure.Count - 1 do
          begin
            Group := SutraLayerStructure[Index];
            result := (Group.DataArrayName = DataArray.Name);
            if result then
            begin
              Exit;
            end;
          end;
        end;
      end;
    else Assert(False);
  end;
end;

procedure TPhastModel.LocateNearestLakeOrStream(TestScreenObject: TScreenObject;
  var NearestLake, NearestStream: TScreenObject; Tolerance: double = 0);
var
  TestDist: Double;
  TestLocation: TPoint2D;
  AScreenObject: TScreenObject;
  Index: Integer;
  Dist: Double;
  OutFlowLocation: TPoint2D;
  SectionIndex: Integer;
begin
  OutFlowLocation := TestScreenObject.Points[TestScreenObject.Count - 1];
  NearestStream := nil;
  Dist := 0;
  for Index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[Index];
    if not AScreenObject.Deleted and (AScreenObject <> TestScreenObject)
      and (AScreenObject.ModflowSfrBoundary <> nil)
      and AScreenObject.ModflowSfrBoundary.Used then
    begin
      TestLocation := AScreenObject.Points[0];
      if NearestStream = nil then
      begin
        TestDist := Distance(TestLocation, OutFlowLocation);
        if Tolerance > 0 then
        begin
          if TestDist < Tolerance then
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end
        else
        begin
          Dist := TestDist;
          NearestStream := AScreenObject;
        end;
      end
      else
      begin
        TestDist := Distance(TestLocation, OutFlowLocation);
        if TestDist < Dist then
        begin
          if (Tolerance > 0) then
          begin
            if TestDist < Tolerance then
            begin
              Dist := TestDist;
              NearestStream := AScreenObject;
            end;
          end
          else
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end;
      end;
    end;
  end;
  NearestLake := nil;
  if ModflowPackages.LakPackage.IsSelected then
  begin
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := frmGoPhast.PhastModel.ScreenObjects[Index];
      if not AScreenObject.Deleted
        and (AScreenObject <> TestScreenObject)
        and (AScreenObject.ModflowLakBoundary <> nil)
        and AScreenObject.ModflowLakBoundary.Used then
      begin
        TestDist := AScreenObject.DistanceToScreenObject(
          OutFlowLocation, TestLocation, 1, SectionIndex);
        if (NearestStream = nil) or (TestDist < Dist) then
        begin
          if Tolerance > 0 then
          begin
            if TestDist < Tolerance then
            begin
              Dist := TestDist;
              NearestLake := AScreenObject;
            end;
          end
          else
          begin
            Dist := TestDist;
            NearestLake := AScreenObject;
          end;
        end;
      end;
    end;
  end;
  if NearestLake <> nil then
  begin
    NearestStream := nil;
  end;
end;

procedure TPhastModel.LocateNearestSwrReachObjects(TestScreenObject: TScreenObject;
  var NearestReachObjects: TList<TScreenObject>; Tolerance: double);
var
  ReferenceLocation: TPoint2D;
  procedure FindNearbyObjects;
  var
    Index: Integer;
    AScreenObject: TScreenObject;
    TestLocation: TPoint2D;
    TestDist: TFloat;
  begin
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[Index];
      if not AScreenObject.Deleted and (AScreenObject <> TestScreenObject)
        and (AScreenObject.ModflowSwrReaches <> nil)
        and AScreenObject.ModflowSwrReaches.Used then
      begin
        TestLocation := AScreenObject.Points[0];
        TestDist := Distance(TestLocation, ReferenceLocation);
        if (TestDist < Tolerance) and (NearestReachObjects.IndexOf(AScreenObject) < 0) then
        begin
          NearestReachObjects.Add(AScreenObject);
        end;
      end;
    end;
  end;
begin
  NearestReachObjects.Clear;

  ReferenceLocation := TestScreenObject.Points[0];
  FindNearbyObjects;

  if TestScreenObject.Count > 1 then
  begin
    ReferenceLocation := TestScreenObject.Points[TestScreenObject.Count-1];
    FindNearbyObjects;
  end;
end;

function TPhastModel.DoLongitudinalDispersionUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoLongitudinalDispersionUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoLongitudinalDispersionUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoLongitudinalDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoLongitudinalDispersionUsedPerSpecies(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoLongitudinalDispersionUsedPerSpecies(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.LocateNearestSfrMf6Stream(TestScreenObject: TScreenObject;
  var NearestStream: TScreenObject; Tolerance: double);
var
  TestDist: Double;
  TestLocation: TPoint2D;
  AScreenObject: TScreenObject;
  Index: Integer;
  Dist: Double;
  OutFlowLocation: TPoint2D;
begin
  OutFlowLocation := TestScreenObject.Points[TestScreenObject.Count - 1];
  NearestStream := nil;
  Dist := 0;
  for Index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[Index];
    if not AScreenObject.Deleted and (AScreenObject <> TestScreenObject)
      and (AScreenObject.ModflowSfr6Boundary <> nil)
      and AScreenObject.ModflowSfr6Boundary.Used then
    begin
      TestLocation := AScreenObject.Points[0];
      if NearestStream = nil then
      begin
        TestDist := Distance(TestLocation, OutFlowLocation);
        if Tolerance > 0 then
        begin
          if TestDist < Tolerance then
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end
        else
        begin
          Dist := TestDist;
          NearestStream := AScreenObject;
        end;
      end
      else
      begin
        TestDist := Distance(TestLocation, OutFlowLocation);
        if TestDist < Dist then
        begin
          if (Tolerance > 0) then
          begin
            if TestDist < Tolerance then
            begin
              Dist := TestDist;
              NearestStream := AScreenObject;
            end;
          end
          else
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.LocateNearestStrStream(TestScreenObject: TScreenObject;
  var NearestStream: TScreenObject; Tolerance: double);
var
  TestDist: Double;
  TestLocation: TPoint2D;
  AScreenObject: TScreenObject;
  Index: Integer;
  Dist: Double;
  OutFlowLocation: TPoint2D;
begin
  OutFlowLocation := TestScreenObject.Points[TestScreenObject.Count - 1];
  NearestStream := nil;
  Dist := 0;
  for Index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[Index];
    if not AScreenObject.Deleted and (AScreenObject <> TestScreenObject)
      and (AScreenObject.ModflowStrBoundary <> nil)
      and AScreenObject.ModflowStrBoundary.Used then
    begin
      TestLocation := AScreenObject.Points[0];
      if NearestStream = nil then
      begin
        TestDist := Distance(TestLocation, OutFlowLocation);
        if Tolerance > 0 then
        begin
          if TestDist < Tolerance then
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end
        else
        begin
          Dist := TestDist;
          NearestStream := AScreenObject;
        end;
      end
      else
      begin
        TestDist := Distance(TestLocation, OutFlowLocation);
        if TestDist < Dist then
        begin
          if (Tolerance > 0) then
          begin
            if TestDist < Tolerance then
            begin
              Dist := TestDist;
              NearestStream := AScreenObject;
            end;
          end
          else
          begin
            Dist := TestDist;
            NearestStream := AScreenObject;
          end;
        end;
      end;
    end;
  end;
end;

function TPhastModel.LpfIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.LpfPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.LpfPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.UpwIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.UpwPackage.IsSelected;
  if frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.UpwPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.SsmIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsSourceSink.IsSelected;
  if frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Mt3dmsSourceSink.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.TobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsTransObs.IsSelected;
  if frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Mt3dmsTransObs.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.TvkIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.TvkIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.TvsIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.TvsIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.InternalClear;
var
  ChildIndex: Integer;
begin
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    if ChildModels[ChildIndex].ChildModel <> nil then
    begin
      ChildModels[ChildIndex].ChildModel.FClearing := True;
    end;
  end;
  try
    SelectedModel := Self;

//    FTimesSeries.Clear;
    FCtsSystems.Clear;

    FColorLegend.ValueAssignmentMethod := vamAutomatic;
    FContourLegend.ValueAssignmentMethod := vamAutomatic;
    FEndPointLegend.ValueAssignmentMethod := vamAutomatic;


    FGeoRef.Initialize;
    FSaveBfhBoundaryConditions := True;

    DisconnectObservers;

    SutraFluxObs.Clear;
    RipPlantGroups.Clear;
    Bitmaps.Clear;
    ClearViewedItems;
    FColorLegend.ValueSource := nil;
    FColorLegend.ValueSourceInterface := nil;
    FContourLegend.ValueSource := nil;
    FContourLegend.ValueSourceInterface := nil;
    FEndPointLegend.ValueSource := nil;
    FEndPointLegend.ValueSourceInterface := nil;

    FCachedZoneArrayIndex := -1;
    FCachedMultiplierArrayIndex := -1;
    ModflowNameFileLines.Clear;
    Title.Clear;
    FrontX := 0;
    FrontY := 0;
    TopX := 0;
    TopY := 0;
    SideX := 0;
    SideY := 0;
    MagnificationFront := 0;
    MagnificationSide := 0;
    MagnificationTop := 0;
    GridColorParameters.Clear;
    ContourColorParameters.Clear;
    FDiffusivity := 1E-9;
    FFreeSurface := False;
    FDiffusivitySet := False;

    // Clear screen objects before clearing child models because
    // the screen objects access the child models while being destroyed.
    FScreenObjectList.Clear;
    FTimesSeries.Clear;

    FmpCrops.Clear;
    FmpSoils.Clear;
    FmpClimate.Clear;
    FmpAllotment.Clear;
    FFarms.Clear;
    FIrrigationTypes.Clear;

    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      if ChildModels[ChildIndex].ChildModel <> nil then
      begin
        ChildModels[ChildIndex].ChildModel.Clear;
      end;
    end;
    ChildModels.Clear;
    ModelSelection := msUndefined;


    FCrossSection.Clear;
    FDataArrayManager.ClearAllDataSets;
    ClearParsers;

    SolutionOptions.Initialize;
    PhastGrid.GridAngle := 0;
    ModflowGrid.GridAngle := 0;
    FLayerStructure.Clear;
    if FSutraLayerStructure <> nil then
    begin
      FSutraLayerStructure.Clear;
    end;

    Times.Initialize;

    ModflowPackages.Reset;
    ModflowSteadyParameters.Clear;
    ModflowTransientParameters.Clear;
    GlobalVariables.Clear;
    ModflowOutputControl.Initialize;
    Mt3dmsOutputControl.Initialize;
    FootprintProperties.Initialize;

    HydrogeologicUnits.Clear;
    FHufParameters.Clear;

    HeadFluxObservations.Clear;
    DrainObservations.Clear;
    GhbObservations.Clear;
    RiverObservations.Clear;
    StreamObservations.Clear;
    Mt3dmsHeadMassFluxObservations.Clear;
    Mt3dmsWellMassFluxObservations.Clear;
    Mt3dmsDrnMassFluxObservations.Clear;
    Mt3dmsRivMassFluxObservations.Clear;
    Mt3dmsGhbMassFluxObservations.Clear;
    Mt3dmsRchMassFluxObservations.Clear;
    Mt3dmsEvtMassFluxObservations.Clear;
    Mt3dmsMassLoadingMassFluxObservations.Clear;
    Mt3dmsResMassFluxObservations.Clear;
    Mt3dmsLakMassFluxObservations.Clear;
    Mt3dmsDrtMassFluxObservations.Clear;
    Mt3dmsEtsMassFluxObservations.Clear;
    Mt3dmsStrMassFluxObservations.Clear;
    Mt3dmsFhbHeadMassFluxObservations.Clear;
    Mt3dmsFhbFlowMassFluxObservations.Clear;

    FilesToArchive.Clear;
    ModelFileName := '';
    ModelInputFiles.Clear;
    ModelOutputFiles.Clear;
    ModpathInputFiles.Clear;
    ModpathOutputFiles.Clear;
    ZoneBudgetInputFiles.Clear;
    ZoneBudgetOutputFiles.Clear;
    Mt3dmsInputFiles.Clear;
    Mt3dmsOutputFiles.Clear;

    FDataArrayManager.InvalidateDataSetLookupList;

    BatchFileAdditionsBeforeModel.Clear;
    BatchFileAdditionsAfterModel.Clear;
    AlternateFlowPackage := False;
    AlternateSolver := False;

    FSutraOptions.RegionalProperties.Clear;
    FormulaManager.Clear;
    FDisplaySettings.Clear;

    if GlobalFont <> nil then
    begin
      ContourFont := GlobalFont;
    end;
    FImmobileComponents.Clear;
    FMobileComponents.Clear;

    Mt3dmsTimes.Clear;
    ModflowStressPeriods.Clear;
    FishnetMeshGenerator.Clear;

    MaxVectors.InitializeVariables;
    MidVectors.InitializeVariables;
    MinVectors.InitializeVariables;
    SvdaPrepProperties.InitializeVariables;
    SupCalcProperties.InitializeVariables;
    PestProperties.InitializeVariables;
    if CtsSystems <> nil then
    begin
      CtsSystems.Clear;
    end;

    FArchiveName := '';
    DoInvalidate(self);
    inherited;
  finally
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      if ChildModels[ChildIndex].ChildModel <> nil then
      begin
        ChildModels[ChildIndex].ChildModel.FClearing := False;
      end;
    end;
  end;
end;

function TPhastModel.DoExchangeUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoExchangeUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoExchangeUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.ExtractScreenObject(const AScreenObject: TScreenObject);
begin
  FScreenObjectList.Extract(AScreenObject);
  DoInvalidate(self);
end;

procedure TPhastModel.InsertScreenObject(const Index: integer;
  const AScreenObject: TScreenObject);
begin
  FScreenObjectList.Insert(Index, AScreenObject);
  DoInvalidate(self);
end;

function TPhastModel.GetObservationPurpose: TObservationPurpose;
begin
  result := FObservationPurpose;
end;

function TPhastModel.GetOwnsScreenObjects: boolean;
begin
  Result := (FScreenObjectList as TObjectList).OwnsObjects;
end;

procedure TPhastModel.SetOwnsScreenObjects(const Value: boolean);
begin
  (FScreenObjectList as TObjectList).OwnsObjects := Value;
end;

function TCustomModel.DoCapillaryFringeUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmSoil4.CapFringeArrayUsed(nil);
end;

function TCustomModel.CellToPoint(ACell: TCellLocation; EvalAt: TEvaluatedAt): TPoint3D;
var
  ModelLayer: Integer;
  ModelRow: Integer;
  ModelColumn: Integer;
  APoint: TPoint2D;
begin
  if ModelSelection in ModflowSelection then
  begin
    Assert(EvalAt = eaBlocks);
    ModelLayer := ModflowLayerToDataSetLayer(ACell.Layer);
  end
  else
  begin
    ModelLayer := ACell.Layer -1;
  end;
  ModelRow := ACell.Row -1;
  ModelColumn := ACell.Column -1;
  if Grid <> nil then
  begin
    case EvalAt of
      eaBlocks:
        begin
          result.Z := Grid.LayerCenter(ModelColumn, ModelRow, ModelLayer);
          APoint := Grid.TwoDElementCenter(ModelColumn, ModelRow);
          result.x := APoint.x;
          result.y := APoint.y;
        end;
      eaNodes:
        begin
          Assert(False);
//          result.Z := Grid.LayerElevation(ModelColumn, ModelRow, ModelLayer);
        end;
      else
        Assert(false);
    end;
  end
  else
  begin
    case EvalAt of
      eaBlocks:
        begin
          result := Mesh3D.ElementArrayI[ModelLayer, ModelColumn].CenterLocation;
        end;
      eaNodes:
        begin
          result := Mesh3D.NodeArrayI[ModelLayer, ModelColumn].NodeLocation;
        end;
    end;
  end;
end;

function TCustomModel.CfpIsSelected: Boolean;
begin
  result := (ModelSelection in [msModflowCfp, msModflowOwhm2]) and
    ModflowPackages.ConduitFlowProcess.IsSelected;
end;

function TCustomModel.DoCfp2PipesSelected(Sender: TObject): Boolean;
begin
  result := DoCfpPipesSelected(Sender) and (ModelSelection = msModflowOwhm2);
end;

function TCustomModel.DoCfpCadsSelected(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2) and CfpIsSelected
    and ModflowPackages.ConduitFlowProcess.PipesUsed
    and ModflowPackages.ConduitFlowProcess.UseCads;
end;

function TCustomModel.DoCfpPipesSelected(Sender: TObject): Boolean;
begin
  result := CfpIsSelected and
    ModflowPackages.ConduitFlowProcess.PipesUsed;
end;

function TCustomModel.SwrIsSelected: Boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.SwrPackage.IsSelected;
end;

function TCustomModel.DoSwrSelected(Sender: TObject): Boolean;
begin
  result := SwrIsSelected
end;

function TPhastModel.CfpRechargeIsSelected(Sender: TObject): Boolean;
begin
  result := DoCfpPipesSelected(Sender) and RchIsSelected
    and ModflowPackages.ConduitFlowProcess.ConduitRechargeUsed;
end;

function TPhastModel.ChdIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ChdIsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoChemistryUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoChemistryUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoChemistryUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.ChobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.ChobPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.ChobPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.ClearScreenObjectCollection;
begin
  FScreenObjectCollection.Clear;
end;

procedure TPhastModel.ClearScreenObjects;
begin
  FScreenObjectList.Clear;
  DoInvalidate(self);
end;

procedure TPhastModel.ClearSwiObsFiles;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  FSwiObsExtractorInputFiles.Clear;
  FSwiObsExtractorOutputFiles.Clear;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.FSwiObsExtractorInputFiles.Clear;
        ChildModel.FSwiObsExtractorOutputFiles.Clear;
      end;
    end;
  end;
end;

procedure TPhastModel.RemoveScreenObject(const AScreenObject: TScreenObject);
begin
  FScreenObjectList.Remove(AScreenObject);
  DoInvalidate(self);
end;

procedure TPhastModel.RenameOldVerticalLeakance;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  Index: integer;
  ADataSet, ChildDataArray: TDataArray;
begin
  if FileVersionEqualOrEarlier('2.14.1.3') then
  begin
    inherited;
    if ChildModels.Count > 0 then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          ChildModel.RenameOldVerticalLeakance
        end;
      end;
      for Index := 0 to FDataArrayManager.DataSetCount - 1 do
      begin
        ADataSet := FDataArrayManager[Index];
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          ChildModel := ChildModels[ChildIndex].ChildModel;
          if ChildModel <> nil then
          begin
            ChildDataArray := ChildModel.DataArrayManager.GetDataSetByName(ADataSet.Name);
            Assert(ChildDataArray <> nil);
            ChildDataArray.AssignProperties(ADataSet);
            ChildDataArray.Formula := ADataSet.Formula;
            ChildDataArray.Limits := ADataSet.Limits;
            ChildDataArray.ContourLimits := ADataSet.ContourLimits;
          end;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.RenameDataArray(DataArray: TDataArray;
  const NewName, NewDisplayName: string);
var
  OldNames: TStringList;
  Compiler: TRbwParser;
  NewNames: TStringList;
  OldName: TComponentName;
  Position: Integer;
begin
  OldName := DataArray.Name;
  // rename data array.
  if OldName <> NewName then
  begin
    TopGridObserver.StopsTalkingTo(DataArray);
    DataArray.StopsTalkingTo(ThreeDGridObserver);
    OldNames := TStringList.Create;
    NewNames := TStringList.Create;
    try
      OldNames.Add(OldName);
      NewNames.Add(NewName);
      UpdateFormulas(OldNames, NewNames);
    finally
      NewNames.Free;
      OldNames.Free;
    end;
    DataArray.Name := NewName;
  end;
  DataArray.DisplayName := NewDisplayName;
  if OldName <> NewName then
  begin
    Compiler := GetCompiler(DataArray.Orientation, DataArray.EvaluatedAt);
    Position := Compiler.IndexOfVariable(OldName);
    if Position >= 0 then
    begin
      Compiler.RenameVariable(Position, NewName, NewDisplayName);
    end;
    Compiler := GetCompiler(dso3D, DataArray.EvaluatedAt);
    Position := Compiler.IndexOfVariable(OldName);
    if Position >= 0 then
    begin
      Compiler.RenameVariable(Position, NewName, NewDisplayName);
    end;
  end;
end;

function TPhastModel.IndexOfScreenObject(const AScreenObject: TScreenObject):
  integer;
begin
  if (FCachedScreenObjectIndex >= 0) and
    (FCachedScreenObjectIndex < FScreenObjectList.Count) then
  begin
    if FScreenObjectList[FCachedScreenObjectIndex] = AScreenObject then
    begin
      result := FCachedScreenObjectIndex;
      Exit;
    end;
  end;
  Inc(FCachedScreenObjectIndex);
  if (FCachedScreenObjectIndex >= 0) and
    (FCachedScreenObjectIndex < FScreenObjectList.Count) then
  begin
    if FScreenObjectList[FCachedScreenObjectIndex] = AScreenObject then
    begin
      result := FCachedScreenObjectIndex;
      Exit;
    end;
  end;
  Dec(FCachedScreenObjectIndex, 2);
  if (FCachedScreenObjectIndex >= 0) and
    (FCachedScreenObjectIndex < FScreenObjectList.Count) then
  begin
    if FScreenObjectList[FCachedScreenObjectIndex] = AScreenObject then
    begin
      result := FCachedScreenObjectIndex;
      Exit;
    end;
  end;
  result := FScreenObjectList.IndexOf(AScreenObject);
  FCachedScreenObjectIndex := result;
end;

procedure TCustomModel.SetPhastGrid(const Value: TPhastGrid);
begin
  FPhastGrid.Assign(Value);
  DoInvalidate(self);
end;

procedure TCustomModel.SetPilotPointData(
  const Value: TStoredPilotParamDataCollection);
begin
  FPilotPointData.Assign(Value);
end;

function TPhastModel.GetHufParameters: THufModflowParameters;
begin
  result := FHufParameters;
end;

function TPhastModel.GetImmobileComponents: TChemSpeciesCollection;
begin
  Result := FImmobileComponents;
end;

function TPhastModel.GetIrrigationTypes: TIrrigationCollection;
begin
  result := FIrrigationTypes;
end;

procedure TPhastModel.SetHeight(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.Height := Value
  end;
end;

procedure TPhastModel.SetHufParameters(const Value: THufModflowParameters);
begin
  FHufParameters.Assign(Value);
end;

procedure TPhastModel.SetImmobileComponents(
  const Value: TChemSpeciesCollection);
begin
  FImmobileComponents.Assign(Value);
end;

procedure TPhastModel.SetIrrigationTypes(const Value: TIrrigationCollection);
begin
  FIrrigationTypes.Assign(Value);
end;

procedure TPhastModel.SetLayerStructure(const Value: TLayerStructure);
begin
  FLayerStructure.Assign(Value);
end;

procedure TPhastModel.SetLeft(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.Left := Value
  end;
end;

procedure TPhastModel.SetLinkedRasters(const Value: TLinkedRasterCollection);
begin
  FLinkedRasters.Assign(Value);
end;

procedure TPhastModel.SetTop(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.Top := Value
  end;
end;

procedure TPhastModel.SetTopDataSet(const Value: TDataArray);
begin
  inherited;
  if Value <> nil then
  begin
    ColorLegend.ValueSource := Value;
  end;
end;

procedure TPhastModel.SetTopTimeList(const Value: TCustomTimeList);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildTimeList: TCustomTimeList;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      if Value = nil then
      begin
        ChildTimeList := nil;
      end
      else
      begin
        ChildTimeList := ChildModel.GetTimeListByName(Value.Name)
      end;
      ChildModel.TopTimeList := ChildTimeList;
    end;
  end;
end;

procedure TPhastModel.SetWidth(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.Width := Value
  end;
end;

function TPhastModel.PhastUsed(Sender: TObject): boolean;
begin
  result := ModelSelection = msPhast;
end;

function TPhastModel.DoPorosityUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoPorosityUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoPorosityUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.StobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.StobPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.StobPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.StoreChildModels: Boolean;
begin
  result := FChildModels.Count > 0;
end;

function TPhastModel.GetMobileComponents: TMobileChemSpeciesCollection;
begin
  result := FMobileComponents;
end;

function TPhastModel.GetModelSelection: TModelSelection;
begin
  result := FModelSelection;
end;

function TPhastModel.GetModflowFullStressPeriods: TModflowStressPeriods;
begin
  result := FModflowFullStressPeriods;
end;

function TPhastModel.GetModflowOutputControl: TModflowOutputControl;
begin
  result := FModflowOutputControl;
end;

function TPhastModel.GetModflowSteadyParameters: TModflowSteadyParameters;
begin
  result := FModflowSteadyParameters;
end;

function TPhastModel.GetModflowStressPeriods: TModflowStressPeriods;
begin
  result := FModflowStressPeriods;
end;

function TPhastModel.GetModflowTransientParameters: TModflowTransientListParameters;
begin
  result := FModflowTransientParameters;
end;

function TPhastModel.GetMt3dmsOutputControl: TMt3dmsOutputControl;
begin
  result := FMt3dmsOutputControl;
end;

function TPhastModel.GetMt3dmsTimes: TMt3dmsTimeCollection;
begin
  result := FMt3dmsTimes;
end;

function TPhastModel.GetNeedToRecalculateFrontCellColors: boolean;
begin
  if Grid <> nil then
  begin
    result := Grid.NeedToRecalculateFrontCellColors;
  end
  else if Mesh3D <> nil then
  begin
    result := Mesh3D.NeedToRecalculateFrontColors;
  end
  else
  begin
    result := False;
  end;
end;

function TPhastModel.GetNeedToRecalculateSideCellColors: boolean;
begin
  if Grid <> nil then
  begin
    result := Grid.NeedToRecalculateSideCellColors;
  end
  else
  begin
    result := False;
  end;
end;

function TPhastModel.GetNeedToRecalculateTopCellColors: boolean;
begin
  if Grid <> nil then
  begin
    result := Grid.NeedToRecalculateTopCellColors;
  end
  else if Mesh3D <> nil then
  begin
    result := Mesh3D.NeedToRecalculateTopColors;
  end
  else
  begin
    result := False;
  end;
end;

procedure TPhastModel.UpdateUseList(DataIndex: integer;
  NewUseList: TStringList; Item: TCustomModflowBoundaryItem);
var
  Formula: string;
  TempUseList: TStringList;
  VariableIndex: Integer;
  ScreenObject: TScreenObject;
  ATimeSeries: TMf6TimeSeries;
  LocalScreenObject: IScreenObjectForDynamicTimeSeries;
  ADynamicTimeSeries: IDynamicTimeSeries;
begin
  Formula := Item.BoundaryFormula[DataIndex];

  ATimeSeries := nil;
  ADynamicTimeSeries := nil;
  if IGlobalModel <> nil then
  begin
    if IGlobalModel.ModelSelection = msModflow2015 then
    begin
      ATimeSeries :=
        frmGoPhast.PhastModel.Mf6TimesSeries.GetTimeSeriesByName(Formula);
      if (ATimeSeries = nil) and (Item.ScreenObjectI <> nil) then
      begin
        if Item.ScreenObjectI.QueryInterface(IScreenObjectForDynamicTimeSeries,
          LocalScreenObject) <> 0 then
        begin
          Assert(False);
        end;
        ADynamicTimeSeries := LocalScreenObject.
          GetDynamicTimeSeriesIByName(Formula);
      end;
    end;
  end;

  if ADynamicTimeSeries <> nil then
  begin
    NewUseList.AddStrings(ADynamicTimeSeries.UsesList);
  end
  else if ATimeSeries = nil then
  begin
    try
      rpThreeDFormulaCompiler.Compile(Formula);
    except on E: ErbwParserError do
      begin
        ScreenObject := Item.ScreenObject as TScreenObject;
        frmFormulaErrors.AddFormulaError(ScreenObject.Name, StrModflowSfrReachLength,
          Formula, E.Message);
        Formula := '0';
        rpThreeDFormulaCompiler.Compile(Formula);
      end;
    end;
    TempUseList := rpThreeDFormulaCompiler.CurrentExpression.VariablesUsed;
    for VariableIndex := 0 to TempUseList.Count - 1 do
    begin
      if NewUseList.IndexOf(TempUseList[VariableIndex]) < 0 then
      begin
        NewUseList.Add(TempUseList[VariableIndex]);
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateDisplayUseList(NewUseList: TStringList;
  ParamType: TParameterType; DataIndex: integer; const DisplayName: string);
var
  ScreenObjectIndex: Integer;
  ScreenObject: TScreenObject;
  Item: TCustomModflowBoundaryItem;
  ValueIndex: Integer;
  ParamIndex: Integer;
  ParamItem: TModflowParamItem;
  Boundary: TModflowParamBoundary;
begin
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    ScreenObject := ScreenObjects[ScreenObjectIndex];
    if ScreenObject.Deleted then
    begin
      Continue;
    end;
    Boundary := ScreenObject.GetMfBoundary(ParamType);
    if (Boundary <> nil) and Boundary.Used then
    begin
      for ValueIndex := 0 to Boundary.Values.Count -1 do
      begin
        Item := Boundary.Values[ValueIndex] as TCustomModflowBoundaryItem;

        try
          UpdateUseList(DataIndex, NewUseList, Item);
        finally

        end;
      end;
      for ParamIndex := 0 to Boundary. Parameters.Count - 1 do
      begin
        ParamItem := Boundary.Parameters[ParamIndex];
        for ValueIndex := 0 to ParamItem.Param.Count - 1 do
        begin
          Item := ParamItem.Param.Items[ValueIndex]
            as TCustomModflowBoundaryItem;
          UpdateUseList(DataIndex, NewUseList, Item);
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.SetMagnificationFront(Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.MagnificationFront := Value
  end;
end;

procedure TPhastModel.SetMagnificationSide(Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.MagnificationSide := Value
  end;
end;

procedure TPhastModel.SetMagnificationTop(Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.MagnificationTop := Value
  end;
end;

procedure TPhastModel.SetMaxVectors(const Value: TPredefinedVectors);
begin
  FMaxVectors.Assign(Value);
end;

procedure TPhastModel.SetMidVectors(const Value: TPredefinedVectors);
begin
  FMidVectors.Assign(Value);
end;

procedure TPhastModel.SetMinVectors(const Value: TPredefinedVectors);
begin
  FMinVectors.Assign(Value);
end;

procedure TPhastModel.SetMobileComponents(
  const Value: TMobileChemSpeciesCollection);
begin
  FMobileComponents.Assign(Value);
  // The following statement causes ModflowPackages.GwtPackages.Count to
  // be updated to be at least as large as MobileComponents.Count.
  ModflowPackages.GwtPackages.Count;
  UpdateGwtConc;
end;

procedure TPhastModel.SetModelMateProject(const Value: TProject);
begin
  if FModelMateProject <> Value then
  begin
    if Value = nil then
    begin
      FreeAndNil(FModelMateProject)
    end
    else
    begin
      if FModelMateProject = nil then
      begin
          FModelMateProject := TProject.Create(nil);
      end;
      FModelMateProject.Assign(Value);
    end;
  end;

end;

procedure TPhastModel.SetModelMateProjectFileName(const Value: string);
begin
  if FModelMateProjectFileName <> Value then
  begin
    FModelMateProjectFileName := Value;
    DoInvalidate(self);
  end;
end;

procedure TPhastModel.SetModelSelection(const Value: TModelSelection);
var
  LayerGroup: TCustomLayerGroup;
  ModpathSelection: TModpathSelection;
begin
  inherited;
  case Value of
    msUndefined: ;
    msPhast: ;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
      begin
        if not (csLoading in ComponentState) then
        begin
          if LayerStructure.Count = 0 then
          begin
            ModflowGrid.RowCount := -1;
            ModflowGrid.ColumnCount := -1;
            ModflowGrid.LayerCount := -1;
          end;
        end;
		    ModpathSelection := ModflowPackages.Modpath;
        if Value = msModflow2015 then
        begin
          ModflowOutputControl.HeadOC.OutputFileType := oftBinary;
          if ModpathSelection.MpathVersion < mp7 then
          begin
            ModpathSelection.MpathVersion := mp7;
          end;
        end
        else if Value in ModflowSelection then
        begin
          if ModpathSelection.MpathVersion >= mp7 then
          begin
            ModpathSelection.MpathVersion := mp6;
          end;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if FSutraLayerStructure.Count = 0 then
        begin
          LayerGroup := FSutraLayerStructure.Add as TCustomLayerGroup;
          LayerGroup.AquiferName := kSUTRAMeshTop;
        end
      end;
    msFootPrint:
      begin
        UpdateDataSetDimensions;
      end
    else Assert(False);
  end;

end;

procedure TCustomModel.DiscretizationChangedEvent(Sender: TObject);
begin
  case FModelSelection of
    msUndefined: ; // do nothing
    msPhast: ;  // do nothing
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        ModflowGrid.NotifyGridChanged(Sender);
      end;
    msModflow2015:
      begin
        if DisvUsed then
        begin
          DisvGrid.NotifyMeshChanged(Sender);
        end
        else
        begin
          ModflowGrid.NotifyGridChanged(Sender);
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        OnTopSutraMeshChanged(Sender);
      end;
    msFootPrint: ; // do nothing.
    else
      Assert(False);
  end;
end;

function TCustomModel.DiscretizationLimits(
  ViewDirection: TViewDirection): TGridLimit;
begin
  result.Minx := 0;
  result.MaxX := 0;
  result.MinY := 0;
  result.MaxY := 0;
  result.MinZ := 0;
  result.MaxZ := 0;
  if ModelSelection in SutraSelection then
  begin
    if SutraMesh <> nil then
    begin
      result := SutraMesh.MeshLimits(ViewDirection, SutraMesh.CrossSection.Angle);
    end;
  end
  else
  begin
    if DisvUsed then
    begin
      if DisvGrid <> nil then
      begin
        result := DisvGrid.MeshLimits(ViewDirection, DisvGrid.CrossSection.Angle);
      end;
    end
    else
    begin
      if (Grid <> nil) and (Grid.ColumnCount > 0) and (Grid.RowCount > 0) then
      begin
        result := Grid.GridLimits(ViewDirection);
      end;
    end;
  end;
end;

function TCustomModel.DisvUsed: Boolean;
begin
  result := (ModelSelection = msModflow2015) and (Mf6GridType = mgtLayered);
end;

procedure TCustomModel.SetModelSelection(const Value: TModelSelection);
var
  ActiveDataSet: TDataArray;
  ObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  if FModelSelection <> Value then
  begin
    EdgeDisplay := nil;
    case FModelSelection of
      msUndefined:
        begin
          // ignore
        end;
      msPhast:
        begin
          PhastGrid.TopGridObserver := nil;
          PhastGrid.ThreeDGridObserver := nil;
        end;
      msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
        msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
        begin
          ModflowGrid.TopGridObserver := nil;
          ModflowGrid.ThreeDGridObserver := nil;
        end;
      msSutra22, msSutra30:
        begin

        end;
      msSutra40:
        begin
        end;
      msFootprint:
        begin
        end
      else Assert(False);
    end;
    FModelSelection := Value;
    LayerStructure.UpdateRequiredDataArrays;
    case FModelSelection of
      msUndefined:
        begin
          PhastGrid.TopGridObserver := nil;
          PhastGrid.ThreeDGridObserver := nil;
          ModflowGrid.TopGridObserver := nil;
          ModflowGrid.ThreeDGridObserver := nil;
          FGrid := nil;
        end;
      msPhast:
        begin
          FGrid := PhastGrid;
        end;
      msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
        msModflowFmp, msModflowCfp, msModflowOwhm2:
        begin
          FGrid := ModflowGrid;
        end;
        msModflow2015:
        begin
          if DisvUsed then
          begin
            FGrid := nil;
            InvalidateScreenObjects;
          end
          else
          begin
            FGrid := ModflowGrid;
          end;
        end;
      msSutra22, msSutra30:
        begin
          FGrid := nil;
          TopGridObserver.OnUpToDateSet := OnTopSutraMeshChanged;
        end;
      msSutra40:
        begin
          FGrid := nil;
          TopGridObserver.OnUpToDateSet := OnTopSutraMeshChanged;
          if SutraOptions.RegionalProperties.Count = 0 then
          begin
            SutraOptions.RegionalProperties.Add;
          end;
        end;
      msFootprint:
        begin
          FGrid := FootPrintGrid;
        end;
      else Assert(False);
    end;
    if (FModelSelection in [msModflow, msModflowLgr, msModflowLGR2,
      msModflowCfp]) then
    begin
      if ModflowPackages.UpwPackage.IsSelected then
      begin
        ModflowPackages.UpwPackage.IsSelected := False;
        ModflowPackages.LpfPackage.IsSelected := True;
      end;
      if ModflowPackages.NwtPackage.IsSelected then
      begin
        ModflowPackages.NwtPackage.IsSelected := False;
        ModflowPackages.PcgPackage.IsSelected := True;
      end;
    end;
    if FModelSelection = msModflow2015 then
    begin
      ModflowPackages.NpfPackage.IsSelected := True;
//      ModflowPackages.UpwPackage.IsSelected := False;
//      ModflowPackages.LpfPackage.IsSelected := False;
//      ModflowPackages.NwtPackage.IsSelected := False;
//      ModflowPackages.PcgPackage.IsSelected := False;
//      ModflowPackages.BcfPackage.IsSelected := False;
//      ModflowPackages.HufPackage.IsSelected := False;
//      ModflowPackages.PcgnPackage.IsSelected := False;
//      ModflowPackages.SipPackage.IsSelected := False;
//      ModflowPackages.GmgPackage.IsSelected := False;
//      ModflowPackages.De4Package.IsSelected := False;

      ModflowPackages.SmsPackage.IsSelected := True;
//      ModflowPackages.NwtPackage.IsSelected := False;
//      ModflowPackages.PcgPackage.IsSelected := False;

      if ModflowPackages.EvtPackage.IsSelected
        and not ModflowPackages.EtsPackage.IsSelected then
      begin
        ModflowPackages.EtsPackage.Assign(ModflowPackages.EvtPackage);
        ModflowPackages.EvtPackage.IsSelected := False;

        for ObjectIndex := 0 to ScreenObjectCount - 1 do
        begin
          AScreenObject := ScreenObjects[ObjectIndex];
          if (AScreenObject.ModflowEvtBoundary <> nil)
            and AScreenObject.ModflowEvtBoundary.Used
            and (AScreenObject.ModflowEtsBoundary = nil) then
          begin
            AScreenObject.CreateEtsBoundary;
            AScreenObject.ModflowEtsBoundary.Assign(
              AScreenObject.ModflowEvtBoundary);
          end;
        end;
      end;
    end;
    if Grid <> nil then
    begin
      Grid.TopGridObserver := TopGridObserver;
      Grid.ThreeDGridObserver := ThreeDGridObserver;
    end;
    AddGIS_Functions(rpTopFormulaCompiler, FModelSelection, eaBlocks);
    AddGIS_Functions(rpFrontFormulaCompiler, FModelSelection, eaBlocks);
    AddGIS_Functions(rpSideFormulaCompiler, FModelSelection, eaBlocks);
    AddGIS_Functions(rpThreeDFormulaCompiler, FModelSelection, eaBlocks);
    AddGIS_Functions(rpTopFormulaCompilerNodes, FModelSelection, eaNodes);
    AddGIS_Functions(rpFrontFormulaCompilerNodes, FModelSelection, eaNodes);
    AddGIS_Functions(rpSideFormulaCompilerNodes, FModelSelection, eaNodes);
    AddGIS_Functions(rpThreeDFormulaCompilerNodes, FModelSelection, eaNodes);

    UpdateDataArrayParameterUsed;

    if Grid <> nil then
    begin
      Grid.GridChanged;
    end;
    if not (csReading in ComponentState) and not (csDestroying in ComponentState)
      and not Clearing then
    begin
      if (frmGoPhast.PhastModel <> nil)
        and not (csReading in frmGoPhast.PhastModel.ComponentState)
        and not (csDestroying in frmGoPhast.PhastModel.ComponentState)
        and not frmGoPhast.PhastModel.Clearing then
      begin
        FDataArrayManager.CreateInitialDataSets;
      end;
    end;
    UpdateAllDataArrayDimensions;
    if not (csDestroying in ComponentState) and not Clearing then
    begin
      InvalidateScreenObjects;
    end;

    ActiveDataSet := FDataArrayManager.GetDataSetByName(rsActive);
    if (ActiveDataSet <> nil) and (CrossSection <> nil)
      and not (csDestroying in ComponentState) and not Clearing then
    begin
      ActiveDataSet.TalksTo(CrossSection);
    end;

    DataArrayManager.UpdateClassifications;
    DoInvalidate(self);
    if Assigned(OnModelSelectionChange) then
    begin
      OnModelSelectionChange(self);
    end;
    InvalidateContours;
  end;
end;

//procedure TPhastModel.SetModflowOptions(const Value: TModflowOptions);
//begin
//  FModflowOptions.Assign(Value);
//end;

procedure TPhastModel.SetModflowOutputControl(
  const Value: TModflowOutputControl);
begin
  FModflowOutputControl.Assign(Value);
end;

procedure TPhastModel.SetModflowSteadyParameters(
  const Value: TModflowSteadyParameters);
begin
  FModflowSteadyParameters.Assign(Value);
  UpdateDataArrayParameterUsed;
end;

procedure TPhastModel.SetModflowStressPeriods(
  const Value: TModflowStressPeriods);
var
  InvalidateTransients: boolean;
  Index: Integer;
  OldStressPeriod: TModflowStressPeriod;
  NewStressPeriod: TModflowStressPeriod;
begin
  InvalidateTransients := FModflowStressPeriods.Count <> Value.Count;
  if not InvalidateTransients then
  begin
    for Index := 0 to FModflowStressPeriods.Count - 1 do
    begin
      OldStressPeriod := FModflowStressPeriods[Index];
      NewStressPeriod := Value[Index];
      InvalidateTransients :=
        (OldStressPeriod.StartTime <> NewStressPeriod.StartTime)
        or (OldStressPeriod.EndTime <> NewStressPeriod.EndTime);
      if InvalidateTransients then
      begin
        break;
      end;
    end;
  end;
  FModflowStressPeriods.Assign(Value);
  if InvalidateTransients then
  begin
    InvalidateModflowBoundaries;
  end;
end;

procedure TPhastModel.SetModflowTransientParameters(
  const Value: TModflowTransientListParameters);
begin
  FModflowTransientParameters.Assign(Value);
end;

procedure TPhastModel.SetMt3dmsOutputControl(const Value: TMt3dmsOutputControl);
begin
  FMt3dmsOutputControl.Assign(Value);
end;

procedure TPhastModel.SetMt3dmsTimes(const Value: TMt3dmsTimeCollection);
begin
  FMt3dmsTimes.Assign(Value);
end;

procedure TPhastModel.SetNeedToRecalculateFrontCellColors(const Value: boolean);
var
  ChildIndex: Integer;
  ChildGrid: TCustomModelGrid;
  ChildModel: TChildModel;
begin
  if Grid <> nil then
  begin
    Grid.NeedToRecalculateFrontCellColors := Value;
    if LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          ChildGrid := ChildModel.Grid;
          if ChildGrid <> nil then
          begin
            ChildGrid.NeedToRecalculateFrontCellColors := Value;
          end;
        end;
      end;
    end;
  end
  else if Mesh3D <> nil then
  begin
    Mesh3D.NeedToRecalculateFrontColors := Value;
  end;
end;

procedure TPhastModel.SetNeedToRecalculateSideCellColors(const Value: boolean);
var
  ChildIndex: Integer;
  ChildGrid: TCustomModelGrid;
  ChildModel: TChildModel;
begin

  if Grid <> nil then
  begin
    Grid.NeedToRecalculateSideCellColors := Value;
    if LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          ChildGrid := ChildModel.Grid;
          if ChildGrid <> nil then
          begin
            ChildGrid.NeedToRecalculateSideCellColors := Value;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.SetNeedToRecalculateTopCellColors(const Value: boolean);
var
  ChildIndex: Integer;
  ChildGrid: TCustomModelGrid;
  ChildModel: TChildModel;
begin
  if Grid <> nil then
  begin
    Grid.NeedToRecalculateTopCellColors := Value;
    if LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;

        if ChildModel <> nil then
        begin
          ChildGrid := ChildModel.Grid;
          if ChildGrid <> nil then
          begin
            ChildGrid.NeedToRecalculateTopCellColors := Value;
          end;
        end;
      end;
    end;
  end
  else if Mesh3D <> nil then
  begin
    Mesh3D.NeedToRecalculateTopColors := Value;
  end;
end;

function TPhastModel.GetFarms: TFarmCollection;
begin
  result := FFarms;
end;

function TPhastModel.GetFilesToDelete: TStrings;
begin
  result := FFilesToDelete;
end;

function TPhastModel.GetFmpAllotment: TAllotmentCollection;
begin
  result := FFmpAllotment;
end;

function TPhastModel.GetFmpClimate: TClimateCollection;
begin
  result := FFmpClimate;
end;

function TPhastModel.GetFmpCrops: TCropCollection;
begin
  result := FFmpCrops;
end;

function TPhastModel.GetFmpSoils: TSoilCollection;
begin
  result := FFmpSoils;
end;

function TPhastModel.GetFootprintProperties: TFootprintProperties;
begin
  Result := FFootprintProperties;
end;

function TPhastModel.GetFormulaManager: TFormulaManager;
begin
  result := FFormulaManager;
end;

function TPhastModel.GetFreeSurface: boolean;
begin
  result := FFreeSurface;
end;

function TPhastModel.GetGeoRef: TGeoRef;
begin
  result := FGeoRef;
end;

function TPhastModel.GetGlobalVariables: TGlobalVariables;
begin
  result := FGlobalVariables;
end;

function TPhastModel.GetGlobalVariablesI: IGlobalVariables;
begin
  Result := FGlobalVariables;
end;

function TPhastModel.GetSoluteTransport: boolean;
begin
  result := FSoluteTransport;
end;

function TPhastModel.GetSomeSegmentsUpToDate: boolean;
begin
  result := FSomeSegmentsUpToDate;
end;

function TPhastModel.GetStrStreamLinkPlot: TSfrStreamLinkPlot;
begin
  Result := FStrStreamLinkPlot;
end;

function TPhastModel.GetSutraLayerStructure: TSutraLayerStructure;
begin
  if FSutraLayerStructure = nil then
  begin
    FSutraLayerStructure := TSutraLayerStructure.Create(self);
  end;
  result := FSutraLayerStructure
end;

function TPhastModel.GetSwrReachConnectionsPlot: TSwrReachConnectionsPlot;
begin
  result := FSwrReachConnectionsPlot;
end;

procedure TPhastModel.SetFrontDataSet(const Value: TDataArray);
begin
  inherited;
  if Value <> nil then
  begin
    ColorLegend.ValueSource := Value;
  end;
end;

procedure TPhastModel.SetFrontHeight(Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.FrontHeight := Value;
  end;
end;

procedure TPhastModel.SetFrontTimeList(const Value: TCustomTimeList);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildTimeList: TCustomTimeList;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      if Value = nil then
      begin
        ChildTimeList := nil;
      end
      else
      begin
        ChildTimeList := ChildModel.GetTimeListByName(Value.Name)
      end;
      ChildModel.FrontTimeList := ChildTimeList;
    end;
  end;
end;

procedure TPhastModel.SetFrontX(const Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.FrontX := Value;
  end;
end;

procedure TPhastModel.SetFrontY(const Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.FrontY := Value;
  end;
end;

procedure TPhastModel.SetSideX(const Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.SideX := Value
  end;
end;

procedure TPhastModel.SetSideY(const Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.SideY := Value
  end;
end;

procedure TPhastModel.SetTopX(const Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.TopX := Value
  end;
end;

procedure TPhastModel.SetTopY(const Value: double);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.TopY := Value
  end;
end;

procedure TPhastModel.SetTopViewHeight(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.TopViewHeight := Value
  end;
end;

procedure TPhastModel.SetTopViewWidth(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.TopViewWidth := Value
  end;
end;

function TPhastModel.GetVersion: string;
begin
  result := IModelVersion;
end;

procedure TPhastModel.SetVersion(const Value: string);
begin
  FFileVersion := Value;
end;

procedure TCustomModel.UpdateActive(Sender: TObject);
const
  SpecifiedHeadComment = 'All specified head cells are active';
var
  LakeIdArray: TDataArray;
  ActiveArray: TDataArray;
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
  IsLake: boolean;
  SpecifiedHeadArray: TDataArray;
  LakeComment: string;
  LakeMf6Array: TDataArray;
  ConnectionTypes: Integer;
  BottomLayer: Integer;
begin
  if (ModelSelection in ModflowSelection)
    and ModflowPackages.ChdBoundary.IsSelected then
  begin
    SpecifiedHeadArray := FDataArrayManager.GetDataSetByName(rsModflowSpecifiedHead);
    if SpecifiedHeadArray <> nil then
    begin
      SpecifiedHeadArray.Initialize;
      ActiveArray := FDataArrayManager.GetDataSetByName(rsActive);
      Assert(ActiveArray <> nil);

      if DisvUsed then
      begin
        for ColIndex := 0 to DisvGrid.TwoDGrid.ElementCount - 1 do
        begin
          for LayerIndex := 0 to DisvGrid.Layers.Count - 1 do
          begin
            if SpecifiedHeadArray.BooleanData[LayerIndex,0,ColIndex]
              and not ActiveArray.BooleanData[LayerIndex,0,ColIndex] then
            begin
              ActiveArray.BooleanData[LayerIndex,0,ColIndex] := True;
              ActiveArray.Annotation[LayerIndex,0,ColIndex] := SpecifiedHeadComment;
            end;
          end;
        end;
      end
      else
      begin
        for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
        begin
          for RowIndex := 0 to ModflowGrid.RowCount - 1 do
          begin
            for LayerIndex := 0 to ModflowGrid.LayerCount - 1 do
            begin
              if SpecifiedHeadArray.BooleanData[LayerIndex,RowIndex,ColIndex]
                and not ActiveArray.BooleanData[LayerIndex,RowIndex,ColIndex] then
              begin
                ActiveArray.BooleanData[LayerIndex,RowIndex,ColIndex] := True;
                ActiveArray.Annotation[LayerIndex,RowIndex,ColIndex] := SpecifiedHeadComment;
              end;
            end;
          end;
        end;

      end;
    end;
  end;
  if (ModelSelection in ModflowSelection)
    and (ModelSelection <> msModflow2015)
    and ModflowPackages.LakPackage.IsSelected  then
  begin
    LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
    ActiveArray := FDataArrayManager.GetDataSetByName(rsActive);
    Assert(LakeIdArray <> nil);
    Assert(ActiveArray <> nil);
    LakeIdArray.Initialize;
    LakeComment := rsLakeComment;
    for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
    begin
      for RowIndex := 0 to ModflowGrid.RowCount - 1 do
      begin
        IsLake := False;
        for LayerIndex := ModflowGrid.LayerCount -1 downto 0 do
        begin
          if LakeIdArray.IntegerData[LayerIndex,RowIndex,ColIndex] <> 0 then
          begin
            IsLake := True;
          end;
          if IsLake then
          begin
            ActiveArray.BooleanData[LayerIndex,RowIndex,ColIndex] := False;
            ActiveArray.Annotation[LayerIndex,RowIndex,ColIndex] := LakeComment;
          end;
        end;
      end;
    end;
    FDataArrayManager.AddDataSetToCache(LakeIdArray);
  end;
  if (ModelSelection = msModflow2015)
    and ModflowPackages.LakMf6Package.IsSelected then
  begin
    LakeMf6Array := FDataArrayManager.GetDataSetByName(KMf6LakeConnectionTypes);
    ActiveArray := FDataArrayManager.GetDataSetByName(rsActive);
    Assert(LakeMf6Array <> nil);
    Assert(ActiveArray <> nil);
    LakeMf6Array.Initialize;

    // See TScreenObject.AssignMf6LakeDataSetValue.
    // It assigns values to LakeMf6Array (KMf6LakeConnectionTypes).
    LakeComment := StrAllLakeCellsAreI;
    if DisvUsed then
    begin
      for ColIndex := 0 to DisvGrid.ColumnCount - 1 do
      begin
        BottomLayer := -1;
        for LayerIndex := DisvGrid.LayerCount -1 downto 0 do
        begin
          ConnectionTypes := LakeMf6Array.IntegerData[LayerIndex,0,ColIndex];
          if BottomLayer > -1 then
          begin
            ActiveArray.BooleanData[LayerIndex,0,ColIndex] := False;
            ActiveArray.Annotation[LayerIndex,0,ColIndex] := LakeComment;
          end
          else
          begin
            if ConnectionTypes = 2 then
            begin
              BottomLayer := LayerIndex - 1;
            end
            else if ConnectionTypes in [1,3] then
            begin
              BottomLayer := LayerIndex;
              ActiveArray.BooleanData[LayerIndex,0,ColIndex] := False;
              ActiveArray.Annotation[LayerIndex,0,ColIndex] := LakeComment;
            end;
          end;
        end;
      end;
    end
    else
    begin
      for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
      begin
        for RowIndex := 0 to ModflowGrid.RowCount - 1 do
        begin
          BottomLayer := -1;
          for LayerIndex := ModflowGrid.LayerCount -1 downto 0 do
          begin
            ConnectionTypes := LakeMf6Array.IntegerData[LayerIndex,RowIndex,ColIndex];
            if BottomLayer > -1 then
            begin
              ActiveArray.BooleanData[LayerIndex,RowIndex,ColIndex] := False;
              ActiveArray.Annotation[LayerIndex,RowIndex,ColIndex] := LakeComment;
            end
            else
            begin
              if ConnectionTypes = 2 then
              begin
                BottomLayer := LayerIndex - 1;
              end
              else if ConnectionTypes in [1,3] then
              begin
                BottomLayer := LayerIndex;
                ActiveArray.BooleanData[LayerIndex,RowIndex,ColIndex] := False;
                ActiveArray.Annotation[LayerIndex,RowIndex,ColIndex] := LakeComment;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateChildGrids;
var
  ChildIndex: Integer;
  ScreenObjectIndex: Integer;
  ChildModel: TChildModel;
  ScreenObject: TScreenObject;
begin
  if ChildModels.Count > 0 then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObject := ScreenObjects[ScreenObjectIndex];
      ChildModel := ScreenObject.ChildModel as TChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.HorizontalPositionScreenObject := ScreenObject;
      end;
    end;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.UpdateGrid;
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateCombinedDisplayColumn;
var
  ModelIndex: Integer;
  ChildIndex: Integer;
  Index: Integer;
begin
  if LgrUsed then
  begin
    if SelectedModel = self then
    begin
      UpdateMapping;
      for Index := 0 to Length(FColumnMapping) - 1 do
      begin
        if FColumnMapping[Index].ParentPostion
          = SelectedColumn then
        begin
          CombinedDisplayColumn := Index;
          break;
        end;
      end;
    end
    else
    begin
      ModelIndex := -1;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        if ChildModels[ChildIndex].ChildModel <> nil then
        begin
          if ChildModels[ChildIndex].ChildModel = SelectedModel then
          begin
            ModelIndex := ChildIndex;
            break;
          end;
        end;
      end;
      Assert(ModelIndex >= 0);
      UpdateMapping;
      for Index := 0 to Length(FColumnMapping) - 1 do
      begin
        if FColumnMapping[Index].ChildPositions[ModelIndex]
          = SelectedModel.SelectedColumn then
        begin
          CombinedDisplayColumn := Index;
          break;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateCombinedDisplayLayer;
var
  ModelIndex: Integer;
  ChildIndex: Integer;
  Index: Integer;
begin
  if LgrUsed then
  begin
    if SelectedModel = self then
    begin
      UpdateMapping;
      for Index := 0 to Length(FLayerMapping) - 1 do
      begin
        if FLayerMapping[Index].ParentPostion
          = SelectedLayer then
        begin
          CombinedDisplayLayer := Index;
          break;
        end;
      end;
    end
    else
    begin
      ModelIndex := -1;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        if ChildModels[ChildIndex].ChildModel <> nil then
        begin
          if ChildModels[ChildIndex].ChildModel = SelectedModel then
          begin
            ModelIndex := ChildIndex;
            break;
          end;
        end;
      end;
      Assert(ModelIndex >= 0);
      UpdateMapping;
      for Index := 0 to Length(FLayerMapping) - 1 do
      begin
        if FLayerMapping[Index].ChildPositions[ModelIndex]
          = SelectedModel.SelectedLayer then
        begin
          CombinedDisplayLayer := Index;
          break;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateCombinedDisplayRow;
var
  ModelIndex: Integer;
  ChildIndex: Integer;
  Index: Integer;
begin
  if LgrUsed then
  begin
    if SelectedModel = self then
    begin
      UpdateMapping;
      for Index := 0 to Length(FRowMapping) - 1 do
      begin
        if FRowMapping[Index].ParentPostion
          = SelectedRow then
        begin
          CombinedDisplayRow := Index;
          break;
        end;
      end;
    end
    else
    begin
      ModelIndex := -1;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        if ChildModels[ChildIndex].ChildModel <> nil then
        begin
          if ChildModels[ChildIndex].ChildModel = SelectedModel then
          begin
            ModelIndex := ChildIndex;
            break;
          end;
        end;
      end;
      Assert(ModelIndex >= 0);
      UpdateMapping;
      for Index := 0 to Length(FRowMapping) - 1 do
      begin
        if FRowMapping[Index].ChildPositions[ModelIndex]
          = SelectedModel.SelectedRow then
        begin
          CombinedDisplayRow := Index;
          break;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateDataArrayParameterUsed;
begin
  if not (csLoading in ComponentState) and not FClearing then
  begin
    UpdateLpfDataArrayParameterUsed(rsKx, ptLPF_HK);
    UpdateLpfDataArrayParameterUsed(rsHorizontalAnisotropy, ptLPF_HANI);
    UpdateLpfDataArrayParameterUsed(rsSpecific_Storage, ptLPF_SS);
    UpdateLpfDataArrayParameterUsed(rsSpecificYield, ptLPF_SY);
    // ideally, the ParameterFormula for the Kz data set should
    // incorporate the vertical anisotropy and the confining bed formulas
    // However, doing so is difficult and has not been done.
    //
    // The user may not have defined any ptLPF_VK parameters but
    // may have defined some ptLPF_VKCB or ptLPF_VANI parameters.
    // In such cases, the user should be able to set Kz using objects
    // for some layers but not others. TDataArray.Initialize
    // won't allow that.
    UpdateLpfDataArrayParameterUsed(rsKz, ptLPF_VK);
    UpdateLpfDataArrayParameterUsed(rsModflow_CBKz, ptLPF_VKCB);
    UpdateLpfDataArrayParameterUsed(rsVerticalAnisotropy, ptLPF_VANI);
  end;
end;

procedure TPhastModel.UpdateDataSets;
var
  Index: integer;
  ADataSet: TDataArray;
  Item: TDataSetItem;
  DataArray: TDataArray;
  ExistingDataSet: TDataArray;
  TempCompiler: TRbwParser;
  ParamItem: TModflowSteadyParameter;
  SearchName: string;
  Compiler: TRbwParser;
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildDataArray: TDataArray;
begin

  FDataArrayManager.DataSetsCapacity := FDataSetCollection.Count
    + FDataArrayManager.DataSetCount;
  for Index := 0 to FDataSetCollection.Count - 1 do
  begin
    Item := FDataSetCollection.Items[Index] as TDataSetItem;
    ADataSet := Item.FDataSet;
    Item.UpdateDataSet;

    SearchName := ADataSet.Name;
    if SearchName = OldLongDispersivityName then
    begin
      SearchName := rsLong_Dispersivity;
    end
    else if SearchName = OldHorizontal_Transv_Dispersivity then
    begin
      SearchName := rsHorizontal_Transv_Dispersivity;
    end
    else if SearchName = OldVertical_Transv_Dispersivity then
    begin
      SearchName := rsVertical_Transv_Dispersivity;
    end;

    ExistingDataSet := FDataArrayManager.GetDataSetByName(SearchName);

    if ExistingDataSet = nil then
    begin
      if ADataSet.Name <> SearchName then
      begin
        ADataSet.Name := SearchName;
        ADataSet.DisplayName := SearchName;
      end;
      AddDataSet(ADataSet);
      CreateVariables(ADataSet);
      UpdateDataArrayDimensions(ADataSet);
//      ADataSet.UpdateDimensions(Grid.LayerCount, Grid.RowCount,
//        Grid.ColumnCount);
    end
    else
    begin
      UpdateDataArrayDimensions(ExistingDataSet);
//      ExistingDataSet.UpdateDimensions(Grid.LayerCount, Grid.RowCount,
//        Grid.ColumnCount);

      if ExistingDataSet.Classification = StrLayerDefinition then
      begin
        ExistingDataSet.OnDataSetUsed := ModelLayerDataArrayUsed;
      end
      else if ExistingDataSet.Classification = StrHUF then
      begin
        ExistingDataSet.OnDataSetUsed := HufDataArrayUsed;
      end;


      TempCompiler := GetCompiler(ExistingDataSet.Orientation,
        ExistingDataSet.EvaluatedAt);
      if TempCompiler.IndexOfVariable(ExistingDataSet.Name) < 0 then
      begin
        CreateVariables(ExistingDataSet);
      end;
    end;
  end;
  // The formulas can not be specified until all the data sets have
  // been updated.
  for Index := 0 to FDataSetCollection.Count - 1 do
  begin
    Item := FDataSetCollection.Items[Index] as TDataSetItem;
    ADataSet := Item.FDataSet;
    SearchName := ADataSet.Name;
    if SearchName = OldLongDispersivityName then
    begin
      SearchName := rsLong_Dispersivity;
    end
    else if SearchName = OldHorizontal_Transv_Dispersivity then
    begin
      SearchName := rsHorizontal_Transv_Dispersivity;
    end
    else if SearchName = OldVertical_Transv_Dispersivity then
    begin
      SearchName := rsVertical_Transv_Dispersivity;
    end;
    ExistingDataSet := FDataArrayManager.GetDataSetByName(SearchName);
    Assert(ExistingDataSet <> nil);
    ExistingDataSet.Assign(ADataSet);
    Compiler := GetCompiler(ExistingDataSet.Orientation,
      ExistingDataSet.EvaluatedAt);
    try
      Compiler.Compile(Item.FDataSetFormula);
    except on E: ERbwParserError do
      begin
//        frmFormulaErrors.DelayShowing := True;
        frmFormulaErrors.AddFormulaError('', ExistingDataSet.Name, Item.FDataSetFormula, E.Message);
        case ExistingDataSet.DataType of
          rdtDouble: Item.FDataSetFormula := '0.';
          rdtInteger: Item.FDataSetFormula := '0';
          rdtBoolean: Item.FDataSetFormula := 'False';
          rdtString: Item.FDataSetFormula := '""';
        end;
        Compiler.Compile(Item.FDataSetFormula);

      end;
    end;
    ExistingDataSet.Formula := Item.FDataSetFormula;
    if ExistingDataSet is TCustomPhastDataSet then
    begin
      TCustomPhastDataSet(ExistingDataSet).MixtureFormula := Item.FMixtureFormula;
    end;
    if ExistingDataSet.Classification = StrLayerDefinition then
    begin
      ExistingDataSet.OnDataSetUsed := ModelLayerDataArrayUsed;
    end
    else if ExistingDataSet.Classification = StrHUF then
    begin
      ExistingDataSet.OnDataSetUsed := HufDataArrayUsed;
    end;
    if (ADataSet.TwoDInterpolator <> nil)
      and (ExistingDataSet.TwoDInterpolator = nil) then
    begin
      ExistingDataSet.TwoDInterpolator := ADataSet.TwoDInterpolator;
    end;
  end;
  for Index := 0 to FDataSetCollection.Count - 1 do
  begin
    Item := FDataSetCollection.Items[Index] as TDataSetItem;
    ADataSet := Item.FDataSet;
    if not DataArrayManager.DataArrayHeld(ADataSet) then
    begin
      ADataSet.Free;
    end;
  end;

  FDataSetCollection.Clear;

  FDataArrayManager.CreateInitialDataSets;
  for Index := 0 to FDataArrayManager.DataSetCount - 1 do
  begin
    ADataSet := FDataArrayManager[Index];
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildDataArray := ChildModel.DataArrayManager.GetDataSetByName(ADataSet.Name);
        Assert(ChildDataArray <> nil);
        ChildDataArray.AssignProperties(ADataSet);
        ChildDataArray.Formula := ADataSet.Formula;
        ChildDataArray.Limits := ADataSet.Limits;
        ChildDataArray.ContourLimits := ADataSet.ContourLimits;
      end;
    end;
  end;

  for Index := 0 to ModflowSteadyParameters.Count - 1 do
  begin
    ParamItem := ModflowSteadyParameters.Items[Index];
    if ParamItem.UseMultiplier then
    begin
      DataArray := FDataArrayManager.GetDataSetByName(ParamItem.MultiplierName);
      if DataArray <> nil then
      begin
        DataArray.OnDataSetUsed := ParameterDataSetUsed;
      end;
    end;
    if ParamItem.UseZone then
    begin
      DataArray := FDataArrayManager.GetDataSetByName(ParamItem.ZoneName);
      if DataArray <> nil then
      begin
        DataArray.OnDataSetUsed := ParameterDataSetUsed;
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateDataArrayParameterUsed;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.UpdateDataArrayParameterUsed;
    end;
  end;
end;

procedure TPhastModel.UpdateDataSetConnections;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.UpdateDataSetConnections;
      TopGridObserver.TalksTo(ChildModel.TopGridObserver);
      ThreeDGridObserver.TalksTo(ChildModel.ThreeDGridObserver);
      HufKxNotifier.TalksTo(ChildModel.HufKxNotifier);
      HufKyNotifier.TalksTo(ChildModel.HufKyNotifier);
      HufKzNotifier.TalksTo(ChildModel.HufKzNotifier);
      HufSsNotifier.TalksTo(ChildModel.HufSsNotifier);
      HufSyNotifier.TalksTo(ChildModel.HufSyNotifier);
    end;
  end;
end;

procedure TPhastModel.UpdateDataSetDimensions;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  DataArrayManager.UpdateDataSetDimensions;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.DataArrayManager.UpdateDataSetDimensions;
    end;
  end;
end;

function TPhastModel.GetSaveBfhBoundaryConditions: boolean;
begin
  result := FSaveBfhBoundaryConditions
end;

function TPhastModel.GetScreenObjectByName(AName: string): TScreenObject;
var
  Index: Integer;
  ScreenObject: TScreenObject;
begin
  result := nil;
  if FSortedObjectList = nil then
  begin
    FSortedObjectList := TLookUpList.Create;
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObject := ScreenObjects[Index];
      if not ScreenObject.Deleted then
      begin
        FSortedObjectList.AddObject(ScreenObject.Name, ScreenObject)
      end;
    end;
    FSortedObjectList.CaseSensitive := False;
    FSortedObjectList.Sorted := True;
  end;
  if (FSortedObjectList.FLastIndex >= 0)
    and (FSortedObjectList.FLastIndex < FSortedObjectList.Count) then
  begin
    if AnsiCompareText(FSortedObjectList[FSortedObjectList.FLastIndex],
      AName) = 0 then
    begin
      result := FSortedObjectList.Objects[FSortedObjectList.FLastIndex] as TScreenObject;
      Exit;
    end;
  end;
  FSortedObjectList.FLastIndex := FSortedObjectList.IndexOf(AName);
  if FSortedObjectList.FLastIndex >= 0 then
  begin
    result := FSortedObjectList.Objects[FSortedObjectList.FLastIndex] as TScreenObject;
  end;
end;

function TPhastModel.GetScreenObjectCollection: TScreenObjectCollection;
var
  Index: integer;
  Item: TScreenObjectItem;
  AScreenObject: TScreenObject;
begin
  FScreenObjectCollection.Clear;

  for Index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[Index];
    if not AScreenObject.Deleted then
    begin
      Item := FScreenObjectCollection.Add as TScreenObjectItem;
      Item.SetScreenObject(AScreenObject);
    end;
  end;

  result := FScreenObjectCollection;
end;

procedure TPhastModel.SetFreeSurface(const Value: boolean);
begin
  if FFreeSurface <> Value then
  begin
    FFreeSurface := Value;
    DoInvalidate(self);
  end;
end;

procedure TPhastModel.SetParamGroups(const Value: TPestParamGroups);
begin
  FParamGroups.Assign(Value);
end;

procedure TPhastModel.SetPestProperties(const Value: TPestProperties);
begin
  FPestProperties.Assign(Value);
end;

procedure TPhastModel.SetPrintFrequency(const Value: TPrintFrequencyCollection);
begin
  FPrintFrequency.Assign(Value);
end;

procedure TPhastModel.SetProgramLocations(const Value: TProgramLocations);
begin
  FProgramLocations.Assign(Value);
end;

procedure TPhastModel.SetRipPlantGroups(const Value: TRipPlantGroups);
begin
  FRipPlantGroups.Assign(Value);
end;

procedure TPhastModel.SetTitle(const Value: TStrings);
begin
  FTitle.Assign(Value);
  DoInvalidate(self);
end;

procedure TCustomModel.SetThreeDContourDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        Grid.ThreeDContourDataSet := Value;
      end;
    msModflow2015:
      begin
        ModflowGrid.ThreeDContourDataSet := Value;
        DisvGrid.ThreeDContourDataSet := Value;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          SutraMesh.ThreeDContourDataSet := Value;
        end;
      end;
    else
       Assert(False);
  end;
  if Value <> nil then
  begin
    ContourLegend.ValueSource := Value;
  end;
end;

procedure TCustomModel.SetThreeDDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        Grid.ThreeDDataSet := Value;
      end;
    msModflow2015:
      begin
        ModflowGrid.ThreeDDataSet := Value;
        DisvGrid.ThreeDDataSet := Value;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          SutraMesh.ThreeDDataSet := Value;
        end;
      end;
    else
       Assert(False);
  end;
end;

procedure TPhastModel.SetThreeDDataSet(const Value: TDataArray);
begin
  inherited;
  if Value <> nil then
  begin
    ColorLegend.ValueSource := Value;
  end;
end;

procedure TPhastModel.SetTimes(const Value: TTimeCollection);
begin
  FTimes.Assign(Value);
  DoInvalidate(self);
end;

procedure TPhastModel.SetMf6TimesSeries(const Value: TTimesSeriesCollections);
begin
  FTimesSeries.Assign(Value);
end;

procedure TPhastModel.SaveArchiveList(FileName: string);
type
  TAttribType = (atAncillary, atBinary, atModelInput, atModelOutput,
    atZonebugetInput, atZonebugetOutput, atModpathInput, atModpathOutput,
    atSwiObsExtInput, atSwiObsExtOutput,
    atMt3dInput, atMt3dOutput, atGeoRef, atExternal);
var
  ArchiveFiles: TXmlVerySimple;
  ANode: TXmlNode;
  FileNames: TStringList;
  ModelIndex: integer;
  ChildIndex: Integer;
  AChildModel: TChildModel;
  SLList: TList<TStrings>;
  SLIndex: Integer;
  AList: TStrings;
  DocNode: TXmlNode;
  BinaryFiles: TStringList;
  ModelDirectory: string;
  FileToSaveName: string;
  FileIndex: Integer;
  procedure SetAttributeType(ANode: TXmlNode; AttType: TAttribType;
    ModelName: string);
  begin
    if AttType = atExternal then
    begin
      ANode.SetAttribute('Model_Name', 'externalfiles');
    end
    else
    begin
      ANode.SetAttribute('Model_Name', ModelName);
    end;
    case AttType of
      atAncillary:
        begin
          ANode.SetAttribute('FileType', StrAncillary)
        end;
      atBinary:
        begin
          ANode.SetAttribute('FileType', StrBinary)
        end;
      atModelInput, atExternal:
        begin
          ANode.SetAttribute('FileType', 'Model Input')
        end;
      atModelOutput:
        begin
          ANode.SetAttribute('FileType', 'Model Output')
        end;
      atZonebugetInput:
        begin
          ANode.SetAttribute('FileType', 'Zonebudget Input')
        end;
      atZonebugetOutput:
        begin
          ANode.SetAttribute('FileType', 'Zonebudget Output')
        end;
      atSwiObsExtInput:
        begin
          ANode.SetAttribute('FileType', 'SWI_Observation_Extractor Input')
        end;
      atSwiObsExtOutput:
        begin
          ANode.SetAttribute('FileType', 'SWI_Observation_Extractor Output')
        end;
      atModpathInput:
        begin
          ANode.SetAttribute('FileType', 'Modpath Input')
        end;
      atModpathOutput:
        begin
          ANode.SetAttribute('FileType', 'Modpath Output')
        end;
      atMt3dInput:
        begin
          if ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
          begin
            ANode.SetAttribute('FileType', 'Mt3d-USGS Input')
          end
          else
          begin
            ANode.SetAttribute('FileType', 'Mt3dms Input')
          end;
        end;
      atMt3dOutput:
        begin
          if ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
          begin
            ANode.SetAttribute('FileType', 'Mt3d-USGS Output')
          end
          else
          begin
            ANode.SetAttribute('FileType', 'Mt3dms Output')

          end;
        end;
      atGeoRef:
        begin
          ANode.SetAttribute('FileType', 'Geo Ref')
        end;
      else
        Assert(False);
    end;
  end;
  procedure AddFileNames(ParentNode: TXmlNode;
    FileNames: TStrings; AttType: TAttribType; ModelName: string);
  var
    FileIndex: Integer;
    AName: string;
    ANode: TXmlNode;
    AFileName: string;
  begin
    for FileIndex := 0 to FileNames.Count - 1 do
    begin
      AName := 'FileName';
      ANode := ParentNode.AddChild(AName);
      AFileName := FileNames[FileIndex];
      AFileName := ExtractRelativePath(FileName,AFileName);
//      if (Pos(ModelDirectory, AFileName) = 1) then
//      begin
//        Assert(Length(ModelDirectory) < Length(AFileName));
//        AFileName := Copy(AFileName, Length(ModelDirectory)+1, MAXINT);
//      end;
      ANode.Text := AFileName;
      SetAttributeType(ANode, AttType, ModelName);
    end;
  end;
  procedure TestArchiveFiles(const GroupName: string; FileNames: TStrings;
    AttType: TAttribType; ModelName: string = '');
  var
    FileIndex: Integer;
    PosIndex: Integer;
//    ModelName: string;
  begin
    if FileNames.Count > 0 then
    begin
      if FileNames is TStringList then
      begin
        TStringList(FileNames).Sort;
      end;
      for FileIndex := FileNames.Count - 1 downto 1 do
      begin
        PosIndex := FileNames.IndexOf(FileNames[FileIndex]);
        if PosIndex <> FileIndex then
        begin
          FileNames.Delete(FileIndex);
        end;
      end;
      ANode := DocNode.AddChild(GroupName);
      if ModelName = '' then
      begin
        ModelName := ChangeFileExt(ExtractFileName(ModelFileName), '');
        // PHAST files have two extensions.
        ModelName := ChangeFileExt(ModelName, '');
      end
      else
      begin
        // child models.
        ModelName := ChangeFileExt(ExtractFileName(ModelFileName), '') + '_' + FixFileName(ModelName);
      end;
      SetAttributeType(ANode, AttType, ModelName);
      AddFileNames(ANode, FileNames, AttType, ModelName);
    end;
  end;
  procedure RemoveBinaryFiles(ArchiveFiles: TStrings);
  var
    Index: Integer;
    BinIndex: Integer;
  begin
    for Index := 0 to BinaryFiles.Count - 1 do
    begin
      BinIndex := ArchiveFiles.IndexOf(BinaryFiles[Index]);
      if BinIndex >= 0 then
      begin
        ArchiveFiles.Delete(BinIndex);
      end;
    end;
  end;
  procedure RemoveNonAncillaryFiles(OtherFiles: TStrings);
  var
    index: Integer;
    OtherIndex: Integer;
    ChildIndex: integer;
    AChildModel: TChildModel;
  begin
    for index := 0 to OtherFiles.Count - 1 do
    begin
      OtherIndex := FFilesToArchive.IndexOf(OtherFiles[index]);
      if OtherIndex >= 0 then
      begin
        FFilesToArchive.Delete(OtherIndex);
      end;
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            OtherIndex := AChildModel.FFilesToArchive.IndexOf(OtherFiles[index]);
            if OtherIndex >= 0 then
            begin
              AChildModel.FFilesToArchive.Delete(OtherIndex);
            end;
          end;
        end;
      end;
    end;
  end;
begin
  SLList := TList<TStrings>.Create;
  try
    SLList.Add(ModelInputFiles);
    SLList.Add(ExternalFiles);
    SLList.Add(ModelOutputFiles);
    SLList.Add(ModpathInputFiles);
    SLList.Add(ModpathInputFiles);
    SLList.Add(ZonebudgetInputFiles);
    SLList.Add(ZonebudgetInputFiles);

    SLList.Add(SwiObsExtractorInputFiles);
    SLList.Add(SwiObsExtractorOutputFiles);

    SLList.Add(Mt3dmsInputFiles);
    SLList.Add(Mt3dmsInputFiles);
    if LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        AChildModel := ChildModels[ChildIndex].ChildModel;
        if AChildModel <> nil then
        begin
          SLList.Add(AChildModel.ModelInputFiles);
          SLList.Add(AChildModel.ExternalFiles);
          SLList.Add(AChildModel.ModelOutputFiles);
          SLList.Add(AChildModel.ModpathInputFiles);
          SLList.Add(AChildModel.ModpathInputFiles);
          SLList.Add(AChildModel.ZonebudgetInputFiles);
          SLList.Add(AChildModel.ZonebudgetInputFiles);
          SLList.Add(AChildModel.SwiObsExtractorInputFiles);
          SLList.Add(AChildModel.SwiObsExtractorOutputFiles);
          SLList.Add(AChildModel.Mt3dmsInputFiles);
          SLList.Add(AChildModel.Mt3dmsInputFiles);
        end;
      end;
    end;
    for SLIndex := 0 to SLList.Count - 1 do
    begin
      AList := SLList[SLIndex];
      RemoveNonAncillaryFiles(AList);
    end;
  finally
    SLList.Free;
  end;

  ModelIndex := FFilesToArchive.IndexOf(ModelFileName);
  if ModelIndex < 0 then
  begin
    FFilesToArchive.Add(ModelFileName);
  end;

  ModelDirectory := ExtractFileDir(FileName);
  ModelDirectory := IncludeTrailingPathDelimiter(ModelDirectory);
  FileToSaveName := ExtractFileName(FileName);
  FileToSaveName := StringReplace(FileToSaveName, ' ', '_',
    [rfReplaceAll, rfIgnoreCase]);
  FileToSaveName := ModelDirectory + FileToSaveName;
//  FileToSaveName := ChangeFileExt(FileToSaveName, '.axml');

  ArchiveFiles := TXmlVerySimple.Create;
  try
    DocNode := ArchiveFiles.AddChild('Model_Archive_List');
    FileNames := TStringList.Create;
    BinaryFiles := TStringList.Create;
    try
      BinaryFiles.AddStrings(FBinaryFiles);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            BinaryFiles.AddStrings(AChildModel.FBinaryFiles);
          end;
        end;
      end;
      AddModelProgramsToList(BinaryFiles);
      TestArchiveFiles(StrBinary, BinaryFiles, atBinary);

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(FilesToArchive);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles(StrAncillary, FileNames, atAncillary);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.FilesToArchive);
            RemoveBinaryFiles(FileNames);

            FileIndex := FileNames.IndexOf(ModelFileName);
            if FileIndex >= 0 then
            begin
              FileNames.Delete(FileIndex);
            end;
            TestArchiveFiles(StrAncillary, FileNames, atAncillary, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ModelInputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles(StrModelInputFiles, FileNames, atModelInput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ModelInputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(StrModelInputFiles, FileNames, atModelInput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ExternalFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles(StrModelInputFiles, FileNames, atExternal);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ExternalFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(StrModelInputFiles, FileNames, atExternal, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ModelOutputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles(StrModelOutputFiles, FileNames, atModelOutput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ModelOutputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(StrModelOutputFiles, FileNames, atModelOutput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ModpathInputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles('Modpath_Input_Files', FileNames, atModpathInput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ModpathInputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Modpath_Input_Files', FileNames, atModpathInput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ModpathOutputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles('Modpath_Output_Files', FileNames, atModpathOutput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ModpathOutputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Modpath_Output_Files', FileNames, atModpathOutput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ZonebudgetInputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles('Zonebudget_Input_Files', FileNames, atZonebugetInput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ZonebudgetInputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Zonebudget_Input_Files', FileNames, atZonebugetInput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(ZonebudgetOutputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles('Zonebudget_Output_Files', FileNames, atZonebugetOutput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.ZonebudgetOutputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Zonebudget_Output_Files', FileNames, atZonebugetOutput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(SwiObsExtractorInputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles('SWI_Observation_Extractor_Input_Files', FileNames, atSwiObsExtInput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.SwiObsExtractorInputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'SWI_Observation_Extractor_Input_Files', FileNames, atSwiObsExtInput, AChildModel.ModelName);
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(SwiObsExtractorOutputFiles);
      RemoveBinaryFiles(FileNames);
      TestArchiveFiles('SWI_Observation_Extractor_Output_Files', FileNames, atSwiObsExtOutput);
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.SwiObsExtractorOutputFiles);
            RemoveBinaryFiles(FileNames);
            TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'SWI_Observation_Extractor_Output_Files', FileNames, atSwiObsExtOutput, AChildModel.ModelName);
          end;
        end;
      end;



      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(Mt3dmsInputFiles);
      RemoveBinaryFiles(FileNames);
      if ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
      begin
        TestArchiveFiles('Mt3d-USGS_Input_Files', FileNames, atMt3dInput);
      end
      else
      begin
        TestArchiveFiles('Mt3dms_Input_Files', FileNames, atMt3dInput);
      end;
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.Mt3dmsInputFiles);
            RemoveBinaryFiles(FileNames);
            if AChildModel.ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
            begin
              TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Mt3d-USGS_Input_Files',
                FileNames, atMt3dInput, AChildModel.ModelName);
            end
            else
            begin
              TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Mt3dms_Input_Files',
                FileNames, atMt3dInput, AChildModel.ModelName);
            end;
          end;
        end;
      end;

      FileNames.Clear;
      FileNames.Duplicates := dupIgnore;
      FileNames.AddStrings(Mt3dmsOutputFiles);
      RemoveBinaryFiles(FileNames);
      if ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
      begin
        TestArchiveFiles('Mt3d-USGS_Output_Files', FileNames, atMt3dOutput);
      end
      else
      begin
        TestArchiveFiles('Mt3dms_Output_Files', FileNames, atMt3dOutput);
      end;
      if LgrUsed then
      begin
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          AChildModel := ChildModels[ChildIndex].ChildModel;
          if AChildModel <> nil then
          begin
            FileNames.Clear;
            FileNames.AddStrings(AChildModel.Mt3dmsOutputFiles);
            RemoveBinaryFiles(FileNames);
            if AChildModel.ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
            begin
              TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Mt3d-USGS_Output_Files',
                FileNames, atMt3dOutput, AChildModel.ModelName);
            end
            else
            begin
              TestArchiveFiles(AChildModel.ModelNameForDos + '_' + 'Mt3dms_Output_Files',
                FileNames, atMt3dOutput, AChildModel.ModelName);
            end;
          end;
        end;
      end;

//      if GeoRefFileName <> '' then
//      begin
//        FileNames.Clear;
//        FileNames.Add(GeoRefFileName);
//        TestArchiveFiles('Geo_Ref', FileNames, atGeoRef);
//      end;


    finally
      FileNames.Free;
      BinaryFiles.Free;
    end;

    try
      ArchiveFiles.SaveToFile(FileToSaveName);
    except on E: EFCreateError do
      begin
        Beep;
        MessageDlg(Format(StrThereWasAnErrorS, [E.message]), mtError, [mbOK], 0);
      end;
    end;
  finally
    ArchiveFiles.Free;
  end;
end;

procedure TPhastModel.ClearModpathFiles;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  FModpathInputFiles.Clear;
  FModpathOutputFiles.Clear;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.FModpathInputFiles.Clear;
        ChildModel.FModpathOutputFiles.Clear;
      end;
    end;
  end;
end;

procedure TPhastModel.ClearZonebudgetFiles;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  FZonebudgetInputFiles.Clear;
  FZonebudgetOutputFiles.Clear;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.FZonebudgetInputFiles.Clear;
        ChildModel.FZonebudgetOutputFiles.Clear;
      end;
    end;
  end;
end;

procedure TPhastModel.AddModelProgramsToList(FileNames: TStringList);
var
  ModelFile: string;
  procedure GetOldFileVersion;
  var
    Index: Integer;
  begin
    for Index := FModelInputFiles.Count - 1 downto 0 do
    begin
      if ExtractFileName(FModelInputFiles[Index]) = ExtractFileName(ModelFile) then
      begin
        ModelFile := FModelInputFiles[Index];
      end;
    end;
  end;

begin
  case ModelSelection of
    msUndefined:
      Exit;
    msPhast:
      ModelFile := ProgramLocations.PhastLocation;
    msModflow:
      ModelFile := ProgramLocations.ModflowLocation;
    msModflowLGR:
      ModelFile := ProgramLocations.ModflowLgrLocation;
    msModflowLGR2:
      ModelFile := ProgramLocations.ModflowLgr2Location;
    msModflowNWT:
      ModelFile := ProgramLocations.ModflowNwtLocation;
    msModflowFmp:
      ModelFile := ProgramLocations.ModflowOwhmLocation;
    msModflowCfp:
      ModelFile := ProgramLocations.ModflowCfpLocation;
    msSutra22:
      ModelFile := ProgramLocations.Sutra22Location;
    msSutra30:
      ModelFile := ProgramLocations.Sutra30Location;
    msSutra40:
      ModelFile := ProgramLocations.Sutra40Location;
    msFootPrint:
      ModelFile := ProgramLocations.FootprintLocation;
    msModflow2015:
      ModelFile := ProgramLocations.Modflow6Location;
    msModflowOwhm2:
      ModelFile := ProgramLocations.ModflowOwhmV2Location;
  else
    Assert(False);
  end;

  GetOldFileVersion;

  FileNames.Add(ModelFile);

  if ModelSelection in ModflowSelection then
  begin
    if Modpath5IsSelected then
    begin
      ModelFile := ProgramLocations.ModPathLocation;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
    if Modpath6IsSelected then
    begin
      ModelFile := ProgramLocations.ModPathLocationVersion6;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
    if Modpath7IsSelected then
    begin
      ModelFile := ProgramLocations.ModPathLocationVersion7;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
    if ModflowPackages.Mt3dBasic.IsSelected and (ModflowPackages.Mt3dBasic.Mt3dVersion = mvMs) then
    begin
      ModelFile := ProgramLocations.Mt3dmsLocation;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
    if ModflowPackages.Mt3dBasic.IsSelected and (ModflowPackages.Mt3dBasic.Mt3dVersion = mvUsgs) then
    begin
      ModelFile := ProgramLocations.Mt3dUsgsLocation;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
    if DoZoneBudgetSelected(nil) then
    begin
      if ModelSelection = msModflow2015 then
      begin
        ModelFile := ProgramLocations.ZoneBudgetLocationMf6;
      end
      else
      begin
        ModelFile := ProgramLocations.ZoneBudgetLocation;
      end;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
  end;
  if ModelSelection in SutraSelection then
  begin
    if SutraMesh.Mesh2D.MeshGenControls.MeshGenerationMethod = mgmGmsh then
    begin
      ModelFile := ProgramLocations.GmshLocation;
      GetOldFileVersion;
      FileNames.Add(ModelFile);
    end;
  end;
end;

procedure TPhastModel.ClearMt3dmsFiles;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  FMt3dmsInputFiles.Clear;
  FMt3dmsOutputFiles.Clear;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.FMt3dmsInputFiles.Clear;
        ChildModel.FMt3dmsOutputFiles.Clear;
      end;
    end;
  end;
end;

procedure TPhastModel.ClearBinaryFiles;
var
  ChildIndex: Integer;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    if ChildModels[ChildIndex].ChildModel <> nil then
    begin
      ChildModels[ChildIndex].ChildModel.ClearBinaryFiles;
    end;
  end;
end;

procedure TPhastModel.GetLayerDataArrays(DataSetList: TDataArrayList);
var
  SutraLayer: TSutraLayerGroup;
  LayerIndex: Integer;
  ALayer: TLayerGroup;
  DataArray: TDataArray;
begin
  if ModelSelection in ModflowSelection then
  begin
    for LayerIndex := 0 to LayerStructure.Count - 1 do
    begin
      ALayer := LayerStructure[LayerIndex];
      DataArray := DataArrayManager.GetDataSetByName(ALayer.DataArrayName);
      Assert(DataArray <> nil);
      DataSetList.Add(DataArray);
    end;
  end
  else if ModelSelection in SutraSelection then
  begin
    for LayerIndex := 0 to SutraLayerStructure.Count - 1 do
    begin
      SutraLayer := SutraLayerStructure[LayerIndex];
      DataArray := DataArrayManager.GetDataSetByName(SutraLayer.DataArrayName);
      if (DataArray <> nil) then
      begin
        DataSetList.Add(DataArray);
      end;
    end;
  end;
end;

procedure TPhastModel.ClearModelFiles;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  FModelInputFiles.Clear;
  FModelOutputFiles.Clear;
  FExternalFiles.Clear;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.FModelInputFiles.Clear;
        ChildModel.FModelOutputFiles.Clear;
      end;
    end;
  end;
  ClearModpathFiles;
  ClearZonebudgetFiles;
  ClearMt3dmsFiles;
  ClearBinaryFiles;
  ClearSwiObsFiles;
end;

function TPhastModel.ScreenObjectClass: TScreenObjectClass;
begin
  result := TScreenObject;
end;

procedure TPhastModel.ScreenObjectsChanged(Sender: TObject);
begin
  if (csDestroying in ComponentState) or Clearing then Exit;
  if FScreenObjectUpdateCount > 0 then Exit;

  if Assigned(OnScreenObjectsChanged) then
  begin
    OnScreenObjectsChanged(Sender);
  end;
end;

procedure TPhastModel.RefreshScreenObjects(Sender: TObject);
begin
  if Assigned(OnRefreshScreenObjects) then
  begin
    OnRefreshScreenObjects(Sender);
  end;
end;

procedure TPhastModel.RegisterGlobalVariables(Parser: TRbwParser; IgnoreDuplicates: Boolean = False);
var
  Variable: IGlobalVariable;
  VariableIndex: Integer;
  VarClassification: string;
begin
  for VariableIndex := 0 to GlobalVariablesI.Count - 1 do
  begin
    Variable := GlobalVariablesI[VariableIndex];
    if IgnoreDuplicates and (Parser.IndexOfVariable(Variable.Name) >= 0) then
    begin
      Continue;
    end;
    if GetPestParameterByName(Variable.Name) = nil then
    begin
      VarClassification := StrGlobalVariables
    end
    else
    begin
      VarClassification := StrPestParamaeters;
    end;
    case Variable.Format of
      rdtDouble:
        begin
          Parser.CreateVariable(Variable.Name, VarClassification, Variable.RealValue, Variable.Name);
        end;
      rdtInteger:
        begin
          Parser.CreateVariable(Variable.Name, VarClassification, Variable.IntegerValue, Variable.Name);
        end;
      rdtBoolean:
        begin
          Parser.CreateVariable(Variable.Name, VarClassification, Variable.BooleanValue, Variable.Name);
        end;
      rdtString:
        begin
          Parser.CreateVariable(Variable.Name, VarClassification, Variable.StringValue, Variable.Name);
        end;
    else
      Assert(False);
    end;
  end;
end;

procedure TPhastModel.ScreenObjectSelected;
begin
  Inc(FSelectedScreenObjectCount);
  if Assigned(OnScreenObjectSelected) then
  begin
    OnScreenObjectSelected(self);
  end;
end;

procedure TPhastModel.ScreenObjectUnSelected;
begin
  Dec(FSelectedScreenObjectCount);
  if Assigned(OnScreenObjectUnSelected) then
  begin
    OnScreenObjectUnSelected(self);
  end;
end;

procedure TPhastModel.SetSideDataSet(const Value: TDataArray);
begin
  inherited;
  if Value <> nil then
  begin
    ColorLegend.ValueSource := Value;
  end;
end;

procedure TPhastModel.SetSideTimeList(const Value: TCustomTimeList);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildTimeList: TCustomTimeList;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      if Value = nil then
      begin
        ChildTimeList := nil;
      end
      else
      begin
        ChildTimeList := ChildModel.GetTimeListByName(Value.Name)
      end;
      ChildModel.SideTimeList := ChildTimeList;
    end;
  end;
end;

procedure TPhastModel.SetSideWidth(const Value: integer);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.SideWidth := Value
  end;
end;

function TPhastModel.DoGasPhaseUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
begin
  result := inherited DoGasPhaseUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      if ChildModels[ChildIndex].ChildModel <> nil then
      begin
        result := result or
          ChildModels[ChildIndex].ChildModel.DoGasPhaseUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.GbobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.GbobPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.GbobPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.GenerateFishNetMesh(var ErrorMessage: string);
var
  QuadTree: TRbwQuadTree;
  FishNetNode: TFishnetMeshNode;
  FishNetNodeIndex: Integer;
  XMin: Double;
  YMin: Double;
  ElementIndex: Integer;
  FishNetElement: TFishnetMeshElement;
  Node1: TFishnetMeshNode;
  Node2: TFishnetMeshNode;
  Node3: TFishnetMeshNode;
  Node4: TFishnetMeshNode;
  ElementOrientation: Integer;
  TempNode: TFishnetMeshNode;
  OuterCount: Integer;
  InnerCount: Integer;
  Distance1: TFloat;
  Distance2: TFloat;
  StartPoint: TPoint2D;
  EndPoint: TPoint2D;
  InnerIndex: Integer;
  FirstFound: Boolean;
  XMax: Double;
  YMax: Double;
  OuterIndex: Integer;
  Distance3: TFloat;
  NewPoint: TPoint2D;
  NewNode: TSutraNode2D;
  LocalEpsilonX: double;
  LocalEpsilonY: Extended;
  NodeArray: array of array of TSutraNode2D;
  ElementArray: array  of array of TSutraElement2D;
  NewElement: TSutraElement2D;
  NodeNumberItem: TSutraNodeNumber2D_Item;
  NodeCount: Integer;
  FishnetElementCount: Integer;
  NodeList: TSutraNode2D_List;
  index: integer;
  ElementCount: Integer;
  ElementList: TSutraElement2D_List;
  F1: TRealArray;
  F2: TRealArray;
begin
  if (FishnetMeshGenerator.Elements.Count = 0)
    or (FishnetMeshGenerator.Nodes.Count = 0) then
  begin
    ErrorMessage := StrYouNeedToDrawQua;
    Exit;
  end;

  FirstFound := False;
  XMin := 0;
  XMax := 0;
  YMin := 0;
  YMax := 0;
  for FishNetNodeIndex := 0 to FishnetMeshGenerator.Nodes.Count - 1 do
  begin
    FishNetNode := FishnetMeshGenerator.Nodes[FishNetNodeIndex];
    if FishNetNode.Elements.Count > 0 then
    begin
      if not FirstFound then
      begin
        XMin := FishNetNode.X;
        XMax := XMin;
        YMin := FishNetNode.Y;
        YMax := YMin;
        FirstFound := True;
      end
      else
      begin
        if XMin > FishNetNode.X then
        begin
          XMin := FishNetNode.X;
        end
        else if XMax < FishNetNode.X then
        begin
          XMax := FishNetNode.X
        end;

        if YMin > FishNetNode.Y then
        begin
          YMin := FishNetNode.Y;
        end
        else if YMax < FishNetNode.Y then
        begin
          YMax := FishNetNode.Y
        end;
      end;
    end;
  end;
  if not FirstFound then
  begin
    ErrorMessage := StrYouNeedToDrawQua;
    Exit;
  end;

  QuadTree := TRbwQuadTree.Create(nil);
  try
    QuadTree.XMax := XMax;
    QuadTree.XMin := XMin;
    QuadTree.YMax := YMax;
    QuadTree.YMin := YMin;
    LocalEpsilonX := (XMax-XMin)/1e7;
    LocalEpsilonY := (YMax-YMin)/1e7;

    NodeCount := 0;
    FishnetElementCount := 0;
    ElementCount := 0;
    FSutraMesh.BeginUpdate;
    FSutraMesh.Mesh2D.BeginUpdate;
    try
      FSutraMesh.Mesh2D.Nodes.Clear;
      FSutraMesh.Mesh2D.Elements.Clear;
      for ElementIndex := 0 to FishnetMeshGenerator.Elements.Count - 1 do
      begin
        FishNetElement := FishnetMeshGenerator.Elements[ElementIndex];
        if FishNetElement.ValidElement then
        begin
          Inc(FishnetElementCount);
          Node1 := FishNetElement.Nodes[0];
          Node2 := FishNetElement.Nodes[1];
          Node3 := FishNetElement.Nodes[2];
          Node4 := FishNetElement.Nodes[3];
          if Node1.SameLocation(Node2) or  Node1.SameLocation(Node3) or
             Node1.SameLocation(Node4) or  Node2.SameLocation(Node3) or
             Node2.SameLocation(Node4) or  Node3.SameLocation(Node4) then
          begin
            Continue;
          end;
          ElementOrientation :=
            Orientation(Node1.Location, Node2.Location, Node3.Location);
          if (ElementOrientation <> Clockwise)
            and  (ElementOrientation <> CounterClockwise) then
          begin
            ElementOrientation :=
              Orientation(Node2.Location, Node3.Location, Node4.Location);
          end;
          Assert((ElementOrientation = Clockwise)
            or  (ElementOrientation = CounterClockwise));
          if ElementOrientation = Clockwise then
          begin
            TempNode := Node2;
            Node2 := Node4;
            Node4 := TempNode;
            OuterCount := FishNetElement.SecondControl.Count;
            InnerCount := FishNetElement.FirstControl.Count;
            F1 := FishNetElement.Fractions2;
            F2 := FishNetElement.Fractions1;
          end
          else
          begin
            OuterCount := FishNetElement.FirstControl.Count;
            InnerCount := FishNetElement.SecondControl.Count;
            F1 := FishNetElement.Fractions1;
            F2 := FishNetElement.Fractions2;
          end;

          SetLength(NodeArray, OuterCount+1, InnerCount+1);
          SetLength(ElementArray, OuterCount, InnerCount);

          Distance1 := Distance(Node1.Location, Node2.Location);
          Distance2 := Distance(Node4.Location, Node3.Location);
          for OuterIndex := 0 to OuterCount do
          begin
            if OuterIndex = 0 then
            begin
              StartPoint := Node1.Location;
              EndPoint := Node4.Location;
            end
            else if OuterIndex = OuterCount then
            begin
              StartPoint := Node2.Location;
              EndPoint := Node3.Location;
            end
            else
            begin
              StartPoint := ProjectPoint(Node1.Location,Node2.Location,
                Distance1 * F1[OuterIndex]);
              EndPoint := ProjectPoint(Node4.Location,Node3.Location,
                Distance2 * F1[OuterIndex]);
            end;
            Distance3 := Distance(StartPoint, EndPoint);
            for InnerIndex := 0 to InnerCount do
            begin
              if InnerIndex = 0 then
              begin
                NewPoint := StartPoint;
              end
              else if InnerIndex = InnerCount then
              begin
                NewPoint := EndPoint;
              end
              else
              begin
                NewPoint := ProjectPoint(StartPoint,EndPoint,
                  Distance3 * F2[InnerIndex]);
              end;
              NewNode := nil;
              if (OuterIndex = 0) or (OuterIndex = OuterCount)
                or (InnerIndex = 0) or (InnerIndex = InnerCount) then
              begin
                if QuadTree.Count > 0 then
                begin
                  NewNode := QuadTree.NearestPointsFirstData
                    (NewPoint.x, NewPoint.y);
                  if (Abs(NewNode.X - NewPoint.x) > LocalEpsilonX)
                    or (Abs(NewNode.Y - NewPoint.y) > LocalEpsilonY) then
                  begin
                    NewNode := nil;
                  end;
                  if NewNode <> nil then
                  begin
                    if not (((OuterIndex = 0) or (OuterIndex = OuterCount))
                      and ((InnerIndex = 0) or (InnerIndex = InnerCount))) then
                    begin
                      NewNode.NodeType := ntSubDomain;
                    end;
                  end;
                end;
              end;
              if NewNode = nil then
              begin
                NewNode := SutraMesh.Mesh2D.Nodes.Add;
                NewNode.Number := -1;
                NewNode.Location := NewPoint;
                if (OuterIndex = 0) or (OuterIndex = OuterCount)
                  or (InnerIndex = 0) or (InnerIndex = InnerCount) then
                begin
                  NewNode.NodeType := ntEdge;
                  QuadTree.AddPoint(NewNode.X, NewNode.Y, NewNode);
                end
                else
                begin
                  NewNode.NodeType := ntInner;
                end;
              end;
              NodeArray[OuterIndex, InnerIndex] := NewNode;
            end;
          end;
          for OuterIndex := 0 to OuterCount -1 do
          begin
            for InnerIndex := 0 to InnerCount-1 do
            begin
              NewElement := SutraMesh.Mesh2D.Elements.Add;
              ElementArray[OuterIndex, InnerIndex] := NewElement;

              NodeNumberItem := NewElement.Nodes.Add;
              NodeNumberItem.Node := NodeArray[OuterIndex, InnerIndex];
//              NodeNumberItem.Node.FElements.Add(NewElement);

              NodeNumberItem := NewElement.Nodes.Add;
              NodeNumberItem.Node := NodeArray[OuterIndex+1, InnerIndex];
//              NodeNumberItem.Node.FElements.Add(NewElement);

              NodeNumberItem := NewElement.Nodes.Add;
              NodeNumberItem.Node := NodeArray[OuterIndex+1, InnerIndex+1];
//              NodeNumberItem.Node.FElements.Add(NewElement);

              NodeNumberItem := NewElement.Nodes.Add;
              NodeNumberItem.Node := NodeArray[OuterIndex, InnerIndex+1];
//              NodeNumberItem.Node.FElements.Add(NewElement);

            end;
          end;
          if OuterCount > InnerCount then
          begin
            for OuterIndex := 0 to OuterCount do
            begin
              for InnerIndex := 0 to InnerCount do
              begin
                if NodeArray[OuterIndex, InnerIndex].Number < 0 then
                begin
                  NodeArray[OuterIndex, InnerIndex].Number := NodeCount;
                  Inc(NodeCount);
                end;
              end;
            end;
            for OuterIndex := 0 to OuterCount-1 do
            begin
              for InnerIndex := 0 to InnerCount-1 do
              begin
                ElementArray[OuterIndex, InnerIndex].ElementNumber := ElementCount;
                Inc(ElementCount);
              end;
            end;
          end
          else
          begin
            for InnerIndex := 0 to InnerCount do
            begin
              for OuterIndex := 0 to OuterCount do
              begin
                if NodeArray[OuterIndex, InnerIndex].Number < 0 then
                begin
                  NodeArray[OuterIndex, InnerIndex].Number := NodeCount;
                  Inc(NodeCount);
                end;
              end;
            end;
            for InnerIndex := 0 to InnerCount-1 do
            begin
              for OuterIndex := 0 to OuterCount-1 do
              begin
                ElementArray[OuterIndex, InnerIndex].ElementNumber := ElementCount;
                Inc(ElementCount);
              end;
            end;
          end;
        end;
      end;
    finally
      NodeList := TSutraNode2D_List.Create;
      try
        NodeList.Capacity := FSutraMesh.Mesh2D.Nodes.Count;
        for index := 0 to FSutraMesh.Mesh2D.Nodes.Count - 1 do
        begin
          NodeList.Add(FSutraMesh.Mesh2D.Nodes[index]);
        end;
        NodeList.Sort(TSutraNode2DNumberComparer.Construct(
          function(const L, R: TSutraNode2D): Integer
          begin
            result := L.Number - R.Number;
          end));
        for Index := 0 to NodeList.Count - 1 do
        begin
          NodeList.Items[index].Index := index;
        end;
      finally
        NodeList.Free;
      end;

      if FishnetElementCount > 1 then
      begin
        FSutraMesh.Mesh2D.Renumber;
      end
      else
      begin
        ElementList := TSutraElement2D_List.Create;
        try
          ElementList.Capacity := FSutraMesh.Mesh2D.Elements.Count;
          for index := 0 to FSutraMesh.Mesh2D.Elements.Count - 1 do
          begin
            ElementList.Add(FSutraMesh.Mesh2D.Elements[index]);
          end;
          ElementList.Sort(TSutraElement2DNumberComparer.Construct(
            function(const L, R: TSutraElement2D): Integer
            begin
              result := L.ElementNumber - R.ElementNumber;
            end));
          for Index := 0 to ElementList.Count - 1 do
          begin
            ElementList.Items[index].Index := index;
          end;
        finally
          ElementList.Free;
        end;

      end;
      FSutraMesh.Mesh2D.EndUpdate;
//      RenumberMesh(FSutraMesh.Mesh2D);


      DataArrayManager.InvalidateAllDataSets;
      DataArrayManager.CreateInitialDataSets;
      FSutraMesh.ElevationsNeedUpdating := true;
      FSutraMesh.EndUpdate;
    end;
    frmGoPhast.InvalidateGrid;
  finally
    QuadTree.Free;
  end;
end;

function TPhastModel.GetAppsMoved: TStringList;
begin
  result := FAppsMoved;
end;

function TPhastModel.GetArchiveName: string;
begin
  if FArchiveName = '' then
  begin
    FArchiveName := DefaultArchiveName;
  end;
  result := FArchiveName;
end;

function TPhastModel.GetChemistryOptions: TChemistryOptions;
begin
  Result := FChemistryOptions;
end;

function TPhastModel.GetChildModel(Index: Integer): IModelForTOrderedCollection;
begin
  result := ChildModels[Index].ChildModel;
end;

function TPhastModel.GetChildModelCount: Integer;
begin
  result := ChildModels.Count;
end;

function TPhastModel.GetChildModels: TChildModelCollection;
begin
  result := FChildModels;
end;

function TPhastModel.GetColorSchemes: TUserDefinedColorSchemeCollection;
begin
  result := FColorSchemes;
end;

function TPhastModel.GetCombinedDisplayColumn: integer;
begin
  result := FCombinedDisplayColumn;
  if (Grid <> nil) and not LgrUsed then
  begin
    result := Grid.DisplayColumn;
  end;
end;

function TPhastModel.GetCombinedDisplayLayer: integer;
begin
  result := FCombinedDisplayLayer;
  if (Grid <> nil) and not LgrUsed then
  begin
    result := Grid.DisplayLayer;
  end
  else if DisvUsed then
  begin
    result := DisvGrid.SelectedLayer;
  end;
end;

function TPhastModel.GetCombinedDisplayRow: integer;
begin
  result := FCombinedDisplayRow;
  if (Grid <> nil) and not LgrUsed then
  begin
    result := Grid.DisplayRow;
  end;
end;

function TPhastModel.GetContourFont: TFont;
begin
  result := FContourFont
end;

function TPhastModel.GetContourLabelSpacing: Integer;
begin
  result := FContourLabelSpacing;
end;

function TPhastModel.GetContourLegend: TLegend;
begin
  result := FContourLegend;
end;

function TPhastModel.GetCtsSystems: TCtsSystemCollection;
begin
  result := FCtsSystems;
end;

function TPhastModel.GetCurrentScreenObject(VD: TViewDirection): TScreenObject;
begin
  if Assigned(OnGetCurrentScreenObject) then
  begin
    OnGetCurrentScreenObject(self, VD, result);
  end;
end;

function TPhastModel.GetDisplayName: string;
begin
  case ModelSelection of
    msUndefined: Assert(False);
    msPhast: result := 'PHAST';
    msModflow, msModflowNWT, msModflowCfp, msModflow2015:
      begin
        result := 'MODFLOW';
      end;
    msModflowLGR, msModflowLGR2, msModflowFmp, msModflowOwhm2:
      begin
        result := 'Parent model';
      end;
    msSutra22, msSutra30, msSutra40: result := 'SUTRA';
    msFootprint: Result := 'WellFootprint';
    else Assert(False);
  end;
end;

function TCustomModel.GetThreeDContourDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        if Grid <> nil then
        begin
          result := Grid.ThreeDContourDataSet;
        end
        else
        begin
          result := nil;
        end;
      end;
    msModflow2015:
      begin
        case Mf6GridType of
          mgtStructured:
            begin
              if Grid <> nil then
              begin
                result := Grid.ThreeDContourDataSet;
              end
              else
              begin
                result := nil;
              end;
            end;
          mgtLayered:
            begin
              if DisvGrid <> nil then
              begin
                result := DisvGrid.ThreeDContourDataSet;
              end
              else
              begin
                result := nil;
              end;
            end;
          mgtUnstructured:
            begin
              result := nil;
            end;
          else
            Assert(False);
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          result := SutraMesh.ThreeDContourDataSet;
        end;
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetThreeDDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        result := Grid.ThreeDDataSet;
      end;
    msModflow2015:
      begin
        case Mf6GridType of
          mgtStructured:
            begin
              result := Grid.ThreeDDataSet;
            end;
          mgtLayered:
            begin
              result := DisvGrid.ThreeDDataSet;
            end;
          mgtUnstructured:
            begin
              result := nil;
            end;
          else
            Assert(False);
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          result := SutraMesh.ThreeDDataSet;
        end;
      end;
    else
       Assert(False);
  end;
end;

function TPhastModel.GetTimeListByName(const AName: string): TCustomTimeList;
var
  Index: Integer;
  AList: TCustomTimeList;
begin
  result := nil;
  for Index := 0 to TimeListCount - 1 do
  begin
    AList := TimeLists[Index];
    if AList.Name = AName then
    begin
      result := AList;
      Exit;
    end;
  end;
end;

function TPhastModel.GetMf6TimesSeries: TTimesSeriesCollections;
begin
  result := FTimesSeries;
end;

procedure TCustomModel.UpdateFarmsFullStressPeriods(TimeList: TRealList);
var
  PhastModel: TPhastModel;
  TestFirstTime: double;
  LastTestTime: double;
  OutOfStartRange, OutOfEndRange: Boolean;
  FarmIndex: integer;
  AFarm: TFarm;
begin
  if not ModflowPackages.FarmProcess.IsSelected then
  begin
    Exit;
  end;

  TestFirstTime := TimeList.First;
  LastTestTime := TimeList.Last;

  if self is TChildModel then
  begin
    PhastModel := TChildModel(self).ParentModel as TPhastModel;
  end
  else
  begin
    PhastModel := self as TPhastModel;
  end;

//  PhastModel := self as TPhastModel;;
  OutOfStartRange := False;
  OutOfEndRange := False;

  for FarmIndex := 0 to PhastModel.Farms.Count - 1 do
  begin
    AFarm := PhastModel.Farms[FarmIndex];
    AFarm.UpdateTimes(TimeList, TestFirstTime, LastTestTime,
      OutOfStartRange, OutOfEndRange);
  end;

//  PhastModel.FmpAllotment.UpdateTimes(TimeList, TestFirstTime, LastTestTime,
//      OutOfStartRange, OutOfEndRange);

  if OutOfStartRange then
  begin
    frmErrorsAndWarnings.AddWarning(self,
      StrAnyTimesBeforeThe, StrFarmTimesEarly);
  end;

  if OutOfEndRange then
  begin
    frmErrorsAndWarnings.AddWarning(self,
      StrAnyTimesAfterThe, StrFarmTmesLate);
  end;
end;

procedure TCustomModel.UpdateFormulaDependencies(OldFormula: string;
  var NewFormula: string; Observer: IObserver; Compiler: TRbwParser;
  ScreenObject: IScreenObject = nil);
var
  OldUses: TStringList;
  NewUses: TStringList;
  Position: integer;
  DS: TObserver;
//  ParentScreenObject: TScreenObject;
  Index: integer;
  TimeSeries: TMf6TimeSeries;
//  DynamicTimeSeries:
  procedure CompileFormula(var AFormula: string; UsesList: TStringList);
  var
    LocalScreenObject: IScreenObjectForDynamicTimeSeries;
    DynamicTimeSeries: IDynamicTimeSeries;
  begin
    if AFormula <> '' then
    begin
      // Mf6TimesSeries.GetTimeSeriesByName always returns nil for
      // non MODFLOW 6 models.
      DynamicTimeSeries := nil;
      TimeSeries := Mf6TimesSeries.GetTimeSeriesByName(AFormula);
      if TimeSeries <> nil then
      begin
        AFormula := String(TimeSeries.SeriesName);
        UsesList.Clear;
      end
      else if ScreenObject <> nil then
      begin
        if ScreenObject.QueryInterface(IScreenObjectForDynamicTimeSeries,
          LocalScreenObject) <> 0 then
        begin
          Assert(False);
        end;
        DynamicTimeSeries := LocalScreenObject.GetDynamicTimeSeriesIByName(AFormula);
        if DynamicTimeSeries <> nil then
        begin
          UsesList.Assign(DynamicTimeSeries.UsesList);
        end;
      end;

      if (TimeSeries = nil) and (DynamicTimeSeries = nil) then
      begin
        try
          Compiler.Compile(AFormula);
          UsesList.Assign(Compiler.CurrentExpression.VariablesUsed);
        except
          on E: ERbwParserError do
          begin
          end;
        end;
      end;
    end;
  end;

begin
  OldFormula := Trim(OldFormula);
  NewFormula := Trim(NewFormula);
  if OldFormula = NewFormula then
  begin
    Exit;
  end;
  if (ComponentState * [csLoading, csReading]) <> [] then
  begin
    Exit;
  end;
//  ParentScreenObject := ScreenObject as TScreenObject;
//  if (ParentScreenObject = nil) then
//  begin
//    Exit;
//  end;
  OldUses := TStringList.Create;
  NewUses := TStringList.Create;
  try
    CompileFormula(OldFormula, OldUses);
    CompileFormula(NewFormula, NewUses);
    for Index := OldUses.Count - 1 downto 0 do
    begin
      Position := NewUses.IndexOf(OldUses[Index]);
      if Position >= 0 then
      begin
        OldUses.Delete(Index);
        NewUses.Delete(Position);
      end;
    end;
    for Index := 0 to OldUses.Count - 1 do
    begin
      DS := GetObserverByName(OldUses[Index]);
      Assert(DS <> nil);
      DS.StopsTalkingTo(Observer as TObserver);
    end;
    for Index := 0 to NewUses.Count - 1 do
    begin
      DS := GetObserverByName(NewUses[Index]);
      Assert(DS <> nil);
      DS.TalksTo(Observer as TObserver);
    end;
  finally
    NewUses.Free;
    OldUses.Free;
  end;
end;

procedure TCustomModel.UpdateFormulas(OldNames, NewNames: TStringList);
var
  CompilerList: TList;
  CompilerIndex: Integer;
  Compiler: TRbwParser;
  VariableIndex: Integer;
  VarIndex: Integer;
begin
  FormulaManager.RemoveSubscriptions(OldNames, NewNames);
  CompilerList := TList.Create;
  try
    FillCompilerList(CompilerList);
    for CompilerIndex := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[CompilerIndex];
      for VariableIndex := 0 to OldNames.Count - 1 do
      begin
        VarIndex := Compiler.IndexOfVariable(OldNames[VariableIndex]);
        if VarIndex >= 0 then
        begin
          Compiler.RenameVariable(VarIndex, NewNames[VariableIndex], NewNames[VariableIndex]);
        end;
      end;
    end;
    FormulaManager.ResetFormulas;
    for CompilerIndex := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[CompilerIndex];
      for VariableIndex := 0 to OldNames.Count - 1 do
      begin
        VarIndex := Compiler.IndexOfVariable(NewNames[VariableIndex]);
        if VarIndex >= 0 then
        begin
          Compiler.RenameVariable(VarIndex, OldNames[VariableIndex], OldNames[VariableIndex]);
        end;
      end;
    end;
  finally
    CompilerList.Free;
  end;
end;

procedure TPhastModel.UpdateFrontTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildList: TCustomTimeList;
begin
  inherited;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildList := ChildModel.GetTimeListByName(TimeList.Name);
        ChildModel.UpdateFrontTimeDataSet(ChildList, Time);
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateFrontTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  TimeIndex: integer;
  LocalSelectedLayer, LocalSelectedRow, LocalSelectedColumn: integer;
begin
  if Grid <> nil then
  begin
    if (Grid.LayerCount <= 0) or (Grid.RowCount <= 0) or (Grid.ColumnCount <= 0) then
    begin
      FFrontTimeList := nil;
      Grid.FrontDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := Grid.SelectedLayer;
    LocalSelectedRow := Grid.SelectedRow;
    LocalSelectedColumn := Grid.SelectedColumn;
    try
      if not TimeList.UpToDate then
      begin
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        Grid.FrontDataSet := nil;
      end
      else
      begin
        Grid.FrontDataSet := TimeList.Items[TimeIndex];
        Grid.FrontDataSet.UpdateMinMaxValues;
      end;
      FFrontTimeList := TimeList;
      FFrontDisplayTime := Time;
    finally
      Grid.SelectedLayer := LocalSelectedLayer;
      Grid.SelectedRow := LocalSelectedRow;
      Grid.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else if DrawMesh <> nil then
  begin
    if (DrawMesh.LayerCount <= 0) then
    begin
      FFrontTimeList := nil;
      Exit;
    end;
    try
      if not TimeList.UpToDate then
      begin
        TimeList.Initialize;
      end;
      FFrontTimeList := TimeList;
      FFrontDisplayTime := Time;
    finally
    end;
  end
  else
  begin
    FFrontTimeList := nil;
  end;
end;

procedure TCustomModel.UpdateGwtConc;
begin
  ModflowPackages.ChdBoundary.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.GhbBoundary.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.WelPackage.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.RivPackage.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.RchPackage.AddRemoveRenameGwtConcentrationTimeLists;
//  ModflowPackages.EtsPackage.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.SfrModflow6Package.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.MawPackage.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.UzfMf6Package.AddRemoveRenameGwtConcentrationTimeLists;

  ModflowPackages.GwtCncPackage.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.GwtCncPackage.AddRemoveRenameGwtMultiplierTimeLists;
  ModflowPackages.GwtCncPackage.AddRemoveRenameGwtActiveTimeLists;

  ModflowPackages.GwtSrcPackage.AddRemoveRenameGwtConcentrationTimeLists;
  ModflowPackages.GwtSrcPackage.AddRemoveRenameGwtMultiplierTimeLists;
  ModflowPackages.GwtSrcPackage.AddRemoveRenameGwtActiveTimeLists;
end;

procedure TCustomModel.UpdateMt3dmsActive(Sender: TObject);
const
  SetToFalse = 'Set to false because the cell is inactive in MODFLOW';
//  SetToTrue = 'Set to true because the cell is a Lake cell in MODFLOW and LKT is active';
var
  Mt3dmsActive: TDataArray;
  ActiveDataArray: TDataArray;
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
begin
  Exit;


  Mt3dmsActive := DataArrayManager.GetDataSetByName(StrMT3DMSActive);
  if Mt3dmsActive <> nil then
  begin
    ActiveDataArray := DataArrayManager.GetDataSetByName(rsActive);
    ActiveDataArray.Initialize;
    for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
    begin
      for RowIndex := 0 to ModflowGrid.RowCount - 1 do
      begin
        for LayerIndex := 0 to ModflowGrid.LayerCount -1 do
        begin
          if Mt3dmsActive.BooleanData[LayerIndex, RowIndex, ColIndex]
            and not ActiveDataArray.BooleanData[LayerIndex, RowIndex, ColIndex] then
          begin
            Mt3dmsActive.BooleanData[LayerIndex, RowIndex, ColIndex] := False;
            Mt3dmsActive.Annotation[LayerIndex, RowIndex, ColIndex] := SetToFalse;
          end;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateLakeId(Sender: TObject);
var
  LakeIdArray: TDataArray;
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
  LakeList: TIntegerList;
  LakeId, NewLakeID: integer;
  ScreenObjectIndex: Integer;
  ScreenObject: TScreenObject;
begin
  if (ModelSelection in ModflowSelection)
    and ModflowPackages.LakPackage.IsSelected  then
  begin
    LakeList := TIntegerList.Create;
    try
      LakeList.Sorted := True;

      for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
      begin
        ScreenObject := ScreenObjects[ScreenObjectIndex];
        if ScreenObject.Deleted then
        begin
          Continue;
        end;
        if (ScreenObject.ModflowLakBoundary <> nil)
          and ScreenObject.ModflowLakBoundary.Used then
        begin
          if ScreenObject.ModflowLakBoundary.LakeID > 0 then
          begin
            LakeList.AddUnique(ScreenObject.ModflowLakBoundary.LakeID);
          end;
        end;
      end;

      LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
      Assert(LakeIdArray <> nil);
      for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
      begin
        for RowIndex := 0 to ModflowGrid.RowCount - 1 do
        begin
          for LayerIndex := 0 to ModflowGrid.LayerCount -1 do
          begin
            LakeId := LakeIdArray.IntegerData[LayerIndex,RowIndex,ColIndex];
            if LakeId <> 0 then
            begin
              NewLakeID := LakeList.IndexOf(LakeId) + 1;
              if LakeId <> NewLakeID then
              begin
                LakeIdArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                  := NewLakeID;
                LakeIdArray.Annotation[LayerIndex,RowIndex,ColIndex]
                  := LakeIdArray.Annotation[LayerIndex,RowIndex,ColIndex]
                  + ' and then renumbered';
              end;
            end;
          end;
        end;
      end;
    finally
      LakeList.Free;
    end;
  end;
end;

procedure TCustomModel.UpdateDischargeRouting(Sender: TObject);
var
  DischargeRoutingArray: TDataArray;
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
  LakeList: TIntegerList;
  DischargeId, NewLakeID, NewStreamID: integer;
  ScreenObjectIndex: Integer;
  ScreenObject: TScreenObject;
  SfrList: TIntegerList;
  ID_Position: integer;
  NewAnnotation: string;
  PriorAnnotation: string;
  CellList: TCellAssignmentList;
begin
  if (ModelSelection in ModflowSelection)
    and (ModflowPackages.LakPackage.IsSelected
    or ModflowPackages.SfrPackage.IsSelected)  then
  begin
    DischargeRoutingArray := FDataArrayManager.GetDataSetByName(StrUzfDischargeRouting);
    Assert(DischargeRoutingArray <> nil);

    LakeList := TIntegerList.Create;
    SfrList := TIntegerList.Create;
    try
      LakeList.Sorted := True;
      SfrList.Sorted := True;

      for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
      begin
        ScreenObject := ScreenObjects[ScreenObjectIndex];
        if ScreenObject.Deleted then
        begin
          Continue;
        end;
        if ModflowPackages.LakPackage.IsSelected
          and (ScreenObject.ModflowLakBoundary <> nil)
          and ScreenObject.ModflowLakBoundary.Used then
        begin
          if ScreenObject.ModflowLakBoundary.LakeID > 0 then
          begin
            LakeList.AddUnique(ScreenObject.ModflowLakBoundary.LakeID);
          end;
        end;
        if ModflowPackages.SfrPackage.IsSelected
          and (ScreenObject.ModflowSfrBoundary <> nil)
          and ScreenObject.ModflowSfrBoundary.Used then
        begin
          CellList := TCellAssignmentList.Create;
          try
            ScreenObject.GetCellsToAssign({Grid,} '0', nil, nil,
              CellList, alAll, self);
            if CellList.Count > 0 then
            begin
              SfrList.AddUnique(ScreenObject.ModflowSfrBoundary.SegmentNumber);
            end;
          finally
            CellList.Free;
          end;
        end;
      end;

      DischargeRoutingArray.UpToDate := True;
      PriorAnnotation := '';
      for RowIndex := 0 to ModflowGrid.RowCount - 1 do
      begin
        for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
        begin
          LayerIndex := 0;
          DischargeId := DischargeRoutingArray.IntegerData[
            LayerIndex,RowIndex,ColIndex];
          if DischargeId < 0 then
          begin
            ID_Position := LakeList.IndexOf(-DischargeId);
            if ID_Position >= 0 then
            begin
              NewLakeID := -(ID_Position + 1);
              if DischargeId <> NewLakeID then
              begin
                NewAnnotation
                  := DischargeRoutingArray.Annotation[
                  LayerIndex,RowIndex,ColIndex]
                  + Format(' and then renumbered from %0:d to %1:d',
                    [DischargeId, NewLakeID]);
                if PriorAnnotation <> NewAnnotation then
                begin
                  PriorAnnotation := NewAnnotation;
                end;
                DischargeRoutingArray.Annotation[LayerIndex,RowIndex,ColIndex]
                  := PriorAnnotation;
                DischargeRoutingArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                  := NewLakeID;
              end;
            end
            else
            begin
              NewAnnotation
                := DischargeRoutingArray.Annotation[
                LayerIndex,RowIndex,ColIndex]
                + Format(' and then renumbered from %0:d to 0 because of an invalid lake number.',
                  [DischargeId]);
              if PriorAnnotation <> NewAnnotation then
              begin
                PriorAnnotation := NewAnnotation;
              end;
              DischargeRoutingArray.Annotation[LayerIndex,RowIndex,ColIndex]
                := PriorAnnotation;
              DischargeRoutingArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                := 0;
            end;
          end
          else if (DischargeId > 0) and (DischargeId <= 100000) then
          begin
            // Don't change numbers for Surface Water Routing process. (DischargeId > 100000)
            ID_Position := SfrList.IndexOf(DischargeId);
            if ID_Position >= 0 then
            begin
              NewStreamID := (ID_Position + 1);
              if DischargeId <> NewStreamID then
              begin
                DischargeRoutingArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                  := NewStreamID;
                NewAnnotation
                  := DischargeRoutingArray.Annotation[
                  LayerIndex,RowIndex,ColIndex]
                  + Format(' and then renumbered from %0:d to %1:d',
                    [DischargeId, NewStreamID]);
                if PriorAnnotation <> NewAnnotation then
                begin
                  PriorAnnotation := NewAnnotation;
                end;
                DischargeRoutingArray.Annotation[LayerIndex,RowIndex,ColIndex]
                  := PriorAnnotation;
              end;
            end
            else
            begin
              NewAnnotation
                := DischargeRoutingArray.Annotation[
                LayerIndex,RowIndex,ColIndex]
                + Format(' and then renumbered from %0:d to 0 because of an invalid stream number.',
                  [DischargeId]);
              if PriorAnnotation <> NewAnnotation then
              begin
                PriorAnnotation := NewAnnotation;
              end;
              DischargeRoutingArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                := 0;
              DischargeRoutingArray.Annotation[LayerIndex,RowIndex,ColIndex]
                := PriorAnnotation;
            end;
          end;
        end;
      end;
    finally
      LakeList.Free;
      SfrList.Free;
    end;
  end;
end;

procedure TCustomModel.UpdateSwrReachNumber(Sender: TObject);
var
  SwrWriter: TModflowSwrWriter;
begin
  frmProgressMM.ShouldContinue := True;
  SwrWriter := TModflowSwrWriter.Create(Self, etDisplay);
  try
    SwrWriter.UpdateReachNumberDisplay;
  finally
    SwrWriter.Free;
  end;
end;

procedure TCustomModel.UpdateOnPostInitialize;
var
  ActiveArray: TDataArray;
  WetDryArray: TDataArray;
  LakeIdArray: TDataArray;
  SpecifiedHeadArray: TDataArray;
  ModPathZoneArray: TDataArray;
  PhastModel: TPhastModel;
  ChildIndex: Integer;
  ResKvArray: TDataArray;
  Mt3dActiveArray: TDataArray;
  SwrReachArray: TDataArray;
  SwrReachGroupArray: TDataArray;
  SwrRoutingTypeArray: TDataArray;
  SwrReachLengthArray: TDataArray;
  Sfr6Array: TDataArray;
  MawArray: TDataArray;
  LakeMf6Array: TDataArray;
  IdomainArray: TDataArray;
  Index: Integer;
  DataSetName: string;
  DataArray: TDataArray;
  ChildModel: TChildModel;
begin
  if ModelSelection in SutraSelection then
  begin
    Exit;
  end;
  LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
  ActiveArray := FDataArrayManager.GetDataSetByName(rsActive);
  WetDryArray := FDataArrayManager.GetDataSetByName(rsWetDryFlag);
  SpecifiedHeadArray := FDataArrayManager.GetDataSetByName(rsModflowSpecifiedHead);
  ModPathZoneArray := FDataArrayManager.GetDataSetByName(StrModpathZone);
  ResKvArray := FDataArrayManager.GetDataSetByName(rsResKv);
  Mt3dActiveArray := FDataArrayManager.GetDataSetByName(StrMT3DMSActive);
  SwrReachArray := FDataArrayManager.GetDataSetByName(KSwrReach);
  SwrReachGroupArray := FDataArrayManager.GetDataSetByName(KSwrReachGroup);
  SwrRoutingTypeArray := FDataArrayManager.GetDataSetByName(KSwrRoutingType);
  SwrReachLengthArray := FDataArrayManager.GetDataSetByName(KSwrReachLength);
  LakeMf6Array := FDataArrayManager.GetDataSetByName(KMf6LakeConnectionTypes);
  IdomainArray := FDataArrayManager.GetDataSetByName(K_IDOMAIN);

  if SpecifiedHeadArray <> nil then
  begin
    SpecifiedHeadArray.OnPostInitialize := UpdateSpecifiedHeadArray;
  end;

  if SwrReachArray <> nil then
  begin
    SwrReachArray.OnPostInitialize := UpdateSwrReachNumber;
  end;

  if SwrReachGroupArray <> nil then
  begin
    SwrReachGroupArray.OnPostInitialize := UpdateSwrReachNumber;
  end;

  if SwrRoutingTypeArray <> nil then
  begin
    SwrRoutingTypeArray.OnPostInitialize := UpdateSwrReachNumber;
  end;

  if SwrReachLengthArray <> nil then
  begin
    SwrReachLengthArray.OnPostInitialize := UpdateSwrReachNumber;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KReachLengthSFR);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KReachWidthSFR6);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KGradientSFR6);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KStreambedTopSFR6);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KStreambedThicknessSFR6);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KHydraulicConductivitySFR6);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  Sfr6Array := FDataArrayManager.GetDataSetByName(KInitialStageSFR6);
  if Sfr6Array <> nil then
  begin
    Sfr6Array.OnPostInitialize := UpdateSfr6SteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWRadius);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWBottom);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWInitialHead);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWScreenTop);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWScreenBottom);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWSkinK);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  MawArray := FDataArrayManager.GetDataSetByName(KMAWSkinRadius);
  if MawArray <> nil then
  begin
    MawArray.OnPostInitialize := UpdateMawSteadyData;
  end;

  if Mt3dActiveArray <> nil then
  begin
    Mt3dActiveArray.OnPostInitialize := UpdateMt3dmsActive;
  end;

  if ResKvArray <> nil then
  begin
    ResKvArray.OnPostInitialize := AdjustResKvArray;
  end;

  if IdomainArray <> nil then
  begin
    IdomainArray.OnPostInitialize := UpdateIdomain;
  end;

  if ModflowPackages.LakMf6Package.IsSelected
    and (ModelSelection = msModflow2015) then
  begin
    ActiveArray.OnPostInitialize := UpdateActive;
    ActiveArray.OnDestroy := FinalizeActive;
    if (ModflowPackages.ChdBoundary.IsSelected)
      or (ModflowPackages.FhbPackage.IsSelected) then
    begin
      if SpecifiedHeadArray <> nil then
      begin
        SpecifiedHeadArray.TalksTo(ActiveArray);
      end;
    end;
    if LakeMf6Array <> nil then
    begin
      LakeMf6Array.TalksTo(ActiveArray);
    end;
    ActiveArray.UpToDate := False;

    if (IdomainArray <> nil) and (LakeMf6Array <> nil) then
    begin
      LakeMf6Array.TalksTo(IdomainArray);
      IdomainArray.UpToDate := False;
    end;
  end
  else if ModflowPackages.LakPackage.IsSelected
    and (ModelSelection in ModflowSelection) then
  begin
    Assert(ActiveArray <> nil);
    if LakeIdArray <> nil then
    begin
      LakeIdArray.OnPostInitialize := UpdateLakeId;
      LakeIdArray.OnDestroy := FinalizeLakeId;
      LakeIdArray.UpToDate := False;
      if ActiveArray <> nil then
      begin
        ActiveArray.OnPostInitialize := UpdateActive;
        ActiveArray.OnDestroy := FinalizeActive;
        LakeIdArray.TalksTo(ActiveArray);
        if ModflowPackages.ChdBoundary.IsSelected
          or ModflowPackages.FhbPackage.IsSelected then
        begin
          if SpecifiedHeadArray <> nil then
          begin
            SpecifiedHeadArray.TalksTo(ActiveArray);
          end;
        end;
        ActiveArray.UpToDate := False;
      end;
      if WetDryArray <> nil then
      begin
        WetDryArray.OnPostInitialize := UpdateWetDry;
        WetDryArray.OnDestroy := FinalizeWetDry;
        LakeIdArray.TalksTo(WetDryArray);
        WetDryArray.UpToDate := False;
      end;
    end;
  end
  else if (ModflowPackages.ChdBoundary.IsSelected
    or (ModflowPackages.FhbPackage.IsSelected and (ModelSelection <> msModflow2015)))
    and (ModelSelection in ModflowSelection) then
  begin
    Assert(ActiveArray <> nil);
    if SpecifiedHeadArray <> nil then
    begin
      ActiveArray.OnPostInitialize := UpdateActive;
      ActiveArray.OnDestroy := FinalizeActive;
      SpecifiedHeadArray.TalksTo(ActiveArray);
      if LakeIdArray <> nil then
      begin
        LakeIdArray.StopsTalkingTo(ActiveArray);
      end;
      ActiveArray.UpToDate := False;
    end;
    if WetDryArray <> nil then
    begin
      WetDryArray.OnPostInitialize := nil;
      WetDryArray.OnDestroy := nil;
      if LakeIdArray <> nil then
      begin
        LakeIdArray.StopsTalkingTo(WetDryArray);
        WetDryArray.UpToDate := False;
      end;
    end;
    if LakeIdArray <> nil then
    begin
      LakeIdArray.OnPostInitialize := nil;
      LakeIdArray.OnDestroy := nil;
      LakeIdArray.UpToDate := False;
    end;
  end
  else
  begin
    if ActiveArray <> nil then
    begin
      ActiveArray.OnPostInitialize := nil;
      ActiveArray.OnDestroy := nil;
      if LakeIdArray <> nil then
      begin
        LakeIdArray.StopsTalkingTo(ActiveArray);
        ActiveArray.UpToDate := False;
      end;
    end;
    if WetDryArray <> nil then
    begin
      WetDryArray.OnPostInitialize := nil;
      WetDryArray.OnDestroy := nil;
      if LakeIdArray <> nil then
      begin
        LakeIdArray.StopsTalkingTo(WetDryArray);
        WetDryArray.UpToDate := False;
      end;
    end;
    if LakeIdArray <> nil then
    begin
      LakeIdArray.OnPostInitialize := nil;
      LakeIdArray.OnDestroy := nil;
      LakeIdArray.UpToDate := False;
    end;
  end;
  DischargeRoutingUpdate;

  if ModPathZoneArray <> nil then
  begin
    ModPathZoneArray.OnPostInitialize := UpdateModPathZone;
    Assert(ActiveArray <> nil);
    ActiveArray.TalksTo(ModPathZoneArray);
    if SpecifiedHeadArray <> nil then
    begin
      SpecifiedHeadArray.TalksTo(ModPathZoneArray);
    end;
  end;

  if DoSftUsed(nil) then
  begin
    for Index := 1 to NumberOfMt3dChemComponents do
    begin
      DataSetName := KSFTInitialConcentra + IntToStr(Index);
      DataArray := FDataArrayManager.GetDataSetByName(DataSetName);
      if DataArray <> nil then
      begin
        DataArray.OnPostInitialize := UpdateSftSteadyData;
      end;
      DataSetName := KSFTDispersion + IntToStr(Index);
      DataArray := FDataArrayManager.GetDataSetByName(DataSetName);
      if DataArray <> nil then
      begin
        DataArray.OnPostInitialize := UpdateSftSteadyData;
      end;
    end;
  end;

  if self is TPhastModel then
  begin
    PhastModel := TPhastModel(self);
    for ChildIndex := 0 to PhastModel.ChildModels.Count - 1 do
    begin
      ChildModel := PhastModel.ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.UpdateOnPostInitialize
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateSfr6SteadyData(Sender: TObject);
var
  SfrWriter: TModflowSFR_MF6_Writer;
begin
  frmProgressMM.ShouldContinue := True;
  SfrWriter := TModflowSFR_MF6_Writer.Create(Self, etDisplay);
  try
    SfrWriter.UpdateSteadyData;
  finally
    SfrWriter.Free;
  end;
end;

procedure TCustomModel.UpdateSftSteadyData(Sender: TObject);
var
  SftWriter: TMt3dmsSftWriter;
begin
  frmProgressMM.ShouldContinue := True;
  SftWriter := TMt3dmsSftWriter.Create(Self, etDisplay);
  try
    SftWriter.UpdateSteadyData;
  finally
    SftWriter.Free;
  end;
end;


procedure TCustomModel.UpdateSideTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  TimeIndex: integer;
  LocalSelectedLayer, LocalSelectedRow, LocalSelectedColumn: integer;
begin
  if Grid <> nil then
  begin
    if (Grid.LayerCount <= 0) or (Grid.RowCount <= 0) or (Grid.ColumnCount <= 0) then
    begin
      FSideTimeList := nil;
      Grid.SideDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := Grid.SelectedLayer;
    LocalSelectedRow := Grid.SelectedRow;
    LocalSelectedColumn := Grid.SelectedColumn;
    try
      if not TimeList.UpToDate then
      begin
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        Grid.SideDataSet := nil;
      end
      else
      begin
        Grid.SideDataSet := TimeList.Items[TimeIndex];
        Grid.SideDataSet.UpdateMinMaxValues;
      end;
      FSideTimeList := TimeList;
      FSideDisplayTime := Time;
    finally
      Grid.SelectedLayer := LocalSelectedLayer;
      Grid.SelectedRow := LocalSelectedRow;
      Grid.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else if Mesh <> nil then
  begin
    if ((Mesh as TSutraMesh3D).LayerCount <= 0) {or (Mesh.RowCount <= 0) or (Mesh.ColumnCount <= 0)} then
    begin
      FSideTimeList := nil;
//      Mesh.SideDataSet := nil;
      Exit;
    end;
//    LocalSelectedLayer := Mesh.SelectedLayer;
//    LocalSelectedRow := Mesh.SelectedRow;
//    LocalSelectedColumn := Mesh.SelectedColumn;
    try
      if not TimeList.UpToDate then
      begin
        TimeList.Initialize;
      end;
//      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
//      if TimeIndex < 0 then
//      begin
//        Mesh.SideDataSet := nil;
//      end
//      else
//      begin
//        Mesh.SideDataSet := TimeList.Items[TimeIndex];
//        Mesh.SideDataSet.UpdateMinMaxValues;
//      end;
      FSideTimeList := TimeList;
      FSideDisplayTime := Time;
    finally
//      Mesh.SelectedLayer := LocalSelectedLayer;
//      Mesh.SelectedRow := LocalSelectedRow;
//      Mesh.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else
  begin
    FSideTimeList := nil;
  end;
end;

procedure TCustomModel.UpdateSpecifiedHeadArray(Sender: TObject);
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  SpecifiedHeadArray: TDataArray;
  GetCells: Boolean;
  CellList: TCellAssignmentList;
  CellIndex: Integer;
  ACell: TCellLocation;
  ChdAnnotation: string;
  FhbAnnotation: string;
  Annotation: string;
  ChdSelected: Boolean;
  FhbSelected: Boolean;
begin
  SpecifiedHeadArray := DataArrayManager.GetDataSetByName(rsModflowSpecifiedHead);
  if SpecifiedHeadArray = nil then
  begin
    Exit;
  end;
  ChdSelected := ModflowPackages.ChdBoundary.IsSelected;
  FhbSelected := (ModelSelection <> msModflow2015)
    and ModflowPackages.FhbPackage.IsSelected;
  if not (ChdSelected or FhbSelected) then
  begin
    Exit;
  end;
  if ModelSelection in ModflowSelection then
  begin
    SpecifiedHeadArray.UpdateDimensions(LayerCount, RowCount, ColumnCount, True);
    ChdAnnotation := 'Set to true because it is in a CHD boundary';
    FhbAnnotation := 'Set to true because it is in a FHB Head boundary';
    Annotation := '';

    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if AScreenObject.Deleted then
      begin
        Continue;
      end;
      if not AScreenObject.UsedModels.UsesModel(self) then
      begin
        Continue;
      end;

      GetCells := False;

      if ChdSelected then
      begin
        if (AScreenObject.ModflowChdBoundary <> nil)
          and AScreenObject.ModflowChdBoundary.Used then
        begin
          GetCells := True;
          Annotation := ChdAnnotation;
        end;
      end;

      if FhbSelected then
      begin
        if (AScreenObject.ModflowFhbHeadBoundary <> nil)
          and AScreenObject.ModflowFhbHeadBoundary.Used then
        begin
          GetCells := True;
          Annotation := FhbAnnotation;
        end;
      end;

      if GetCells then
      begin
        CellList := TCellAssignmentList.Create;
        try
          AScreenObject.GetCellsToAssign('0', nil, nil, CellList, alAll, self);
          for CellIndex := 0 to CellList.Count - 1 do
          begin
            ACell := CellList[CellIndex].Cell;
            SpecifiedHeadArray.BooleanData[ACell.Layer, ACell.Row, ACell.Column] := True;
            SpecifiedHeadArray.Annotation[ACell.Layer, ACell.Row, ACell.Column] := Annotation;
          end;
        finally
          CellList.Free;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateTopTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  TimeIndex: integer;
  LocalSelectedLayer, LocalSelectedRow, LocalSelectedColumn: integer;
begin
  if Grid <> nil then
  begin
    if (Grid.LayerCount <= 0) or (Grid.RowCount <= 0) or (Grid.ColumnCount <= 0) then
    begin
      FTopTimeList := nil;
      Grid.TopDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := Grid.SelectedLayer;
    LocalSelectedRow := Grid.SelectedRow;
    LocalSelectedColumn := Grid.SelectedColumn;
    try
      if not TimeList.UpToDate then
      begin
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        Grid.TopDataSet := nil;
      end
      else
      begin
        Grid.TopDataSet := TimeList.Items[TimeIndex];
        Grid.TopDataSet.UpdateMinMaxValues;
      end;
      FTopTimeList := TimeList;
      FTopDisplayTime := Time;
    finally
      Grid.SelectedLayer := LocalSelectedLayer;
      Grid.SelectedRow := LocalSelectedRow;
      Grid.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else if DrawMesh <> nil then
  begin
    if (DrawMesh.LayerCount <= 0) {or (Mesh.RowCount <= 0) or (Mesh.ColumnCount <= 0)} then
    begin
      FTopTimeList := nil;
      DrawMesh.TopDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := DrawMesh.SelectedLayer;
//    LocalSelectedRow := Mesh.SelectedRow;
//    LocalSelectedColumn := Mesh.SelectedColumn;
    try
      if not TimeList.UpToDate then
      begin
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        DrawMesh.TopDataSet := nil;
      end
      else
      begin
        DrawMesh.TopDataSet := TimeList.Items[TimeIndex];
        DrawMesh.TopDataSet.UpdateMinMaxValues;
      end;
      FTopTimeList := TimeList;
      FTopDisplayTime := Time;
    finally
      DrawMesh.SelectedLayer := LocalSelectedLayer;
//      Mesh.SelectedRow := LocalSelectedRow;
//      Mesh.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else
  begin
    FTopTimeList := nil;
  end;
end;

procedure TCustomModel.UpdateModPathZone(Sender: TObject);
var
  ModPathZoneArray: TDataArray;
  ActiveArray: TDataArray;
  SpecifiedHeadArray: TDataArray;
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
  NegatedString: string;
  MadePositiveString: string;
  PriorNegatedString: string;
  PriorMadePositiveString: string;
begin
  // MODPATH version 3-5 used a version of the IBOUND array to designate
  // both which cells were active and zone numbers.
  // Those two arrays were separated in MODPATH 6.
  if ModflowPackages.ModPath.MpathVersion <> mp5 then
  begin
    Exit;
  end;
  PriorNegatedString := '';
  PriorMadePositiveString := '';
  ModPathZoneArray := FDataArrayManager.GetDataSetByName(StrModpathZone);
  ActiveArray := FDataArrayManager.GetDataSetByName(rsActive);
  Assert(ActiveArray <> nil);
  ActiveArray.Initialize;

  SpecifiedHeadArray := nil;
  if ModelSelection in ModflowSelection then
  begin
    if ModelSelection = msModflow2015 then
    begin
      // You can't really use MODPATH 5 with MODFLOW 6 but just in case...
      if ChdIsSelected then
      begin
        SpecifiedHeadArray := FDataArrayManager.
          GetDataSetByName(rsModflowSpecifiedHead);
      end;
    end
    else
    begin
      if ChdIsSelected or FhbIsSelected then
      begin
        SpecifiedHeadArray := FDataArrayManager.
          GetDataSetByName(rsModflowSpecifiedHead);
      end;
    end;
  end;
  if SpecifiedHeadArray <> nil then
  begin
    SpecifiedHeadArray.Initialize;
  end;
  for ColIndex := 0 to ColumnCount - 1 do
  begin
    for RowIndex := 0 to RowCount - 1 do
    begin
      for LayerIndex := LayerCount -1 downto 0 do
      begin
        if ActiveArray.BooleanData[LayerIndex,RowIndex,ColIndex] then
        begin
          if ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex] = 0 then
          begin
            ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex] := 1;
            ModPathZoneArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
              StrValueOfZeroConver;
          end;
        end
        else if ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex] <> 0
          then
        begin
          ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex] := 0;
          ModPathZoneArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
            StrNonzeroValueOfZe;
        end;

        if SpecifiedHeadArray <> nil then
        begin
          if SpecifiedHeadArray.BooleanData[LayerIndex,RowIndex,ColIndex] then
          begin
            if ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex] > 0
              then
            begin
              ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                := -ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex];
              NegatedString := ModPathZoneArray.
                Annotation[LayerIndex,RowIndex,ColIndex]
                + StrAndNegatedAtCons;
              if PriorNegatedString <> NegatedString then
              begin
                PriorNegatedString := NegatedString
              end;
              ModPathZoneArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
                PriorNegatedString

            end;
          end
          else
          begin
            if ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex] < 0
              then
            begin
              ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex]
                := -ModPathZoneArray.IntegerData[LayerIndex,RowIndex,ColIndex];
              MadePositiveString := ModPathZoneArray.
                Annotation[LayerIndex,RowIndex,ColIndex]
                + StrAndMadePositiveA;
              if PriorMadePositiveString <> MadePositiveString then
              begin
                PriorMadePositiveString := MadePositiveString
              end;
              ModPathZoneArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
                PriorMadePositiveString
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateWetDry(Sender: TObject);
var
  LakeIdArray: TDataArray;
  WetDryArray: TDataArray;
  ColIndex: Integer;
  RowIndex: Integer;
  LayerIndex: Integer;
  IsLake: boolean;
begin
  if (ModelSelection in ModflowSelection)
    and ModflowPackages.LakPackage.IsSelected  then
  begin
    LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
    WetDryArray := FDataArrayManager.GetDataSetByName(rsWetDryFlag);
    Assert(LakeIdArray <> nil);
    Assert(WetDryArray <> nil);
    LakeIdArray.Initialize;
    for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
    begin
      for RowIndex := 0 to ModflowGrid.RowCount - 1 do
      begin
        IsLake := False;
        for LayerIndex := ModflowGrid.LayerCount -1 downto 0 do
        begin
          if LakeIdArray.IntegerData[LayerIndex,RowIndex,ColIndex] <> 0 then
          begin
            IsLake := True;
          end;
          if IsLake then
          begin
            WetDryArray.IntegerData[LayerIndex,RowIndex,ColIndex] := 0;
            WetDryArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
              'All Lake cells are inactive: (' + rsLakeID + ' <> 0)';
          end;
        end;
      end;
    end;
    FDataArrayManager.AddDataSetToCache(LakeIdArray);
  end;
end;

procedure TCustomModel.DoUseFootprintWells(Sender: TObject;
  var ShouldUse: Boolean);
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  ShouldUse := False;
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[ScreenObjectIndex];
    if (not AScreenObject.Deleted)
      and (AScreenObject.FootprintWell <> nil)
      and AScreenObject.FootprintWell.Used then
    begin
      ShouldUse := true;
      break;
    end;
  end;
end;

function TPhastModel.DoUzfInitialInfiltrationUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoUzfInitialInfiltrationUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoUzfInitialInfiltrationUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.UzfIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.UzfPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.UzfPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.UzfMf6IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.UzfMf6Package.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.UzfMf6Package.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoUzfMf6PackageUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoUzfMf6PackageUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoUzfMf6PackageUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoUzfPackageUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoUzfPackageUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoUzfPackageUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoUzfResidualWaterContentUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoUzfResidualWaterContentUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoUzfResidualWaterContentUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.UzfSeepageUsed: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if (not result) and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.UzfSeepageUsed;
        if Result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.DoUzfSurfKUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoUzfSurfKUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoUzfSurfKUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoUzfUnsatVertKUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoUzfUnsatVertKUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoUzfUnsatVertKUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.UztUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited UztUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.UztUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoVerticalAnisotropyUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoVerticalAnisotropyUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoVerticalAnisotropyUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoVerticalTransverseDispersionUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoVerticalTransverseDispersionUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoVerticalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoVerticalTransverseDispersionUsedPerSpecies(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoVerticalTransverseDispersionUsedPerSpecies(Sender);
      end;
    end;
  end;
end;

function TPhastModel.WelIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.WelPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.WelPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoWetDryUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoWetDryUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoWetDryUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.WettingActive: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited WettingActive;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.WettingActive;
      end;
    end;
  end;
end;

//function TPhastModel.Xt3DUsed(Sender: TObject): boolean;
//var
//  ChildIndex: Integer;
//  ChildModel: TChildModel;
//begin
//  result := inherited Xt3DUsed(Sender);
//  if not result and LgrUsed then
//  begin
//    for ChildIndex := 0 to ChildModels.Count - 1 do
//    begin
//      ChildModel := ChildModels[ChildIndex].ChildModel;
//      if ChildModel <> nil then
//      begin
//        result := result or ChildModel.Xt3DUsed(Sender);
//      end;
//    end;
//  end;
//end;

function TPhastModel.ZoneBudgetIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.ZoneBudget.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.ZoneBudget.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoZoneBudgetSelected(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoZoneBudgetSelected(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoZoneBudgetSelected(Sender);
      end;
    end;
  end;
end;

function TPhastModel.ZoomBox(VD: TViewDirection): TQrbwZoomBox2;
begin
  if Assigned(OnGetZoomBox) then
  begin
    OnGetZoomBox(self, VD, result);
  end
  else
  begin
    result := nil;
  end;
end;

function TPhastModel.DoReservoirLayerUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoReservoirLayerUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoReservoirLayerUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoReservoirPackageUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoReservoirPackageUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoReservoirPackageUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.ResetSelectedScreenObjects: boolean;
var
  Index: integer;
  AScreenObject: TScreenObject;
begin
  // Deselect all objects.
  result := False;
  for Index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[Index];
    if AScreenObject.Selected then
    begin
      result := True;
      AScreenObject.Selected := False;
    end;
  end;
end;

function TPhastModel.ResIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.ResPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.ResPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.RestoreColoredDataSets;
var
  TimeIndex: integer;
begin
  if FTopTimeList <> nil then
  begin
    TimeIndex := FTopTimeList.FirstTimeGreaterThan(FTopDisplayTime) - 1;
    if TimeIndex < 0 then
    begin
      Grid.TopDataSet := nil;
    end
    else
    begin
      Grid.TopDataSet := FTopTimeList.Items[TimeIndex];
    end;
  end;

  if FFrontTimeList <> nil then
  begin
    TimeIndex := FFrontTimeList.FirstTimeGreaterThan(FFrontDisplayTime) - 1;
    if TimeIndex < 0 then
    begin
      Grid.FrontDataSet := nil;
    end
    else
    begin
      Grid.FrontDataSet := FFrontTimeList.Items[TimeIndex];
    end;
  end;

  if FSideTimeList <> nil then
  begin
    TimeIndex := FSideTimeList.FirstTimeGreaterThan(FSideDisplayTime) - 1;
    if TimeIndex < 0 then
    begin
      Grid.SideDataSet := nil;
    end
    else
    begin
      Grid.SideDataSet := FSideTimeList.Items[TimeIndex];
    end;
  end;

  if FThreeDTimeList <> nil then
  begin
    TimeIndex := FThreeDTimeList.FirstTimeGreaterThan(FThreeDDisplayTime) - 1;
    if TimeIndex < 0 then
    begin
      ThreeDDataSet := nil;
    end
    else
    begin
      ThreeDDataSet := FThreeDTimeList.Items[TimeIndex];
    end;
  end;
end;

function TPhastModel.RipIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.RipPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.RipPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.RivIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.RivPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.RivPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoRouteUzfDischarge(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoRouteUzfDischarge(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoRouteUzfDischarge(Sender);
      end;
    end;
  end;
end;

function TPhastModel.RvobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.RvobPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.RvobPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.ClearViewedItems;
var
  Index: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  PhastGrid.TopDataSet := nil;
  PhastGrid.FrontDataSet := nil;
  PhastGrid.SideDataSet := nil;
  PhastGrid.ThreeDDataSet := nil;

  PhastGrid.TopContourDataSet := nil;
  PhastGrid.FrontContourDataSet := nil;
  PhastGrid.SideContourDataSet := nil;
  PhastGrid.ThreeDContourDataSet := nil;

  FootPrintGrid.TopDataSet := nil;
  FootPrintGrid.FrontDataSet := nil;
  FootPrintGrid.SideDataSet := nil;
  FootPrintGrid.ThreeDDataSet := nil;

  FootPrintGrid.TopContourDataSet := nil;
  FootPrintGrid.FrontContourDataSet := nil;
  FootPrintGrid.SideContourDataSet := nil;
  FootPrintGrid.ThreeDContourDataSet := nil;
  for Index := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[Index].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.ClearViewedItems;
    end;
  end;
end;

function TPhastModel.DirectionCount(ViewDirection: TViewDirection): integer;
begin
  // This is needed in setting the selected column, row, or layer
  // with the ModelCube even when LGR is not used.
  result := 0;

//  if LgrUsed then
  begin
    case ViewDirection of
      vdTop: result := LayerCount;
      vdFront: result := RowCount;
      vdSide: result := ColumnCount;
      else Assert(False);
    end;
  end;
end;

procedure TPhastModel.DisallowChildGridUpdates;
var
  ChildModel: TChildModel;
  Index: Integer;
begin
  Inc(FChildGridUpdateCount);
  for Index := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[Index].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.CanUpdateGrid := False;
    end;
  end;
end;

function TPhastModel.DispersionSelected: boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mt3dmsDispersion.IsSelected;
  if not Result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.ModflowPackages.Mt3dmsDispersion.IsSelected;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateMapping;
begin
  if (Length(FColumnMapping) = 0)
    and (Grid <> nil) and (Grid.ColumnCount > 0)
    and (Grid.RowCount > 0)and (Grid.LayerCount > 0) then
  begin
    UpdateAMapping(FColumnMapping, vdSide);
    UpdateAMapping(FRowMapping, vdFront);
    UpdateAMapping(FLayerMapping, vdTop);
  end;
end;

function TPhastModel.CombinedCount(ViewDirection: TViewDirection): integer;
begin
  result := 0;
  case ViewDirection of
    vdTop: result := CombinedLayerCount;
    vdFront: result := CombinedRowCount;
    vdSide: result := CombinedColumnCount;
    else Assert(False);
  end;
end;

function TPhastModel.CombinedColumnCount: integer;
var
  ColIndex: Integer;
begin
  result := 0;
  case ModelSelection of
    msUndefined: result := 0;
    msPhast: result := PhastGrid.ColumnCount;
    msModflow, msModflowNWT, msModflowCfp, msModflow2015:
      begin
        result := ModflowGrid.ColumnCount;
      end;
    msModflowLGR, msModflowLGR2, msModflowFmp, msModflowOwhm2:
      begin
        result := 0;
        for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
        begin
          Inc(result, MaxChildColumnsPerColumn(ColIndex));
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        result := 0;
//        if SutraMesh = nil then
//        begin
//          result := 0;
//        end
//        else
//        begin
//          result := SutraMesh.LayerCount;
//        end;
      end;
    msFootPrint:
      begin
        result := FootPrintGrid.ColumnCount;
      end;
    else Assert(False);
  end;
end;

procedure TPhastModel.UpdateAMapping(var AMapping: TMappingArray;
  ViewDirection: TViewDirection);
var
  SubDisCount: Integer;
  ARange: TGridRange;
  ChildModel: TChildModel;
  ChildIndex: Integer;
  ChildCombinedIndex: Integer;
  SubDisIndex: Integer;
  MaxSubDiscretization: Integer;
  ParentDisIndex: Integer;
  CombinedIndex: Integer;
  Index: Integer;
  ArrayLength: Integer;
  MaximumPosition: Integer;
begin
  ArrayLength := CombinedCount(ViewDirection);
  SetLength(AMapping, ArrayLength);
  for Index := 0 to Length(AMapping) - 1 do
  begin
    SetLength(AMapping[Index].ChildPositions, ChildModels.Count);
  end;
  CombinedIndex := 0;
  for ParentDisIndex := 0 to DirectionCount(ViewDirection) - 1 do
  begin
    MaxSubDiscretization := MaxChildDisPerParentDis(
      ViewDirection, ParentDisIndex);
    for SubDisIndex := 0 to MaxSubDiscretization - 1 do
    begin
      ChildCombinedIndex := CombinedIndex + SubDisIndex;
      AMapping[ChildCombinedIndex].ParentPostion := ParentDisIndex;
    end;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        MaximumPosition := ChildModel.MaxPosition(ViewDirection);
        ARange := ChildModel.ParentPositionToChildPositions(ViewDirection,
          ParentDisIndex);
        SubDisCount := ARange.Last - ARange.First + 1;
        for SubDisIndex := 0 to MaxSubDiscretization - 1 do
        begin
          ChildCombinedIndex := CombinedIndex + SubDisIndex;
          if (ARange.First < 0) then
          begin
            AMapping[ChildCombinedIndex].ChildPositions[ChildIndex] := -1;
          end
          else if ARange.First >= MaximumPosition then
          begin
            AMapping[ChildCombinedIndex].ChildPositions[ChildIndex] :=
              MaximumPosition;
          end
          else if (SubDisIndex >= SubDisCount) then
          begin
            AMapping[ChildCombinedIndex].ChildPositions[ChildIndex]
              := AMapping[ChildCombinedIndex-1].ChildPositions[ChildIndex]
          end
          else
          begin
            AMapping[ChildCombinedIndex].ChildPositions[ChildIndex] :=
              ARange.First + SubDisIndex;
          end;
        end;
      end;
    end;
    Inc(CombinedIndex, MaxSubDiscretization);
  end;
end;

function TPhastModel.CombinedRowCount: integer;
var
  RowIndex: Integer;
begin
  result := 0;
  case ModelSelection of
    msUndefined: result := 0;
    msPhast: result := PhastGrid.RowCount;
    msModflow, msModflowNWT, msModflowCfp, msModflow2015:
      begin
        result := ModflowGrid.RowCount;
      end;
    msModflowLGR, msModflowLGR2, msModflowFmp, msModflowOwhm2:
      begin
        result := 0;
        for RowIndex := 0 to ModflowGrid.RowCount - 1 do
        begin
          Inc(result, MaxChildRowsPerRow(RowIndex));
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        result := 0;
//        if SutraMesh = nil then
//        begin
//          result := 0;
//        end
//        else
//        begin
//          result := SutraMesh.LayerCount;
//        end;
      end;
    msFootPrint:
      begin
        result := FootPrintGrid.RowCount;
      end;
    else Assert(False);
  end;
end;

function TPhastModel.CombinedLayerCount: integer;
var
  LayerIndex: Integer;
begin
  result := 0;
  case ModelSelection of
    msUndefined: result := 0;
    msPhast: result := PhastGrid.LayerCount;
    msModflow, msModflowNWT, msModflowCfp:
      begin
        result := ModflowGrid.LayerCount;
      end;
    msModflow2015:
      begin
        if DisvUsed then
        begin
          result := DisvGrid.LayerCount;
        end
        else
        begin
          result := ModflowGrid.LayerCount;
        end;
      end;
    msModflowLGR, msModflowLGR2, msModflowFmp, msModflowOwhm2:
      begin
        result := 0;
        for LayerIndex := 0 to ModflowGrid.LayerCount - 1 do
        begin
          Inc(result, MaxChildLayersPerLayer(LayerIndex));
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if SutraMesh = nil then
        begin
          result := 0;
        end
        else
        begin
          result := SutraMesh.LayerCount;
        end;
      end;
    msFootPrint:
      begin
        result := FootPrintGrid.LayerCount;
      end;
    else Assert(False);
  end;
end;

function TPhastModel.MaxChildDisPerParentDis(ViewDirection: TViewDirection;
  Position: integer): integer;
begin
  result := 0;
  case ViewDirection of
    vdTop: result := MaxChildLayersPerLayer(Position);
    vdFront: result := MaxChildRowsPerRow(Position);
    vdSide: result := MaxChildColumnsPerColumn(Position);
    else Assert(False);
  end;
end;

function TPhastModel.GncIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflow2015);
  if result then
  begin
    result := ModflowPackages.GncPackage.IsSelected;
    if not result and frmGoPhast.PhastModel.LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.GncPackage.IsSelected;
        end;
      end;
    end;
  end;
end;

function TPhastModel.GwtMobileBulkDensityUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.MobileBulkDensityDataArrayName = DataArray.Name;
      if result then
      begin
        GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
        MstPackage := GwtPackagesItem.GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
          and (MstPackage.Sorption <> gscNone);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtMobileDecayUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.MobileDecayRateDataArrayName = DataArray.Name;
      if result then
      begin
        GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
        MstPackage := GwtPackagesItem.GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
          and (MstPackage.ZeroOrderDecay or MstPackage.FirstOrderDecay);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwePorosityUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := ModflowPackages.GweEstPackage.IsSelected;
    if result then
    begin
      result := False;
      for Index := 0 to ChemSpecies.Count - 1 do
      begin
        AChemItem := ChemSpecies[Index];
        result := (AChemItem.Name = StrGweTemperature)
          and (AChemItem.GwePorosityDataArrayName = DataArray.Name);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GweUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtCncIsSelected: Boolean;
begin
  result := GwtUsed and (MobileComponents.Count > 0)
    and ModflowPackages.GwtCncPackage.IsSelected;
end;

function TPhastModel.DoGwtDispUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoGwtDispUsed(nil);
      end;
    end;
  end;
end;

function TPhastModel.GwtImmobileBulkDensityUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileBulkDensities.Count - 1 do
      begin
        result := AChemItem.ImmobileBulkDensities[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            result := IstPackage.IstPackageProperties[DomainIndex].Sorption;
            if result then
            begin
              Exit;
            end;
          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileCimUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileInitialConcentrations.Count - 1 do
      begin
        result := AChemItem.ImmobileInitialConcentrations[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            Exit;
          end;
//          begin
//            result := IstPackage.IstPackageProperties[DomainIndex].Sorption
//          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileDecaySorbedUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
    IstProp: TIstPackageItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileDecaySorbed.Count - 1 do
      begin
        result := AChemItem.ImmobileDecaySorbed[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            IstProp := IstPackage.IstPackageProperties[DomainIndex];
            result := IstProp.Sorption
              and (IstProp.FirstOrderDecay or IstProp.ZeroOrderDecay);
            if result then
            begin
              Exit;
            end;
          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileDecayUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
    IstProp: TIstPackageItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileDecay.Count - 1 do
      begin
        result := AChemItem.ImmobileDecay[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            IstProp := IstPackage.IstPackageProperties[DomainIndex];
            result := (IstProp.FirstOrderDecay or IstProp.ZeroOrderDecay);
            if result then
            begin
              Exit;
            end;
          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileDistCoefUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileDistCoeficients.Count - 1 do
      begin
        result := AChemItem.ImmobileDistCoeficients[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            result := IstPackage.IstPackageProperties[DomainIndex].Sorption;
            if result then
            begin
              Exit;
            end;
          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileFreundlichExponentSp2Used(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileFreundlichExponentSp2s.Count - 1 do
      begin
        result := AChemItem.ImmobileFreundlichExponentSp2s[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            result := IstPackage.IstPackageProperties[DomainIndex].SorptionType = gscFreundlich;
            if result then
            begin
              Exit;
            end;
          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileSorptionCapacitySp2Used(
  Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileSorptionCapacitySp2s.Count - 1 do
      begin
        result := AChemItem.ImmobileSorptionCapacitySp2s[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            result := IstPackage.IstPackageProperties[DomainIndex].SorptionType = gscLangmuir;
            if result then
            begin
              Exit;
            end;
          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;


function TPhastModel.GwtImmobileThetaimUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobilePorosities.Count - 1 do
      begin
        result := AChemItem.ImmobilePorosities[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            Exit;
          end;
//          if result then
//          begin
//            result := IstPackage.IstPackageProperties[DomainIndex].Sorption
//          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileVolumeFractUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileVolumeFractions.Count - 1 do
      begin
        result := AChemItem.ImmobileVolumeFractions[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            Exit;
          end;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtImmobileZetaimUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    IstPackage: TGwtIstPackage;
    DomainIndex: Integer;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      for DomainIndex := 0 to AChemItem.ImmobileMassTransferRates.Count - 1 do
      begin
        result := AChemItem.ImmobileMassTransferRates[DomainIndex] = DataArray.Name;
        if result then
        begin
          IstPackage :=  ModflowPackages.GwtPackages[Index].GwtIst;
          result := IstPackage.IsSelected
            and (DomainIndex < IstPackage.IstPackageProperties.Count);
          if result then
          begin
            Exit;
          end;
//          if result then
//          begin
//            result := IstPackage.IstPackageProperties[DomainIndex].Sorption
//          end;
        end;
//        Exit;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtMobileDistibutionCoefUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.MobileDistCoefDataArrayName = DataArray.Name;
      if result then
      begin
        GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
        MstPackage := GwtPackagesItem.GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
          and (MstPackage.Sorption <> gscNone);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtMobileFreundlichExponentUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.MobileFreundlichExponentDataArrayName = DataArray.Name;
      if result then
      begin
        GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
        MstPackage := GwtPackagesItem.GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
          and (MstPackage.Sorption = gscFreundlich);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtMobileSeparatePorosityUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.PorosityDataArrayName = DataArray.Name;
      if result then
      begin
        if ModflowPackages.GweEstPackage.IsSelected then
        begin
          if AChemItem.Name = StrGweTemperature then
          begin
            result := False;
          end
          else
          begin
            GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
            MstPackage := GwtPackagesItem.GwtMst;
            result := (MstPackage <> nil) and MstPackage.IsSelected
              and MstPackage.SeparatePorosity;
          end;
        end
        else
        begin
          GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
          MstPackage := GwtPackagesItem.GwtMst;
          result := (MstPackage <> nil) and MstPackage.IsSelected
            and MstPackage.SeparatePorosity;
        end;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed or GweUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtMobileSorbedDecayUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.MobileSorbedDecayRateDataArrayName = DataArray.Name;
      if result then
      begin
        GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
        MstPackage := GwtPackagesItem.GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
          and (MstPackage.ZeroOrderDecay or MstPackage.FirstOrderDecay)
          and (MstPackage.Sorption <> gscNone);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtMobileSorptionCapacityUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
    MstPackage: TGwtMstPackage;
    GwtPackagesItem: TGwtPackagesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.MobileSorptionCapacityDataArrayName = DataArray.Name;
      if result then
      begin
        GwtPackagesItem :=  ModflowPackages.GwtPackages[Index];
        MstPackage := GwtPackagesItem.GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
          and (MstPackage.Sorption = gscLangmuir);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
begin
  result := GwtUsed;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.GwtSrcIsSelected: Boolean;
begin
  result := GwtUsed and (MobileComponents.Count > 0)
    and ModflowPackages.GwtSrcPackage.IsSelected;
end;

function TPhastModel.DoGwtUztUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoGwtUztUsed(nil);
      end;
    end;
  end;
end;

function TPhastModel.MawIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflow2015);
  if result then
  begin
    result := ModflowPackages.MawPackage.IsSelected;
    if not result and frmGoPhast.PhastModel.LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.MawPackage.IsSelected;
        end;
      end;
    end;
  end;
end;

function TPhastModel.MaxChildColumnsPerColumn(ColIndex: Integer): integer;
var
  Range: TGridRange;
  ChildModel: TChildModel;
  ChildIndex: Integer;
begin
  result := 1;
  if not LgrUsed then
  begin
    Exit;
  end;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      Range := ChildModel.ParentColToChildCols(ColIndex);
      result := Max(result, Range.Last - Range.First + 1);
    end;
  end;
end;

function TPhastModel.MaxChildRowsPerRow(RowIndex: Integer): integer;
var
  Range: TGridRange;
  ChildModel: TChildModel;
  ChildIndex: Integer;
begin
  result := 1;
  if not LgrUsed then
  begin
    Exit;
  end;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      Range := ChildModel.ParentRowToChildRows(RowIndex);
      result := Max(result, Range.Last - Range.First + 1);
    end;
  end;
end;

function TPhastModel.Mf6GwtUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.Mf6GwtUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.Mf6ObsIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.Mf6ObsIsSelected;
      end;
    end;
  end;
end;

function TPhastModel.Mf6UzfInitialConcentrationUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.UztInitialConcDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection = msModflow2015)
    and GwtUsed
    and ModflowPackages.UzfMf6Package.IsSelected;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
//      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.Mf6VTransDispUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.TransverseVertDispDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection = msModflow2015)
    and ((GwtUsed
    and ModflowPackages.GwtDispersionPackage.IsSelected
    and ModflowPackages.GwtDispersionPackage.UseTransverseDispForVertFlow)
    or (GweUsed and ModflowPackages.GweConductionAndDispersionPackage.IsSelected));
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TPhastModel.Mnw2IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mnw2Package.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Mnw2Package.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.Mnw1IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Mnw1Package.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Mnw1Package.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.Mnw1LossTypes: TMnw1LossTypes;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := [];
  if ModflowPackages.Mnw1Package.IsSelected then
  begin
    Include(result, ModflowPackages.Mnw1Package.LossType);
  end;
  if not LgrUsed then
  begin
    Exit;
  end;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      if ChildModel.ModflowPackages.Mnw1Package.IsSelected then
      begin
        Include(result, ChildModel.ModflowPackages.Mnw1Package.LossType);
      end;
    end;
  end;
end;

function TPhastModel.MaxChildLayersPerLayer(LayerIndex: Integer): integer;
var
  Range: TGridRange;
  ChildModel: TChildModel;
  ChildIndex: Integer;
begin
  result := 1;
  if not LgrUsed then
  begin
    Exit;
  end;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      Range := ChildModel.ParentLayerToChildLayers(LayerIndex);
      result := Max(result, Range.Last - Range.First + 1);
    end;
  end;
end;

function TPhastModel.DoCombinedHorizontalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoCombinedHorizontalTransverseDispersionUsedPerSpecies(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoCombinedHorizontalTransverseDispersionUsedPerSpecies(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoConfinedStorageCoefUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoConfinedStorageCoefUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoConfinedStorageCoefUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoConfiningBedKzUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoConfiningBedKzUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoConfiningBedKzUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.ConvertPoint(VD: TViewDirection;
  const RealPoint: TPoint2D): TPoint;
begin
  Assert(Assigned(OnConvertPoint));
  OnConvertPoint(self, VD, RealPoint, result);
end;

procedure TPhastModel.CopyScreenObjectsToClipboard;
var
  Objects: TScreenObjectClipboard;
  Index: Integer;
  AScreenObject: TScreenObject;
  Item: TScreenObjectItem;
  MemStream: TMemoryStream;
  ClipStream: TStringStream;
begin
  inherited;
  Objects := TScreenObjectClipboard.Create(nil);
  try
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[Index];
      if AScreenObject.Selected then
      begin
        Item := Objects.ScreenObjects.Add as TScreenObjectItem;
        Item.SetScreenObject(AScreenObject);
      end;
    end;
    if Objects.ScreenObjects.Count > 0 then
    begin
      MemStream := TMemoryStream.Create;
      ClipStream := TStringStream.Create('');
      try
        MemStream.WriteComponent(Objects);
        MemStream.Position := 0;
        ClipStream.Position := 0;
        ObjectBinaryToText(MemStream, ClipStream);
        ClipStream.Position := 0;
        Clipboard.AsText := ClipStream.ReadString(ClipStream.Size);
      finally
        ClipStream.Free;
        MemStream.Free;
      end;
    end;
  finally
    Objects.Free;
  end;
end;

procedure TPhastModel.InitializeTimes;
begin
  ModelTimes.Clear;
  ModelTimes.Sorted := True;
  ModelTimes.Add(0);
  InitializePhastBoundaries;
  RecordTimeControl;
  DoInvalidate(self);
end;

function TPhastModel.DoInitialWaterTableUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoInitialWaterTableUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoInitialWaterTableUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.RchIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.RchPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.RchPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.RchTimeVaryingLayers: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.RchPackage.TimeVaryingLayers;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.RchPackage.TimeVaryingLayers;
      end;
    end;
  end;
end;

procedure TPhastModel.RecordTimeControl;
var
  Index: integer;
  TimeItem: TTimeItem;
begin
  for Index := 0 to Times.Count - 1 do
  begin
    TimeItem := Times.Items[Index] as TTimeItem;
    ModelTimes.AddUnique(TimeItem.EndingTime);
  end;
end;

function TPhastModel.DoInitialHeadUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoInitialHeadUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoInitialHeadUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.InitializeGages;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.InitializeGages
    end;
  end;
end;

procedure TPhastModel.InitializePhastBoundaries;
var
  Index: integer;
  TimeList: TCustomTimeList;
  TimeIndex: integer;
begin
  for Index := 0 to TimeListCount - 1 do
  begin
    TimeList := TimeLists[Index];
    if not (TimeList is TPhastTimeList) then
    begin
      Continue;
    end;
    TimeList.Initialize;
    for TimeIndex := 0 to TimeList.Count - 1 do
    begin
      ModelTimes.AddUnique(TimeList.Times[TimeIndex]);
    end;
  end;
end;

procedure TPhastModel.InitializeSfrWriter(EvaluationType: TEvaluationType);
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.InitializeSfrWriter(EvaluationType);
    end;
  end;
end;

type
  TComponentCrack = class(TComponent);

function TCustomModel.Layavg: TOneDIntegerArray;
begin
  result := LayerStructure.Layavg;
end;

function TCustomModel.LayerCount: integer;
begin
  result := -1;
  case ModelSelection of
    msUndefined: result := 0;
    msPhast:
      begin
        Result := PhastGrid.LayerCount;
      end;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
      begin
        result := LayerStructure.LayerCount;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if self is TPhastModel then
        begin
          result := TPhastModel(self).SutraLayerStructure.LayerCount;
        end
        else
        begin
          result := 0
        end;
      end;
    msFootPrint:
      begin
        result := FootPrintGrid.LayerCount;
      end;
    else
      Assert(False);
  end;

end;

function TCustomModel.LayerGroupUsed(LayerGroup: TLayerGroup): boolean;
begin
  result := True;
end;


function TCustomModel.Laytyp: TOneDIntegerArray;
begin
  result := LayerStructure.Laytyp;
end;

function TCustomModel.Layvka: TOneDIntegerArray;
begin
  result := LayerStructure.Layvka;
end;

function TCustomModel.LayerFractions(LayerGroup: TCustomLayerGroup): TDoubleDynArray;
var
  FractionIndex: Integer;
//  Fraction: Real;
begin
  if LayerGroup.RunTimeSimulated then
  begin
    SetLength(result, LayerGroup.LayerCollection.Count);
    for FractionIndex := 0 to LayerGroup.LayerCollection.Count - 1 do
    begin
      result[FractionIndex] := (LayerGroup.LayerCollection.Items[FractionIndex]
        as TLayerFraction).Fraction;
    end;
  end
  else
  begin
    result := nil;
  end;
end;

function TPhastModel.DoLakePackageUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoLakePackageUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoLakePackageUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.LakIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.LakPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.LakPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.LakMf6IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflow2015);
  if result then
  begin
    result := ModflowPackages.LakMf6Package.IsSelected;
    if not result and frmGoPhast.PhastModel.LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := ChildModel.ModflowPackages.LakMf6Package.IsSelected;
          if result then
          begin
            break;
          end;
        end;
      end;
    end;
  end;
end;

function TPhastModel.LakBathymetryUsed: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.LakPackage.IsSelected
    and (ModflowPackages.LakPackage.ExternalLakeChoice = elcAll);
  if frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or (ChildModel.ModflowPackages.LakPackage.IsSelected
          and (ChildModel.ModflowPackages.LakPackage.ExternalLakeChoice = elcAll));
      end;
    end;
  end;
end;

function TPhastModel.LgrUsed: boolean;
begin
  // Scott Boyce says LGR is experimental in MODFLOW-OWHM version 2.
  // 2/1/3024
  result := (ModelSelection in [msModflowLGR, msModflowLGR2, msModflowFmp {,
    msModflowOwhm2}])
    and (ChildModels.Count > 0);
end;

function TPhastModel.LgrV1Used: boolean;
begin
  result := (ModelSelection in [msModflowLGR])
    and (ChildModels.Count > 0);
end;

procedure TPhastModel.CheckObservationGUIDs;
var
  ObsItemDictionary: TObsItemDictionary;
  ObsItemList: TObservationInterfaceList;
  ItemIndex: Integer;
  ChildIndex: Integer;
  ObsItem: IObservationItem;
  ChildModel: TChildModel;
begin
  ObsItemDictionary := TObsItemDictionary.Create;
  ObsItemList:=  TObservationInterfaceList.Create;
  try
    FillObsInterfaceItemList(ObsItemList);
    for ItemIndex := 0 to ObsItemList.Count - 1 do
    begin
      ObsItem := ObsItemList[ItemIndex];
      if ObsItemDictionary.ContainsKey(ObsItem.GUID) then
      begin
        ObsItem.ReplaceGUID;
      end;
      ObsItemDictionary.Add(ObsItem.GUID, ObsItem);
    end;
    ObsItemList.Clear;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      ChildModel.FillObsInterfaceItemList(ObsItemList);
      for ItemIndex := 0 to ObsItemList.Count - 1 do
      begin
        ObsItem := ObsItemList[ItemIndex];
        if ObsItemDictionary.ContainsKey(ObsItem.GUID) then
        begin
          ObsItem.ReplaceGUID;
        end;
        ObsItemDictionary.Add(ObsItem.GUID, ObsItem);
      end;
    end;
  finally
    ObsItemList.Free;
    ObsItemDictionary.Free;
  end;

end;

procedure TPhastModel.Loaded;
var
  Index: integer;
  Component: TComponentCrack;
begin
  inherited;
  Mf6TimesSeries.Loaded;
  for Index := 0 to ComponentCount - 1 do
  begin
    Component := TComponentCrack(Components[Index]);
    Component.Loaded;
  end;
  if not FDiffusivitySet then
  begin
    FDiffusivity := 0;
  end;
  SwrObservations.Loaded;
//  Farms.Loaded;

  UpdateTimeLists;

  if GuiSettings.FrontHeight <= 0 then
  begin
    GuiSettings.FrontHeight := 1;
  end;
  if GuiSettings.SideWidth <= 0 then
  begin
    GuiSettings.SideWidth := 1;
  end;
  ModflowTransientParameters.Loaded;
  if (ModelSelection in ModflowSelection)
    and not LgrUsed then
  begin
    if Grid <> nil then
    begin
      CombinedDisplayColumn := Grid.DisplayColumn;
      CombinedDisplayRow := Grid.DisplayRow;
      CombinedDisplayLayer := Grid.DisplayLayer;
    end;
  end;
  FSutraMesh.Assign(SutraSettings);
  SetMf2005ObsGroupNames;
end;

procedure TPhastModel.InvalidateSegments;
var
  Index: integer;
  AScreenObject: TScreenObject;
begin
  if SomeSegmentsUpToDate then
  begin
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[Index];
      AScreenObject.InvalidateSegments;
    end;
    SomeSegmentsUpToDate := False;
  end
  else
  begin
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[Index];
      AScreenObject.InvalidateCachedCells;
    end;
  end;
end;

function TPhastModel.IsChildModelEdgeCell(Col, Row, Layer: integer;
  out CModel: TBaseModel): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  LastLayer: integer;
begin
  result := False;
  CModel := nil;
  if LgrUsed then
  begin
    result := IsChildModelEdgeColRow(Col, Row, Layer, CModel);
    if not result then
//    begin
//      ChildModel := CModel as TChildModel;
//    end;
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          LastLayer := ChildModel.Discretization.BottomLayerIndex;
          if (Layer = LastLayer)
            and (LastLayer <> ModflowGrid.LayerCount - 1)
            and (Col >= ChildModel.FirstCol)
            and (Col <= ChildModel.LastCol)
            and (Row >= ChildModel.FirstRow)
            and (Row <= ChildModel.LastRow) then
          begin
            result := True;
            CModel := ChildModel;
            break;
          end;
        end;
      end;
    end;
  end;
end;

function TPhastModel.IsChildModelEdgeColRow(Col, Row, Layer: integer;
  out CModel: TBaseModel) : boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  ChildModel := nil;
  result := False;
  if LgrV1Used then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        if (Col = ChildModel.FirstCol)
          or (Col = ChildModel.LastCol) then
        begin
          if (Row >= ChildModel.FirstRow)
            and (Row <= ChildModel.LastRow) then
          begin
            if Layer <= ChildModel.Discretization.BottomLayerIndex then
            begin
              result := True;
              break;
            end;
          end;
        end
        else if (Row = ChildModel.FirstRow)
          or (Row = ChildModel.LastRow) then
        begin
          if (Col >= ChildModel.FirstCol)
            and (Col <= ChildModel.LastCol) then
          begin
            if Layer <= ChildModel.Discretization.BottomLayerIndex then
            begin
              result := True;
              break;
            end;
          end;
        end;
      end;
    end;
  end;
  CModel := ChildModel;
end;

function TPhastModel.IsCurrentScreenObject(
  ScreenObject: TScreenObject): boolean;
begin
  if Assigned(OnCheckScreenObject) then
  begin
    OnCheckScreenObject(self, ScreenObject, result);
  end
  else
  begin
    result := False;
  end;
end;

function TPhastModel.DoKineticsUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoKineticsUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoKineticsUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoKyUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoKyUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoKyUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoKzUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoKzUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoKzUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateDrainReturnObjects;
var
  Index: Integer;
  SortedScreenObjectList: TStringList;
  ObjectIndex: Integer;
  ObjectName: string;
  ScreenObject: TScreenObject;
  DrainReturn: TDrainReturn;
begin
  SortedScreenObjectList := TStringList.Create;
  try
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObject := ScreenObjects[Index];
      if ScreenObject.Deleted then
      begin
        Continue;
      end;
      SortedScreenObjectList.AddObject(ScreenObject.Name, ScreenObject);
    end;
    SortedScreenObjectList.Sort;
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObject := ScreenObjects[Index];
      if ScreenObject.Deleted then
      begin
        Continue;
      end;
      if ScreenObject.ModflowDrtBoundary <> nil then
      begin
        DrainReturn := ScreenObject.ModflowDrtBoundary.DrainReturn;
        if DrainReturn.ReturnChoice = rtObject then
        begin
          ObjectName := DrainReturn.ReturnObject.ObjectName;
          if ObjectName <> '' then
          begin
            ObjectIndex := SortedScreenObjectList.IndexOf(ObjectName);
            if ObjectIndex >= 0 then
            begin
              DrainReturn.ReturnObject.ScreenObject :=
                SortedScreenObjectList.Objects[ObjectIndex];
            end;
          end;
        end;
      end;
    end;
  finally
    SortedScreenObjectList.Free;
  end;
end;

procedure TPhastModel.SetFarms(const Value: TFarmCollection);
begin
  FFarms.Assign(Value);
//  FFmpCrops.UpdateFarmProperties;
end;

procedure TPhastModel.SetFileName(const Value: string);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.SetFileName(Value);
    end;
  end;
end;

procedure TPhastModel.SetFishnetMeshGenerator(
  const Value: TFishnetMeshGenerator);
begin
  FFishnetMeshGenerator.Assign(Value);
end;

procedure TPhastModel.SetFlowOnly(const Value: boolean);
begin
  SoluteTransport := not Value;
end;

procedure TPhastModel.SetFmpAllotment(const Value: TAllotmentCollection);
begin
  FFmpAllotment.Assign(Value);
end;

procedure TPhastModel.SetFmpClimate(const Value: TClimateCollection);
begin
  FFmpClimate.Assign(Value);
end;

procedure TPhastModel.SetFmpCrops(const Value: TCropCollection);
begin
  FFmpCrops.Assign(Value);
end;

procedure TPhastModel.SetFmpSoils(const Value: TSoilCollection);
begin
  FFmpSoils.Assign(Value);
end;

procedure TPhastModel.SetFootprintProperties(const Value: TFootprintProperties);
begin
  FootprintProperties.Assign(Value);
end;

procedure TPhastModel.SetMf2005ObsGroupNames;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.SetMf2005ObsGroupNames;
    end;
  end;
end;

procedure TPhastModel.SetDiffusivity(const Value: double);
begin
  if FDiffusivity <> Value then
  begin
    FDiffusivity := Value;
    DoInvalidate(self);
  end;
  FDiffusivitySet := True;
end;

procedure TPhastModel.SetDisplaySettings(
  const Value: TDisplaySettingsCollection);
begin
  FDisplaySettings.Assign(Value);
end;

function TCustomModel.ModelResultsRequired(Sender: TObject): boolean;
begin
  result := False;
end;

function TPhastModel.DoModflowInitialHeadUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoModflowInitialHeadUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModels[ChildIndex].ChildModel.DoModflowInitialHeadUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoModflowUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoModflowUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoModflowUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.Modpath5IsSelected: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Modpath.IsSelected
    and (ModflowPackages.Modpath.MpathVersion = mp5);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Modpath.IsSelected
          and (ChildModel.ModflowPackages.Modpath.MpathVersion = mp5);
      end;
    end;
  end;
end;

function TPhastModel.Modpath6IsSelected: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Modpath.IsSelected
    and (ModflowPackages.Modpath.MpathVersion = mp6);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Modpath.IsSelected
          and (ChildModel.ModflowPackages.Modpath.MpathVersion = mp5);
      end;
    end;
  end;
end;

function TPhastModel.Modpath7IsSelected: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Modpath.IsSelected
    and (ModflowPackages.Modpath.MpathVersion = mp7);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Modpath.IsSelected
          and (ChildModel.ModflowPackages.Modpath.MpathVersion = mp5);
      end;
    end;
  end;
end;

procedure TPhastModel.ModpathHeadWarning;
var
  HeadOC: THeadDrawdownOutputControl;
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  frmErrorsAndWarnings.RemoveWarningGroup(self,StrWrongHeadModpath);
  if ModflowPackages.Modpath.IsSelected
    and (ModflowPackages.Modpath.MpathVersion = mp6) then
  begin
    HeadOC := ModflowOutputControl.HeadOC;
    if HeadOC.OutputFileType = oftText then
    begin
      frmErrorsAndWarnings.AddWarning(self,
        StrWrongHeadModpath, StrWrongHeadModpathDetailed);
    end;
  end;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if (ChildModel <> nil) then
      begin
        frmErrorsAndWarnings.RemoveWarningGroup(ChildModel,StrWrongHeadModpath);
        if ChildModel.ModflowPackages.Modpath.IsSelected
          and (ChildModel.ModflowPackages.Modpath.MpathVersion = mp6) then
        begin
          HeadOC := ChildModel.ModflowOutputControl.HeadOC;
          if HeadOC.OutputFileType = oftText then
          begin
            frmErrorsAndWarnings.AddWarning(ChildModel,
              StrWrongHeadModpath, StrWrongHeadModpathDetailed);
          end;
        end;
      end;
    end;
  end;
end;

//function TPhastModel.Mt3dIsSelected: Boolean;
//var
//  ChildIndex: Integer;
//  ChildModel: TChildModel;
//begin
//  result := ModflowPackages.Mt3dBasic.IsSelected;
//  if not result and LgrUsed then
//  begin
//    for ChildIndex := 0 to ChildModels.Count - 1 do
//    begin
//      ChildModel := ChildModels[ChildIndex].ChildModel;
//      if ChildModel <> nil then
//      begin
//        result := result or ChildModel.ModflowPackages.Mt3dBasic.IsSelected;
//      end;
//    end;
//  end;
//end;

function TPhastModel.MODPATHIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.Modpath.IsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.Modpath.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.ModpathUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited ModpathUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.ModpathUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoModpathZonesNeeded(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoModpathZonesNeeded(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoModpathZonesNeeded(Sender);
      end;
    end;
  end;
end;

function TPhastModel.ModDispDataArrayUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TMobileChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TMobileChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.DiffusionCoefDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and AnyDispersionMultiDiffusion;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents);
  end;
end;

function TPhastModel.Mt3dMsInitialConcUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.InitialConcDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and (ModflowPackages.Mt3dBasic.IsSelected or GwtUsed or GweUsed);
  if result then
  begin
    DataArray := Sender as TDataArray;
    if ModflowPackages.Mt3dBasic.IsSelected then
    begin
      result := DataArrayUsed(MobileComponents)
        or DataArrayUsed(ImmobileComponents);
    end
    else if GwtUsed or GweUsed then
    begin
      result := DataArrayUsed(MobileComponents);
    end;
  end;
end;

function TPhastModel.Mt3dIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.Mt3dIsSelected;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.DoMt3dMSBulkDensityUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoMt3dMS_StrictUsed(Sender)
    and inherited DoMt3dMSBulkDensityUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.DoMt3dMSBulkDensityUsed(Sender);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.Mt3dMsFirstSorbParamUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.FirstSorbParamDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.SorptionChoice <> scNone);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.DoMt3dMSImmobPorosityUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoMt3dMS_StrictUsed(Sender)
    and inherited DoMt3dMSImmobPorosityUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.DoMt3dMSImmobPorosityUsed(Sender);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.Mt3dMsSecondSorbParamUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.SecondSorbParamDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.SorptionChoice <> scNone);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.Mt3dmsReactionRateDisolvedUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.ReactionRateDisolvedDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.KineticChoice <> kcNone);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.Mt3dmsReactionRateSorbedUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.ReactionRateSorbedDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.KineticChoice <> kcNone);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

procedure TCustomModel.RenameOldVerticalLeakance;
const
  OldVerticalConductance = 'Vertical_Conductance';
var
  DataArray: TDataArray;
  VarIndex: Integer;
  DA: TDataArray;
  CompilerIndex: Integer;
  CompilerList: TList;
  Compiler: TRbwParser;
begin
  DataArray := DataArrayManager.GetDataSetByName(OldVerticalConductance);
  if DataArray <> nil then
  begin
    DA := DataArrayManager.GetDataSetByName(StrVerticalConductance);
    if DA <> nil then
    begin
      DataArrayManager.ExtractDataSet(DA);
      CompilerList := TList.Create;
      try
        FillCompilerList(CompilerList);
        for CompilerIndex := 0 to CompilerList.Count - 1 do
        begin
          Compiler := CompilerList[CompilerIndex];
          VarIndex := Compiler.IndexOfVariable(DA.Name);
          if VarIndex >= 0 then
          begin
            Compiler.RemoveVariable(Compiler.Variables[VarIndex] as TCustomVariable);
          end;
        end;
      finally
        CompilerList.Free;
      end;
      RenameDataArray(DataArray, StrVerticalConductance,
        StrVerticalConductanceDisplayName);
      DataArray.OnDataSetUsed := DA.OnDataSetUsed;
      DA.Free;
    end;
  end;
//  end;
end;


procedure TCustomModel.RestoreSubscriptions;
begin
  FormulaManager.RestoreSubscriptions;
end;

function TPhastModel.Mt3dMsSorbImmobInitialConcUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.SorbOrImmobInitialConcDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.OtherInitialConcChoice = oicUse);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.Mt3dmsSsmIsSelected: Boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := Mt3dIsSelected;
  if result then
  begin
    result := ModflowPackages.Mt3dmsSourceSink.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.Mt3dmsSourceSink.IsSelected;
        end;
      end;
    end;
  end;
end;

function TPhastModel.Mt3dmsTobIsSelected: Boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := Mt3dIsSelected;
  if result then
  begin
    result := ModflowPackages.Mt3dmsTransObs.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.Mt3dmsTransObs.IsSelected;
        end;
      end;
    end;
  end;
end;

//function TPhastModel.Mt3dMSUsed(Sender: TObject): boolean;
//var
//  ChildIndex: Integer;
//  ChildModel: TChildModel;
//begin
//  result := inherited;
//  if not result and LgrUsed then
//  begin
//    for ChildIndex := 0 to ChildModels.Count - 1 do
//    begin
//      ChildModel := ChildModels[ChildIndex].ChildModel;
//      if ChildModel <> nil then
//      begin
//        result := ChildModel.Mt3dMSUsed(Sender);
//        if result then
//        begin
//          Exit;
//        end;
//      end;
//    end;
//  end;
//end;

function TPhastModel.DoMt3dMS_StrictUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoMt3dMS_StrictUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.Mt3dUsgsDualSeparateUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.ImmobilePartioningCoefficientDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.SorptionChoice = scDualWithDifferingConstants);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.Mt3dUsgsMonodUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      result := AChemItem.HalfSaturationConstantDataArrayName = DataArray.Name;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.KineticChoice = kcMonod);
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
      or DataArrayUsed(ImmobileComponents);
  end;
end;

function TPhastModel.Mt3d_UztEtIsSelected: Boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := Mt3dIsSelected;
  if result then
  begin
    result := ModflowPackages.Mt3dUnsatTransport.IsSelected
      and ModflowPackages.UzfPackage.IsSelected
      and ModflowPackages.UzfPackage.SimulateET;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := ChildModel.ModflowPackages.Mt3dUnsatTransport.IsSelected
            and ChildModel.ModflowPackages.UzfPackage.IsSelected
            and ChildModel.ModflowPackages.UzfPackage.SimulateET;
          if result then
          begin
            Exit;
          end;
        end;
      end;
    end;
  end;
end;


function TPhastModel.DoMt3d_LktIsSelected(Sender: TObject): Boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := Mt3dIsSelected;
  if result then
  begin
    result := ModflowPackages.Mt3dLkt.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.DoMt3d_LktIsSelected(Sender);
        end;
      end;
    end;
  end;
end;

function TPhastModel.Mt3d_SftIsSelected: Boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := Mt3dIsSelected;
  if result then
  begin
    result := ModflowPackages.Mt3dSft.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.Mt3dSft.IsSelected;
        end;
      end;
    end;
  end;
end;

function TPhastModel.Mt3d_UztIsSelected: Boolean;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  result := Mt3dIsSelected;
  if result then
  begin
    result := ModflowPackages.Mt3dUnsatTransport.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.Mt3dUnsatTransport.IsSelected;
        end;
      end;
    end;
  end;
end;

function TPhastModel.MvrIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.MvrPackage.IsSelected and (ModelSelection = msModflow2015);
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.MvrPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.EndDataSetUpdate;
begin
  Dec(FDataSetUpdateCount);
end;

procedure TPhastModel.EndGridChange;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  if ChildModels <> nil then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.EndGridChange;
      end;
    end;
  end;
end;

procedure TPhastModel.EndScreenObjectUpdate;
begin
  Dec(FScreenObjectUpdateCount);
  ScreenObjectsChanged(nil);
end;

function TPhastModel.SubIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.SubPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.SubPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.SubsidenceDataArrayUsed(Sender: TObject): boolean;
var
  Index: Integer;
  Group: TLayerGroup;
  DataArray: TDataArray;
  SubDataSetIndex: Integer;
  NoDelayItem: TSubNoDelayBedLayerItem;
  DelayItem: TSubDelayBedLayerItem;
  WT_Item: TSwtWaterTableItem;
begin
  result := (ModelSelection in ModflowSelection)
    and (ModelSelection <> msModflow2015)
    and ModflowPackages.SubPackage.IsSelected;
  if result then
  begin
//    result := False;
    DataArray := Sender as TDataArray;
    for Index := 0 to LayerStructure.Count - 1 do
    begin
      Group := LayerStructure[Index];
      for SubDataSetIndex := 0 to Group.SubNoDelayBedLayers.Count - 1 do
      begin
        NoDelayItem := Group.SubNoDelayBedLayers[SubDataSetIndex];
        if (NoDelayItem.PreconsolidationHeadDataArrayName = DataArray.Name)
          or (NoDelayItem.ElasticSkeletalStorageCoefficientDataArrayName = DataArray.Name)
          or (NoDelayItem.InelasticSkeletalStorageCoefficientDataArrayName = DataArray.Name)
//          or (NoDelayItem.InitialCompactionDataArrayName = DataArray.Name)
          then
        begin
          result := True;
          Exit;
        end;
        if ModelSelection in [msModflowFmp, msModflowOwhm2] then
        begin
          if (NoDelayItem.InitialElasticCompactionDataArrayName = DataArray.Name)
            or (NoDelayItem.InitialInelasticCompactionDataArrayName = DataArray.Name)
            then
          begin
            result := True;
            Exit;
          end;
        end
        else
        begin
          if (NoDelayItem.InitialCompactionDataArrayName = DataArray.Name)
            then
          begin
            result := True;
            Exit;
          end;
        end;
      end;
      for SubDataSetIndex := 0 to Group.SubDelayBedLayers.Count - 1 do
      begin
        DelayItem := Group.SubDelayBedLayers[SubDataSetIndex];
        if (DelayItem.EquivNumberDataArrayName = DataArray.Name)
          or (DelayItem.VerticalHydraulicConductivityDataArrayName = DataArray.Name)
          or (DelayItem.ElasticSpecificStorageDataArrayName = DataArray.Name)
          or (DelayItem.InelasticSpecificStorageDataArrayName = DataArray.Name)
//          or (DelayItem.InterbedStartingCompactionDataArrayName = DataArray.Name)
          or (DelayItem.InterbedEquivalentThicknessDataArrayName = DataArray.Name)
          then
        begin
          result := True;
          Exit;
        end
        else if (DelayItem.InterbedStartingHeadDataArrayName = DataArray.Name)
          or (DelayItem.InterbedPreconsolidationHeadDataArrayName = DataArray.Name)
          then
        begin
          result := ModflowPackages.SubPackage.ReadDelayRestartFileName = '';
          Exit;
        end;
        if ModelSelection in [msModflowFmp, msModflowOwhm2] then
        begin
          if (DelayItem.InterbedStartingElasticCompactionDataArrayName = DataArray.Name)
            or (DelayItem.InterbedStartingInelasticCompactionDataArrayName = DataArray.Name)
            then
          begin
            result := True;
            Exit;
          end
        end
        else
        begin
          if (DelayItem.InterbedStartingCompactionDataArrayName = DataArray.Name) then
          begin
            result := True;
            Exit;
          end
        end;

      end;
    end;
  end;
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.SwtPackage.IsSelected;
  if result then
  begin
    result := False;
    DataArray := Sender as TDataArray;
    for Index := 0 to LayerStructure.Count - 1 do
    begin
      Group := LayerStructure[Index];
      for SubDataSetIndex := 0 to Group.WaterTableLayers.Count - 1 do
      begin
        WT_Item := Group.WaterTableLayers[SubDataSetIndex];
        if (WT_Item.WaterTableCompressibleThicknessDataArrayName = DataArray.Name)
          or (WT_Item.WaterTableInitialVoidRatioDataArrayName = DataArray.Name)
          or (WT_Item.WaterTableInitialCompactionDataArrayName = DataArray.Name)
          then
        begin
          result := True;
          Exit;
        end;
        if (WT_Item.WaterTableInitialElasticSkeletalSpecificStorageDataArrayName = DataArray.Name)
          or (WT_Item.WaterTableInitialInelasticSkeletalSpecificStorageDataArrayName = DataArray.Name)
          then
        begin
          result := ModflowPackages.SwtPackage.CompressionSource = csSpecificStorage;
          Exit;
        end;
        if (WT_Item.WaterTableRecompressionIndexDataArrayName = DataArray.Name)
          or (WT_Item.WaterTableCompressionIndexDataArrayName = DataArray.Name)
          then
        begin
          result := ModflowPackages.SwtPackage.CompressionSource = csCompressionReComp;
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.DoSurfacesUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSurfacesUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSurfacesUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.SwrIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.SwrIsSelected;
      end;
    end;
  end;
end;

function TPhastModel.SwtIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.SwtPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.SwtPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoSwtOffsetsUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSwtOffsetsUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSwtOffsetsUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSwtSelected(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSwtSelected(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSwtSelected(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSwtSpecifiedUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSwtSpecifiedUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSwtSpecifiedUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.FixSpecifyingGridByThreeDObjects;
var
  DataSetList: TDataArrayList;
  ObjectIndex: Integer;
  AScreenObject: TScreenObject;
  DataArrayIndex: integer;
begin
  FFixingModel := True;
  DataSetList := TDataArrayList.Create;
  try
    GetLayerDataArrays(DataSetList);
    if DataSetList.Count = 0 then
    begin
      Exit;
    end;
    for ObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ObjectIndex];
      if AScreenObject.ElevationCount in [ecOne, ecTwo] then
      begin
        for DataArrayIndex := 0 to DataSetList.Count - 1 do
        begin
          AScreenObject.RemoveDataSet(DataSetList[DataArrayIndex]);
        end;
      end;
    end;
  finally
    DataSetList.Free;
    FFixingModel := False;
  end;
end;

procedure TPhastModel.FixScreenObjectNames;
var
  Names: TStringList;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  DuplicatesFound: Boolean;
  NewIndex: Integer;
  NewName: string;
begin
  Names := TStringList.Create;
  try
    repeat
      Names.Clear;
      DuplicatesFound := False;
      Names.Capacity := ScreenObjectCount;
      for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
      begin
        AScreenObject := ScreenObjects[ScreenObjectIndex];
        Names.AddObject(AScreenObject.Name, AScreenObject);
      end;
      Names.CaseSensitive := False;
      Names.Sorted := True;
      NewIndex := Names.Count + 1;
      for ScreenObjectIndex := 1 to Names.Count - 1 do
      begin
        if SameText(Names[ScreenObjectIndex], Names[ScreenObjectIndex-1]) then
        begin
          DuplicatesFound := True;
          NewName := Format('Object%d', [NewIndex]);
          While Names.IndexOf(NewName) >= 0 do
          begin
            Inc(NewIndex);
            NewName := Format('Object%d', [NewIndex]);
          end;
          AScreenObject := Names.Objects[ScreenObjectIndex] as TScreenObject;
          AScreenObject.Name := NewName;
          Inc(NewIndex);
        end;
      end;
    until not DuplicatesFound
  finally
    Names.Free;
  end;
  FreeAndNil(FSortedObjectList);
end;

procedure TPhastModel.UpdateFarmProperties;
begin
  FmpCrops.UpdateFarmProperties;
end;

procedure TPhastModel.FixMvr;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  ModflowMvr: TMvrBoundary;
  ReceiverCount: Integer;
  TimeIndex: Integer;
  MvrItem: TMvrItem;
begin
  if (ModelSelection = msModflow2015) and ModflowPackages.MvrPackage.IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      ModflowMvr := AScreenObject.ModflowMvr;
      if ModflowMvr <> nil then
      begin
        ReceiverCount := ModflowMvr.Receivers.Count;
        for TimeIndex := 0 to ModflowMvr.Values.Count - 1 do
        begin
          MvrItem := ModflowMvr.Values[TimeIndex] as TMvrItem;
          if ReceiverCount < MvrItem.Items.Count then
          begin
            MvrItem.Items.Count := ReceiverCount;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.FixOldModel;
var
  ModpathZone: TDataArray;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  LakeIDArray: TDataArray;
  ModflowLakBoundary: TLakBoundary;
  SfrBoundary: TSfrBoundary;
  ParamItem: TSfrParamIcalcItem;
  SegItem: TCustomModflowBoundaryItem;
  TempBool: boolean;
  TempSelected: Boolean;
  ChannelItem: TSfrChannelItem;
  ItemIndex: Integer;
  ModelIndex: Integer;
  ChildModel: TChildModel;
  DepthRateIndexDataArray: TDataArray;
  SwrReachDataArray: TDataArray;
  GlobalVariableIndex: Integer;
  ChildIndex: Integer;
  AGlobalVariable: IGlobalVariable;
  CompilerIndex: Integer;
  ACompiler: TRbwParser;
  VarIndex: Integer;
  CompilerList: TList;
  DischargeRoutingArray: TDataArray;
  HfbParamNames: TStringList;
  ParamIndex: Integer;
  AParam: TModflowSteadyParameter;
  ModflowHfbBoundary: THfbBoundary;
  Sfr6Boundary: TSfrMf6Boundary;
  Sfr6DiversionCount: Integer;
  SfrMf6Item: TSfrMf6Item;
  FootprintWell: TFootprintWell;
  Withdrawals: TDataArray;
  Position: Integer;
  UnsatNodeDataArray: TDataArray;
  UnsatElementDataArray: TDataArray;
  UpdatedDataArray: TDataArray;
begin

  FixMvr;
  UpdateFarmProperties;

  CheckObservationGUIDs;


  FixScreenObjectNames;
  RenameOldVerticalLeakance;
  FixSpecifyingGridByThreeDObjects;

//  if SwiObsUsed(nil) and FileVersionEqualOrEarlier('4.3.0.65') then
//  begin
//    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
//    begin
//      AScreenObject := ScreenObjects[ScreenObjectIndex];
//      ModflowSwiObservations := AScreenObject.ModflowSwiObservations;
//      if (ModflowSwiObservations <> nil) and ModflowSwiObservations.Used then
//      begin
//        ModflowSwiObservations.SwiPostProcessor := sppSwiExtractor;
//      end;
//    end;
//  end;

  if SfrIsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      SfrBoundary := AScreenObject.ModflowSfrBoundary;
      if (SfrBoundary <> nil) and SfrBoundary.Used then
      begin
        if SfrBoundary.ParamIcalc.Count < SfrBoundary.ChannelValues.Count then
        begin
          for ItemIndex := SfrBoundary.ChannelValues.Count - 1 downto 0 do
          begin
            ChannelItem := SfrBoundary.ChannelValues.Items[ItemIndex];
            if ChannelItem.StartTime >= ChannelItem.EndTime then
            begin
              SfrBoundary.ChannelValues.Delete(ItemIndex);
            end;
          end;
          while SfrBoundary.ParamIcalc.Count < SfrBoundary.ChannelValues.Count do
          begin
            SfrBoundary.ChannelValues.Delete(SfrBoundary.ChannelValues.Count-1);
          end;
        end;
      end;
    end;
  end;

  if Sfr6IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      Sfr6Boundary := AScreenObject.ModflowSfr6Boundary;
      if Sfr6Boundary <> nil then
      begin
        Sfr6DiversionCount := Sfr6Boundary.Diversions.Count;
        for ItemIndex := 0 to Sfr6Boundary.Values.Count - 1 do
        begin
          SfrMf6Item := Sfr6Boundary.Values[ItemIndex] as TSfrMf6Item;
          SfrMf6Item.DiversionCount := Sfr6DiversionCount;
        end;
      end;
    end;
  end;

//  if FileVersionEqualOrEarlier('3.3.0.10') then
//  begin
//    // Changed how intersected objects are used so that if the length
//    // of intersection is small enough, it is treated as not intersecting.
//    FDataArrayManager.InvalidateAllDataSets;
//  end;

  if FileVersionEqualOrEarlier('3.10.0.65') then
  begin
    // Fixed evaluation of formulas that involve both 2D and 3D data sets.
    FDataArrayManager.InvalidateAllDataSets;
  end;


  if FileVersionEqualOrEarlier('2.6.0.8') then
  begin
    // Modpath zone incorrectly limited to values >= 0 in
    // version 2.6.0.8 and earlier.
    ModpathZone := FDataArrayManager.GetDataSetByName(StrModpathZone);
    if ModpathZone <> nil then
    begin
      ModpathZone.CheckMin := False;
      ModpathZone.Invalidate;
    end;
  end;

  if FileVersionEqualOrEarlier('4.3.0.67') then
  begin
    LakeIDArray := DataArrayManager.GetDataSetByName(rsLakeID);
    if LakeIDArray <> nil then
    begin
      for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
      begin
        AScreenObject := ScreenObjects[ScreenObjectIndex];
        ModflowLakBoundary := AScreenObject.ModflowLakBoundary;
        if (ModflowLakBoundary = nil) or not ModflowLakBoundary.Used then
        begin
          AScreenObject.RemoveDataSet(LakeIDArray);
        end;
      end;
      LakeIDArray.Invalidate;
    end;
  end;

  if FileVersionEqualOrEarlier('2.11.0.5')
    and not ModflowPackages.NwtPackage.IsSelected then
  begin
    ModflowPackages.NwtPackage.FluxTolerance.Value := 0.06;
  end;

  if FileVersionEqualOrEarlier('2.12.0.1') then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      SfrBoundary := AScreenObject.ModflowSfrBoundary;
      if SfrBoundary <> nil then
      begin
        while SfrBoundary.ParamIcalc.Count < SfrBoundary.SegmentFlows.Count do
        begin
          ParamItem := SfrBoundary.ParamIcalc.Add as TSfrParamIcalcItem;
          if ParamItem.Index > 0 then
          begin
            ParamItem.Assign(SfrBoundary.ParamIcalc.Items[ParamItem.Index-1]);
          end;
          SegItem := SfrBoundary.SegmentFlows.Items[ParamItem.Index] as TCustomModflowBoundaryItem;
          ParamItem.StartTime := SegItem.StartTime;
          ParamItem.EndTime := SegItem.EndTime;
        end;
      end;
    end;
  end;

  if FileVersionEqualOrEarlier('2.16.1.1')
    and ModflowPackages.ModPath.IsSelected then
  begin
    ModflowPackages.ModPath.MpathVersion := mp5;
    ModflowPackages.ModPath.StopOption := soExtend;
  end;

  if FileVersionEqualOrEarlier('2.17.1.9')
    and not ModflowPackages.NwtPackage.IsSelected then
//    or (ModflowPackages.NwtPackage.Option <> noSpecified))  then
  begin
    TempBool := ModflowPackages.NwtPackage.ContinueNWT;
    TempSelected := ModflowPackages.NwtPackage.IsSelected;
    ModflowPackages.NwtPackage.InitializeVariables;
    ModflowPackages.NwtPackage.IsSelected := TempSelected;
    if ModflowPackages.NwtPackage.IsSelected then
    begin
      ModflowPackages.NwtPackage.ContinueNWT := TempBool;
    end;
  end;

  if FileVersionEqualOrEarlier('2.19.1.25') then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount -1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      SfrBoundary := AScreenObject.ModflowSfrBoundary;
      if SfrBoundary <> nil then
      begin
        SfrBoundary.FixCollections;
      end;
    end;
  end;
  FixFhbItems;

  if FileVersionEqualOrEarlier('3.6.2.10') then
  begin
    if not ModflowPackages.SwiPackage.IsSelected then
    begin
      ModflowPackages.SwiPackage.TipSlope.Value := 0.04;
      ModflowPackages.SwiPackage.ToeSlope.Value := 0.04;
    end;

    for ModelIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ModelIndex].ChildModel;
      if ChildModel <> nil then
      begin
        if not ChildModel.ModflowPackages.SwiPackage.IsSelected then
        begin
          ChildModel.ModflowPackages.SwiPackage.TipSlope.Value := 0.04;
          ChildModel.ModflowPackages.SwiPackage.ToeSlope.Value := 0.04;
        end;
      end;
    end;

  end;

  if (ModelSelection = msFootPrint) and FileVersionEqualOrEarlier('3.6.3.6') then
  begin
    DepthRateIndexDataArray := DataArrayManager.
      GetDataSetByName(KDepthRateIndex);
    if (DepthRateIndexDataArray <> nil) then
    begin
      DepthRateIndexDataArray.CheckMin := True;
      DepthRateIndexDataArray.Min := 1e-6;
      DepthRateIndexDataArray.Invalidate;
    end;
  end;

  if FileVersionEqualOrEarlier('3.6.3.27') then
  begin
    EndPoints.UpdateMinMax;
    for ModelIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ModelIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.EndPoints.UpdateMinMax;
      end;
    end;
  end;
  if FileVersionEqualOrEarlier('3.6.3.28') then
  begin
    PathLines.UpdateMinMax;
    for ModelIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ModelIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.PathLines.UpdateMinMax;
      end;
    end;
  end;
  if FileVersionEqualOrEarlier('3.7.1.15') then
  begin
    SwrReachDataArray := DataArrayManager.GetDataSetByName(KSwrReach);
    if SwrReachDataArray <> nil then
    begin
      SwrReachDataArray.Orientation := dsoTop;
    end;
    for ModelIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ModelIndex].ChildModel;
      if ChildModel <> nil then
      begin
        SwrReachDataArray := ChildModel.DataArrayManager.GetDataSetByName(KSwrReach);
        if SwrReachDataArray <> nil then
        begin
          SwrReachDataArray.Orientation := dsoTop;
        end;
      end;
    end;
    SwrReachDataArray := DataArrayManager.GetDataSetByName(KSwrReach);
    if SwrReachDataArray <> nil then
    begin
      RemoveVariables(SwrReachDataArray);
      CreateVariables(SwrReachDataArray);
    end;
//    for ModelIndex := 0 to ChildModels.Count - 1 do
//    begin
//      ChildModel := ChildModels[ModelIndex].ChildModel;
//      SwrReachDataArray := ChildModel.DataArrayManager.GetDataSetByName(KSwrReach);
//      ChildModel.RemoveVariables(SwrReachDataArray);
//      ChildModel.CreateVariables(SwrReachDataArray);
//    end;
  end;

  if FileVersionEqualOrEarlier('3.7.1.16') then
  begin
    RemoveNonAncillaryFiles;
  end;

  if FileVersionEqualOrEarlier('3.8.0.0') then
  begin
    if ChildModels.Count > 0 then
    begin
      CompilerList := TList.Create;
      try
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          ChildModel := ChildModels[ChildIndex].ChildModel;
          if ChildModel <> nil then
          begin
            ChildModels[ChildIndex].ChildModel.FillCompilerList(CompilerList);
          end;
        end;
        for GlobalVariableIndex := 0 to GlobalVariablesI.Count - 1 do
        begin
          AGlobalVariable := GlobalVariablesI[GlobalVariableIndex];
          for CompilerIndex := 0 to CompilerList.Count - 1 do
          begin
            ACompiler := CompilerList[CompilerIndex];
            VarIndex := ACompiler.IndexOfVariable(AGlobalVariable.Name);
            if VarIndex < 0 then
            begin
              case AGlobalVariable.Format of
                rdtDouble:
                  begin
                    ACompiler.CreateVariable(AGlobalVariable.Name, StrGlobalVariables,
                      AGlobalVariable.RealValue, AGlobalVariable.Name);
                  end;
                rdtInteger:
                  begin
                    ACompiler.CreateVariable(AGlobalVariable.Name, StrGlobalVariables,
                      AGlobalVariable.IntegerValue, AGlobalVariable.Name);
                  end;
                rdtBoolean:
                  begin
                    ACompiler.CreateVariable(AGlobalVariable.Name, StrGlobalVariables,
                      AGlobalVariable.BooleanValue, AGlobalVariable.Name);
                  end;
                rdtString:
                  begin
                    ACompiler.CreateVariable(AGlobalVariable.Name, StrGlobalVariables,
                      AGlobalVariable.StringValue, AGlobalVariable.Name);
                  end;
                else Assert(False);
              end;
            end;

          end;
        end;
      finally
        CompilerList.Free;
      end;
    end;
  end;

  if FileVersionEqualOrEarlier('3.8.0.2') then
  begin
    DischargeRoutingArray := FDataArrayManager.GetDataSetByName(
      StrUzfDischargeRouting);
    if DischargeRoutingArray <> nil then
    begin
      DischargeRoutingArray.Invalidate;
    end;
  end;

  if FileVersionEqualOrEarlier('3.8.1.5') then
  begin
    // prior to version 3.8.1.6, nomOriginal had not been defined and
    // the ordinal values that the users would have thought they were
    // specifying for NORDER were not the ones actually specified.
    case ModflowPackages.NwtPackage.OrderingMethod of
      nomOriginal: ; // do nothing;
      nomRCM: ModflowPackages.NwtPackage.OrderingMethod := nomOriginal;
      nomMinimumOrdering: ModflowPackages.NwtPackage.OrderingMethod := nomRCM;
    end;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        case ChildModel.ModflowPackages.NwtPackage.OrderingMethod of
          nomOriginal: ; // do nothing;
          nomRCM: ChildModel.ModflowPackages.NwtPackage.OrderingMethod := nomOriginal;
          nomMinimumOrdering: ChildModel.ModflowPackages.NwtPackage.OrderingMethod := nomRCM;
        end;
      end;
    end;
  end;

  if FileVersionEqualOrEarlier('3.8.1.33') then
  begin
    if ModflowPackages.Mt3dBasic.IsSelected then
    begin
      ModflowPackages.Mt3dBasic.Mt3dVersion := mvMS;
    end;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        if ChildModel.ModflowPackages.Mt3dBasic.IsSelected then
        begin
          ChildModel.ModflowPackages.Mt3dBasic.Mt3dVersion := mvMS;
        end;
      end;
    end;
  end;

  if FileVersionEqualOrEarlier('3.10.0.47') and HfbIsSelected then
  begin
    HfbParamNames := TStringList.Create;
    try
      for ParamIndex := 0 to ModflowSteadyParameters.Count -1 do
      begin
        AParam := ModflowSteadyParameters.Items[ParamIndex];
        if AParam.ParameterType = ptHFB then
        begin
          HfbParamNames.Add(AParam.ParameterName);
        end;
      end;

      for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
      begin
        AScreenObject := ScreenObjects[ScreenObjectIndex];
        ModflowHfbBoundary := AScreenObject.ModflowHfbBoundary;
        if (ModflowHfbBoundary <> nil) and ModflowHfbBoundary.Used
          and (ModflowHfbBoundary.ParameterName <> '')
          and (HfbParamNames.IndexOf(ModflowHfbBoundary.ParameterName) < 0)  then
        begin
          ModflowHfbBoundary.ParameterName := '';
        end;
      end;

    finally
	    HfbParamNames.Free;
    end;
  end;
//  if (ModelSelection = msFootPrint)
//    and FileVersionEqualOrEarlier('3.8.1.17') then
//  begin
//    Withdrawals := FDataArrayManager.GetDataSetByName(KWithdrawals);
//    if Withdrawals <> nil then
//    begin
//      Withdrawals.Invalidate;
//    end;
//  end;

  Withdrawals := FDataArrayManager.GetDataSetByName(KWithdrawals);
  if Withdrawals <> nil then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      FootprintWell := AScreenObject.FootprintWell;
      if (FootprintWell <> nil) and FootprintWell.Used
        and (AScreenObject.Count = AScreenObject.SectionCount) then
      begin
        if AScreenObject.IndexOfDataSet(Withdrawals) < 0 then
        begin
          Position := AScreenObject.AddDataSet(Withdrawals);
          AScreenObject.DataSetFormulas[Position] := FootprintWell.Withdrawal;
        end;
      end;
    end;
  end;

  if FileVersionEqualOrEarlier('4.3.0.31')
    and (PestProperties.PilotPointSpacing > 0) then
  begin
    PestProperties.ArrayPilotPointSelection := appsRectangular;
    PestProperties.PilotPointBuffer := PestProperties.PilotPointSpacing * Sqrt(2);
  end;

  if FileVersionEqualOrEarlier('5.0.0.7')
    and (ModelSelection in SutraSelection) then
  begin
    FixSutraMeshEdge;
  end;

  if FileVersionEqualOrEarlier('5.0.0.11') then
  begin
    UnsatNodeDataArray := FDataArrayManager.GetDataSetByName('Unsat_Region_Nodes');
    if UnsatNodeDataArray <> nil then
    begin
      FDataArrayManager.RemoveDataSetFromLookUpList(UnsatNodeDataArray);
      UpdatedDataArray := FDataArrayManager.GetDataSetByName(KUnsatRegionNodes);
      if UpdatedDataArray <> nil then
      begin
        UnsatNodeDataArray.OnDataSetUsed := UpdatedDataArray.OnDataSetUsed;
        FDataArrayManager.RemoveDataSet(UpdatedDataArray);
      end;
      UnsatNodeDataArray.Name := KUnsatRegionNodes;
      UnsatNodeDataArray.DisplayName := StrUnsatRegionNodesDisplayName;
      FDataArrayManager.AddDataSetToLookUpList(UnsatNodeDataArray);
    end;

    UnsatElementDataArray := FDataArrayManager.GetDataSetByName('Unsat_Region_Elements');
    if UnsatElementDataArray <> nil then
    begin
      UpdatedDataArray := FDataArrayManager.GetDataSetByName(KUnsatRegionElements);
      FDataArrayManager.RemoveDataSetFromLookUpList(UnsatElementDataArray);
      if UpdatedDataArray <> nil then
      begin
        UnsatElementDataArray.OnDataSetUsed := UpdatedDataArray.OnDataSetUsed;
        FDataArrayManager.RemoveDataSet(UpdatedDataArray)
      end;
      UnsatElementDataArray.Name := KUnsatRegionElements;
      UnsatElementDataArray.DisplayName := StrUnsatRegionElementsDisplayName;
      FDataArrayManager.AddDataSetToLookUpList(UnsatElementDataArray);
    end;
  end;



  // prevent rounding errors in saved files from being used.
//  for StressPeriodIndex := 0 to ModflowStressPeriods.Count - 1 do
//  begin
//    StressPeriod := ModflowStressPeriods[StressPeriodIndex];
//    StressPeriod.StartTime := FortranStrToFloat(FortranFloatToStr(
//      StressPeriod.StartTime));
//    StressPeriod.EndTime := FortranStrToFloat(FortranFloatToStr(
//      StressPeriod.EndTime));
//  end;
//
//  for StressPeriodIndex := 0 to Mt3dmsTimes.Count - 1 do
//  begin
//    Mt3dStressPeriod := Mt3dmsTimes[StressPeriodIndex];
//    Mt3dStressPeriod.StartTime := FortranStrToFloat(FortranFloatToStr(
//      Mt3dStressPeriod.StartTime));
//    Mt3dStressPeriod.EndTime := FortranStrToFloat(FortranFloatToStr(
//      Mt3dStressPeriod.EndTime));
//  end;

end;

procedure TPhastModel.RemoveNonAncillaryFiles;
var
  ExtensionList: TExtensionList;
  WildCardExtensions: TStringList;
  ExtIndex: Integer;
  ExtObj: TExtensionObject;
  SearchExt: string;
  AncFileIndex: Integer;
  AFileName: string;
  NonWildCardExtensions: TStringList;
  Extension: string;
  LocalFilesToArchive: TStrings;
  ExtPosition: Integer;
begin
  ExtensionList := TExtensionList.Create;
  NonWildCardExtensions := TStringList.Create;
  WildCardExtensions := TStringList.Create;
  try
    NonWildCardExtensions.CaseSensitive := False;
    NonWildCardExtensions.Duplicates := dupError;
    ExtensionList.SetDefaultExtensions;
    for ExtIndex := 0 to ExtensionList.Count - 1 do
    begin
      ExtObj := ExtensionList[ExtIndex];
      if Pos('*', ExtObj.Extension) > 0 then
      begin
        SearchExt := StringReplace(ExtObj.Extension, '*', '',
          [rfReplaceAll, rfIgnoreCase]);
        SearchExt := LowerCase(SearchExt);
        WildCardExtensions.AddObject(SearchExt, ExtObj)
      end
      else
      begin
        NonWildCardExtensions.AddObject(ExtObj.Extension, ExtObj)
      end;
    end;

    LocalFilesToArchive := FilesToArchive;
    for AncFileIndex := LocalFilesToArchive.Count - 1 downto 0 do
    begin
      AFileName := LocalFilesToArchive[AncFileIndex];
      Extension := ExtractFileExtendedExt(AFileName);

      ExtObj := nil;
      ExtPosition := NonWildCardExtensions.IndexOf(Extension);
      if ExtPosition >= 0 then
      begin
        ExtObj := NonWildCardExtensions.Objects[ExtPosition] as TExtensionObject;
      end
      else
      begin
        for ExtIndex := 0 to WildCardExtensions.Count - 1 do
        begin
          if Pos(WildCardExtensions[ExtIndex], LowerCase(Extension)) = 1  then
          begin
            ExtObj := WildCardExtensions.Objects[ExtIndex] as TExtensionObject;
            break;
          end;
        end;
      end;
      if ExtObj <> nil then
      begin
        case ExtObj.ExtensionType of
          etModelInput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FModelInputFiles.Add(AFileName);
            end;
          etModelOutput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FModelOutputFiles.Add(AFileName);
            end;
          etModpathInput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FModpathInputFiles.Add(AFileName);
            end;
          etModpathOutput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FModpathOutputFiles.Add(AFileName);
            end;
          etZoneBudgetInput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FZoneBudgetInputFiles.Add(AFileName);
            end;
          etZoneBudgetOutput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FZoneBudgetOutputFiles.Add(AFileName);
            end;
          etSwiObsExtInput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FSwiObsExtractorInputFiles.Add(AFileName);
            end;
          etSwiObsExtOutput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FSwiObsExtractorOutputFiles.Add(AFileName);
            end;
          etMt3dmsInput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FMt3dmsInputFiles.Add(AFileName);
            end;
          etMt3dmsOutput:
            begin
              LocalFilesToArchive.Delete(AncFileIndex);
              FMt3dmsOutputFiles.Add(AFileName);
            end;
          etAncillary: ; // do nothing
          else
            Assert(False);
        end;
      end;
    end;

  finally
    ExtensionList.Free;
    WildCardExtensions.Free;
    NonWildCardExtensions.Free;
  end;
end;

procedure TPhastModel.FixFhbItems;
const
  Epsilon = 1e-8;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  LastTime: Double;
  FhbHeadBoundary: TFhbHeadBoundary;
  FhbItem: TFhbItem;
  FhbFlowBoundary: TFhbFlowBoundary;
  NewFhbItem: TFhbItem;
  FirstTime: Double;
  LastItem: TFhbItem;
  NextToLastItem: TFhbItem;
  PriorItem: TFhbItem;
  TotalTime: Double;
  ElapsedTime: Double;
begin
  if FhbIsSelected and (ModflowStressPeriods.Count > 0) then
  begin
    FirstTime := ModflowStressPeriods.First.StartTime;
    LastTime := ModflowStressPeriods.Last.EndTime;
    for ScreenObjectIndex := 0 to ScreenObjectCount -1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      FhbHeadBoundary := AScreenObject.ModflowFhbHeadBoundary;
      if (FhbHeadBoundary <> nil)  then
      begin
        FhbItem := FhbHeadBoundary.Values.First as TFhbItem;
        if FhbItem.StartTime > FirstTime then
        begin
          FhbItem.StartTime := FirstTime;
        end;
        FhbItem := FhbHeadBoundary.Values.Last as TFhbItem;
        if FhbItem.StartTime < LastTime then
        begin
          if Abs((LastTime-FhbItem.StartTime)/(LastTime-FirstTime)) < Epsilon then
          begin
            FhbItem.StartTime := LastTime;
          end
          else
          begin
            NewFhbItem := FhbHeadBoundary.Values.Add  as TFhbItem;
            FhbItem.EndTime := LastTime;
            NewFhbItem.Assign(FhbItem);
            NewFhbItem.StartTime := LastTime;
          end;
        end
        else if FhbItem.StartTime > LastTime then
        begin
          if Abs((LastTime-FhbItem.StartTime)/(LastTime-FirstTime)) < Epsilon then
          begin
            FhbItem.StartTime := LastTime;
          end
          else
          begin
            if FhbHeadBoundary.Values.Count > 1 then
            begin
              PriorItem := FhbHeadBoundary.Values[FhbHeadBoundary.Values.Count - 2] as TFhbItem;

              NewFhbItem := FhbHeadBoundary.Values.Add  as TFhbItem;
              NewFhbItem.Assign(FhbItem);
              NewFhbItem.StartTime := LastTime;
              NewFhbItem.EndTime := FhbItem.StartTime;
              NewFhbItem.Index := NewFhbItem.Index - 1;
              PriorItem.EndTime := NewFhbItem.StartTime;

              if (PriorItem.BoundaryValue <> FhbItem.BoundaryValue) then
              begin
                TotalTime := FhbItem.StartTime - PriorItem.StartTime;
                ElapsedTime := NewFhbItem.StartTime - PriorItem.StartTime;
                NewFhbItem.BoundaryValue := '(' + FloatToStr(ElapsedTime/TotalTime) + ' * (' + FhbItem.BoundaryValue + ' - ' + PriorItem.BoundaryValue + ')) + ' + PriorItem.BoundaryValue;
              end;
            end;
          end;
        end;

        if FhbHeadBoundary.Values.Count >= 2 then
        begin
          LastItem := FhbHeadBoundary.Values.Last as TFhbItem;
          NextToLastItem := FhbHeadBoundary.Values[FhbHeadBoundary.Values.Count-2] as TFhbItem;
          if (Abs((LastItem.StartTime - NextToLastItem.StartTime)/
            (LastTime-FirstTime)) < Epsilon) then
          begin
            NextToLastItem.StartTime := LastTime;
            LastItem.Free;
          end;
        end;
      end;

      FhbFlowBoundary := AScreenObject.ModflowFhbFlowBoundary;
      if (FhbFlowBoundary <> nil)  then
      begin
        FhbItem := FhbFlowBoundary.Values.First as TFhbItem;
        if FhbItem.StartTime > FirstTime then
        begin
          FhbItem.StartTime := FirstTime;
        end;
        FhbItem := FhbFlowBoundary.Values.Last as TFhbItem;
        if FhbItem.StartTime < LastTime then
        begin
          if Abs((LastTime-FhbItem.StartTime)/(LastTime-FirstTime)) < Epsilon then
          begin
            FhbItem.StartTime := LastTime;
          end
          else
          begin
            NewFhbItem := FhbFlowBoundary.Values.Add  as TFhbItem;
            FhbItem.EndTime := LastTime;
            NewFhbItem.Assign(FhbItem);
            NewFhbItem.StartTime := LastTime;
          end;
        end
        else if FhbItem.StartTime > LastTime then
        begin
          if Abs((LastTime-FhbItem.StartTime)/(LastTime-FirstTime)) < Epsilon then
          begin
            FhbItem.StartTime := LastTime;
          end
          else
          begin
            if FhbFlowBoundary.Values.Count > 1 then
            begin
              PriorItem := FhbFlowBoundary.Values[FhbFlowBoundary.Values.Count - 2] as TFhbItem;

              NewFhbItem := FhbFlowBoundary.Values.Add  as TFhbItem;
              NewFhbItem.Assign(FhbItem);
              NewFhbItem.StartTime := LastTime;
              NewFhbItem.EndTime := FhbItem.StartTime;
              NewFhbItem.Index := NewFhbItem.Index - 1;
              PriorItem.EndTime := NewFhbItem.StartTime;

              if (PriorItem.BoundaryValue <> FhbItem.BoundaryValue) then
              begin
                TotalTime := FhbItem.StartTime - PriorItem.StartTime;
                ElapsedTime := NewFhbItem.StartTime - PriorItem.StartTime;
                NewFhbItem.BoundaryValue := '(' + FloatToStr(ElapsedTime/TotalTime) + ' * (' + FhbItem.BoundaryValue + ' - ' + PriorItem.BoundaryValue + ')) + ' + PriorItem.BoundaryValue;
              end;
            end;
          end;
        end;

        if FhbFlowBoundary.Values.Count >= 2 then
        begin
          LastItem := FhbFlowBoundary.Values.Last as TFhbItem;
          NextToLastItem := FhbFlowBoundary.Values[FhbFlowBoundary.Values.Count-2] as TFhbItem;
          if (Abs((LastItem.StartTime - NextToLastItem.StartTime)/
            (LastTime-FirstTime)) < Epsilon) then
          begin
            NextToLastItem.StartTime := LastTime;
            LastItem.Free;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.FreeSfrWriter;
var
  ChildIndex: integer;
  ChildModel: TChildModel;
begin
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.FreeSfrWriter;
    end;
  end;
end;

procedure TPhastModel.UpdateModelMateParameter(ParameterList: TStringList;
  ModelMuseParam: TModflowParameter; Project: TProject;
  Operation: TModelMateOperation);
const
  GroupNames : array[Low(TParameterType)..ptQMAX] of string
    = ('Undefined', 'HK', 'HANI', 'VK',
    'VANI', 'SS', 'SY', 'VKCB', 'RCH', 'EVT', 'ETS',
    'CHD', 'GHB', 'Q',
    'RIV', 'DRN', 'DRT', 'SFR', 'HFB',
    'HK', 'HANI', 'VK', 'VANI', 'SS', 'SY', 'SYTP', 'KDEP', 'LVDA', 'STR',
    'QMAX');
var
  PIndex: integer;
  ValAttribute: TParameterAttribute;
  ModelMateParam: TParam;
  PARNAM: string;
  GroupAttribute: TParameterAttribute;
  GroupIndex: Integer;
  Group: TParam;
  FoundGroup: Boolean;
begin
  // update this case statement when new parameter types added.
  case ModelMuseParam.ParameterType of
    ptUndefined: Assert(False);
    ptLPF_HK, ptLPF_HANI, ptLPF_VK, ptLPF_VANI, ptLPF_VKCB:
      begin
        if not (ModflowPackages.LpfPackage.IsSelected
          or ModflowPackages.UpwPackage.IsSelected) then
        begin
          Exit;
        end;
      end;
    ptLPF_SS,ptLPF_SY:
      begin
        if not (ModflowPackages.LpfPackage.IsSelected
          or ModflowPackages.UpwPackage.IsSelected)
          or not ModflowStressPeriods.TransientModel then
        begin
          Exit;
        end;
      end;
    ptHUF_HK, ptHUF_HANI, ptHUF_VK, ptHUF_VANI, ptHUF_KDEP, ptHUF_LVDA:
      begin
        if not ModflowPackages.HufPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptHUF_SS, ptHUF_SY, ptHUF_SYTP:
      begin
        if not ModflowPackages.HufPackage.IsSelected
          or not ModflowStressPeriods.TransientModel then
        begin
          Exit;
        end;
      end;
    ptRCH:
      begin
        if not ModflowPackages.RchPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptEVT:
      begin
        if not ModflowPackages.EvtPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptETS:
      begin
        if not ModflowPackages.EtsPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptCHD:
      begin
        if not ModflowPackages.ChdBoundary.IsSelected then
        begin
          Exit;
        end;
      end;
    ptGHB:
      begin
        if not ModflowPackages.GhbBoundary.IsSelected then
        begin
          Exit;
        end;
      end;
    ptQ:
      begin
        if not ModflowPackages.WelPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptRIV:
      begin
        if not ModflowPackages.RivPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptDRN:
      begin
        if not ModflowPackages.DrnPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptDRT:
      begin
        if not ModflowPackages.DrtPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptSFR:
      begin
        if not ModflowPackages.SfrPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptHFB:
      begin
        if not ModflowPackages.HfbPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptSTR:
      begin
        if not ModflowPackages.StrPackage.IsSelected then
        begin
          Exit;
        end;
      end;
    ptQMAX:
      begin
        if not ModflowPackages.FarmProcess.IsSelected then
        begin
          Exit;
        end;
      end;
    ptPEST:
      begin
        Exit;
      end
    else Assert(False);
  end;

  PARNAM := ModelMuseParam.ParameterName;
  if Length(PARNAM) > 10 then
  begin
    SetLength(PARNAM, 10);
  end;
  PIndex := ParameterList.IndexOf(PARNAM);

  ModelMateParam := nil;
  if (PIndex < 0) then
  begin
    if Operation = mmoExport then
    begin
      ModelMateParam := Project.ParamSet.Add;
      ModelMateParam.Initialize('ParamDefault','ParamDefault');
      Assert(Length(PARNAM) <= MaxString12);
      ModelMateParam.Name := ConvertString12(PARNAM);
      GroupAttribute := ModelMateParam.AllAtts.Items[ParAttPos(patGroupName)];
      GroupAttribute.Text := GroupNames[ModelMuseParam.ParameterType];
      FoundGroup := False;
      for GroupIndex := 0 to Project.ParGpSet.Count - 1 do
      begin
        Group := Project.ParGpSet.Items[GroupIndex];
        if SameText(string(Group.Name), GroupAttribute.Text) then
        begin
          FoundGroup := True;
          Break;
        end;
      end;
      if not FoundGroup then
      begin
        Group := Project.ParGpSet.Add;
        Assert(Length(GroupAttribute.Text) <= MaxString12);
        Group.Initialize(ConvertString12(GroupAttribute.Text), ConvertString12(GroupAttribute.Text));
      end;
    end;
  end
  else
  begin
    ModelMateParam := ParameterList.Objects[PIndex] as TParam;
  end;
  if ModelMateParam = nil then
  begin
    Exit;
  end;

  try

    ValAttribute := ModelMateParam.AllAtts.Items[ParAttPos(patStartValue)];
    case Operation of
      mmoImport:
        begin
          ModelMuseParam.Value := StrToFloatDef( ValAttribute.Text, 0);
        end;
      mmoExport:
        begin
          ValAttribute.Text := FortranFloatToStr(ModelMuseParam.Value);
        end
      else
        Assert(False);
    end;
  finally
    if PIndex >= 0 then
    begin
      ParameterList.Delete(PIndex);
    end;
  end;
end;

procedure TPhastModel.UpdateModelMateFluxObservation(
  ObservationList: TStringList; ModelMuseFluxObsGroup: TFluxObservationGroup;
  Project: TProject; Operation: TModelMateOperation);
Const
  ObservationGroupNames : array[Low(TFluxObsType)..High(TFluxObsType)] of string
    = ('CHOB_flows', 'RIV_flows', 'DRN_flows', 'GHB_flows', 'STR_flows');
var
  ModelMuseFluxObs: TFluxObservation;
  TimeIndex: Integer;
  OBSNAM: string;
  ObsIndex: Integer;
  ValAttribute: TDependentAttribute;
  ModelMateObs: TDep;
  GroupName: string;
  StatisticAttribute: TDependentAttribute;
  StatFlagAttribute: TDependentAttribute;
  DepSet: TDepSet;
  TimeString: string;
begin
  DepSet := nil;
  case ObservationPurpose of
    ofObserved: DepSet :=  Project.ObsSet;
    ofPredicted: DepSet :=  Project.PredSet;
    else Assert(False);
  end;
  for TimeIndex := 0 to ModelMuseFluxObsGroup.ObservationTimes.Count - 1 do
  begin
    ModelMuseFluxObs := ModelMuseFluxObsGroup.ObservationTimes[TimeIndex];
    TimeString := ModelMuseFluxObs.ObsNameTimeString;
    OBSNAM := ModelMuseFluxObsGroup.ObservationName
      + '_' + TimeString;
    ObsIndex := ObservationList.IndexOf(OBSNAM);
    ModelMateObs := nil;
    if ObsIndex < 0 then
    begin
      if Operation = mmoExport then
      begin
        ModelMateObs := DepSet.Add;
        Assert(Length(OBSNAM) <= MaxString20);
        ModelMateObs.Name := ConvertString20(OBSNAM);
        GroupName := ObservationGroupNames[ModelMuseFluxObsGroup.FluxObsType];
        ModelMateObs.AllAtts[DepAttPos(datGroupName)].Text := GroupName;

        EnsureModelMateObsGroup(Project, GroupName,
          Ord(ModelMuseFluxObsGroup.FluxObsType)+3);
      end;
    end
    else
    begin
      ModelMateObs := ObservationList.Objects[ObsIndex] as TDep;
    end;
    if ModelMateObs = nil then
    begin
      Exit;
    end;

    try
      ValAttribute := nil;
      StatisticAttribute := nil;
      StatFlagAttribute := nil;
      case ObservationPurpose of
        ofObserved:
          begin
            ValAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datObsValue)];
            StatisticAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datStatistic)];
            StatFlagAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datStatFlag)];
          end;
        ofPredicted:
          begin
            ValAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datRefValue)];
            StatisticAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datMeasStatistic)];
            StatFlagAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datMeasStatFlag)];
          end;
        else Assert(False);
      end;
      case Operation of
        mmoImport:
          begin
            ModelMuseFluxObs.ObservedValue := StrToFloatDef(ValAttribute.Text, 0);
            ModelMuseFluxObs.Statistic := StrToFloatDef(StatisticAttribute.Text, 0);
            ModelMuseFluxObs.StatFlag := StrToStatFlag(StatFlagAttribute.Text);
          end;
        mmoExport:
          begin
            ValAttribute.Text := FortranFloatToStr(ModelMuseFluxObs.ObservedValue);
            StatisticAttribute.Text := FortranFloatToStr(ModelMuseFluxObs.Statistic);
            StatFlagAttribute.Text := StatFlagStrings[ModelMuseFluxObs.StatFlag];
          end;
        else
          Assert(False);
      end;
    finally
      if ObsIndex >= 0 then
      begin
        ObservationList.Delete(ObsIndex);
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateModelMateZetaObservation(
  ObservationList: TStringList; const OBSNAM: string;
  ModelMuseSwiObs: TSwiObsItem; Project: TProject;
  Operation: TModelMateOperation);
const
  PlotSymbolZeta = 10;
var
  ObsIndex: Integer;
  ValAttribute: TDependentAttribute;
  ModelMateObs: TDep;
  GroupName: string;
  StatAttribute: TDependentAttribute;
  StatFlagAttribute: TDependentAttribute;
  DepSet: TDepSet;
begin
  DepSet := nil;
  case ObservationPurpose of
    ofObserved: DepSet :=  Project.ObsSet;
    ofPredicted: DepSet :=  Project.PredSet;
    else Assert(False);
  end;
  ObsIndex := ObservationList.IndexOf(OBSNAM);
  ModelMateObs := nil;
  GroupName := 'Zeta';
  if ObsIndex < 0 then
  begin
    if Operation = mmoExport then
    begin
      ModelMateObs := DepSet.Add;
      Assert(Length(OBSNAM) <= MaxString20);
      ModelMateObs.Name := ConvertString20(OBSNAM);

      ModelMateObs.AllAtts[DepAttPos(datGroupName)].Text := GroupName;
      EnsureModelMateObsGroup(Project, GroupName, PlotSymbolZeta);
    end;
  end
  else
  begin
    ModelMateObs := ObservationList.Objects[ObsIndex] as TDep;
  end;
  if ModelMateObs = nil then
  begin
    Exit;
  end;

  try
    ValAttribute := nil;
    StatAttribute := nil;
    StatFlagAttribute := nil;
    case ObservationPurpose of
      ofObserved:
        begin
          ValAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datObsValue)];
          StatAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datStatistic)];
          StatFlagAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datStatFlag)];
        end;
      ofPredicted:
        begin
          ValAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datRefValue)];
          StatAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datMeasStatistic)];
          StatFlagAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datMeasStatFlag)];
        end;
      else Assert(False);
    end;
    case Operation of
      mmoImport:
        begin
          ModelMuseSwiObs.ObservedValue := StrToFloatDef(ValAttribute.Text, 0);
          ModelMuseSwiObs.Statistic := StrToFloatDef(StatAttribute.Text, 0);
          ModelMuseSwiObs.StatFlag := StrToStatFlag(StatFlagAttribute.Text);
        end;
      mmoExport:
        begin
          ValAttribute.Text := FortranFloatToStr(ModelMuseSwiObs.ObservedValue);
          StatAttribute.Text := FortranFloatToStr(ModelMuseSwiObs.Statistic);
          StatFlagAttribute.Text := StatFlagStrings[ModelMuseSwiObs.StatFlag];
        end;
      else
        Assert(False);
    end;
  finally
    if ObsIndex >= 0 then
    begin
      ObservationList.Delete(ObsIndex);
    end;
  end;
end;

procedure TPhastModel.UpdateModelMateHeadObservation(
  ObservationList: TStringList; const OBSNAM: string;
  ModelMuseHeadObs: THobItem; Project: TProject;
  Operation: TModelMateOperation; Method: TMultiObsMethod);
const GroupNames: array[Low(TMultiObsMethod)..High(TMultiObsMethod)] of string
  = ('Heads', 'Head_Changes');
var
  ObsIndex: Integer;
  ValAttribute: TDependentAttribute;
  ModelMateObs: TDep;
  GroupName: string;
  StatAttribute: TDependentAttribute;
  StatFlagAttribute: TDependentAttribute;
  DepSet: TDepSet;
begin
  DepSet := nil;
  case ObservationPurpose of
    ofObserved: DepSet :=  Project.ObsSet;
    ofPredicted: DepSet :=  Project.PredSet;
    else Assert(False);
  end;
  ObsIndex := ObservationList.IndexOf(OBSNAM);
  ModelMateObs := nil;
  if ObsIndex < 0 then
  begin
    if Operation = mmoExport then
    begin
        ModelMateObs := DepSet.Add;
        Assert(Length(OBSNAM) <= MaxString20);
        ModelMateObs.Name := ConvertString20(OBSNAM);

        GroupName := GroupNames[Method];
        ModelMateObs.AllAtts[DepAttPos(datGroupName)].Text := GroupName;
        EnsureModelMateObsGroup(Project, GroupName, Ord(Method)+1);
    end;
  end
  else
  begin
    ModelMateObs := ObservationList.Objects[ObsIndex] as TDep;
  end;
  if ModelMateObs = nil then
  begin
    Exit;
  end;

  try
      ValAttribute := nil;
      StatAttribute := nil;
      StatFlagAttribute := nil;
      case ObservationPurpose of
        ofObserved:
          begin
            ValAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datObsValue)];
            StatAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datStatistic)];
            StatFlagAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datStatFlag)];
          end;
        ofPredicted:
          begin
            ValAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datRefValue)];
            StatAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datMeasStatistic)];
            StatFlagAttribute := ModelMateObs.AllAtts.Items[DepAttPos(datMeasStatFlag)];
          end;
        else Assert(False);
      end;
    case Operation of
      mmoImport:
        begin
          case Method of
            momAllHeads: ModelMuseHeadObs.Head := StrToFloatDef(ValAttribute.Text, 0);
            momHeadAndDrawdown: ModelMuseHeadObs.HeadChange := StrToFloatDef(ValAttribute.Text, 0);
            else Assert(False);
          end;
          ModelMuseHeadObs.Statistic := StrToFloatDef(StatAttribute.Text, 0);
          ModelMuseHeadObs.StatFlag := StrToStatFlag(StatFlagAttribute.Text);
        end;
      mmoExport:
        begin
          case Method of
            momAllHeads: ValAttribute.Text := FortranFloatToStr(ModelMuseHeadObs.Head);
            momHeadAndDrawdown: ValAttribute.Text := FortranFloatToStr(ModelMuseHeadObs.HeadChange);
            else Assert(False);
          end;
          StatAttribute.Text := FortranFloatToStr(ModelMuseHeadObs.Statistic);
          StatFlagAttribute.Text := StatFlagStrings[ModelMuseHeadObs.StatFlag];
        end;
      else
        Assert(False);
    end;
  finally
    if ObsIndex >= 0 then
    begin
      ObservationList.Delete(ObsIndex);
    end;
  end;
end;


procedure TPhastModel.UpdateModelMateProject;
var
  ParameterList: TStringList;
  Index: Integer;
  ModelMateParam: TParam;
  ObservationList: TStringList;
  PIndex: Integer;
  ObsIndex: Integer;
  AMessage: string;
  ModelMateObs: TDep;
  ModMatObs: TDepSet;
  DepType: string;
  ObsGroup: TDepSet;
  GroupIndex: Integer;
  Group: TDep;
  GroupUsed: Boolean;
  IniFName: string;
  IniFile: TMemIniFile;
  ModName: string;
  ObsPair: TModelIOPair;
  IncludeSwiObs: Boolean;
begin
  if FileExists(ProgramLocations.ModflowLocation) then
  begin
    IniFName := IniFileName(frmGoPhast.Handle, 'ModelMate.exe');
    IniFile:= TMemInifile.Create(IniFName);
    try
      GlobalProgramLocations.ReadFromIniFile(IniFile);
      GlobalProgramLocations.Modflow2005Location
        := ProgramLocations.ModflowLocation;
      GlobalProgramLocations.WriteToIniFile(IniFile);
      IniFile.UpdateFile;
    finally
      IniFile.Free;
    end;
  end;
  case ModflowOptions.TimeUnit of
    0: ;// do nothing
    1:
      begin
        ModelMateProject.UcProject.ModelTimeUnits := 's';
      end;
    2:
      begin
        ModelMateProject.UcProject.ModelTimeUnits := 'min';
      end;
    3:
      begin
        ModelMateProject.UcProject.ModelTimeUnits := 'hr';
      end;
    4:
      begin
        ModelMateProject.UcProject.ModelTimeUnits := 'day';
      end;
    5:
      begin
        ModelMateProject.UcProject.ModelTimeUnits := 'yr';
      end;
    else Assert(False);
  end;

  case ModflowOptions.LengthUnit of
    0: ;// do nothing
    1:
      begin
        ModelMateProject.UcProject.ModelLengthUnits := 'ft';
      end;
    2:
      begin
        ModelMateProject.UcProject.ModelLengthUnits := 'm';
      end;
    3:
      begin
        ModelMateProject.UcProject.ModelLengthUnits := 'cm';
      end;
    else Assert(False);
  end;

  if ModflowOptions.ProjectName <> '' then
  begin
    ModelMateProject.UcProject.ModelName :=
      ConvertString12(Copy(ModflowOptions.ProjectName, 1, MaxString12));
  end
  else if ModelFileName <> '' then
  begin
    ModName := Copy(ChangeFileExt(ExtractFileName(ModelFileName),''), 1, MaxString12);
    ModelMateProject.UcProject.ModelName := ConvertString12(ModName);
  end;

  ParameterList := TStringList.Create;
  try
    // parameters
    ModelMateProject.ParamSet.BeginUpdate;
    try
      HandleModelMateParameters(mmoExport, ParameterList, ModelMateProject);
      if (ParameterList.Count > 0) then
      begin
        if ParameterList.Count <= 10 then
        begin
          AMessage := StrYourModelMateFile + sLineBreak + sLineBreak
            + ParameterList.Text
        end
        else
        begin
          AMessage := Format(StrYourModelMateFile2, [ParameterList.Count])
        end;
        if (MessageDlg(AMessage,
          mtInformation, [mbYes, mbNo], 0) = mrYes) then
        begin
          for Index := 0 to ParameterList.Count - 1 do
          begin
            ModelMateParam := ParameterList.Objects[Index] as TParam;
            for PIndex := 0 to ModelMateProject.ParamSet.Count - 1 do
            begin
              if ModelMateProject.ParamSet.Items[PIndex]
                = ModelMateParam then
              begin
                ModelMateProject.ParamSet.Delete(PIndex);
                break;
              end;
            end;
          end;
        end;
      end;
    finally
      ModelMateProject.ParamSet.EndUpdate;
    end;
  finally
    ParameterList.Free;
  end;

  DepType := '';
  ModMatObs := nil;
  ObsGroup := nil;
  ObservationList := TStringList.Create;
  try
    case ObservationPurpose of
      ofObserved:
        begin
          ModMatObs := ModelMateProject.ObsSet;
          DepType := 'observations';
          ObsGroup := ModelMateProject.ObsGpSet;
        end;
      ofPredicted:
        begin
          ModMatObs := ModelMateProject.PredSet;
          DepType := 'predictions';
          ObsGroup := ModelMateProject.PredGpSet;
        end
      else Assert(False);
    end;

    ModMatObs.BeginUpdate;
    try
      HandleModelMateObservations(mmoExport, ObservationList, ModelMateProject);

      if (ObservationList.Count > 0) then
      begin
        if ObservationList.Count <= 10 then
        begin
          AMessage := Format(StrYourModelMateFile3, [DepType])
            + sLineBreak + sLineBreak
            + ObservationList.Text;
        end
        else
        begin
          AMessage := Format(StrYourModelMateFile4, [ObservationList.Count, DepType])
        end;
        if (MessageDlg(AMessage,
          mtInformation, [mbYes, mbNo], 0) = mrYes) then
        begin
          for Index := 0 to ObservationList.Count - 1 do
          begin
            ModelMateObs := ObservationList.Objects[Index] as TDep;
            for ObsIndex := 0 to ModMatObs.Count - 1 do
            begin
              if ModMatObs.Items[ObsIndex]
                = ModelMateObs then
              begin
                ModMatObs.Delete(ObsIndex);
                break;
              end;
            end;
          end;
          for GroupIndex := ObsGroup.Count - 1 downto 0 do
          begin
            Group := ObsGroup.Items[GroupIndex];
            GroupUsed := False;
            for Index := 0 to ModMatObs.Count - 1 do
            begin
              ModelMateObs := ModMatObs.Items[Index];
              if ModelMateObs.AllAtts[DepAttPos(datGroupName)].Text = string(Group.Name) then
              begin
                GroupUsed := True;
                break;
              end;
            end;
            if not GroupUsed then
            begin
              ObsGroup.Delete(GroupIndex);
            end;
          end;
        end;
      end;

      if InterpSwiObsDefined then
      begin
        IncludeSwiObs := False;
        for ObsIndex := 0 to ModelMateProject.MOFiles.Count - 1 do
        begin
          ObsPair := ModelMateProject.MOFiles[ObsIndex];
          if LowerCase(ExtractFileExt(ObsPair.ModelFile)) = '.swi_obsi_out' then
          begin
            IncludeSwiObs := true;
          end;
        end;
        if not IncludeSwiObs then
        begin
          ObsPair := ModelMateProject.MOFiles.Add as TModelIOPair;
          ObsPair.ModelFile := ChangeFileExt(ExtractFileName(ModelFileName), '.swi_obsi_out');
          ObsPair.AppFile := ObsPair.ModelFile + '.jif';
        end;
      end;

    finally
      ModMatObs.EndUpdate;
    end;
  finally
    ObservationList.Free;
  end;
end;

procedure TPhastModel.UpdateMt3dmsChemDataSets;
var
  ScreenObjectIndex: Integer;
begin
  MobileComponents.UpdateDataArrays;
  ImMobileComponents.UpdateDataArrays;
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    ScreenObjects[ScreenObjectIndex].CreateGwtTimeLists(self);
  end;
end;

function TPhastModel.FarmProcess4IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection =  msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.ModflowPackages.FarmProcess4.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoFarmProcess4SteadyCropsUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          DoFarmProcess4SteadyCropsUsed(Sender);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.DoFarmProcess4SteadyFarmsUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          DoFarmProcess4SteadyFarmsUsed(Sender);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientAddedDemandIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientAddedDemandIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientAddedDemandMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientAddedDemandMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientBareEvapArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientBareEvapArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientBareEvapArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientBareRunoffFractionArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientBareRunoffFractionArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientBareRunoffFractionArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientConsumptiveUseIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientConsumptiveUseIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientConsumptiveUseMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientConsumptiveUseMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientCropCoefficientIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientCropCoefficientIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientCropCoefficientMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientCropCoefficientMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientCropsUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientCropsUsed(Sender);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientDirectRechargeArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientDirectRechargeArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientDirectRechargeArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TCustomModel.FarmProcess4TransientEfficiencyArrayIsSelected: Boolean;
begin
    result := (ModelSelection =  msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and (ModflowPackages.FarmProcess4.EfficiencyOptions.FarmOption = foTransient)
    and (ModflowPackages.FarmProcess4.EfficiencyOptions.ArrayList  = alArray)
end;

function TPhastModel.FarmProcess4TransientEfficiencyArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  function IsSelected(Model: TCustomModel): Boolean;
  begin
    result := Model.FarmProcess4TransientEfficiencyArrayIsSelected;
  end;
begin
  result := inherited FarmProcess4TransientEfficiencyArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := IsSelected(ChildModel);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientEfficiencyArrayUsed(
  Sender: TObject): Boolean;
begin
  result := FarmProcess4TransientEfficiencyArrayIsSelected;
end;

function TPhastModel.FarmProcess4TransientEfficiencyImprovementArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientEfficiencyImprovementArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientEfficiencyImprovementArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientEvaporationIrrigationFractionIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientEvaporationIrrigationFractionIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientFarmIsSelected: Boolean;
var
  ChildIndex: Integer;
  LocalModflowPackages: TModflowPackages;
  ChildModel: TChildModel;
begin
  result := (ModelSelection =  msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and (ModflowPackages.FarmProcess4.Farms.FarmOption = foTransient);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        LocalModflowPackages := ChildModel.ModflowPackages;
        result := (ModelSelection =  msModflowOwhm2)
          and LocalModflowPackages.FarmProcess4.IsSelected
          and (LocalModflowPackages.FarmProcess4.Farms.FarmOption = foTransient);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientFarmsUsed(Sender: TObject): boolean;
begin
  result := FarmProcess4TransientFarmIsSelected;
end;

function TPhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientCropHasSalinityDemandIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientCropHasSalinityDemandIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientCropHasSalinityDemandMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientCropHasSalinityDemandMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientIrrigationIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientIrrigationIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientIrrigationMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientIrrigationMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientLandUseAreaFractionIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientLandUseAreaFractionIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientLandUseAreaFractionMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientLandUseAreaFractionMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientNrdInfilLocIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientNrdInfilLocIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientPrecipIsSelected: Boolean;
var
  ChildIndex: Integer;
  LocalModflowPackages: TModflowPackages;
  ChildModel: TChildModel;
begin
  result := (ModelSelection =  msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.TransientPrecipUsed(nil);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        LocalModflowPackages := ChildModel.ModflowPackages;
        result := (ModelSelection =  msModflowOwhm2)
          and LocalModflowPackages.FarmProcess4.IsSelected
          and LocalModflowPackages.FarmClimate4.TransientPrecipUsed(nil);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientPrecipPotConsumptionArrayIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcess4TransientPrecipPotConsumptionArrayIsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.FarmProcess4TransientPrecipPotConsumptionArrayIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientRefEtIsSelected: Boolean;
var
  ChildIndex: Integer;
  LocalModflowPackages: TModflowPackages;
  ChildModel: TChildModel;
begin
  result := (ModelSelection =  msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.TransientEvapUsed(nil);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        LocalModflowPackages := ChildModel.ModflowPackages;
        result := (ModelSelection =  msModflowOwhm2)
          and LocalModflowPackages.FarmProcess4.IsSelected
          and LocalModflowPackages.FarmClimate4.TransientEvapUsed(nil);
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientRootDepthIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientRootDepthIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientRootDepthMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientRootDepthMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientTranspirationFractionIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientTranspirationFractionIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4TransientTranspirationFractionMultIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.
          FarmProcess4TransientTranspirationFractionMultIsSelected;
        if result then
        begin
          break;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess4WellSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflowOwhm2);
  if result then
  begin
    result := ModflowPackages.FarmProcess4.IsSelected
      and ModflowPackages.FarmWells4.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result :=
            ChildModel.ModflowPackages.FarmProcess4.IsSelected
            and ChildModel.ModflowPackages.FarmWells4.IsSelected;
          if result then
          begin
            Exit;
          end;
        end;
      end;
    end;
  end;
end;

function TPhastModel.Farm4ProcessUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.FarmProcess4.IsSelected;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.ModflowPackages.FarmProcess4.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcess3IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflowFmp);
  if result then
  begin
    result :=  ModflowPackages.FarmProcess.IsSelected;
    if not result and LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or
            ChildModel.ModflowPackages.FarmProcess.IsSelected;
        end;
      end;
    end;
  end;
end;

function TPhastModel.FarmProcessUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited FarmProcessUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.FarmProcessUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.FhbIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.FhbIsSelected;
      end;
    end;
  end;
end;

function TPhastModel.FileVersionEqualOrEarlier(TestVersion: string): boolean;
var
  ProgramNum: Integer;
  SavedNum: Integer;
  VIndex: Integer;
  ProgramVersionList: TStringList;
  SavedVersionList: TStringList;
begin
  result := True;
  SavedVersionList := TStringList.Create;
  ProgramVersionList := TStringList.Create;
  try
    SavedVersionList.Delimiter := '.';
    SavedVersionList.DelimitedText := FileVersion;
    ProgramVersionList.Delimiter := '.';
    ProgramVersionList.DelimitedText := TestVersion;
    Assert(SavedVersionList.Count = 4);
    Assert(ProgramVersionList.Count = 4);
    for VIndex := 0 to SavedVersionList.Count - 1 do
    begin
      SavedNum := StrToInt(SavedVersionList[VIndex]);
      ProgramNum := StrToInt(ProgramVersionList[VIndex]);
      result := SavedNum <= ProgramNum;
      if (not result) or (SavedNum <> ProgramNum) then
      begin
        break;
      end;
    end;
  finally
    ProgramVersionList.Free;
    SavedVersionList.Free;
  end;
end;

procedure TPhastModel.SetUseGsflowFormat(const Value: boolean);
begin
  if FUseGsflowFormat <> Value then
  begin
    FUseGsflowFormat := Value;
    DoInvalidate(self);
  end;
end;

procedure TPhastModel.SetUseWaterTable(const Value: boolean);
begin
  if FUseWaterTable <> Value then
  begin
    FUseWaterTable := Value;
    DoInvalidate(self);
  end;
end;

procedure TPhastModel.ImportFromModelMateProject(Project: TProject);
var
  ParameterList: TStringList;
  ObservationList: TStringList;
  IniFName: string;
  IniFile: TMemIniFile;
  OldDecSeparator: Char;
begin
  OldDecSeparator := FormatSettings.DecimalSeparator;
  try
    FormatSettings.DecimalSeparator := '.';
    if Project.UcProject.ModelName <> '' then
    begin
      ModflowOptions.ProjectName := string(Project.UcProject.ModelName);
    end;

    ParameterList := TStringList.Create;
    try
      HandleModelMateParameters(mmoImport, ParameterList, Project);
    finally
      ParameterList.Free;
    end;

    ObservationList := TStringList.Create;
    try
      HandleModelMateObservations(mmoImport, ObservationList, Project);
    finally
      ObservationList.Free;
    end;

    IniFName := IniFileName(frmGoPhast.Handle, 'ModelMate.exe');
    IniFile:= TMemInifile.Create(IniFName);
    try
      GlobalProgramLocations.ReadFromIniFile(IniFile);
    finally
      IniFile.Free;
    end;

    if FileExists(GlobalProgramLocations.Modflow2005Location) then
    begin
      ProgramLocations.ModflowLocation := ExpandFileName(
        GlobalProgramLocations.Modflow2005Location);
    end;
  finally
    FormatSettings.DecimalSeparator := OldDecSeparator;
  end;
end;

procedure TPhastModel.EnsureModelMateObsGroup(Project: TProject; GroupName: string;
  PlotSymbol: integer);
var
  FoundGroup: Boolean;
  GroupIndex: Integer;
  Group: TDep;
  IAtt: Integer;
begin
  FoundGroup := False;
  for GroupIndex := 0 to Project.ObsGpSet.Count - 1 do
  begin
    Group := Project.ObsGpSet.Items[GroupIndex];
    if SameText(string(Group.Name), GroupName) then
    begin
      FoundGroup := True;
      break;
    end;
  end;
  if not FoundGroup then
  begin
    Group := Project.ObsGpSet.Add;

    Assert(Length(GroupName) <= MaxString12);
    Group.Initialize(ConvertString20(GroupName), ConvertString12(GroupName), dcObs);
    Group.AllAtts[DepAttPos(datPlotSymbol)].Text := IntToStr(PlotSymbol);

    IAtt := PosDepCap('Statistic');
    Project.ObservationSetup.ObsAttributes.Items[IAtt].ControlMethod := cmByItem;
    IAtt := PosDepCap('StatFlag');
    Project.ObservationSetup.ObsAttributes.Items[IAtt].ControlMethod := cmByItem;
  end;
end;

function TPhastModel.DoEquilibriumPhasesUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoEquilibriumPhasesUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoEquilibriumPhasesUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.EtsIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.EtsPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.EtsPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.EtsTimeVaryingLayers: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.EtsPackage.TimeVaryingLayers;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.EtsPackage.TimeVaryingLayers;
      end;
    end;
  end;
end;

function TPhastModel.EvtIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.EvtPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.EvtPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.EvtTimeVaryingLayers: boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.EvtPackage.TimeVaryingLayers;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.EvtPackage.TimeVaryingLayers;
      end;
    end;
  end;
end;

procedure TPhastModel.HandleModelMateObservations(
  Operation: TModelMateOperation;
  ObservationList: TStringList; Project: TProject);
var
  Observations: THobBoundary;
  ScreenObject: TScreenObject;
  ScreenObjectIndex: Integer;
  ModelMuseFluxObsGroup: TFluxObservationGroup;
  ModelMateObs: TDep;
  ValueIndex: Integer;
  OBSNAM: string;
  ModelMuseHeadObs: THobItem;
  Index: Integer;
  DepSet: TDepSet;
  Method: TMultiObsMethod;
  ObsVersionSingular: string;
  ObsVersionPlural: string;
  WarningMessage: string;
  SwiObservations: TSwiObsBoundary;
  ModelMuseSwiObs: TSwiObsItem;
  CellList: TCellAssignmentList;
begin
  // flux observations
  ObservationList.CaseSensitive := False;

  DepSet := nil;
  case ObservationPurpose of
    ofObserved: DepSet := Project.ObsSet;
    ofPredicted: DepSet := Project.PredSet;
    else Assert(False);
  end;
  for Index := 0 to DepSet.Count - 1 do
  begin
    ModelMateObs := DepSet.Items[Index];
    ObservationList.AddObject(string(ModelMateObs.Name), ModelMateObs);
  end;
  if ModflowPackages.ChobPackage.IsSelected then
  begin
    for Index := 0 to HeadFluxObservations.Count - 1 do
    begin
      ModelMuseFluxObsGroup := HeadFluxObservations[Index];
      if ModelMuseFluxObsGroup.Purpose = ObservationPurpose then
      begin
        UpdateModelMateFluxObservation(ObservationList, ModelMuseFluxObsGroup, Project, Operation);
      end;
    end;
  end;
  if ModflowPackages.DrobPackage.IsSelected then
  begin
    for Index := 0 to DrainObservations.Count - 1 do
    begin
      ModelMuseFluxObsGroup := DrainObservations[Index];
      if ModelMuseFluxObsGroup.Purpose = ObservationPurpose then
      begin
        UpdateModelMateFluxObservation(ObservationList, ModelMuseFluxObsGroup, Project, Operation);
      end;
    end;
  end;
  if ModflowPackages.GbobPackage.IsSelected then
  begin
    for Index := 0 to GhbObservations.Count - 1 do
    begin
      ModelMuseFluxObsGroup := GhbObservations[Index];
      if ModelMuseFluxObsGroup.Purpose = ObservationPurpose then
      begin
        UpdateModelMateFluxObservation(ObservationList, ModelMuseFluxObsGroup, Project, Operation);
      end;
    end;
  end;
  if ModflowPackages.RvobPackage.IsSelected then
  begin
    for Index := 0 to RiverObservations.Count - 1 do
    begin
      ModelMuseFluxObsGroup := RiverObservations[Index];
      if ModelMuseFluxObsGroup.Purpose = ObservationPurpose then
      begin
        UpdateModelMateFluxObservation(ObservationList, ModelMuseFluxObsGroup, Project, Operation);
      end;
    end;
  end;
  if ModflowPackages.StobPackage.IsSelected then
  begin
    for Index := 0 to StreamObservations.Count - 1 do
    begin
      ModelMuseFluxObsGroup := StreamObservations[Index];
      if ModelMuseFluxObsGroup.Purpose = ObservationPurpose then
      begin
        UpdateModelMateFluxObservation(ObservationList, ModelMuseFluxObsGroup, Project, Operation);
      end;
    end;
  end;
  // Head observations
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    ScreenObject := ScreenObjects[ScreenObjectIndex];
    if ScreenObject.Deleted then
    begin
      Continue;
    end;
    Observations := ScreenObject.ModflowHeadObservations;
    if (Observations <> nil) and Observations.Used
      and (Observations.Purpose = ObservationPurpose) then
    begin
      CellList := TCellAssignmentList.Create;
      try
        ScreenObject.GetCellsToAssign( '0', nil, nil, CellList, alAll, self);
        if CellList.Count > 0 then
        begin
          Method := Observations.MultiObsMethod;
          if Observations.Values.Count = 1 then
          begin
            ModelMuseHeadObs := Observations.Values.HobItems[0];
            OBSNAM := Observations.ObservationName;
            UpdateModelMateHeadObservation(ObservationList, OBSNAM,
              ModelMuseHeadObs, Project, Operation, momAllHeads);
          end
          else
          begin
            for ValueIndex := 0 to Observations.Values.Count - 1 do
            begin
              ModelMuseHeadObs := Observations.Values.HobItems[ValueIndex];
              OBSNAM := Observations.ObservationName + '_' + IntToStr(ValueIndex + 1);
              if Length(OBSNAM) > MaxString12 then
              begin
                OBSNAM := Observations.ObservationName + IntToStr(ValueIndex + 1);
              end;
              if Length(OBSNAM) > MaxString12 then
              begin
                // The GUI is designed to prevent this from ever being required.
                SetLength(OBSNAM, MaxString12);
              end;
              if ValueIndex = 0 then
              begin
                UpdateModelMateHeadObservation(ObservationList, OBSNAM,
                  ModelMuseHeadObs, Project, Operation, momAllHeads);
              end
              else
              begin
                UpdateModelMateHeadObservation(ObservationList, OBSNAM,
                  ModelMuseHeadObs, Project, Operation, Method);
              end;
            end;
          end;
        end;
      finally
        CellList.Free;
      end;
    end;
  end;
  // Zeta observations;
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    ScreenObject := ScreenObjects[ScreenObjectIndex];
    if ScreenObject.Deleted then
    begin
      Continue;
    end;
    SwiObservations := ScreenObject.ModflowSwiObservations;
    if (SwiObservations <> nil) and SwiObservations.Used
      and (SwiObservations.Purpose = ObservationPurpose) then
    begin
      for ValueIndex := 0 to SwiObservations.Values.Count - 1 do
      begin
        ModelMuseSwiObs := SwiObservations.Values.SwiItems[ValueIndex];
        OBSNAM := ModelMuseSwiObs.Name;
        UpdateModelMateZetaObservation(ObservationList, OBSNAM,
          ModelMuseSwiObs, Project, Operation);
      end;

    end;
  end;

  case Operation of
    mmoImport:
      begin
        if ObservationList.Count > 0 then
        begin
          case ObservationPurpose of
            ofObserved:
              begin
                ObsVersionSingular := StrObservation;
                ObsVersionPlural := StrObservations;
              end;

            ofPredicted:
              begin
                ObsVersionSingular := StrPrediction;
                ObsVersionPlural := StrPredictions;
              end
            else Assert(False);
          end;
          Beep;
          WarningMessage := Format(StrOneOrMore0sFro,
            [ObsVersionPlural, ObsVersionSingular, ObsVersionSingular]);
          MessageDlg(WarningMessage + sLineBreak + sLineBreak
            + ObservationList.Text, mtWarning, [mbOK], 0);
        end;
      end;
    mmoExport: ;
    else Assert(False);
  end;
end;

procedure TPhastModel.HandleModelMateParameters(Operation: TModelMateOperation;
  ParameterList: TStringList; Project: TProject);
var
  ModelMuseParam: TModflowParameter;
  ModelMateParam: TParam;
  Index: Integer;
begin
  for Index := 0 to Project.ParamSet.Count - 1 do
  begin
    ModelMateParam := Project.ParamSet.Items[Index];
    ParameterList.AddObject(string(ModelMateParam.Name), ModelMateParam);
  end;
  ParameterList.CaseSensitive := False;
  for Index := 0 to ModflowSteadyParameters.Count - 1 do
  begin
    ModelMuseParam := ModflowSteadyParameters[Index];
    UpdateModelMateParameter(ParameterList, ModelMuseParam, Project, Operation);
  end;
  for Index := 0 to ModflowTransientParameters.Count - 1 do
  begin
    ModelMuseParam := ModflowTransientParameters[Index];
    UpdateModelMateParameter(ParameterList, ModelMuseParam, Project, Operation);
  end;
  for Index := 0 to HufParameters.Count - 1 do
  begin
    ModelMuseParam := HufParameters[Index];
    UpdateModelMateParameter(ParameterList, ModelMuseParam, Project, Operation);
  end;

  case Operation of
    mmoImport:
      begin
        if ParameterList.Count > 0 then
        begin
          Beep;
          MessageDlg(StrOneOrMoreParamete + sLineBreak + sLineBreak
            + ParameterList.Text, mtWarning, [mbOK], 0);
        end;
      end;
    mmoExport: ;
    else Assert(False);
  end;
end;

function TPhastModel.HfbIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.HfbPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.HfbPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.HobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.HobPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.HobPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoHorizontalAnisotropyUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoHorizontalAnisotropyUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoHorizontalAnisotropyUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoHorizontalTransverseDispersionUsed(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoHorizontalTransverseDispersionUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoHorizontalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoHorizontalTransverseDispersionUsedPerSpecies(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoHorizontalTransverseDispersionUsedPerSpecies(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.IncreaseScreenObjectCapacity(const Delta: integer);
begin
  if Delta <= 0 then Exit;
  FScreenObjectList.Capacity := FScreenObjectList.Capacity + Delta;
end;

function TPhastModel.GhbIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.GhbBoundary.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.GhbBoundary.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.GmgIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.GmgPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.GmgPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.SetWindowState(const Value: TWindowState);
begin
  if GuiSettings <> nil then
  begin
    GuiSettings.WindowState := Value
  end;
//  frmGoPhast.WindowState := Value;
end;

function TPhastModel.Sfr6IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.SfrModflow6Package.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.SfrModflow6Package.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.SfrIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.SfrPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.SfrPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoSftUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoMt3dMS_StrictUsed(Sender) and inherited DoSftUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := ChildModel.DoSftUsed(Sender);
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;
end;

function TPhastModel.ShouldDrawPilotPoints: Boolean;
begin
  result := PestProperties.ShouldDrawPilotPoints;
end;

procedure TPhastModel.DisconnectObservers;
var
  Index: Integer;
  Variable: IGlobalVariable;
  ScreenObject: TScreenObject;
  DataArray: TDataArray;
begin
  SutraFluxObs.StopTalkingToAnyOne;
  RipPlantGroups.StopTalkingToAnyone;
  AllObserversStopTalking;
  FLayerStructure.StopTalkingToAnyone;
  //  FSutraLayerStructure.StopTalkingToAnyone;
  for Index := 0 to GlobalVariablesI.Count - 1 do
  begin
    Variable := GlobalVariablesI[Index];
    Variable.StopTalkingToAnyone;
  end;
  for Index := 0 to ScreenObjectCount - 1 do
  begin
    ScreenObject := ScreenObjects[Index];
    ScreenObject.StopTalkingToAnyone;
  end;
  for Index := 0 to FDataArrayManager.DataSetCount - 1 do
  begin
    DataArray := FDataArrayManager.DataSets[Index];
    DataArray.StopTalkingToAnyone;
  end;
end;

function TPhastModel.GetPestName: string;
begin
  result := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory) + 'I64pest.exe';
  if not FileExists(Trim(result)) then
  begin
    result := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory) + 'pest.exe';
  end;
  if not FileExists(Trim(result)) then
  begin
    result := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory) + 'pest_hp.exe';
  end;
end;

function TPhastModel.StrIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.StrPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.StrPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.SipIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.SipPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.SipPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DoSoilIDUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSoilIDUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSoilIDUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSolidSolutionUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSolidSolutionUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSolidSolutionUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSpecificStorageUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSpecificStorageUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSpecificStorageUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSpecificYieldUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSpecificYieldUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSpecificYieldUsed(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.SetSoluteTransport(const Value: boolean);
begin
  if FSoluteTransport <> Value then
  begin
    FSoluteTransport := Value;
    DoInvalidate(self);
  end;
end;

procedure TPhastModel.SetSomeSegmentsUpToDate(const Value: boolean);
begin
  FSomeSegmentsUpToDate := Value;
end;

procedure TPhastModel.SetStrStreamLinkPlot(const Value: TSfrStreamLinkPlot);
begin
  FStrStreamLinkPlot.Assign(Value);
end;

procedure TPhastModel.SetSupCalcProperties(const Value: TSupCalcProperties);
begin
  FSupCalcProperties.Assign(Value);
end;

procedure TPhastModel.SetSutraLayerStructure(const Value: TSutraLayerStructure);
begin
  FSutraLayerStructure.Assign(Value);
end;

procedure TPhastModel.SetSutraSettings(const Value: TSutraSettings);
begin
  FSutraSettings.Assign(Value);
  SutraMesh.Assign(FSutraSettings)
end;

procedure TPhastModel.SetSutraTimeOptions(const Value: TSutraTimeOptions);
begin
  FSutraTimeOptions.Assign(Value);
end;

procedure TPhastModel.SetSvdaPrepProperties(const Value: TSvdaPrepProperties);
begin
  FSvdaPrepProperties.Assign(Value);
end;

procedure TPhastModel.SetSwrReachConnectionsPlot(
  const Value: TSwrReachConnectionsPlot);
var
  UpdateReachNumbers: Boolean;
begin
  UpdateReachNumbers := SwrIsSelected
    and (FSwrReachConnectionsPlot.ReachesToPlot <> Value.ReachesToPlot)
    and ((FSwrReachConnectionsPlot.ReachesToPlot = stpNone)
    or (Value.ReachesToPlot = stpNone));

  FSwrReachConnectionsPlot.Assign(Value);

  if UpdateReachNumbers then
  begin
    UpdateSwrReachNumber(nil);
  end;
end;

procedure TCustomModel.SetSwiObsExtractorInputFiles(const Value: TStrings);
begin
  FSwiObsExtractorInputFiles.Assign(Value);
end;

procedure TCustomModel.SetSwiObsExtractorOutputFiles(const Value: TStrings);
begin
  FSwiObsExtractorOutputFiles.Assign(Value);
end;

procedure TCustomModel.SetSwrObservations(const Value: TSwrObsCollection);
begin
  FSwrObservations.Assign(Value);
end;

procedure TCustomModel.SetSwrReachGeometry(
  const Value: TReachGeometryCollection);
begin
  FSwrReachGeometry.Assign(Value);
  InvalidateMfSwrGeometryNumber(self);
end;

procedure TCustomModel.SetSwrStructures(const Value: TStructureCollection);
begin
  FSwrStructures.Assign(Value);
end;

procedure TCustomModel.SetSwrTabFiles(const Value: TTabFileCollection);
begin
  FSwrTabFiles.Assign(Value);
end;

procedure TPhastModel.SetSaveBfhBoundaryConditions(const Value: boolean);
begin
  FSaveBfhBoundaryConditions := Value;
end;

procedure TPhastModel.SetScreenObjectCollection(
  const Value: TScreenObjectCollection);
begin
  FScreenObjectCollection.Assign(Value);
end;

procedure TPhastModel.SetSelectedModel(const Value: TCustomModel);
begin
  FSelectedModel := Value;
end;

procedure TPhastModel.SetSfrMf6StreamLinkPlot(const Value: TSfrStreamLinkPlot);
begin
  FSfrMf6StreamLinkPlot.Assign(Value);
end;

procedure TPhastModel.SetSfrStreamLinkPlot(const Value: TSfrStreamLinkPlot);
begin
  FSfrStreamLinkPlot.Assign(Value);
end;

procedure TPhastModel.SetShowContourLabels(const Value: boolean);
begin
  FShowContourLabels := Value;
end;

procedure TPhastModel.UpdateThreeDTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildList: TCustomTimeList;
begin
  inherited;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildList := ChildModel.GetTimeListByName(TimeList.Name);
        ChildModel.UpdateThreeDTimeDataSet(ChildList, Time);
      end;
    end;
  end;
end;

procedure TPhastModel.UpdateTimeLists;
var
  Index: integer;
  TimeList: TCustomTimeList;
begin
  for Index := 0 to TimeListCount - 1 do
  begin
    TimeList := TimeLists[Index];
    if TimeList is TPhastTimeList then
    begin
      TPhastTimeList(TimeList).Loaded;
    end;
  end;
  ModflowPackages.EtsPackage.UpdateEtsSegmentCount;
end;

procedure TPhastModel.UpdateTopTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildList: TCustomTimeList;
begin
  inherited;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildList := ChildModel.GetTimeListByName(TimeList.Name);
        ChildModel.UpdateTopTimeDataSet(ChildList, Time);
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateThreeDTimeDataSet(const TimeList: TCustomTimeList;
  const Time: double);
var
  TimeIndex: integer;
  LocalSelectedLayer, LocalSelectedRow, LocalSelectedColumn: integer;
  LocalMesh3D: IMesh3D;
begin
  if TimeList.UpToDate then
  begin
    Exit;
  end;
  if Grid <> nil then
  begin
    if (Grid.LayerCount <= 0) or (Grid.RowCount <= 0) or (Grid.ColumnCount <= 0) then
    begin
      FThreeDTimeList := nil;
      ThreeDDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := Grid.SelectedLayer;
    LocalSelectedRow := Grid.SelectedRow;
    LocalSelectedColumn := Grid.SelectedColumn;
    try
      FThreeDDisplayTime := Time;
      if not TimeList.UpToDate then
      begin
        ThreeDDataSet := nil;
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        ThreeDDataSet := nil;
      end
      else
      begin
        ThreeDDataSet := TimeList.Items[TimeIndex];
        ThreeDDataSet.UpdateMinMaxValues
      end;
      FThreeDTimeList := TimeList;
    finally
      Grid.SelectedLayer := LocalSelectedLayer;
      Grid.SelectedRow := LocalSelectedRow;
      Grid.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else if Mesh <> nil then
  begin
    if (Mesh as TSutraMesh3D).Mesh2D.Nodes.Count <= 0 then
    begin
      FThreeDTimeList := nil;
      ThreeDDataSet := nil;
      Exit;
    end;
    if ((Mesh as TSutraMesh3D).MeshType = mt3D)
      and ((Mesh as TSutraMesh3D).Nodes.Count <= 0) then
    begin
      FThreeDTimeList := nil;
      ThreeDDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := (Mesh as TSutraMesh3D).SelectedLayer;
//    LocalSelectedRow := Mesh.SelectedRow;
//    LocalSelectedColumn := Mesh.SelectedColumn;
    try
      FThreeDDisplayTime := Time;
      if not TimeList.UpToDate then
      begin
        ThreeDDataSet := nil;
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        ThreeDDataSet := nil;
      end
      else
      begin
        ThreeDDataSet := TimeList.Items[TimeIndex];
        ThreeDDataSet.UpdateMinMaxValues
      end;
      FThreeDTimeList := TimeList;
    finally
      (Mesh as TSutraMesh3D).SelectedLayer := LocalSelectedLayer;
//      Mesh.SelectedRow := LocalSelectedRow;
//      Mesh.SelectedColumn := LocalSelectedColumn;
    end;
  end
  else if Mesh3d <> nil then
  begin
    LocalMesh3D := Mesh3d;
    if LocalMesh3D.ElementCount <= 0 then
    begin
      FThreeDTimeList := nil;
      ThreeDDataSet := nil;
      Exit;
    end;
    LocalSelectedLayer := LocalMesh3D.SelectedLayer;
    try
      FThreeDDisplayTime := Time;
      if not TimeList.UpToDate then
      begin
        ThreeDDataSet := nil;
        TimeList.Initialize;
      end;
      TimeIndex := TimeList.FirstTimeGreaterThan(Time) - 1;
      if TimeIndex < 0 then
      begin
        ThreeDDataSet := nil;
      end
      else
      begin
        ThreeDDataSet := TimeList.Items[TimeIndex];
        ThreeDDataSet.UpdateMinMaxValues
      end;
      FThreeDTimeList := TimeList;
    finally
      LocalMesh3D.SelectedLayer := LocalSelectedLayer;
    end;
  end;
end;

procedure TPhastModel.DrawHeadObservations(const BitMap: TPersistent;
  const ZoomBox: TQRbwZoomBox2);
var
  MaxResid: Double;
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  MaxResid := 0;
  if StoreHeadObsResults and FHeadObsResults.Visible then
  begin
    FHeadObsResults.CalculateMaxResidual(self);
    MaxResid := FHeadObsResults.MaxResidual;
  end;
  if LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        if ChildModel.StoreHeadObsResults and ChildModel.HeadObsResults.Visible then
        begin
          ChildModel.HeadObsResults.CalculateMaxResidual(ChildModel);
          if MaxResid < ChildModel.HeadObsResults.MaxResidual then
          begin
            MaxResid := ChildModel.HeadObsResults.MaxResidual;
          end;
        end;
      end;
    end;
    if StoreHeadObsResults and FHeadObsResults.Visible then
    begin
      FHeadObsResults.MaxResidual := MaxResid;
    end;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        if ChildModel.StoreHeadObsResults and ChildModel.HeadObsResults.Visible then
        begin
          ChildModel.HeadObsResults.MaxResidual := MaxResid;
        end;
      end;
    end;
  end;
  inherited;
  for ChildIndex := 0 to ChildModels.Count - 1 do
  begin
    ChildModel := ChildModels[ChildIndex].ChildModel;
    if ChildModel <> nil then
    begin
      ChildModel.DrawHeadObservations(BitMap, ZoomBox);
    end;
  end;
end;

procedure TPhastModel.DrawPilotPoints(BitMap32: TBitmap32);
begin
  PestProperties.DrawPilotPoints(BitMap32);
end;

procedure TPhastModel.DrawScreenObjects3D;
var
  Index: integer;
  AScreenObject: TScreenObject;
begin
  EnableLighting;

  glMatrixMode(GL_MODELVIEW);
  // do in reverse order so that object that are on top but at the same
  // location appear on top.
  for Index := ScreenObjectCount - 1 downto 0 do
  begin
    AScreenObject := ScreenObjects[Index];
    AScreenObject.Draw3D;
  end;
end;

procedure TCustomModel.DrawStrStreamLinkages(const BitMap: TPersistent;
  const ZoomBox: TQRbwZoomBox2);
var
  StreamList: TSfrStreamPlotList;
  StreamNumbers: TIntegerList;
  Index: Integer;
  StreamToPlot: TSfrStreamPlot;
  StreamIndex: Integer;
  OtherStream: TSfrStreamPlot;
  UpstreamPoint: TPoint2D;
  Points: array[0..1] of TPoint;
  DownstreamPoint: TPoint2D;
  StreamColor: TColor32;
  DiversionColor: TColor32;
  UnconnectedColor: TColor32;
  BadConnectionColor: TColor32;
  DownstreamObject: TScreenObject;
  UpstreamObject: TScreenObject;
  StreamObject: TScreenObject;
  SquareSize: integer;
begin
  inherited;
  StreamList := TSfrStreamPlotList.Create;
  try
    StrStreamLinkPlot.GetObjectsToPlot(StreamList);
    if StreamList.Count > 0 then
    begin
      StreamColor := Color32(StrStreamLinkPlot.StreamColor);
      DiversionColor := Color32(StrStreamLinkPlot.DiversionColor);
      UnconnectedColor := Color32(StrStreamLinkPlot.UnconnectedColor);
      BadConnectionColor := Color32(StrStreamLinkPlot.BadConnectionColor);
      SquareSize := StrStreamLinkPlot.SquareSize;

      StreamNumbers := TIntegerList.Create;
      try
        for Index := 0 to StreamList.Count - 1 do
        begin
          StreamToPlot := StreamList[Index];
          StreamNumbers.Add(StreamToPlot.Segment);
        end;
        StreamNumbers.Sorted := True;
        for Index := 0 to StreamList.Count - 1 do
        begin
          StreamToPlot := StreamList[Index];
          if StrStreamLinkPlot.PlotUnconnected then
          begin
            if StreamToPlot.OutflowSegment = 0 then
            begin
              StreamObject := StreamToPlot.StreamObject as TScreenObject;
              UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
              Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
              Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
              DrawBigRectangle32(BitMap, UnconnectedColor, UnconnectedColor, 1,
                Points[0].X - SquareSize, Points[0].Y - SquareSize,
                Points[0].X + SquareSize, Points[0].Y + SquareSize);
            end;
          end;
          if StrStreamLinkPlot.PlotStreamConnections
            or StrStreamLinkPlot.PlotBadConnection then
          begin
            DownstreamObject := nil;
            if StreamToPlot.OutflowSegment > 0 then
            begin
              StreamIndex := StreamNumbers.IndexOf(StreamToPlot.OutflowSegment);
              if StreamIndex >= 0 then
              begin
                OtherStream := StreamList[StreamIndex];
                DownstreamObject := OtherStream.StreamObject as TScreenObject;
                Assert(StreamToPlot.OutflowSegment = OtherStream.Segment)
              end;
            end;
            if DownstreamObject = nil then
            begin
              if StrStreamLinkPlot.PlotBadConnection
                and (StreamToPlot.OutflowSegment > 0) then
              begin
                StreamObject := StreamToPlot.StreamObject as TScreenObject;
                UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
                Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
                Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
                DrawBigRectangle32(BitMap, BadConnectionColor, BadConnectionColor, 1,
                  Points[0].X - SquareSize, Points[0].Y - SquareSize,
                  Points[0].X + SquareSize, Points[0].Y + SquareSize);
              end;
            end
            else
            begin
              if StrStreamLinkPlot.PlotStreamConnections then
              begin
                StreamObject := StreamToPlot.StreamObject as TScreenObject;
                UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
                Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
                Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);

                DownstreamPoint := DownstreamObject.Points[0];
                Points[1].X := ZoomBox.XCoord(DownstreamPoint.x);
                Points[1].Y := ZoomBox.YCoord(DownstreamPoint.y);

                if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                begin
                  DrawBigRectangle32(BitMap, StreamColor, StreamColor, 1,
                    Points[0].X - SquareSize, Points[0].Y - SquareSize,
                    Points[0].X + SquareSize, Points[0].Y + SquareSize);
                end
                else
                begin
                  DrawBigPolyline32(BitMap, StreamColor, 2, Points, True);
                end;
              end;
            end;
          end;
          if StrStreamLinkPlot.PlotDiversions then
          begin
            UpstreamObject := nil;
            if StreamToPlot.DiversionSegment > 0 then
            begin
              StreamIndex := StreamNumbers.IndexOf(StreamToPlot.DiversionSegment);
              if StreamIndex >= 0 then
              begin
                OtherStream := StreamList[StreamIndex];
                UpstreamObject := OtherStream.StreamObject as TScreenObject;
                Assert(StreamToPlot.DiversionSegment = OtherStream.Segment)
              end;
            end;
            if UpstreamObject <> nil then
            begin
              UpstreamPoint := UpstreamObject.Points[UpstreamObject.Count-1];
              Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
              Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);

              StreamObject := StreamToPlot.StreamObject as TScreenObject;
              DownstreamPoint := StreamObject.Points[0];
              Points[1].X := ZoomBox.XCoord(DownstreamPoint.x);
              Points[1].Y := ZoomBox.YCoord(DownstreamPoint.y);

              if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
              begin
                DrawBigRectangle32(BitMap, DiversionColor, DiversionColor, 1,
                  Points[0].X - SquareSize, Points[0].Y - SquareSize,
                  Points[0].X + SquareSize, Points[0].Y + SquareSize);
              end
              else
              begin
                DrawBigPolyline32(BitMap, DiversionColor, 2, Points, True);
              end;
            end;
          end;
        end;
      finally
        StreamNumbers.Free;
      end;
    end;
  finally
    StreamList.Free;
  end;
end;

procedure TCustomModel.DrawSwrReachConnections(const BitMap: TPersistent;
  const ZoomBox: TQRbwZoomBox2);
const
  SquareSize = 6;
var
  SwrReachArray: TModflowBoundaryDisplayDataArray;
  ReachIndex: Integer;
  AReach: TSwrReachPlot;
  APoint2D: TPoint2D;
  APoint: TPoint;
  ConnectedColor: TColor32;
  UnConnectedColor: TColor32;
  NeighborIndex: Integer;
  NeightborReachIndex: Integer;
  NeighborReach: TSwrReachPlot;
  NeighborPoint: TPoint2D;
  Points: array[0..1] of TPoint;
  UnconnectedReachesPresent: boolean;
  StructureIndex: Integer;
  AStructure: TStructure;
  StructureColor: TColor32;
  AScreenObject: TScreenObject;
begin
  if SwrReachConnectionsPlot.ReachesToPlot = stpNone then
  begin
    exit;
  end;
  if not DoSwrSelected(nil) then
  begin
    Exit;
  end;
  frmErrorsAndWarnings.RemoveErrorGroup(Self, StrIllegalSWRReachNu);

  SwrReachArray := DataArrayManager.GetDataSetByName(KSwrReach)
    as TModflowBoundaryDisplayDataArray;
  if SwrReachArray = nil then
  begin
    Exit;
  end;
  if not SwrReachArray.UpToDate then
  begin
    UpdateSwrReachNumber(nil);
  end;
  SwrReachConnectionsPlot.UpdateReachVisibility;
  ConnectedColor := Color32(SwrReachConnectionsPlot.ConnectedColor);
  UnConnectedColor := Color32(SwrReachConnectionsPlot.UnConnectedColor);
  StructureColor := Color32(SwrReachConnectionsPlot.StructureColor);
  UnconnectedReachesPresent := False;
  for ReachIndex := 0 to SwrReachConnectionsPlot.ReachList.Count - 1 do
  begin
    AReach := SwrReachConnectionsPlot.ReachList[ReachIndex];
    if AReach.Visible then
    begin
      if AReach.NeighborCount = 0 then
      begin
        UnconnectedReachesPresent := True;
      end
      else
      begin
        if SwrReachConnectionsPlot.PlotReachConnections then
        begin
          AScreenObject := AReach.ScreenObject as TScreenObject;
          if AScreenObject.Count = 1 then
          begin
            APoint2D := AScreenObject.Points[0];
          end
          else
          begin
            APoint2D := Grid.TwoDElementCenter(AReach.Column, AReach.Row);
          end;
          APoint.X := ZoomBox.XCoord(APoint2D.x);
          APoint.Y := ZoomBox.YCoord(APoint2D.y);
          Points[0] := APoint;
          for NeighborIndex := 0 to AReach.NeighborCount - 1 do
          begin
            NeightborReachIndex := AReach.Neighbors[NeighborIndex]-1;
            if NeightborReachIndex >= SwrReachConnectionsPlot.ReachList.Count then
            begin
              frmErrorsAndWarnings.AddError(self, 'Illegal SWR Reach number',
                Format('The SWR reach number %0:d is too large',
                [AReach.Neighbors[NeighborIndex]]),
                AReach.ScreenObject);
            end
            else
            begin
              NeighborReach := SwrReachConnectionsPlot.ReachList[NeightborReachIndex];
              if NeighborReach.Visible then
              begin
                AScreenObject := NeighborReach.ScreenObject as TScreenObject;
                if AScreenObject.Count = 1 then
                begin
                  NeighborPoint := AScreenObject.Points[0];
                end
                else
                begin
                  NeighborPoint := Grid.TwoDElementCenter(NeighborReach.Column, NeighborReach.Row);
                end;
                APoint.X := ZoomBox.XCoord(NeighborPoint.x);
                APoint.Y := ZoomBox.YCoord(NeighborPoint.y);
                Points[1] := APoint;

                if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                begin
                  DrawBigRectangle32(BitMap, ConnectedColor, ConnectedColor, 1,
                    Points[0].X - SquareSize, Points[0].Y - SquareSize,
                    Points[0].X + SquareSize, Points[0].Y + SquareSize);
                end
                else
                begin
                  DrawBigPolyline32(BitMap, ConnectedColor, 2, Points, True);
                end;

              end;
            end;
          end;
        end;
      end;
    end;
  end;
  if UnconnectedReachesPresent and SwrReachConnectionsPlot.PlotUnconnected then
  begin
    for ReachIndex := 0 to SwrReachConnectionsPlot.ReachList.Count - 1 do
    begin
      AReach := SwrReachConnectionsPlot.ReachList[ReachIndex];
      if AReach.Visible then
      begin
        if AReach.NeighborCount = 0 then
        begin
          AScreenObject := AReach.ScreenObject as TScreenObject;
          if AScreenObject.Count = 1 then
          begin
            APoint2D := AScreenObject.Points[0];
          end
          else
          begin
            APoint2D := Grid.TwoDElementCenter(AReach.Column, AReach.Row);
          end;
          APoint.X := ZoomBox.XCoord(APoint2D.x);
          APoint.Y := ZoomBox.YCoord(APoint2D.y);
          DrawBigRectangle32(BitMap, UnconnectedColor, UnconnectedColor, 1,
            APoint.X - SquareSize, APoint.Y - SquareSize,
            APoint.X + SquareSize, APoint.Y + SquareSize);
        end
      end;
    end;
  end;
  if SwrReachConnectionsPlot.PlotStructures then
  begin
    for StructureIndex := 0 to SwrStructures.Count - 1 do
    begin
      AStructure := SwrStructures[StructureIndex];
      if (AStructure.Reach >= 1)
        and (AStructure.Reach <= SwrReachConnectionsPlot.ReachList.Count) then
      begin
        AReach := SwrReachConnectionsPlot.ReachList[AStructure.Reach-1];
        if AStructure.Reach = AReach.Reach then
        begin
          if AReach.Visible then
          begin
            AScreenObject := AReach.ScreenObject as TScreenObject;
            if AScreenObject.Count = 1 then
            begin
              APoint2D := AScreenObject.Points[0];
            end
            else
            begin
              APoint2D := Grid.TwoDElementCenter(AReach.Column, AReach.Row);
            end;
            APoint.X := ZoomBox.XCoord(APoint2D.x);
            APoint.Y := ZoomBox.YCoord(APoint2D.y);
            Points[0] := APoint;
            if (AStructure.ConnectedReach >= 1)
              and (AStructure.ConnectedReach
              <= SwrReachConnectionsPlot.ReachList.Count) then
            begin
              AReach := SwrReachConnectionsPlot.ReachList[AStructure.ConnectedReach-1];
              if AStructure.ConnectedReach = AReach.Reach then
              begin
                if AReach.Visible then
                begin
                  AScreenObject := AReach.ScreenObject as TScreenObject;
                  if AScreenObject.Count = 1 then
                  begin
                    APoint2D := AScreenObject.Points[0];
                  end
                  else
                  begin
                    APoint2D := Grid.TwoDElementCenter(AReach.Column, AReach.Row);
                  end;
                  APoint.X := ZoomBox.XCoord(APoint2D.x);
                  APoint.Y := ZoomBox.YCoord(APoint2D.y);
                  Points[1] := APoint;
                  if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                  begin
                    DrawBigRectangle32(BitMap, StructureColor, StructureColor, 1,
                      Points[0].X - SquareSize, Points[0].Y - SquareSize,
                      Points[0].X + SquareSize, Points[0].Y + SquareSize);
                  end
                  else
                  begin
                    DrawBigPolyline32(BitMap, StructureColor, 2, Points, True);
                  end;
                end;
              end
              else
              begin
                frmErrorsAndWarnings.AddError(Self, StrIllegalSWRReachNu,
                  StrThereIsAnErrorIn);
              end;
            end
            else
            begin
              DrawBigRectangle32(BitMap, StructureColor, StructureColor, 1,
                APoint.X - SquareSize, APoint.Y - SquareSize,
                APoint.X + SquareSize, APoint.Y + SquareSize);
            end;
            if (AStructure.StructureType in [sstPump,sstMoveableWeir,
              sstGatedSpillway, sstSpillEquation])
              and (AStructure.ControlReach >= 1) then
            begin
              AReach := SwrReachConnectionsPlot.ReachList[AStructure.ControlReach-1];
              Assert(AStructure.ControlReach = AReach.Reach);
              if AReach.Visible then
              begin
                AScreenObject := AReach.ScreenObject as TScreenObject;
                if AScreenObject.Count = 1 then
                begin
                  APoint2D := AScreenObject.Points[0];
                end
                else
                begin
                  APoint2D := Grid.TwoDElementCenter(AReach.Column, AReach.Row);
                end;
                APoint.X := ZoomBox.XCoord(APoint2D.x);
                APoint.Y := ZoomBox.YCoord(APoint2D.y);
                Points[1] := APoint;
                if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                begin
                  DrawBigRectangle32(BitMap, StructureColor, StructureColor, 1,
                    Points[0].X - SquareSize, Points[0].Y - SquareSize,
                    Points[0].X + SquareSize, Points[0].Y + SquareSize);
                end
                else
                begin
                  DrawBigPolyline32(BitMap, StructureColor, 2, Points, True);
                end;
              end;
              if (AStructure.ControlType = ctFlow) and (AStructure.ConnectedControlReach >= 1) then
              begin
                AReach := SwrReachConnectionsPlot.ReachList[AStructure.ConnectedControlReach-1];
                Assert(AStructure.ConnectedControlReach = AReach.Reach);
                if AReach.Visible then
                begin
                  AScreenObject := AReach.ScreenObject as TScreenObject;
                  if AScreenObject.Count = 1 then
                  begin
                    APoint2D := AScreenObject.Points[0];
                  end
                  else
                  begin
                    APoint2D := Grid.TwoDElementCenter(AReach.Column, AReach.Row);
                  end;
                  APoint.X := ZoomBox.XCoord(APoint2D.x);
                  APoint.Y := ZoomBox.YCoord(APoint2D.y);
                  Points[1] := APoint;
                  if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                  begin
                    DrawBigRectangle32(BitMap, StructureColor, StructureColor, 1,
                      Points[0].X - SquareSize, Points[0].Y - SquareSize,
                      Points[0].X + SquareSize, Points[0].Y + SquareSize);
                  end
                  else
                  begin
                    DrawBigPolyline32(BitMap, StructureColor, 2, Points, True);
                  end;
                end;
              end;
            end;
          end;
        end
        else
        begin
          frmErrorsAndWarnings.AddError(Self, StrIllegalSWRReachNu,
            StrThereIsAnErrorIn);
        end;
      end;
    end;
  end;

  if frmErrorsAndWarnings.HasMessages then
  begin
    frmErrorsAndWarnings.Show;
  end;
end;

procedure TCustomModel.DrawSfrMf6StreamLinkages(const BitMap: TPersistent;
  const ZoomBox: TQRbwZoomBox2);
var
  StreamList: TSfrStreamPlotList;
//  LakeList: TLakePlotList;
  StreamNumbers: TIntegerList;
//  LakeNumbers: TIntegerList;
  Index: Integer;
  StreamToPlot: TSfrStreamPlot;
//  LakeToPlot: TLakePlot;
  StreamIndex: Integer;
  OtherStream: TSfrStreamPlot;
//  LakeIndex: Integer;
  UpstreamPoint: TPoint2D;
  Points: array[0..1] of TPoint;
  DownstreamPoint: TPoint2D;
  StreamColor: TColor32;
  DiversionColor: TColor32;
  UnconnectedColor: TColor32;
  BadConnectionColor: TColor32;
  DownstreamObject: TScreenObject;
//  UpstreamObject: TScreenObject;
  StreamObject: TScreenObject;
  SquareSize: integer;
  OtherIndex: Integer;
  SectionIndex: Integer;
  PointIndex1: Integer;
  PointIndex2: Integer;
begin
  inherited;
  StreamList := TSfrStreamPlotList.Create;
//  LakeList := TLakePlotList.Create;
  try
    SfrMf6StreamLinkPlot.GetMf6ObjectsToPlot(StreamList);
    if StreamList.Count > 0 then
    begin
      StreamColor := Color32(SfrMf6StreamLinkPlot.StreamColor);
      DiversionColor := Color32(SfrMf6StreamLinkPlot.DiversionColor);
      UnconnectedColor := Color32(SfrMf6StreamLinkPlot.UnconnectedColor);
      BadConnectionColor := Color32(SfrMf6StreamLinkPlot.BadConnectionColor);
      SquareSize := SfrMf6StreamLinkPlot.SquareSize;

      StreamNumbers := TIntegerList.Create;
//      LakeNumbers := TIntegerList.Create;
      try
        for Index := 0 to StreamList.Count - 1 do
        begin
          StreamToPlot := StreamList[Index];
          StreamNumbers.Add(StreamToPlot.Segment);
        end;
        StreamNumbers.Sorted := True;
//        for Index := 0 to LakeList.Count - 1 do
//        begin
//          LakeToPlot := LakeList[Index];
//          LakeNumbers.Add(LakeToPlot.LakeId);
//        end;
//        LakeNumbers.Sorted := True;
        for Index := 0 to StreamList.Count - 1 do
        begin
          StreamToPlot := StreamList[Index];
          StreamObject := StreamToPlot.StreamObject as TScreenObject;
          if SfrMf6StreamLinkPlot.PlotUnconnected then
          begin
            if (StreamToPlot.OutflowSegments.Count = 0)
              and (StreamToPlot.DiversionSegments.Count = 0) then
            begin
              UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
              Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
              Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
              DrawBigRectangle32(BitMap, UnconnectedColor, UnconnectedColor, 1,
                Points[0].X - SquareSize, Points[0].Y - SquareSize,
                Points[0].X + SquareSize, Points[0].Y + SquareSize);
            end;
          end;

          if SfrMf6StreamLinkPlot.PlotStreamConnections
            and (StreamObject.SectionCount > 1) then
          begin
            for SectionIndex := 1 to StreamObject.SectionCount - 1 do
            begin
              PointIndex1 := StreamObject.SectionEnd[SectionIndex-1];
              PointIndex2 := StreamObject.SectionEnd[SectionIndex];
              UpstreamPoint := StreamObject.Points[PointIndex1];
              DownstreamPoint := StreamObject.Points[PointIndex2];
              Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
              Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
              Points[1].X := ZoomBox.XCoord(DownstreamPoint.x);
              Points[1].Y := ZoomBox.YCoord(DownstreamPoint.y);
              if (Points[0].X <> Points[1].X)
                or (Points[0].Y <> Points[1].Y) then
              begin
                DrawBigPolyline32(BitMap, StreamColor, 2, Points, True);
              end;
            end;
          end;

          if SfrMf6StreamLinkPlot.PlotStreamConnections
            or SfrMf6StreamLinkPlot.PlotBadConnection then
          begin
            for OtherIndex := 0 to StreamToPlot.OutflowSegments.Count -1 do
            begin
              DownstreamObject := nil;
              if StreamToPlot.OutflowSegments[OtherIndex] > 0 then
              begin
                StreamIndex := StreamNumbers.IndexOf(StreamToPlot.OutflowSegments[OtherIndex]);
                if StreamIndex >= 0 then
                begin
                  OtherStream := StreamList[StreamIndex];
                  DownstreamObject := OtherStream.StreamObject as TScreenObject;
                  Assert(StreamToPlot.OutflowSegments[OtherIndex] = OtherStream.Segment)
                end;
              end;
              if (DownstreamObject = nil) then
              begin
                if SfrMf6StreamLinkPlot.PlotBadConnection
                  and (StreamToPlot.OutflowSegments[OtherIndex] <> 0) then
                begin
                  StreamObject := StreamToPlot.StreamObject as TScreenObject;
                  UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
                  Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
                  Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
                  DrawBigRectangle32(BitMap, BadConnectionColor, BadConnectionColor, 1,
                    Points[0].X - SquareSize, Points[0].Y - SquareSize,
                    Points[0].X + SquareSize, Points[0].Y + SquareSize);
                end;
              end
              else
              begin
                if SfrMf6StreamLinkPlot.PlotStreamConnections then
                begin
                  StreamObject := StreamToPlot.StreamObject as TScreenObject;
                  UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
                  Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
                  Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);

                  DownstreamPoint := DownstreamObject.Points[0];
                  Points[1].X := ZoomBox.XCoord(DownstreamPoint.x);
                  Points[1].Y := ZoomBox.YCoord(DownstreamPoint.y);

                  if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                  begin
                    DrawBigRectangle32(BitMap, StreamColor, StreamColor, 1,
                      Points[0].X - SquareSize, Points[0].Y - SquareSize,
                      Points[0].X + SquareSize, Points[0].Y + SquareSize);
                  end
                  else
                  begin
                    DrawBigPolyline32(BitMap, StreamColor, 2, Points, True);
                  end;
                end;
              end;
            end;
          end;
          if SfrMf6StreamLinkPlot.PlotDiversions or SfrMf6StreamLinkPlot.PlotBadConnection then
          begin
            for OtherIndex := 0 to StreamToPlot.DiversionSegments.Count -1 do
            begin
              DownstreamObject := nil;
              if StreamToPlot.DiversionSegments[OtherIndex] > 0 then
              begin
                StreamIndex := StreamNumbers.IndexOf(StreamToPlot.DiversionSegments[OtherIndex]);
                if StreamIndex >= 0 then
                begin
                  OtherStream := StreamList[StreamIndex];
                  DownstreamObject := OtherStream.StreamObject as TScreenObject;
                  Assert(StreamToPlot.DiversionSegments[OtherIndex] = OtherStream.Segment)
                end;
  //            end
  //            else if StreamToPlot.DiversionSegment < 0 then
  //            begin
  //              LakeIndex := LakeNumbers.IndexOf(-StreamToPlot.DiversionSegment);
  //              if LakeIndex >= 0 then
  //              begin
  //                LakeToPlot := LakeList[LakeIndex];
  //                UpstreamObject := LakeToPlot.LakeObject as TScreenObject;
  //                Assert(-StreamToPlot.DiversionSegment = LakeToPlot.LakeId)
  //              end;
              end;
              if DownstreamObject <> nil then
              begin
                if SfrMf6StreamLinkPlot.PlotDiversions then
                begin
                  DownstreamPoint := DownstreamObject.Points[0];
                  Points[0].X := ZoomBox.XCoord(DownstreamPoint.x);
                  Points[0].Y := ZoomBox.YCoord(DownstreamPoint.y);

                  StreamObject := StreamToPlot.StreamObject as TScreenObject;
                  UpstreamPoint := StreamObject.Points[StreamObject.Count -1];
                  Points[1].X := ZoomBox.XCoord(UpstreamPoint.x);
                  Points[1].Y := ZoomBox.YCoord(UpstreamPoint.y);

                  if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                  begin
                    DrawBigRectangle32(BitMap, DiversionColor, DiversionColor, 1,
                      Points[0].X - SquareSize, Points[0].Y - SquareSize,
                      Points[0].X + SquareSize, Points[0].Y + SquareSize);
                  end
                  else
                  begin
                    DrawBigPolyline32(BitMap, DiversionColor, 2, Points, True);
                  end;
                end;
              end
              else
              begin
                if SfrMf6StreamLinkPlot.PlotBadConnection then
                begin
                  StreamObject := StreamToPlot.StreamObject as TScreenObject;
                  DownstreamPoint := StreamObject.Points[StreamObject.Count-1];
                  Points[0].X := ZoomBox.XCoord(DownstreamPoint.x);
                  Points[0].Y := ZoomBox.YCoord(DownstreamPoint.y);
                  DrawBigRectangle32(BitMap, BadConnectionColor, BadConnectionColor, 1,
                    Points[0].X - SquareSize, Points[0].Y - SquareSize,
                    Points[0].X + SquareSize, Points[0].Y + SquareSize);
                end;
              end;
            end;
          end;
        end;
      finally
//        LakeNumbers.Free;
        StreamNumbers.Free;
      end;
    end;
  finally
//    LakeList.Free;
    StreamList.Free;
  end;
end;

procedure TCustomModel.DrawSfrStreamLinkages(const BitMap: TPersistent;
  const ZoomBox: TQRbwZoomBox2);
//const
//  SquareSize = 6;
var
  StreamList: TSfrStreamPlotList;
  LakeList: TLakePlotList;
  StreamNumbers: TIntegerList;
  LakeNumbers: TIntegerList;
  Index: Integer;
  StreamToPlot: TSfrStreamPlot;
  LakeToPlot: TLakePlot;
  StreamIndex: Integer;
  OtherStream: TSfrStreamPlot;
  LakeIndex: Integer;
  UpstreamPoint: TPoint2D;
  Points: array[0..1] of TPoint;
  DownstreamPoint: TPoint2D;
  StreamColor: TColor32;
  DiversionColor: TColor32;
  UnconnectedColor: TColor32;
  BadConnectionColor: TColor32;
  DownstreamObject: TScreenObject;
  UpstreamObject: TScreenObject;
  StreamObject: TScreenObject;
  SquareSize: integer;
begin
  inherited;
  StreamList := TSfrStreamPlotList.Create;
  LakeList := TLakePlotList.Create;
  try
    SfrStreamLinkPlot.GetObjectsToPlot(StreamList, LakeList);
    if StreamList.Count > 0 then
    begin
      StreamColor := Color32(SfrStreamLinkPlot.StreamColor);
      DiversionColor := Color32(SfrStreamLinkPlot.DiversionColor);
      UnconnectedColor := Color32(SfrStreamLinkPlot.UnconnectedColor);
      BadConnectionColor := Color32(SfrStreamLinkPlot.BadConnectionColor);
      SquareSize := SfrStreamLinkPlot.SquareSize;

      StreamNumbers := TIntegerList.Create;
      LakeNumbers := TIntegerList.Create;
      try
        for Index := 0 to StreamList.Count - 1 do
        begin
          StreamToPlot := StreamList[Index];
          StreamNumbers.Add(StreamToPlot.Segment);
        end;
        StreamNumbers.Sorted := True;
        for Index := 0 to LakeList.Count - 1 do
        begin
          LakeToPlot := LakeList[Index];
          LakeNumbers.Add(LakeToPlot.LakeId);
        end;
        LakeNumbers.Sorted := True;
        for Index := 0 to StreamList.Count - 1 do
        begin
          StreamToPlot := StreamList[Index];
          if SfrStreamLinkPlot.PlotUnconnected then
          begin
            if StreamToPlot.OutflowSegment = 0 then
            begin
              StreamObject := StreamToPlot.StreamObject as TScreenObject;
              UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
              Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
              Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
              DrawBigRectangle32(BitMap, UnconnectedColor, UnconnectedColor, 1,
                Points[0].X - SquareSize, Points[0].Y - SquareSize,
                Points[0].X + SquareSize, Points[0].Y + SquareSize);
            end;
          end;
          if SfrStreamLinkPlot.PlotStreamConnections or SfrStreamLinkPlot.PlotBadConnection then
          begin
            DownstreamObject := nil;
            if StreamToPlot.OutflowSegment > 0 then
            begin
              StreamIndex := StreamNumbers.IndexOf(StreamToPlot.OutflowSegment);
              if StreamIndex >= 0 then
              begin
                OtherStream := StreamList[StreamIndex];
                DownstreamObject := OtherStream.StreamObject as TScreenObject;
                Assert(StreamToPlot.OutflowSegment = OtherStream.Segment)
              end;
            end
            else if StreamToPlot.OutflowSegment < 0 then
            begin
              LakeIndex := LakeNumbers.IndexOf(-StreamToPlot.OutflowSegment);
              if LakeIndex >= 0 then
              begin
                LakeToPlot := LakeList[LakeIndex];
                DownstreamObject := LakeToPlot.LakeObject as TScreenObject;
                Assert(-StreamToPlot.OutflowSegment = LakeToPlot.LakeId)
              end;
            end;
            if (DownstreamObject = nil) then
            begin
              if SfrStreamLinkPlot.PlotBadConnection
                and (StreamToPlot.OutflowSegment <> 0) then
              begin
                StreamObject := StreamToPlot.StreamObject as TScreenObject;
                UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
                Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
                Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);
                DrawBigRectangle32(BitMap, BadConnectionColor, BadConnectionColor, 1,
                  Points[0].X - SquareSize, Points[0].Y - SquareSize,
                  Points[0].X + SquareSize, Points[0].Y + SquareSize);
              end;
            end
            else
            begin
              if SfrStreamLinkPlot.PlotStreamConnections then
              begin
                StreamObject := StreamToPlot.StreamObject as TScreenObject;
                UpstreamPoint := StreamObject.Points[StreamObject.Count-1];
                Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
                Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);

                DownstreamPoint := DownstreamObject.Points[0];
                Points[1].X := ZoomBox.XCoord(DownstreamPoint.x);
                Points[1].Y := ZoomBox.YCoord(DownstreamPoint.y);

                if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
                begin
                  DrawBigRectangle32(BitMap, StreamColor, StreamColor, 1,
                    Points[0].X - SquareSize, Points[0].Y - SquareSize,
                    Points[0].X + SquareSize, Points[0].Y + SquareSize);
                end
                else
                begin
                  DrawBigPolyline32(BitMap, StreamColor, 2, Points, True);
                end;
              end;
            end;
          end;
          if SfrStreamLinkPlot.PlotDiversions then
          begin
            UpstreamObject := nil;
            if StreamToPlot.DiversionSegment > 0 then
            begin
              StreamIndex := StreamNumbers.IndexOf(StreamToPlot.DiversionSegment);
              if StreamIndex >= 0 then
              begin
                OtherStream := StreamList[StreamIndex];
                UpstreamObject := OtherStream.StreamObject as TScreenObject;
                Assert(StreamToPlot.DiversionSegment = OtherStream.Segment)
              end;
            end
            else if StreamToPlot.DiversionSegment < 0 then
            begin
              LakeIndex := LakeNumbers.IndexOf(-StreamToPlot.DiversionSegment);
              if LakeIndex >= 0 then
              begin
                LakeToPlot := LakeList[LakeIndex];
                UpstreamObject := LakeToPlot.LakeObject as TScreenObject;
                Assert(-StreamToPlot.DiversionSegment = LakeToPlot.LakeId)
              end;
            end;
            if UpstreamObject <> nil then
            begin
              UpstreamPoint := UpstreamObject.Points[UpstreamObject.Count-1];
              Points[0].X := ZoomBox.XCoord(UpstreamPoint.x);
              Points[0].Y := ZoomBox.YCoord(UpstreamPoint.y);

              StreamObject := StreamToPlot.StreamObject as TScreenObject;
              DownstreamPoint := StreamObject.Points[0];
              Points[1].X := ZoomBox.XCoord(DownstreamPoint.x);
              Points[1].Y := ZoomBox.YCoord(DownstreamPoint.y);

              if (Points[0].X = Points[1].X) and (Points[0].Y = Points[1].Y) then
              begin
                DrawBigRectangle32(BitMap, DiversionColor, DiversionColor, 1,
                  Points[0].X - SquareSize, Points[0].Y - SquareSize,
                  Points[0].X + SquareSize, Points[0].Y + SquareSize);
              end
              else
              begin
                DrawBigPolyline32(BitMap, DiversionColor, 2, Points, True);
              end;
            end;
          end;
        end;
      finally
        LakeNumbers.Free;
        StreamNumbers.Free;
      end;
    end;
  finally
    LakeList.Free;
    StreamList.Free;
  end;
end;

function TPhastModel.DrnIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.DrnPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.DrnPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DrobIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.DrobPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.DrobPackage.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DrtIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.DrtPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.DrtPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TCustomModel.InvalidateAllDynamicLists;
var
  index: Integer;
  AScreenObject: TScreenObject;
begin
  for index := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[index];
    AScreenObject.DynamicTimesSeriesCollections.Invalidate;
  end;
  Mf6TimesSeries.ResetDictionaries;
end;

procedure TCustomModel.InvalidateCncActive(Sender: TObject);
begin
  ModflowPackages.GwtCncPackage.InvalidateActives;
end;

procedure TCustomModel.InvalidateCncConcentration(Sender: TObject);
begin
  ModflowPackages.GwtCncPackage.InvalidateConcentrationsOrTemperatures;
end;

procedure TCustomModel.InvalidateCncMultiplier(Sender: TObject);
begin
  ModflowPackages.GwtCncPackage.InvalidateMultipliers;
end;

procedure TCustomModel.InvalidateContours;
begin
  TopContoursUpToDate := False;
  FrontContoursUpToDate := False;
  SideContoursUpToDate := False;
end;

procedure TCustomModel.InvalidateCSubStressOffset(Sender: TObject);
begin
  ModflowPackages.CSubPackage.StressOffset.Invalidate;
end;

//procedure TCustomModel.InvalidateEtsConc(Sender: TObject);
//begin
//  ModflowPackages.EtsPackage.InvalidateConcentrations;
//end;

procedure TCustomModel.InvalidateEtsDepthFractions(Sender: TObject);
begin
  ModflowPackages.EtsPackage.InvalidateEtsDepthFractions(Sender);
end;

procedure TCustomModel.InvalidateEtsRateFractions(Sender: TObject);
begin
  ModflowPackages.EtsPackage.InvalidateEtsRateFractions(Sender);
end;

procedure TPhastModel.InvalidateContours;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  inherited;
  if ChildModels <> nil then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.InvalidateContours;
      end;
    end;
  end;
end;

procedure TPhastModel.InvalidateMapping;
begin
  SetLength(FColumnMapping, 0);
  SetLength(FRowMapping, 0);
  SetLength(FLayerMapping, 0);
end;

procedure TCustomModel.InvalidateMassSrc(Sender: TObject);
begin
  ModflowPackages.GwtSrcPackage.InvalidateConcentrationsOrTemperatures;
end;

procedure TCustomModel.InvalidateMassSrcActive(Sender: TObject);
begin
  ModflowPackages.GwtSrcPackage.InvalidateActives;
end;

procedure TCustomModel.InvalidateMassSrcMultiplier(Sender: TObject);
begin
  ModflowPackages.GwtSrcPackage.InvalidateMultipliers;
end;

procedure TCustomModel.InvalidateMawGwtConc(Sender: TObject);
begin
  ModflowPackages.MawPackage.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateMawDensity(Sender: TObject);
begin

end;

procedure TCustomModel.InvalidateMawFlowingWellConductance(Sender: TObject);
begin
  ModflowPackages.MawPackage.FlowingWellConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMawFlowingWellElevation(Sender: TObject);
begin
  ModflowPackages.MawPackage.FlowingWellElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMawFlowingWellReductionLength(Sender: TObject);
begin
  ModflowPackages.MawPackage.FlowingWellReductionLength.Invalidate;
end;

procedure TCustomModel.InvalidateMawMaximumPumpRate(Sender: TObject);
begin
  ModflowPackages.MawPackage.MaximumPumpRate.Invalidate;
end;

procedure TCustomModel.InvalidateMawMinimumPumpRate(Sender: TObject);
begin
  ModflowPackages.MawPackage.MinimumPumpRate.Invalidate;
end;

procedure TCustomModel.InvalidateMawPumpElevation(Sender: TObject);
begin
  ModflowPackages.MawPackage.PumpElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMawScalingLength(Sender: TObject);
begin
  ModflowPackages.MawPackage.ScalingLength.Invalidate;
end;

procedure TCustomModel.InvalidateMawViscosity(Sender: TObject);
begin

end;

procedure TCustomModel.InvalidateMawWell_Head(Sender: TObject);
begin
  ModflowPackages.MawPackage.Well_Head.Invalidate;
end;

procedure TCustomModel.InvalidateMawWell_Limit(Sender: TObject);
begin
  ModflowPackages.MawPackage.Well_Limit.Invalidate;
end;

procedure TCustomModel.InvalidateMawWell_Rate(Sender: TObject);
begin
  ModflowPackages.MawPackage.Well_Rate.Invalidate;
end;

procedure TCustomModel.InvalidateMfChdEndingHead(Sender: TObject);
begin
  ModflowPackages.ChdBoundary.MfChdEndingHead.Invalidate;
end;

procedure TCustomModel.InvalidateMfChdMultiplier(Sender: TObject);
begin
  ModflowPackages.ChdBoundary.MfChdMultiplier.Invalidate;;
end;

procedure TCustomModel.InvalidateMfChdStartingHead(Sender: TObject);
begin
  ModflowPackages.ChdBoundary.MfChdStartingHead.Invalidate;
end;

procedure TCustomModel.InvalidateMfConduitCadsRecharge(Sender: TObject);
begin
  ModflowPackages.ConduitFlowProcess.MfConduitCadsRechargeFraction.Invalidate;
end;

procedure TCustomModel.InvalidateMfConduitRecharge(Sender: TObject);
begin
  ModflowPackages.ConduitFlowProcess.MfConduitRechargeFraction.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrnConductance(Sender: TObject);
begin
  ModflowPackages.DrnPackage.MfDrnConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrnDdrn(Sender: TObject);
begin
  ModflowPackages.DrnPackage.MfDrnDdrn.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrnElevation(Sender: TObject);
begin
  ModflowPackages.DrnPackage.MfDrnElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrnMultiplier(Sender: TObject);
begin
  ModflowPackages.DrnPackage.MfDrnMultiplier.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrtConductance(Sender: TObject);
begin
  ModflowPackages.DrtPackage.MfDrtConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrtElevation(Sender: TObject);
begin
  ModflowPackages.DrtPackage.MfDrtElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfDrtReturnFraction(Sender: TObject);
begin
  ModflowPackages.DrtPackage.MfDrtReturnFraction.Invalidate;
end;

procedure TCustomModel.InvalidateMfEtsEvapDepth(Sender: TObject);
begin
  ModflowPackages.EtsPackage.MfEtsEvapDepth.Invalidate;
end;

procedure TCustomModel.InvalidateMfEtsEvapLayer(Sender: TObject);
begin
  ModflowPackages.EtsPackage.MfEtsEvapLayer.Invalidate;
end;

procedure TCustomModel.InvalidateMfEtsEvapRate(Sender: TObject);
begin
  ModflowPackages.EtsPackage.MfEtsEvapRate.Invalidate;
end;

procedure TCustomModel.InvalidateMfEtsEvapSurface(Sender: TObject);
begin
  ModflowPackages.EtsPackage.MfEtsEvapSurface.Invalidate;
end;

procedure TCustomModel.InvalidateMfEtsMultiplier(Sender: TObject);
begin
  ModflowPackages.EtsPackage.MfEtsMultiplier.Invalidate;
end;

procedure TCustomModel.InvalidateMfEvtEvapDepth(Sender: TObject);
begin
  ModflowPackages.EvtPackage.MfEvtEvapDepth.Invalidate;
end;

procedure TCustomModel.InvalidateMfEvtEvapLayer(Sender: TObject);
begin
  ModflowPackages.EvtPackage.InvalidateMfEvtEvapLayer(Sender);
end;

procedure TCustomModel.InvalidateMfEvtEvapRate(Sender: TObject);
begin
  ModflowPackages.EvtPackage.MfEvtEvapRate.Invalidate;
end;

procedure TCustomModel.InvalidateMfEvtEvapSurface(Sender: TObject);
begin
  ModflowPackages.EvtPackage.MfEvtEvapSurface.Invalidate;
end;

procedure TCustomModel.InvalidateMfFhbFlows(Sender: TObject);
begin
  ModflowPackages.FhbPackage.MfFhbFlows.Invalidate;
end;

procedure TCustomModel.InvalidateMfFhbHeads(Sender: TObject);
begin
  ModflowPackages.FhbPackage.MfFhbHeads.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4AddedDemand(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4AddedDemand.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienAddedDemandArrays;
end;

procedure TCustomModel.InvalidateMfFmp4AddedDemandRunoffSplit(Sender: TObject);
begin
  ModflowPackages.FarmProcess4.AddedDemandRunoffSplitDisplay.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4BareEvap(Sender: TObject);
begin
  ModflowPackages.FarmClimate4.MfFmp4EvapBare.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4BarePrecipitationConsumptionFraction(
  Sender: TObject);
begin
  ModflowPackages.FarmProcess4.BarePrecipitationConsumptionFractionDisplay.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4BareRunoffFraction(Sender: TObject);
begin
  ModflowPackages.FarmProcess4.BareRunoffFractionDisplay.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4ConsumptiveUse(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4ConsumptiveUse.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienConsumptiveUseArrays;
end;

procedure TCustomModel.InvalidateMfFmp4CropCoefficient(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4CropCoefficient.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienCropCoefficientArrays;
end;

procedure TCustomModel.InvalidateMfFmp4CropID(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4CropID.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4DirectRecharge(Sender: TObject);
begin
  ModflowPackages.FarmClimate4.MfFmp4DirectRecharge.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4Efficiency(Sender: TObject);
begin
  ModflowPackages.FarmProcess4.MfFmp4Efficiency.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4EfficiencyImprovement(Sender: TObject);
begin
  ModflowPackages.FarmProcess4.MfFmp4EfficiencyImprovement.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4Evap(Sender: TObject);
begin
  ModflowPackages.FarmClimate4.MfFmp4EvapRate.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4EvaporationIrrigationFraction(
  Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4EvaporationIrrigationFraction.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienEvaporationIrrigationFractionArrays;
end;

procedure TCustomModel.InvalidateMfFmp4FarmID(Sender: TObject);
begin
  ModflowPackages.FarmProcess4.FarmID.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4FractionOfIrrigToSurfaceWater(
  Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4FractionOfIrrigToSurfaceWater.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienFractionOfIrrigToSurfaceWaterArrays;
end;

procedure TCustomModel.InvalidateMfFmp4FractionOfPrecipToSurfaceWater(
  Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4FractionOfPrecipToSurfaceWater.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienFractionOfPrecipToSurfaceWaterArrays;
end;

procedure TCustomModel.InvalidateMfFmp4CropHasSalinityDemand(Sender: TObject);
begin
  ModflowPackages.FarmSalinityFlush.MfFmp4CropHasSalinityDemand.Invalidate;
  ModflowPackages.FarmSalinityFlush.InvalidateMultTransienCropHasSalinityDemandArrays;
end;

procedure TCustomModel.InvalidateMfFmp4Irrigation(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4Irrigation.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienIrrigationArrays;
end;

procedure TCustomModel.InvalidateMfFmp4LandUseAreaFraction(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4LandUseAreaFraction.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransientLandUseAreaFractionArrays;
end;

procedure TCustomModel.InvalidateMfFmp4NrdInfilLocation(Sender: TObject);
begin
  ModflowPackages.FarmSurfaceWater4.MfFmp4NrdInfilLocation.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4Precip(Sender: TObject);
begin
  ModflowPackages.FarmClimate4.MfFmp4Precip.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4PrecipPotConsumption(Sender: TObject);
begin
  ModflowPackages.FarmClimate4.MfFmp4PrecipPotConsumption.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmp4RootDepth(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4RootDepth.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienRootDepthArrays;
end;

procedure TCustomModel.InvalidateMfFmp4TranspirationFraction(Sender: TObject);
begin
  ModflowPackages.FarmLandUse.MfFmp4TranspirationFraction.Invalidate;
  ModflowPackages.FarmLandUse.InvalidateMultTransienTranspirationFractionArrays;
end;

procedure TCustomModel.InvalidateMfFmpCropID(Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpCropID.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmpEvap(Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpEvapRate.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmpFarmID(Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpFarmID.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmpMaxPumpingRate(Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpMaxPumpingRate.Invalidate;
  ModflowPackages.FarmWells4.MfFmpMaxPumpingRate.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmpPrecip(Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpPrecip.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmpPumpOnlyIfCropRequiresWater(
  Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpFarmWellPumpIfRequired.Invalidate;
end;

procedure TCustomModel.InvalidateMfFmpWellFarmID(Sender: TObject);
begin
  ModflowPackages.FarmProcess.MfFmpFarmWellFarmID.Invalidate;
  ModflowPackages.FarmWells4.MfFmpFarmWellFarmID.Invalidate;
end;

procedure TCustomModel.InvalidateMfGhbBoundaryHead(Sender: TObject);
begin
  ModflowPackages.GhbBoundary.MfGhbBoundaryHead.Invalidate;
end;

procedure TCustomModel.InvalidateMfGhbConc(Sender: TObject);
begin
  ModflowPackages.GhbBoundary.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateMfGhbConductance(Sender: TObject);
begin
  ModflowPackages.GhbBoundary.MfGhbConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMfGhbMultiplier(Sender: TObject);
begin
  ModflowPackages.GhbBoundary.MfGhbMultiplier.Invalidate;
end;

procedure TCustomModel.InvalidateMt3dTobConcs(Sender: TObject);
begin
  Mt3dTobCond.Invalidate;
end;

procedure TCustomModel.InvalidateParamNamesDataSets;
var
  DataSetIndex: Integer;
  ADataArray: TDataArray;
  NameDataArray: TDataArray;
begin
  for DataSetIndex := 0 to DataArrayManager.DataSetCount - 1 do
  begin
    ADataArray := DataArrayManager[DataSetIndex];
    if ADataArray.PestParametersUsed then
    begin
      NameDataArray := DataArrayManager.GetDataSetByName(
        ADataArray.ParamDataSetName);
      if NameDataArray <> nil then
      begin
        NameDataArray.Invalidate;
      end;
    end;
  end;
end;

procedure TCustomModel.InvalidateMfChdActive(Sender: TObject);
begin
  ModflowPackages.ChdBoundary.MfChdActive.Invalidate;;
end;

procedure TCustomModel.InvalidateMfChdConc(Sender: TObject);
begin
  ModflowPackages.ChdBoundary.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateRipCoverages(Sender: TObject);
begin
  ModflowPackages.RipPackage.InvalidateCoverages;
end;

procedure TCustomModel.InvalidateRipGroundSurface(Sender: TObject);
begin
  ModflowPackages.RipPackage.MfRipLandElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfHobHeads(Sender: TObject);
begin
  MfHobHeads.Invalidate;
end;

procedure TCustomModel.InvalidateMfRchConc(Sender: TObject);
begin
  ModflowPackages.RchPackage.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateMfRchLayer(Sender: TObject);
begin
  ModflowPackages.RchPackage.InvalidateMfRchLayer(Sender);
end;

procedure TCustomModel.InvalidateMfRchMultiplier(Sender: TObject);
begin
  ModflowPackages.RchPackage.MfRchMultiplier.Invalidate;
end;

procedure TCustomModel.InvalidateMfRchRate(Sender: TObject);
begin
  ModflowPackages.RchPackage.MfRchRate.Invalidate;
end;

procedure TCustomModel.InvalidateMfRivBottom(Sender: TObject);
begin
  ModflowPackages.RivPackage.MfRivBottom.Invalidate;
end;

procedure TCustomModel.InvalidateMfRivConc(Sender: TObject);
begin
  ModflowPackages.RivPackage.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateMfRivConductance(Sender: TObject);
begin
  ModflowPackages.RivPackage.MfRivConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMfRivMultiplier(Sender: TObject);
begin
  ModflowPackages.RivPackage.MfRivMultiplier.Invalidate;
end;

procedure TCustomModel.InvalidateMfRivStage(Sender: TObject);
begin
  ModflowPackages.RivPackage.MfRivStage.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrBankRoughness(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrBankRoughness.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrBrooksCorey(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrBrooksCorey.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrChannelRoughness(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrChannelRoughness.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrData(Sender: TObject);
begin
  InvalidateMfSfrUpstreamHydraulicConductivity(Sender);
  InvalidateMfSfrDownstreamHydraulicConductivity(Sender);
end;

procedure TPhastModel.InvalidateMfSfrDepthCoefficient(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDepthCoefficient.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrDepthExponent(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDepthExponent.Invalidate
end;

procedure TCustomModel.InvalidateMfSfrDownstreamBrooksCorey(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamBrooksCorey.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamElevation(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamHydraulicConductivity(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamHydraulicConductivity.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamThickness(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamThickness.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamUnsatInitialWaterContent(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamUnsatInitialWaterContent.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamUnsatKz(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamUnsatKz.Invalidate;
end;

function TCustomModel.DoDirectRechargeUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.StaticDirectRechargeUsed(nil);
end;

procedure TCustomModel.DischargeRoutingUpdate;
var
  LakeIdArray: TDataArray;
  DischargeRoutingArray: TDataArray;
begin
  LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
  DischargeRoutingArray := FDataArrayManager.GetDataSetByName(StrUzfDischargeRouting);

  if (ModflowPackages <> nil) and
    (ModflowPackages.SfrPackage.IsSelected
    or ModflowPackages.LakPackage.IsSelected) then
  begin
    if DischargeRoutingArray <> nil then
    begin
      DischargeRoutingArray.OnPostInitialize := UpdateDischargeRouting;
      DischargeRoutingArray.OnDestroy := FinalizeDischargeRouting;
      DischargeRoutingArray.UpToDate := False;
      if LakeIdArray <> nil then
      begin
        DischargeRoutingArray.TalksTo(LakeIdArray);
      end;
    end;
  end
  else
  begin
    if DischargeRoutingArray <> nil then
    begin
      DischargeRoutingArray.OnPostInitialize := nil;
      DischargeRoutingArray.OnDestroy := nil;
      DischargeRoutingArray.UpToDate := False;
      if LakeIdArray <> nil then
      begin
        DischargeRoutingArray.StopsTalkingTo(LakeIdArray);
      end;
    end;
  end;
end;

procedure TCustomModel.DiscretizationChanged;
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        Grid.GridChanged;
      end;
    msModflow2015:
      begin
        if DisvUsed then
        begin
          DisvGrid.MeshChanged;
        end
        else
        begin
          Grid.GridChanged;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          (Mesh as TSutraMesh3D).MeshChanged;
        end;
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.DMCOEF: TOneDRealArray;
begin
  result := LayerStructure.DMCOEF;
end;

procedure TCustomModel.DrawHeadObservations(const BitMap: TPersistent;
  const ZoomBox: TQRbwZoomBox2);
begin
  if StoreHeadObsResults and FHeadObsResults.Visible then
  begin
    HeadObsResults.Draw(BitMap, ZoomBox);
  end;
end;

procedure TCustomModel.DrawMt3dPointObservations(const BitMap: TPersistent;
  const ZoomBox: TQrbwZoomBox2);
begin
  if (Mt3dObsCollection.Count > 0) and Mt3dObsCollection.Visible then
  begin
    Mt3dObsCollection.Draw(BitMap, ZoomBox);
  end;
end;

procedure TCustomModel.DrawPestPointObservations(const BitMap: TPersistent;
  const ZoomBox: TQrbwZoomBox2);
begin
  if (PestObsCollection.Count > 0) and PestObsCollection.Visible then
  begin
    PestObsCollection.Draw(BitMap, ZoomBox);
  end;
end;

function TPhastModel.De4IsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.De4Package.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.De4Package.IsSelected;
      end;
    end;
  end;
end;

function TPhastModel.DefaultArchiveName: string;
var
  ArchiveRoot: string;
begin
  if ModelFileName = '' then
  begin
    ArchiveRoot := GetCurrentDir + '\Archive'
  end
  else
  begin
    ArchiveRoot := ChangeFileExt(ModelFileName, '');
  end;
  result := ArchiveRoot + ' '
    + FormatDateTime('yyyy_mm_dd', Now) + '.zip';
end;

function TPhastModel.DefaultElevationFormula(
  ViewDirection: TViewDirection; EvalAt: TEvaluatedAt): string;
var
  UnitID: Integer;
  LayerGroup: TLayerGroup;
  Row: Integer;
  Column: Integer;
  Orientation: TDataSetOrientation;
  Compiler: TRbwParser;
  ALine: TLine2D;
  ADistance: TFloat;
  SutraLayerGroup: TSutraLayerGroup;
  ClosestPoint: TPoint2D;
  MeshLimits: TGridLimit;
  LayerCount: integer;
  UnitIndex: integer;
begin
  if (Grid = nil) and (DrawMesh = nil) then
  begin
    result := '0';
    Exit;
  end;
  Orientation :=  dsoTop;
  case ViewDirection of
    vdTop:
      begin
        Orientation :=  dsoTop;

        case ModelSelection of
          msUndefined: Assert(False);
          msPhast:
            begin
              if Grid.LayerCount > 0 then
              begin
                result := FortranFloatToStr((Grid.HighestElevation + Grid.LowestElevation)/2);
              end
              else
              begin
                result := '0'
              end;
            end;
          msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
            msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
            begin
              if DisvUsed then
              begin
                if DisvGrid.LayerCount > 0 then
                begin
                  GetUnitID(UnitID);
                  if UnitID > 0 then
                  begin
                    LayerGroup := LayerStructure.LayerGroups[UnitID-1];
                    result := LayerGroup.DataArrayName;
                    LayerGroup := LayerStructure.LayerGroups[UnitID];
                    result := '(' + result + ' + '
                      + LayerGroup.DataArrayName + ')/2';
                  end
                  else
                  begin
                    result :=
                      FortranFloatToStr((Grid.HighestElevation
                      + Grid.LowestElevation)/2);
                  end;
                end
                else
                begin
                  result := '0'
                end;
              end
              else
              begin
                if Grid.LayerCount > 0 then
                begin
                  GetUnitID(UnitID);
                  if UnitID > 0 then
                  begin
                    LayerGroup := LayerStructure.LayerGroups[UnitID-1];
                    result := LayerGroup.DataArrayName;
                    LayerGroup := LayerStructure.LayerGroups[UnitID];
                    result := '(' + result + ' + '
                      + LayerGroup.DataArrayName + ')/2';
                  end
                  else
                  begin
                    result :=
                      FortranFloatToStr((Grid.HighestElevation
                      + Grid.LowestElevation)/2);
                  end;
                end
                else
                begin
                  result := '0'
                end;
              end;
            end;
          msSutra22, msSutra30, msSutra40:
            begin
             if ((Mesh as TSutraMesh3D).MeshType = mt3D) and ((Mesh as TSutraMesh3D).LayerCount > 0) then
              begin
                GetUnitID(UnitID);
                if UnitID > 0 then
                begin
                  case EvalAt of
                    eaBlocks:
                      begin
                        LayerCount := 0;
                        for UnitIndex := 1 to UnitID-1 do
                        begin
                          SutraLayerGroup := SutraLayerStructure.LayerGroups[
                            UnitIndex];
                          LayerCount := LayerCount + SutraLayerGroup.LayerCount;
                        end;
                        result := StrLayerBoundaryPosition + '('
                          + IntToStr(LayerCount+1) + ')';
                        SutraLayerGroup := SutraLayerStructure.LayerGroups[
                          UnitID];
                        LayerCount := LayerCount + SutraLayerGroup.LayerCount;
                        result := '('+ result + ' + ' + StrLayerBoundaryPosition + '('
                          + IntToStr(LayerCount+1) + '))/2';                      end;
                    eaNodes:
                      begin
                        SutraLayerGroup := SutraLayerStructure.LayerGroups[UnitID-1];
                        result := SutraLayerGroup.DataArrayName;
                        SutraLayerGroup := SutraLayerStructure.LayerGroups[UnitID];
                        result := '(' + result + ' + '
                          + SutraLayerGroup.DataArrayName + ')/2';
                      end;
                    else Assert(False);
                  end;
                end
                else
                begin
                  MeshLimits := SutraMesh.MeshLimits(vdFront, 0);
                  result :=
                    FortranFloatToStr((MeshLimits.MaxZ + MeshLimits.MinZ)/2);
                end;
              end
              else
              begin
                result := '0'
              end;
            end;
          msFootprint:
            begin
              result := '0'
            end
          else Assert(False);
        end;

      end;
    vdFront:
      begin
        Orientation :=  dsoFront;
        case ModelSelection of
          msUndefined: Assert(False);
          msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
            msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
            begin
              if DisvUsed then
              begin
                if DisvGrid <> nil then
                begin
                  result := FortranFloatToStr((DisvGrid.MaxDist + DisvGrid.MinDist)/2);
                end
                else
                begin
                  result := '0';
                end;
              end
              else
              begin
                if Grid .RowCount > 0 then
                begin
                  Row := Grid.SelectedRow;
                  if Row >= Grid.RowCount then
                  begin
                    Row := Grid.RowCount-1;
                  end;
                    result :=
                      FortranFloatToStr((Grid.RowPositions[Row]+ Grid.RowPositions[Row+1])/2);
                end
                else
                begin
                  result := '0';
                end;
              end;
            end;
          msSutra22, msSutra30, msSutra40:
            begin

              ALine := EquateLine(SutraMesh.CrossSection.StartPoint,
                SutraMesh.CrossSection.EndPoint);
              if (ALine[1].x <> ALine[2].x) or (ALine[1].y <> ALine[2].y) then
              begin
                ClosestPoint := ClosestPointOnLineFromPoint(
                  ALine, EquatePoint(0.0, 0.0));
                ADistance := Distance(EquatePoint(0.0, 0.0), ClosestPoint);
              end
              else
              begin
                ADistance := 0;
              end;
              if ADistance <> 0 then
              begin
                if FastGEO.Orientation(EquatePoint(0.0, 0.0),
                  SutraMesh.CrossSection.StartPoint, SutraMesh.CrossSection.EndPoint) =
                  LeftHandSide then
                begin
                  ADistance := -ADistance;
                end;
              end;
              result := FortranFloatToStr(ADistance);
            end;
          msFootPrint:
            begin
              result := '0';
            end
          else Assert(False);
        end;
      end;
    vdSide:
      begin
        Assert(not (ModelSelection in SutraSelection));
        Orientation :=  dsoSide;
        if Grid.ColumnCount > 0 then
        begin
          Column := Grid.SelectedColumn;
          if Column >= Grid.ColumnCount then
          begin
            Column := Grid.ColumnCount -1;
          end;
          result :=
            FortranFloatToStr((Grid.ColumnPositions[Column]
            + Grid.ColumnPositions[Column+1])/2);
        end
        else
        begin
          result := '0';
        end;
      end;
    else Assert(False);
  end;
  Compiler := GetCompiler(Orientation, EvalAt);
  Compiler.Compile(result);
end;

procedure TPhastModel.GetUnitID(var UnitID: Integer);
var
  UnitIndex: Integer;
  LayersInUnitCount: Integer;
  Layer: Integer;
  LocalLayerStructure: TCustomLayerStructure;
  ALayerGroup: TCustomLayerGroup;
begin
  if ModelSelection = msFootprint then
  begin
    UnitID := 0;
    Exit;
  end;
  Layer := -1;
  LocalLayerStructure := nil;
  case ModelSelection of
    msUndefined, msPhast: Assert(False);
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
      begin
        if DisVUsed then
        begin
          Layer := DisvGrid.SelectedLayer;
          if Layer >= DisvGrid.LayerCount then
          begin
            Layer := DisvGrid.LayerCount - 1;
          end;
        end
        else
        begin
          Layer := Grid.SelectedLayer;
          if Layer >= Grid.LayerCount then
          begin
            Layer := Grid.LayerCount - 1;
          end;
        end;
        LocalLayerStructure := LayerStructure;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        Layer := SutraMesh.SelectedLayer;
        if Layer >= SutraMesh.LayerCount then
        begin
          Layer := SutraMesh.LayerCount - 1;
        end;
        LocalLayerStructure := SutraLayerStructure;
      end
    else Assert(False);
  end;

  LayersInUnitCount := 0;
  UnitID := -1;
  for UnitIndex := 1 to LocalLayerStructure.Count - 1 do
  begin
    ALayerGroup := LocalLayerStructure.Items[UnitIndex] as TCustomLayerGroup;
    LayersInUnitCount := LayersInUnitCount + ALayerGroup.LayerCount;
    if LayersInUnitCount >= Layer + 1 then
    begin
      UnitID := UnitIndex;
      break;
    end;
  end;

end;

function TPhastModel.GetUseGsflowFormat: boolean;
begin
  result := FUseGsflowFormat;
end;

function TPhastModel.GetUseWaterTable: boolean;
begin
  result := FUseWaterTable;
end;

function TPhastModel.DefaultHigherElevationFormula(
  ViewDirection: TViewDirection; EvalAt: TEvaluatedAt): string;
var
  UnitID: Integer;
  LayerGroup: TLayerGroup;
  Row: Integer;
  Column: Integer;
  SutraLayerGroup: TSutraLayerGroup;
  LayerCount: integer;
  UnitIndex: Integer;
  MeshLimits: TGridLimit;
  Orientation: TDataSetOrientation;
  Compiler: TRbwParser;
begin
  if (Grid = nil) and (DrawMesh = nil) then
  begin
    result := '0';
    Exit;
  end;
  Orientation := dsoTop;
  case ViewDirection of
    vdTop:
      begin
        Orientation := dsoTop;
        case ModelSelection of
          msUndefined: Assert(False);
          msPhast:
            begin
              if Grid.LayerCount > 0 then
              begin
                result := FortranFloatToStr(Grid.HighestElevation);
              end
              else
              begin
                result := '0'
              end;
            end;
          msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
            msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
            begin
              if DisvUsed then
              begin
                if DisvGrid.LayerCount > 0 then
                begin
                  GetUnitID(UnitID);
                  if UnitID > 0 then
                  begin
                    LayerGroup := frmGoPhast.PhastModel.LayerStructure.
                      LayerGroups[UnitID-1];
                    result :=
                      LayerGroup.DataArrayName;
                  end
                  else
                  begin
                    result :=
                      FortranFloatToStr(Grid.HighestElevation);
                  end;
                end
                else
                begin
                  result := '0';
                end;
              end
              else
              begin
                if Grid.LayerCount > 0 then
                begin
                  GetUnitID(UnitID);
                  if UnitID > 0 then
                  begin
                    LayerGroup := frmGoPhast.PhastModel.LayerStructure.
                      LayerGroups[UnitID-1];
                    result :=
                      LayerGroup.DataArrayName;
                  end
                  else
                  begin
                    result :=
                      FortranFloatToStr(Grid.HighestElevation);
                  end;
                end
                else
                begin
                  result := '0';
                end;
              end;
            end;
          msSutra22, msSutra30, msSutra40:
            begin
              if (SutraMesh.MeshType = mt3D) and (SutraMesh.LayerCount > 0) then
              begin
                GetUnitID(UnitID);
                if UnitID > 0 then
                begin
                  case EvalAt of
                    eaBlocks:
                      begin
                        LayerCount := 0;
                        for UnitIndex := 1 to UnitID-1 do
                        begin
                          SutraLayerGroup := SutraLayerStructure.LayerGroups[
                            UnitIndex];
                          LayerCount := LayerCount + SutraLayerGroup.LayerCount;
                        end;
                        result := StrLayerBoundaryPosition + '('
                          + IntToStr(LayerCount+1) + ')';
                      end;
                    eaNodes:
                      begin
                        SutraLayerGroup := frmGoPhast.PhastModel.SutraLayerStructure.
                          LayerGroups[UnitID-1];
                        result := SutraLayerGroup.DataArrayName;
                      end;
                    else Assert(False);
                  end;
                end
                else
                begin
                  MeshLimits := SutraMesh.MeshLimits(vdFront, 0);
                  result := FortranFloatToStr(MeshLimits.MaxZ);
                end;
              end
              else
              begin
                result := '0';
              end;
            end;
          msFootPrint:
            begin
                result := '0';
            end
          else Assert(False);
        end;
      end;
    vdFront:
      begin
        Orientation := dsoFront;
        case ModelSelection of
          msUndefined: Assert(False);
          msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
            msModflowFmp, msModflowCfp, msFootprint, msModflow2015,
            msModflowOwhm2:
            begin
              if DisvUsed then
              begin
                if DisvGrid <> nil then
                begin
                  result := FortranFloatToStr(DisvGrid.MaxDist);
                end
                else
                begin
                  result := '0';
                end;
              end
              else
              begin
                if (Grid.RowCount > 0) then
                begin
                  Row := Grid.SelectedRow;
                  if Row >= Grid.RowCount then
                  begin
                    Row := Grid.RowCount-1;
                  end;
                  case Grid.RowDirection of
                    rdSouthToNorth:
                      begin
                        result :=
                          FortranFloatToStr(Grid.RowPositions[Row+1]);
                      end;
                    rdNorthToSouth:
                      begin
                        result :=
                          FortranFloatToStr(Grid.RowPositions[Row]);
                      end;
                    else Assert(False);
                  end;
                end
                else
                begin
                  result := '0';
                end;
              end;
            end;
          msSutra22, msSutra30, msSutra40:
            begin
              result := FortranFloatToStr(SutraMesh.MaxDist);
            end
          else Assert(False);
        end;

      end;
    vdSide:
      begin
        Orientation := dsoSide;
        Assert(not (ModelSelection in SutraSelection));
        if Grid.ColumnCount > 0 then
        begin
          Column := Grid.SelectedColumn;
          if Column >= Grid.ColumnCount then
          begin
            Column := Grid.ColumnCount -1;
          end;
          case Grid.ColumnDirection of
            cdWestToEast:
              begin
                result :=
                  FortranFloatToStr(Grid.ColumnPositions[Column+1]);
              end;
            cdEastToWest:
              begin
                result :=
                  FortranFloatToStr(Grid.ColumnPositions[Column]);
              end;
          end;
        end
        else
        begin
          result := '0';
        end;
      end;
    else Assert(False);
  end;
  Compiler := GetCompiler(Orientation, EvalAt);
  Compiler.Compile(result);
end;

function TPhastModel.DefaultLowerElevationFormula(
  ViewDirection: TViewDirection; EvalAt: TEvaluatedAt): string;
var
  UnitID: Integer;
  LayerGroup: TLayerGroup;
  Row: Integer;
  Column: Integer;
  SutraLayerGroup: TSutraLayerGroup;
  MeshLimits: TGridLimit;
  LayerCount: integer;
  UnitIndex: Integer;
  Orientation: TDataSetOrientation;
  Compiler: TRbwParser;
begin
  if (Grid = nil) and (DrawMesh = nil) then
  begin
    result := '0';
    Exit;
  end;
  Orientation :=  dsoTop;
  case ViewDirection of
    vdTop:
      begin
        Orientation :=  dsoTop;
        case ModelSelection of
          msUndefined: Assert(False);
          msPhast:
            begin
              if Grid.LayerCount > 0 then
              begin
                result := FortranFloatToStr(Grid.LowestElevation);
              end
              else
              begin
                result := '0'
              end;
            end;
          msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
            msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2:
            begin
              if DisvUsed then
              begin
                if DisvGrid.LayerCount > 0 then
                begin
                  GetUnitID(UnitID);
                  if UnitID > 0 then
                  begin
                    LayerGroup := frmGoPhast.PhastModel.LayerStructure.
                      LayerGroups[UnitID];
                    result :=
                      LayerGroup.DataArrayName;
                  end
                  else
                  begin
                    result :=
                      FortranFloatToStr(Grid.LowestElevation);
                  end;
                end
                else
                begin
                  result := '0'
                end;
              end
              else
              begin
                if Grid.LayerCount > 0 then
                begin
                  GetUnitID(UnitID);
                  if UnitID > 0 then
                  begin
                    LayerGroup := frmGoPhast.PhastModel.LayerStructure.
                      LayerGroups[UnitID];
                    result :=
                      LayerGroup.DataArrayName;
                  end
                  else
                  begin
                    result :=
                      FortranFloatToStr(Grid.LowestElevation);
                  end;
                end
                else
                begin
                  result := '0'
                end;
              end;
            end;
          msSutra22, msSutra30, msSutra40:
            begin
              if (SutraMesh.MeshType = mt3D) and (SutraMesh.LayerCount > 0) then
              begin
                GetUnitID(UnitID);
                if UnitID > 0 then
                begin
                  case EvalAt of
                    eaBlocks:
                      begin
                        LayerCount := 0;
                        for UnitIndex := 1 to UnitID do
                        begin
                          SutraLayerGroup := SutraLayerStructure.LayerGroups[
                            UnitIndex];
                          LayerCount := LayerCount + SutraLayerGroup.LayerCount;
                        end;
                        result := StrLayerBoundaryPosition + '('
                          + IntToStr(LayerCount+1) + ')';
                      end;
                    eaNodes:
                      begin
                        SutraLayerGroup := frmGoPhast.PhastModel.SutraLayerStructure.
                          LayerGroups[UnitID];
                        result := SutraLayerGroup.DataArrayName;
                      end;
                    else Assert(False);
                  end;
                end
                else
                begin
                  MeshLimits := SutraMesh.MeshLimits(vdFront, 0);
                  result := FortranFloatToStr(MeshLimits.MinZ);
                end;
              end
              else
              begin
                result := '0'
              end;
            end;
          msFootPrint:
            begin
              result := '0'
            end;
          else Assert(False);
        end;
      end;
    vdFront:
      begin
        Orientation :=  dsoFront;
        case ModelSelection of
          msUndefined: Assert(False);
          msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
            msModflowFmp, msModflowCfp, msFootPrint, msModflow2015,
            msModflowOwhm2:
            begin
              if DisvUsed then
              begin
                if DisvGrid <> nil then
                begin
                  result := FortranFloatToStr(DisvGrid.MinDist);
                end
                else
                begin
                  result := '0';
                end;
              end
              else
              begin
                if (Grid <> nil) and (Grid.RowCount > 0) then
                begin
                  Row := Grid.SelectedRow;
                  if Row >= Grid.RowCount then
                  begin
                    Row := Grid.RowCount-1;
                  end;
                  case Grid.RowDirection of
                    rdSouthToNorth:
                      begin
                        result :=
                          FortranFloatToStr(Grid.RowPositions[Row]);
                      end;
                    rdNorthToSouth:
                      begin
                        result :=
                          FortranFloatToStr(Grid.RowPositions[Row+1]);
                      end;
                    else Assert(False);
                  end;
                end
                else
                begin
                  result := '0';
                end;
              end;
            end;
          msSutra22, msSutra30, msSutra40:
            begin
              result := FortranFloatToStr(SutraMesh.MinDist);
            end
          else Assert(False);
        end;
      end;
    vdSide:
      begin
        Orientation :=  dsoSide;
        Assert(not (ModelSelection in SutraSelection));
        if Grid.ColumnCount > 0 then
        begin
          Column := Grid.SelectedColumn;
          if Column >= Grid.ColumnCount then
          begin
            Column := Grid.ColumnCount -1;
          end;
          case Grid.ColumnDirection of
            cdWestToEast:
              begin
                result :=
                  FortranFloatToStr(Grid.ColumnPositions[Column]);
              end;
            cdEastToWest:
              begin
                result :=
                  FortranFloatToStr(Grid.ColumnPositions[Column+1]);
              end;
          end;
        end
        else
        begin
          result := '0';
        end;
      end;
    else Assert(False);
  end;
  Compiler := GetCompiler(Orientation, EvalAt);
  Compiler.Compile(result);
end;

function TCustomModel.DefaultModflowOutputFileName: string;
var
  Extension: string;
begin
  GetDefaultOutputFileExtension(Extension);
  if Extension = '' then
  begin
    result := '';
    Exit;
  end;
  result := ChangeFileExt(ModelFileName, Extension);
  result := FixFileName(result);
end;

procedure TCustomModel.InvalidateMfSfrDownstreamUnsaturatedWaterContent(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamUnsaturatedWaterContent.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamWidth(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamWidth.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrInitialWaterContent(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrInitialWaterContent.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrIprior(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrIprior.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrStreamK(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrStreamK.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrSaturatedWaterContent(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrSaturatedWaterContent.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrStreamSlope(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrStreamSlope.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrStreamThickness(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrStreamThickness.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrStreamTop(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrStreamTop.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamBrooksCorey(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamBrooksCorey.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamElevation(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamHydraulicConductivity(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamHydraulicConductivity.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamThickness(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamThickness.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamUnsatInitialWaterContent(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamUnsatInitialWaterContent.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamUnsatKz(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamUnsatKz.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamUnsaturatedWaterContent(
  Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamUnsaturatedWaterContent.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamWidth(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamWidth.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrVerticalUnsatK(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrVerticalUnsatK.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrBedBottom(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrBedBottomElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrBedTop(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrBedTopElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrConductance(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrDiversionSegmentNumber(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrDiversionSegmentNumber.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrFlow(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrFlow.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrOutflowSegmentNumber(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrOutflowSegmentNumber.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrReachNumber(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrReachNumber.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrRoughness(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrRoughness.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrSegmentNumber(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrSegmentNumber.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrSlope(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrSlope.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrStage(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrStage.Invalidate;
end;

procedure TCustomModel.InvalidateMfStrWidth(Sender: TObject);
begin
  ModflowPackages.StrPackage.MfStrWidth.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrBoundaryType(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfBoundaryType.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrDirectRunoffReach(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfDirectRunoffReach.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrDirectRunoffValue(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfDirectRunoffValue.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrEvaporation(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfEvaporation.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrGeometryNumber(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfGeometryNumber.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrLateralInflow(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfLatInflow.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrRainfall(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfRainfall.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrStage(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfStage.Invalidate;
end;

procedure TCustomModel.InvalidateMfSwrVerticalOffset(Sender: TObject);
begin
  ModflowPackages.SwrPackage.MfVerticalOffset.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrWidthCoefficient(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrWidthCoefficient.Invalidate;
end;

procedure TPhastModel.InvalidateMfSfrWidthExponent(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrWidthExponent.Invalidate;
end;

procedure TCustomModel.InvalidateMfUzfEtDemand(Sender: TObject);
begin
  ModflowPackages.UzfPackage.MfUzfEtDemand.Invalidate;
end;

procedure TCustomModel.InvalidateMfUzfExtinctionDepth(Sender: TObject);
begin
  ModflowPackages.UzfPackage.MfUzfExtinctionDepth.Invalidate;
end;

procedure TCustomModel.InvalidateMfUzfInfiltration(Sender: TObject);
begin
  ModflowPackages.UzfPackage.MfUzfInfiltration.Invalidate;
end;

procedure TCustomModel.InvalidateMfUzfWaterContent(Sender: TObject);
begin
  ModflowPackages.UzfPackage.MfUzfWaterContent.Invalidate;
end;

function TCustomModel.CountStepsInMt3dExport: Integer;
begin
  result := 1;
  if ModflowPackages.Mt3dmsAdvection.IsSelected then
  begin
    Inc(result);
  end;
  if ModflowPackages.Mt3dmsDispersion.IsSelected then
  begin
    Inc(result);
  end;
  if ModflowPackages.Mt3dmsSourceSink.IsSelected then
  begin
    Inc(result);
  end;
  if ModflowPackages.Mt3dmsChemReact.IsSelected then
  begin
    Inc(result);
  end;
  if ModflowPackages.Mt3dmsGCGSolver.IsSelected then
  begin
    Inc(result);
  end;
  if ModflowPackages.Mt3dmsTransObs.IsSelected then
  begin
    Inc(result);
  end;
end;

function TCustomModel.CountStepsInExport: Integer;
var
  HufParam: THufUsedParameter;
  HGU: THydrogeologicUnit;
  HufUnitIndex: Integer;
  SteadyParam: TModflowSteadyParameter;
  PIndex: Integer;
  ZoneUsed: Boolean;
  MultipliersUsed: Boolean;
begin
  // The following tasks are always required.
  // 1. Full Stress periods,
  // 2. Discretization,
  // 3. Basic,
  // 4. Output Control,
  // The following are sometimes required.
  // 5. Zone Arrays,
  // 6. Multiplier Arrays
  result := 4;
  result := result + ModflowPackages.SelectedModflowPackageCount;
  if ModflowPackages.SfrPackage.IsSelected
    or ModflowPackages.LakPackage.IsSelected then
  begin
    // gages
    Inc(result);
  end;
  MultipliersUsed := False;
  ZoneUsed := False;
  if ModflowTransientParameters.Count > 0 then
  begin
    MultipliersUsed := True;
    ZoneUsed := True;
  end;
  if not MultipliersUsed then
  begin
    if (ModflowPackages.LpfPackage.IsSelected
      or ModflowPackages.UpwPackage.IsSelected) then
    begin
      for PIndex := 0 to ModflowSteadyParameters.Count - 1 do
      begin
        SteadyParam := ModflowSteadyParameters[PIndex];
        if SteadyParam.UseMultiplier then
        begin
          MultipliersUsed := True;
        end;
        if SteadyParam.UseZone then
        begin
          ZoneUsed := True;
        end;
      end;
    end
    else if ModflowPackages.HufPackage.IsSelected then
    begin
      for HufUnitIndex := 0 to HydrogeologicUnits.Count - 1 do
      begin
        HGU := HydrogeologicUnits[HufUnitIndex];
        for PIndex := 0 to HGU.HufUsedParameters.Count - 1 do
        begin
          HufParam := HGU.HufUsedParameters[PIndex];
          if HufParam.UseMultiplier then
          begin
            MultipliersUsed := True;
          end;
          if HufParam.UseZone then
          begin
            ZoneUsed := True;
          end;
        end;
      end;
    end;
  end;
  if MultipliersUsed then
  begin
    Inc(result);
  end;
  if ZoneUsed then
  begin
    Inc(result);
  end;
end;

function TCustomModel.DoPrecipPotConsumptionUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.StaticPrecipPotConsumptionUsed(nil);
end;

function TCustomModel.PrepareModflowFullStressPeriods(ShowWarning: boolean): Boolean;
var
  StressPeriod: TModflowStressPeriod;
  Index: Integer;
  StepCount: Integer;
begin
  result := True;
  UpdateModflowFullStressPeriods;
  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    result := False;
    Exit;
  end;
  frmProgressMM.StepIt;
  if ShowWarning then
  begin
    StepCount := 0;
    for Index := 0 to ModflowFullStressPeriods.Count - 1 do
    begin
      StressPeriod := ModflowFullStressPeriods.Items[Index];
      try
        StepCount := StepCount + StressPeriod.NumberOfSteps;
      except on EIntOverflow do
        begin
          Beep;
          result := False;
          MessageDlg(StrThereAreFarTooMa, mtError, [mbOK], 0);
          Exit;
        end;
      end;
    end;
    if StepCount > 1000 then
    begin
      if MessageDlg(Format(StrYourModelHasSTi, [StepCount]),
        mtWarning, [mbYes, mbNo], 0) <> mrYes then
      begin
        result := False;
      end;
    end;
  end;
end;

procedure TPhastModel.InvalidateMfSfrSegmentReachAndIcalc(Sender: TObject);
begin
  ModflowPackages.SfrPackage.
    InvalidateMfSfrSegmentReachAndIcalc(Sender);
end;

procedure TCustomModel.InvalidateMfWellConc(Sender: TObject);
begin
  ModflowPackages.WelPackage.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateMfWellMultiplier(Sender: TObject);
begin
  ModflowPackages.WelPackage.MfWellMultiplier.Invalidate;
end;

procedure TCustomModel.InvalidateMfWellPumpage(Sender: TObject);
begin
  ModflowPackages.WelPackage.MfWellPumpage.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1Conductance(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfConductance.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1DesiredPumpingRate(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfDesiredPumpingRate.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1LimitingWaterLevel(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfLimitingWaterLevel.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1MinimumPumpingRate(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfMinimumPumpingRate.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1NonLinearLossCoefficient(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfNonLinearLossCoefficient.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1ReactivationPumpingRate(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfReactivationPumpingRate.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1ReferenceElevation(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfReferenceElevation.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1SkinFactor(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfSkinFactor.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1WaterQuality(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfWaterQuality.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1WaterQualityGroup(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfWaterQualityGroup.Invalidate;
end;

procedure TCustomModel.InvalidateMnw1WellRadius(Sender: TObject);
begin
  ModflowPackages.Mnw1Package.MfWellRadius.Invalidate;
end;

procedure TCustomModel.InvalidateMt3dmsChemSources(Sender: TObject);
begin
  ModflowPackages.Mt3dmsSourceSink.Concentrations.Invalidate;
end;

procedure TPhastModel.InvalidateModflowBoundaries;
begin
  ModflowPackages.EtsPackage.InvalidateAllTimeLists;
  ModflowPackages.ChdBoundary.InvalidateAllTimeLists;
  ModflowPackages.DrnPackage.InvalidateAllTimeLists;
  ModflowPackages.DrtPackage.InvalidateAllTimeLists;
  ModflowPackages.EvtPackage.InvalidateAllTimeLists;
  ModflowPackages.GhbBoundary.InvalidateAllTimeLists;
  if ModflowHobPackageUsed(nil) then
  begin
    InvalidateMfHobHeads(nil);
  end;
  ModflowPackages.RchPackage.InvalidateAllTimeLists;
  ModflowPackages.RivPackage.InvalidateAllTimeLists;
  ModflowPackages.SfrPackage.InvalidateAllTimeLists;
  ModflowPackages.UzfPackage.InvalidateAllTimeLists;
  ModflowPackages.WelPackage.InvalidateAllTimeLists;
  ModflowPackages.Mnw2Package.InvalidateAllTimeLists;
  if Mt3dmsTobPackageUsed(nil) then
  begin
    InvalidateMt3dTobConcs(nil);
  end;
end;

procedure TPhastModel.CreatePhastTimeListGroups;
begin
  FSpecifiedHeadGroup := TTimeListGroup.Create;
  FSpecifiedHeadGroup.Add(FSpecifiedHeadHead);
  FSpecifiedHeadGroup.Name := 'Specified_Head';
  FSpecifiedHeadSolutionGroup := TTimeListGroup.Create;
  FSpecifiedHeadSolutionGroup.Add(FSpecifiedHeadAssociatedSolution);
  FSpecifiedHeadSolutionGroup.Name := 'Specified_Head_Solution';
  FFluxBoundaryFluxGroup := TTimeListGroup.Create;
  FFluxBoundaryFluxGroup.Add(FTopFluxBoundaryFlux);
  FFluxBoundaryFluxGroup.Add(FFrontFluxBoundaryFlux);
  FFluxBoundaryFluxGroup.Add(FSideFluxBoundaryFlux);
  FFluxBoundaryFluxGroup.Name := 'Flux_Boundary_Flux';
  FFluxBoundaryChemistryGroup := TTimeListGroup.Create;
  FFluxBoundaryChemistryGroup.Add(FTopFluxBoundaryChemistry);
  FFluxBoundaryChemistryGroup.Add(FFrontFluxBoundaryChemistry);
  FFluxBoundaryChemistryGroup.Add(FSideFluxBoundaryChemistry);
  FFluxBoundaryChemistryGroup.Name := 'Flux_Boundary_Chemistry';
  FLeakyHeadGroup := TTimeListGroup.Create;
  FLeakyHeadGroup.Add(FTopLeakyHead);
  FLeakyHeadGroup.Add(FFrontLeakyHead);
  FLeakyHeadGroup.Add(FSideLeakyHead);
  FLeakyHeadGroup.Name := 'Leaky_Head';
  FLeakyAssociatedSolutionGroup := TTimeListGroup.Create;
  FLeakyAssociatedSolutionGroup.Add(FTopLeakyAssociatedSolution);
  FLeakyAssociatedSolutionGroup.Add(FFrontLeakyAssociatedSolution);
  FLeakyAssociatedSolutionGroup.Add(FSideLeakyAssociatedSolution);
  FLeakyAssociatedSolutionGroup.Name := 'Leaky_Associated_Solution';
  FRiverHeadGroup := TTimeListGroup.Create;
  FRiverHeadGroup.Add(FRiverHead);
  FRiverHeadGroup.Name := 'River_Head';
  FRiverAssociatedSolutionGroup := TTimeListGroup.Create;
  FRiverAssociatedSolutionGroup.Add(FRiverAssociatedSolution);
  FRiverAssociatedSolutionGroup.Name := 'River_Associated_Solution';
  FWellPumpingRateGroup := TTimeListGroup.Create;
  FWellPumpingRateGroup.Add(FWellInjectionOrPumpingRate);
  FWellPumpingRateGroup.Name := 'Well_Pumping_Rate';
  FWellSolutionGroup := TTimeListGroup.Create;
  FWellSolutionGroup.Add(FWellSolution);
  FWellSolutionGroup.Name := 'Well_Solution';

end;

procedure TPhastModel.CreateInitialDataSetsForPhastTimeLists;
var
  PhastDataSet: TSparseArrayPhastInterpolationDataSet;
begin
  PhastDataSet := TSparseRealPhastDataSet.Create(self);
  PhastDataSet.Lock := [dcName, dcType, dcOrientation, dcEvaluatedAt];
  PhastDataSet.UpdateWithName('Z_Flux_Boundary_Flux0');
  PhastDataSet.DataType := rdtDouble;
  PhastDataSet.EvaluatedAt := eaNodes;
  PhastDataSet.Orientation := dso3D;
  PhastDataSet.Formula := '0.';
  PhastDataSet.BoundaryDataType := TopBoundaryType;
  FTopFluxBoundaryFlux.Add(0, (PhastDataSet
    as TSparseArrayPhastInterpolationDataSet));

  PhastDataSet := TSparseRealPhastDataSet.Create(self);
  PhastDataSet.Lock := [dcName, dcType, dcOrientation, dcEvaluatedAt];
  PhastDataSet.UpdateWithName('Y_Flux_Boundary_Flux0');
  PhastDataSet.DataType := rdtDouble;
  PhastDataSet.EvaluatedAt := eaNodes;
  PhastDataSet.Orientation := dso3D;
  PhastDataSet.Formula := '0.';
  PhastDataSet.BoundaryDataType := FrontBoundaryType;
  FFrontFluxBoundaryFlux.Add(0, PhastDataSet
    as TSparseArrayPhastInterpolationDataSet);

  PhastDataSet := TSparseRealPhastDataSet.Create(self);
  PhastDataSet.Lock := [dcName, dcType, dcOrientation, dcEvaluatedAt];
  PhastDataSet.UpdateWithName('X_Flux_Boundary_Flux0');
  PhastDataSet.DataType := rdtDouble;
  PhastDataSet.EvaluatedAt := eaNodes;
  PhastDataSet.Orientation := dso3D;
  PhastDataSet.Formula := '0.';
  PhastDataSet.BoundaryDataType := SideBoundaryType;
  FSideFluxBoundaryFlux.Add(0, PhastDataSet
    as TSparseArrayPhastInterpolationDataSet);

  PhastDataSet := TSparseIntegerPhastDataSet.Create(self);
  PhastDataSet.Lock := [dcName, dcType, dcOrientation, dcEvaluatedAt];
  PhastDataSet.UpdateWithName('Z_Flux_Boundary_Chemistry0');
  PhastDataSet.DataType := rdtInteger;
  PhastDataSet.EvaluatedAt := eaNodes;
  PhastDataSet.Orientation := dso3D;
  PhastDataSet.Formula := '0';
  PhastDataSet.BoundaryDataType := TopBoundaryType;
  FTopFluxBoundaryChemistry.Add(0, (PhastDataSet
    as TSparseArrayPhastInterpolationDataSet));

  PhastDataSet := TSparseIntegerPhastDataSet.Create(self);
  PhastDataSet.Lock := [dcName, dcType, dcOrientation, dcEvaluatedAt];
  PhastDataSet.UpdateWithName('Y_Flux_Boundary_Chemistry0');
  PhastDataSet.DataType := rdtInteger;
  PhastDataSet.EvaluatedAt := eaNodes;
  PhastDataSet.Orientation := dso3D;
  PhastDataSet.Formula := '0';
  PhastDataSet.BoundaryDataType := FrontBoundaryType;
  FFrontFluxBoundaryChemistry.Add(0, PhastDataSet
    as TSparseArrayPhastInterpolationDataSet);

  PhastDataSet := TSparseIntegerPhastDataSet.Create(self);
  PhastDataSet.Lock := [dcName, dcType, dcOrientation, dcEvaluatedAt];
  PhastDataSet.UpdateWithName('X_Flux_Boundary_Chemistry0');
  PhastDataSet.DataType := rdtInteger;
  PhastDataSet.EvaluatedAt := eaNodes;
  PhastDataSet.Orientation := dso3D;
  PhastDataSet.Formula := '0';
  PhastDataSet.BoundaryDataType := SideBoundaryType;
  FSideFluxBoundaryChemistry.Add(0, PhastDataSet
    as TSparseArrayPhastInterpolationDataSet);
end;

procedure TPhastModel.CreatePhastTimeLists;
begin
  FSpecifiedHeadHead := TPhastTimeList.Create(self);
  FSpecifiedHeadHead.Name := StrSpecifiedHead;
  FSpecifiedHeadHead.Orientation := dso3D;
  FSpecifiedHeadHead.Direction := dso3D;
  FSpecifiedHeadHead.BoundaryType := btSpecifiedHead;
  FSpecifiedHeadHead.BoundaryTypeDataSets.Add(FTopBoundaryType
    as TIntegerSparseDataSet);
  FSpecifiedHeadHead.BoundaryTypeDataSets.Add(FFrontBoundaryType
    as TIntegerSparseDataSet);
  FSpecifiedHeadHead.BoundaryTypeDataSets.Add(FSideBoundaryType
    as TIntegerSparseDataSet);
  FSpecifiedHeadHead.DataType := rdtDouble;
  FSpecifiedHeadHead.OnTimeListUsed := PhastUsed;
  AddTimeList(FSpecifiedHeadHead);

  FSpecifiedHeadAssociatedSolution := TPhastTimeList.Create(self);
  FSpecifiedHeadAssociatedSolution.Name := StrSpecifiedHeadSolution;
  FSpecifiedHeadAssociatedSolution.Orientation := dso3D;
  FSpecifiedHeadAssociatedSolution.Direction := dso3D;
  FSpecifiedHeadAssociatedSolution.BoundaryType := btSpecifiedHead;
  FSpecifiedHeadAssociatedSolution.BoundaryTypeDataSets.Add(FTopBoundaryType
    as TIntegerSparseDataSet);
  FSpecifiedHeadAssociatedSolution.BoundaryTypeDataSets.Add(FFrontBoundaryType
    as TIntegerSparseDataSet);
  FSpecifiedHeadAssociatedSolution.BoundaryTypeDataSets.Add(FSideBoundaryType
    as TIntegerSparseDataSet);
  FSpecifiedHeadAssociatedSolution.DataType := rdtInteger;
  FSpecifiedHeadAssociatedSolution.OnTimeListUsed := PhastUsed;
  AddTimeList(FSpecifiedHeadAssociatedSolution);

  FTopFluxBoundaryFlux := TPhastTimeList.Create(self);
  FTopFluxBoundaryFlux.Name := StrTopFluxBoundaryFlux;
  FTopFluxBoundaryFlux.Orientation := dso3D;
  FTopFluxBoundaryFlux.Direction := dsoTop;
  FTopFluxBoundaryFlux.BoundaryType := btFlux;
  FTopFluxBoundaryFlux.BoundaryTypeDataSets.Add(FTopBoundaryType
    as TIntegerSparseDataSet);
  FTopFluxBoundaryFlux.DataType := rdtDouble;
  FTopFluxBoundaryFlux.OnTimeListUsed := PhastUsed;
  AddTimeList(FTopFluxBoundaryFlux);

  FFrontFluxBoundaryFlux := TPhastTimeList.Create(self);
  FFrontFluxBoundaryFlux.Name := StrFrontFluxBoundaryFlux;
  FFrontFluxBoundaryFlux.Orientation := dso3D;
  FFrontFluxBoundaryFlux.Direction := dsoFront;
  FFrontFluxBoundaryFlux.BoundaryType := btFlux;
  FFrontFluxBoundaryFlux.BoundaryTypeDataSets.Add(FFrontBoundaryType
    as TIntegerSparseDataSet);
  FFrontFluxBoundaryFlux.DataType := rdtDouble;
  FFrontFluxBoundaryFlux.OnTimeListUsed := PhastUsed;
  AddTimeList(FFrontFluxBoundaryFlux);

  FSideFluxBoundaryFlux := TPhastTimeList.Create(self);
  FSideFluxBoundaryFlux.Name := StrSideFluxBoundaryFlux;
  FSideFluxBoundaryFlux.Orientation := dso3D;
  FSideFluxBoundaryFlux.Direction := dsoSide;
  FSideFluxBoundaryFlux.BoundaryType := btFlux;
  FSideFluxBoundaryFlux.BoundaryTypeDataSets.Add(FSideBoundaryType
    as TIntegerSparseDataSet);
  FSideFluxBoundaryFlux.DataType := rdtDouble;
  FSideFluxBoundaryFlux.OnTimeListUsed := PhastUsed;
  AddTimeList(FSideFluxBoundaryFlux);

  FTopFluxBoundaryChemistry := TPhastTimeList.Create(self);
  FTopFluxBoundaryChemistry.Name := StrTopFluxBoundaryAssocSoln;
  FTopFluxBoundaryChemistry.Orientation := dso3D;
  FTopFluxBoundaryChemistry.Direction := dsoTop;
  FTopFluxBoundaryChemistry.BoundaryType := btFlux;
  FTopFluxBoundaryChemistry.BoundaryTypeDataSets.Add(FTopBoundaryType
    as TIntegerSparseDataSet);
  FTopFluxBoundaryChemistry.DataType := rdtInteger;
  FTopFluxBoundaryChemistry.OnTimeListUsed := PhastUsed;
  AddTimeList(FTopFluxBoundaryChemistry);

  FFrontFluxBoundaryChemistry := TPhastTimeList.Create(self);
  FFrontFluxBoundaryChemistry.Name := StrFrontFluxBoundaryAssocSoln;
  FFrontFluxBoundaryChemistry.Orientation := dso3D;
  FFrontFluxBoundaryChemistry.Direction := dsoFront;
  FFrontFluxBoundaryChemistry.BoundaryType := btFlux;
  FFrontFluxBoundaryChemistry.BoundaryTypeDataSets.Add(FFrontBoundaryType
    as TIntegerSparseDataSet);
  FFrontFluxBoundaryChemistry.DataType := rdtInteger;
  FFrontFluxBoundaryChemistry.OnTimeListUsed := PhastUsed;
  AddTimeList(FFrontFluxBoundaryChemistry);

  FSideFluxBoundaryChemistry := TPhastTimeList.Create(self);
  FSideFluxBoundaryChemistry.Name := StrSideFluxBoundaryAssocSoln;
  FSideFluxBoundaryChemistry.Orientation := dso3D;
  FSideFluxBoundaryChemistry.Direction := dsoSide;
  FSideFluxBoundaryChemistry.BoundaryType := btFlux;
  FSideFluxBoundaryChemistry.BoundaryTypeDataSets.Add(FSideBoundaryType
    as TIntegerSparseDataSet);
  FSideFluxBoundaryChemistry.DataType := rdtInteger;
  FSideFluxBoundaryChemistry.OnTimeListUsed := PhastUsed;
  AddTimeList(FSideFluxBoundaryChemistry);

  FTopLeakyHead := TPhastTimeList.Create(self);
  FTopLeakyHead.Name := StrTopLeakyBoundaryHead;
  FTopLeakyHead.Orientation := dso3D;
  FTopLeakyHead.Direction := dsoTop;
  FTopLeakyHead.BoundaryType := btLeaky;
  FTopLeakyHead.BoundaryTypeDataSets.Add(FTopBoundaryType
    as TIntegerSparseDataSet);
  FTopLeakyHead.DataType := rdtDouble;
  FTopLeakyHead.OnTimeListUsed := PhastUsed;
  AddTimeList(FTopLeakyHead);

  FTopLeakyAssociatedSolution := TPhastTimeList.Create(self);
  FTopLeakyAssociatedSolution.Name := StrTopLeakyBoundaryAssocSoln;
  FTopLeakyAssociatedSolution.Orientation := dso3D;
  FTopLeakyAssociatedSolution.Direction := dsoTop;
  FTopLeakyAssociatedSolution.BoundaryType := btLeaky;
  FTopLeakyAssociatedSolution.BoundaryTypeDataSets.Add(FTopBoundaryType
    as TIntegerSparseDataSet);
  FTopLeakyAssociatedSolution.DataType := rdtInteger;
  FTopLeakyAssociatedSolution.OnTimeListUsed := PhastUsed;
  AddTimeList(FTopLeakyAssociatedSolution);

  FFrontLeakyHead := TPhastTimeList.Create(self);
  FFrontLeakyHead.Name := StrFrontLeakyBoundaryHead;
  FFrontLeakyHead.Orientation := dso3D;
  FFrontLeakyHead.Direction := dsoFront;
  FFrontLeakyHead.BoundaryType := btLeaky;
  FFrontLeakyHead.BoundaryTypeDataSets.Add(FFrontBoundaryType
    as TIntegerSparseDataSet);
  FFrontLeakyHead.DataType := rdtDouble;
  FFrontLeakyHead.OnTimeListUsed := PhastUsed;
  AddTimeList(FFrontLeakyHead);

  FFrontLeakyAssociatedSolution := TPhastTimeList.Create(self);
  FFrontLeakyAssociatedSolution.Name := StrFrontLeakyBoundaryAssocSoln;
  FFrontLeakyAssociatedSolution.Orientation := dso3D;
  FFrontLeakyAssociatedSolution.Direction := dsoFront;
  FFrontLeakyAssociatedSolution.BoundaryType := btLeaky;
  FFrontLeakyAssociatedSolution.BoundaryTypeDataSets.Add(FFrontBoundaryType
    as TIntegerSparseDataSet);
  FFrontLeakyAssociatedSolution.DataType := rdtInteger;
  FFrontLeakyAssociatedSolution.OnTimeListUsed := PhastUsed;
  AddTimeList(FFrontLeakyAssociatedSolution);

  FSideLeakyHead := TPhastTimeList.Create(self);
  FSideLeakyHead.Name := StrSideLeakyBoundaryHead;
  FSideLeakyHead.Orientation := dso3D;
  FSideLeakyHead.Direction := dsoSide;
  FSideLeakyHead.BoundaryType := btLeaky;
  FSideLeakyHead.BoundaryTypeDataSets.Add(FSideBoundaryType
    as TIntegerSparseDataSet);
  FSideLeakyHead.DataType := rdtDouble;
  FSideLeakyHead.OnTimeListUsed := PhastUsed;
  AddTimeList(FSideLeakyHead);

  FSideLeakyAssociatedSolution := TPhastTimeList.Create(self);
  FSideLeakyAssociatedSolution.Name := StrSideLeakyBoundaryAssocSoln;
  FSideLeakyAssociatedSolution.Orientation := dso3D;
  FSideLeakyAssociatedSolution.Direction := dsoSide;
  FSideLeakyAssociatedSolution.BoundaryType := btLeaky;
  FSideLeakyAssociatedSolution.BoundaryTypeDataSets.Add(FSideBoundaryType
    as TIntegerSparseDataSet);
  FSideLeakyAssociatedSolution.DataType := rdtInteger;
  FSideLeakyAssociatedSolution.OnTimeListUsed := PhastUsed;
  AddTimeList(FSideLeakyAssociatedSolution);

  FRiverHead := TPhastTimeList.Create(self);
  FRiverHead.Name := StrRiverHead;
  FRiverHead.Orientation := dsoTop;
  FRiverHead.Direction := dsoTop;
  FRiverHead.BoundaryType := btRiver;
  FRiverHead.BoundaryTypeDataSets.Add(FTop2DBoundaryType
    as TIntegerSparseDataSet);
  FRiverHead.DataType := rdtDouble;
  FRiverHead.OnTimeListUsed := PhastUsed;
  AddTimeList(FRiverHead);

  FRiverAssociatedSolution := TPhastTimeList.Create(self);
  FRiverAssociatedSolution.Name := StrRiverAssocSoln;
  FRiverAssociatedSolution.Orientation := dsoTop;
  FRiverAssociatedSolution.Direction := dsoTop;
  FRiverAssociatedSolution.BoundaryType := btRiver;
  FRiverAssociatedSolution.BoundaryTypeDataSets.Add(FTop2DBoundaryType
    as TIntegerSparseDataSet);
  FRiverAssociatedSolution.DataType := rdtInteger;
  FRiverAssociatedSolution.OnTimeListUsed := PhastUsed;
  AddTimeList(FRiverAssociatedSolution);

  FWellInjectionOrPumpingRate := TPhastTimeList.Create(self);
  FWellInjectionOrPumpingRate.Name := StrWellInjectionRate;
  FWellInjectionOrPumpingRate.Orientation := dsoTop;
  FWellInjectionOrPumpingRate.Direction := dsoTop;
  FWellInjectionOrPumpingRate.BoundaryType := btWell;
  FWellInjectionOrPumpingRate.BoundaryTypeDataSets.Add(FTop2DBoundaryType
    as TIntegerSparseDataSet);
  FWellInjectionOrPumpingRate.DataType := rdtDouble;
  FWellInjectionOrPumpingRate.OnTimeListUsed := PhastUsed;
  AddTimeList(FWellInjectionOrPumpingRate);

  FWellSolution := TPhastTimeList.Create(self);
  FWellSolution.Name := StrWellSolution;
  FWellSolution.Orientation := dsoTop;
  FWellSolution.Direction := dsoTop;
  FWellSolution.BoundaryType := btWell;
  FWellSolution.BoundaryTypeDataSets.Add(FTop2DBoundaryType
    as TIntegerSparseDataSet);
  FWellSolution.DataType := rdtInteger;
  FWellSolution.OnTimeListUsed := PhastUsed;
  AddTimeList(FWellSolution);
end;

function TPhastModel.CSubIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := (ModelSelection = msModflow2015);
  if result then
  begin
    result := ModflowPackages.CSubPackage.IsSelected;
    if not result and frmGoPhast.PhastModel.LgrUsed then
    begin
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          result := result or ChildModel.ModflowPackages.CSubPackage.IsSelected;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.InvalidateScreenObjects;
var
  Index: integer;
  AScreenObject: TScreenObject;
begin
  BeginGridChange;
  try
    for Index := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[Index];
      AScreenObject.Invalidate;
    end;
  finally
    EndGridChange;
  end;
end;

procedure TCustomModel.InvalidateSfr6Evaporation(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.Evaporation.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6GwtConc(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateSfr6Inflow(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.Inflow.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6Rainfall(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.Rainfall.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6ReachNumber(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.ReachNumber.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6Roughness(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.Roughness.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6Runoff(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.Runoff.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6Stage(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.Stage.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6StreamStatus(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.StreamStatus.Invalidate;
end;

procedure TCustomModel.InvalidateSfr6UpstreamFraction(Sender: TObject);
begin
  ModflowPackages.SfrModflow6Package.UpstreamFraction.Invalidate;
end;

procedure TCustomModel.InvalidateSftConstConc(Sender: TObject);
var
  Index: Integer;
begin
  for Index := 0 to ModflowPackages.Mt3dSft.ConstConcTimeLists.Count - 1 do
  begin
    ModflowPackages.Mt3dSft.ConstConcTimeLists[Index].Invalidate;
  end;
end;

procedure TCustomModel.InvalidateSftHeadwatersConc(Sender: TObject);
var
  Index: Integer;
begin
  for Index := 0 to ModflowPackages.Mt3dSft.HeadWatersTimeLists.Count - 1 do
  begin
    ModflowPackages.Mt3dSft.HeadWatersTimeLists[Index].Invalidate;
  end;
end;

procedure TCustomModel.InvalidateSftPrecipConc(Sender: TObject);
var
  Index: Integer;
begin
  for Index := 0 to ModflowPackages.Mt3dSft.PrecipTimeLists.Count - 1 do
  begin
    ModflowPackages.Mt3dSft.PrecipTimeLists[Index].Invalidate;
  end;
end;

procedure TCustomModel.InvalidateSftRunoffConc(Sender: TObject);
var
  Index: Integer;
begin
  for Index := 0 to ModflowPackages.Mt3dSft.RunOffTimeLists.Count - 1 do
  begin
    ModflowPackages.Mt3dSft.RunOffTimeLists[Index].Invalidate;
  end;
end;

procedure TCustomModel.InvalidateSutraFluidFlux(Sender: TObject);
begin
  FSutraFluidFluxTimeList.Invalidate;
end;

procedure TCustomModel.InvalidateSutraFluidFluxU(Sender: TObject);
begin
  FSutraFluidFluxUTimeList.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenFlowPress1(Sender: TObject);
begin
  FSutraGenFlowPress1.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenFlowPress2(Sender: TObject);
begin
  FSutraGenFlowPress2.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenFlowRate1(Sender: TObject);
begin
  FSutraGenFlowRate1.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenFlowRate2(Sender: TObject);
begin
  FSutraGenFlowRate2.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenFlowU1(Sender: TObject);
begin
  FSutraGenFlowU1.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenFlowU2(Sender: TObject);
begin
  FSutraGenFlowU2.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenTransQU1(Sender: TObject);
begin
  FSutraGenTranQU1.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenTransQU2(Sender: TObject);
begin
  FSutraGenTranQU2.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenTransU1(Sender: TObject);
begin
  FSutraGenTranU1.Invalidate;
end;

procedure TCustomModel.InvalidateSutraGenTransU2(Sender: TObject);
begin
  FSutraGenTranU2.Invalidate;
end;

procedure TCustomModel.InvalidateSutraSpecifiedU(Sender: TObject);
begin
  FSutraConcTempTimeList.Invalidate;
end;

procedure TCustomModel.InvalidateSutraSpecPressure(Sender: TObject);
begin
  FSutraSpecPressureTimeList.Invalidate;
end;

procedure TCustomModel.InvalidateSutraSpecPressureU(Sender: TObject);
begin
  FSutraSpecPresUTimeList.Invalidate;
end;

procedure TCustomModel.InvalidateSutraUFlux(Sender: TObject);
begin
  FSutraMassEnergyFluxTimeList.Invalidate;
end;

procedure TCustomModel.InvalidateSwiObs(Sender: TObject);
begin
  { TODO -cSWI Obs : This needs to be finished }
end;

procedure TCustomModel.InvalidateTransientKx(Sender: TObject);
begin
  ModflowPackages.TvkPackage.TransientKx.Invalidate;
end;

procedure TCustomModel.InvalidateTransientKy(Sender: TObject);
begin
  ModflowPackages.TvkPackage.TransientKy.Invalidate;
end;

procedure TCustomModel.InvalidateTransientKz(Sender: TObject);
begin
  ModflowPackages.TvkPackage.TransientKz.Invalidate;
end;

procedure TCustomModel.InvalidateTransientSS(Sender: TObject);
begin
  ModflowPackages.TvsPackage.TransientSS.Invalidate;
end;

procedure TCustomModel.InvalidateTransientSY(Sender: TObject);
begin
  ModflowPackages.TvsPackage.TransientSY.Invalidate;
end;

procedure TCustomModel.InvalidateUzfGwtConc(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.InvalidateConcentrations;
end;

procedure TCustomModel.InvalidateUzfMf6AirEntryPotential(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6AirEntryPotential.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6ExtinctionDepth(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6ExtinctionDepth.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6ExtinctionWaterContent(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6ExtinctionWaterContent.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6Infiltration(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6Infiltration.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6Multiplier(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6Multiplier.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6PotentialET(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6PotentialEt.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6RootActivity(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6RootActivity.Invalidate;
end;

procedure TCustomModel.InvalidateUzfMf6RootPotential(Sender: TObject);
begin
  ModflowPackages.UzfMf6Package.MfUzfMf6RootPotential.Invalidate;
end;

procedure TCustomModel.InvalidateUzfSsmSinkConc(Sender: TObject);
begin
  ModflowPackages.Mt3dmsSourceSink.SinkConcentrations.Invalidate;
end;

procedure TCustomModel.InvalidateUztRechConc(Sender: TObject);
begin
  ModflowPackages.Mt3dUnsatTransport.RechConcentrations.Invalidate;
  ModflowPackages.Mt3dmsSourceSink.RechConcentrations.Invalidate;
end;

procedure TCustomModel.InvalidateUztSatConc(Sender: TObject);
begin
  ModflowPackages.Mt3dUnsatTransport.UnsatConcentrations.Invalidate;
end;

procedure TCustomModel.InvalidateUztUnsatConc(Sender: TObject);
begin
  ModflowPackages.Mt3dUnsatTransport.SatConcentrations.Invalidate;
end;

function TCustomModel.DoIrrigationUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticIrrigationArrayUsed(nil);
end;

function TCustomModel.IsLayerConfined(const LayerID: integer): boolean;
begin
  result := LayerStructure.IsLayerConfined(LayerID);
end;

function TCustomModel.IsLayerSimulated(const LayerID: integer): boolean;
begin
  if ModelSelection = msModflow2015 then
  begin
    result := True;
  end
  else
  begin
    result := LayerStructure.IsLayerSimulated(LayerID);
  end;
end;

function TPhastModel.DoSeparatedHorizontalTransverseDispersionUsed(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoSeparatedHorizontalTransverseDispersionUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSeparatedHorizontalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSeparatedHorizontalTransverseDispersionUsedPerSpecies(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSeparatedHorizontalTransverseDispersionUsedPerSpecies(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSeparatedLongitudinalDispersionUsed(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited;
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoSeparatedLongitudinalDispersionUsed(Sender);
      end;
    end;
  end;
end;

function TPhastModel.DoSeparatedLongitudinalDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoSeparatedLongitudinalDispersionUsedPerSpecies(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or
          ChildModel.DoSeparatedLongitudinalDispersionUsedPerSpecies(Sender);
      end;
    end;
  end;
end;

procedure TPhastModel.SetArchiveName(const Value: string);
begin
  FArchiveName := Value;
end;

procedure TPhastModel.SetBitmaps(const Value: TCompressedBitmapCollection);
begin
  FBitmaps.Assign(Value);
end;

procedure TPhastModel.SetChemistryOptions(const Value: TChemistryOptions);
begin
  FChemistryOptions.Assign(Value);
end;

procedure TPhastModel.SetChildModels(const Value: TChildModelCollection);
begin
  FChildModels.Assign(Value);
end;

procedure TPhastModel.SetColorSchemes(
  const Value: TUserDefinedColorSchemeCollection);
begin
  FColorSchemes.Assign(Value);
end;

procedure TPhastModel.SetCombinedDisplayColumn(const Value: integer);
var
  LocalCombinedCount: Integer;
  ChildIndex: Integer;
  ChildModel: TChildModel;
  NewPosition: Integer;
begin
  FCombinedDisplayColumn := Value;
  if FCombinedDisplayColumn < 0 then
  begin
    FCombinedDisplayColumn := 0;
  end;
  if ModelSelection = msPhast then
  begin
    Grid.DisplayColumn := FCombinedDisplayColumn;
    FCombinedDisplayColumn := Grid.DisplayColumn;
    Exit;
  end;
  if (Grid <> nil) and (Grid.ColumnCount > 0)
    and (Grid.RowCount > 0)and (Grid.LayerCount > 0) then
  begin
    UpdateMapping;
    LocalCombinedCount := Length(FColumnMapping);
    if FCombinedDisplayColumn > LocalCombinedCount then
    begin
      FCombinedDisplayColumn := LocalCombinedCount;
    end;
    if FCombinedDisplayColumn >= 0 then
    begin
      if FCombinedDisplayColumn < LocalCombinedCount then
      begin
        ModflowGrid.DisplayColumn :=
          FColumnMapping[FCombinedDisplayColumn].ParentPostion;
      end
      else
      begin
        ModflowGrid.DisplayColumn :=
          FColumnMapping[FCombinedDisplayColumn-1].ParentPostion+1;
      end;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          if FCombinedDisplayColumn < LocalCombinedCount then
          begin
            NewPosition := FColumnMapping[FCombinedDisplayColumn].
              ChildPositions[ChildIndex];
          end
          else
          begin
            NewPosition := FColumnMapping[FCombinedDisplayColumn-1].
              ChildPositions[ChildIndex]+1;
          end;
          ChildModel.ModflowGrid.DisplayColumn := NewPosition;
        end;
      end;
    end;
  end;
end;

function TPhastModel.CombinedLayerSimulated(ALayer: Integer): boolean;
var
  LocalCombinedCount: Integer;
begin
  if ALayer < 0 then
  begin
    ALayer := 0;
  end;
  if ModelSelection = msPhast then
  begin
    result := True;
    Exit;
  end;
  if (Grid <> nil) and (Grid.ColumnCount > 0)
    and (Grid.RowCount > 0)and (Grid.LayerCount > 0) then
  begin
    UpdateMapping;
    LocalCombinedCount := Length(FLayerMapping);
    if ALayer > LocalCombinedCount then
    begin
      ALayer := LocalCombinedCount;
    end;
    Assert(ALayer >= 0);
    if ALayer < LocalCombinedCount then
    begin
      ALayer :=
        FLayerMapping[ALayer].ParentPostion;
    end
    else
    begin
      ALayer :=
        FLayerMapping[ALayer-1].ParentPostion+1;
    end;
    result := LayerStructure.IsLayerSimulated(ALayer)
  end
  else
  begin
    result := True
  end;
end;

procedure TPhastModel.PasteModelMuseObjectsFromClipboard(
  const ClipboardText: string; List: TList);
var
  ScreenObj: TScreenObjectCrack;
  ClipStream: TStringStream;
  NewName: string;
  ScreenObject: TScreenObject;
  NewScreenObject: TScreenObject;
  ScreenObjectNames: TStringList;
  MemStream: TMemoryStream;
  NewIndex: Integer;
  Item: TScreenObjectItem;
  OldScreenObject: TScreenObject;
  Index: Integer;
  Objects: TScreenObjectClipboard;
begin
  // Copied from ModelMuse.
  ClipStream := TStringStream.Create(ClipboardText);
  try
    ClipStream.Position := 0;
    MemStream := TMemoryStream.Create;
    try
      ObjectTextToBinary(ClipStream, MemStream);
      Objects := TScreenObjectClipboard.Create(nil);
      try
        MemStream.Position := 0;
        MemStream.ReadComponent(Objects);
        Objects.UpdateModel(self);
        ScreenObjectNames := TStringList.Create;
        try
          ScreenObjectNames.Sorted := True;
          ScreenObjectNames.Duplicates := dupIgnore;
          ScreenObjectNames.CaseSensitive := False;
          for Index := 0 to ScreenObjectCount - 1 do
          begin
            ScreenObject := ScreenObjects[Index];
            if not ScreenObject.Deleted then
            begin
              ScreenObjectNames.Add(ScreenObject.Name);
            end;
          end;
          for Index := 0 to Objects.ScreenObjects.Count - 1 do
          begin
            Item := Objects.ScreenObjects.Items[Index] as TScreenObjectItem;
            NewScreenObject := TScreenObjectClass(Item.ScreenObject.ClassType).Create(self);
            List.Add(NewScreenObject);
            OldScreenObject := Item.ScreenObject;
            Item.SetScreenObject(NewScreenObject);
            NewScreenObject.Assign(OldScreenObject);
            if ScreenObjectNames.IndexOf(NewScreenObject.Name) >= 0 then
            begin
              NewIndex := 0;
              NewName := ObjectPrefix + IntToStr(NewIndex);
              while ScreenObjectNames.IndexOf(NewName) >= 0 do
              begin
                Inc(NewIndex);
                NewName := ObjectPrefix + IntToStr(NewIndex);
              end;
              NewScreenObject.Name := NewName;
            end;
            OldScreenObject.Free;
          end;
          Objects.ScreenObjects.UpdateScreenObjects;
          for Index := 0 to Objects.ScreenObjects.Count - 1 do
          begin
            Item := Objects.ScreenObjects.Items[Index] as TScreenObjectItem;
            ScreenObj := TScreenObjectCrack(Item.ScreenObject);
            ScreenObj.Loaded;
            ScreenObj.ReplaceGUID;
          end;
          UpdateDrainReturnObjects;
        finally
          ScreenObjectNames.Free;
        end;
      finally
        Objects.Free;
      end;
    finally
      MemStream.Free;
    end;
  finally
    ClipStream.Free;
  end;
end;

procedure TPhastModel.SetCombinedDisplayLayer(const Value: integer);
var
  LocalCombinedCount: Integer;
  ChildIndex: Integer;
  ChildModel: TChildModel;
  NewPosition: Integer;
begin
  FCombinedDisplayLayer := Value;
  if FCombinedDisplayLayer < 0 then
  begin
    FCombinedDisplayLayer := 0;
  end;
  if ModelSelection = msPhast then
  begin
    Grid.DisplayLayer := FCombinedDisplayLayer;
    FCombinedDisplayLayer := Grid.DisplayLayer;
    Exit;
  end;
  if (Grid <> nil) and (Grid.ColumnCount > 0)
    and (Grid.RowCount > 0)and (Grid.LayerCount > 0) then
  begin
    UpdateMapping;
    LocalCombinedCount := Length(FLayerMapping);
    if FCombinedDisplayLayer > LocalCombinedCount then
    begin
      FCombinedDisplayLayer := LocalCombinedCount;
    end;
    if FCombinedDisplayLayer >= 0 then
    begin
      if FCombinedDisplayLayer < LocalCombinedCount then
      begin
        ModflowGrid.DisplayLayer :=
          FLayerMapping[FCombinedDisplayLayer].ParentPostion;
      end
      else
      begin
        ModflowGrid.DisplayLayer :=
          FLayerMapping[FCombinedDisplayLayer-1].ParentPostion+1;
      end;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          if FCombinedDisplayLayer < LocalCombinedCount then
          begin
            NewPosition := FLayerMapping[FCombinedDisplayLayer].
              ChildPositions[ChildIndex];
          end
          else
          begin
            NewPosition := FLayerMapping[FCombinedDisplayLayer-1].
              ChildPositions[ChildIndex]+1;
          end;
          ChildModel.ModflowGrid.DisplayLayer := NewPosition;
        end;
      end;
    end;
  end;

  if (SutraMesh <> nil) and (ModelSelection in SutraSelection) then
  begin
    SutraMesh.SelectedLayer := FCombinedDisplayLayer;
    FCombinedDisplayLayer := SutraMesh.SelectedLayer;
  end;

  if Mesh3D <> nil then
  begin
    Mesh3D.SelectedLayer := FCombinedDisplayLayer;
    FCombinedDisplayLayer := Mesh3D.SelectedLayer;
  end;
end;

procedure TPhastModel.SetCombinedDisplayRow(const Value: integer);
var
  LocalCombinedCount: Integer;
  ChildIndex: Integer;
  ChildModel: TChildModel;
  NewPosition: Integer;
begin
  FCombinedDisplayRow := Value;
  if FCombinedDisplayRow < 0 then
  begin
    FCombinedDisplayRow := 0;
  end;
  if ModelSelection = msPhast then
  begin
    Grid.DisplayRow := FCombinedDisplayRow;
    FCombinedDisplayRow := Grid.DisplayRow;
    Exit;
  end;
  if (Grid <> nil) and (Grid.ColumnCount > 0)
    and (Grid.RowCount > 0)and (Grid.LayerCount > 0) then
  begin
    UpdateMapping;
    LocalCombinedCount := Length(FRowMapping);
    if FCombinedDisplayRow > LocalCombinedCount then
    begin
      FCombinedDisplayRow := LocalCombinedCount;
    end;
    if FCombinedDisplayRow >= 0 then
    begin
      if FCombinedDisplayRow < LocalCombinedCount then
      begin
        ModflowGrid.DisplayRow :=
          FRowMapping[FCombinedDisplayRow].ParentPostion;
      end
      else
      begin
        ModflowGrid.DisplayRow :=
          FRowMapping[FCombinedDisplayRow-1].ParentPostion+1;
      end;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          if FCombinedDisplayRow < LocalCombinedCount then
          begin
            NewPosition := FRowMapping[FCombinedDisplayRow].
              ChildPositions[ChildIndex];
          end
          else
          begin
            NewPosition := FRowMapping[FCombinedDisplayRow-1].
              ChildPositions[ChildIndex]+1;
          end;
          ChildModel.ModflowGrid.DisplayRow := NewPosition;
        end;
      end;
    end;
  end;
end;

procedure TPhastModel.SetContourFont(const Value: TFont);
begin
  FContourFont.Assign(Value);
end;

procedure TPhastModel.SetContourLabelSpacing(const Value: Integer);
begin
  if FContourLabelSpacing <> Value then
  begin
    FContourLabelSpacing := Value;
    DoInvalidate(self);
  end;
end;

procedure TPhastModel.SetCtsSystems(const Value: TCtsSystemCollection);
begin
  FCtsSystems.Assign(Value);
end;

procedure TPhastModel.SetUnits(const Value: TUnits);
begin
  FUnits.Assign(Value);
end;

procedure TPhastModel.SetUpToDate(const Value: boolean);
begin
  inherited;
  if not UpToDate then
  begin
    FreeAndNil(FSortedObjectList);
  end;

end;

procedure TPhastModel.Notify3DViewChanged;
begin
  if Assigned(On3DViewChanged) then
  begin
    On3DViewChanged(self);
  end;
end;

function TPhastModel.NumberOfLargestScreenObjectsStartingWith(
  const Root: string): integer;
var
  Index: integer;
  AScreenObject: TScreenObject;
  AName: String;
  Value: integer;
  Check: boolean;
begin
  result := 0;
  for Index := 0 to ScreenObjectCount -1 do
  begin
    AScreenObject := ScreenObjects[Index];
    if not AScreenObject.Deleted and (Pos(Root, AScreenObject.Name) = 1) then
    begin
      AName := Copy(AScreenObject.Name, Length(Root)+1, MAXINT);

      try
        Check := True;
        if AName = '' then
        begin
          Value := 1;
        end
        else
        begin
          Check := TryStrToInt(AName, Value);
//          Value := StrToInt(AName);
        end;
        if Check and (Value > result) then
        begin
          result := value;
        end;

      except on EConvertError do
        begin
          // Ignore
        end;
      end;
    end;
  end;
end;

procedure EnableLighting;
var
  light_specular: array[0..3] of Extended;
  light_diffuse: array[0..3] of Extended;
  light_ambient: array[0..3] of Extended;
begin
  light_ambient[0] := ColorValues.Ambient;
  light_ambient[1] := light_ambient[0];
  light_ambient[2] := light_ambient[0];
  light_ambient[3] := 1;

  light_diffuse[0] := ColorValues.Diffuse;
  light_diffuse[1] := light_diffuse[0];
  light_diffuse[2] := light_diffuse[0];
  light_diffuse[3] := 1;

  light_specular[0] := ColorValues.Specular;
  light_specular[1] := light_specular[0];
  light_specular[2] := light_specular[0];
  light_specular[3] := 1;

  glLightfv(GL_LIGHT0, GL_AMBIENT, @light_ambient);
  glLightfv(GL_LIGHT0, GL_DIFFUSE, @light_diffuse);
  glLightfv(GL_LIGHT0, GL_SPECULAR, @light_specular);

  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 1);

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
end;

function TPhastModel.PackageIsSelected(APackage: TObject): Boolean;
begin
  result := False;
  if APackage = frmGoPhast.PhastModel.ModflowPackages.ChdBoundary then
  begin
    result := ChdIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.GhbBoundary then
  begin
    result := GhbIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.GhbBoundary then
  begin
    result := GhbIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.LpfPackage then
  begin
    result := LpfIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.PcgPackage then
  begin
    result := PcgIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.WelPackage then
  begin
    result := WelIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.RivPackage then
  begin
    result := RivIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.DrnPackage then
  begin
    result := DrnIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.DrtPackage then
  begin
    result := DrtIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.StrPackage then
  begin
    result := StrIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.FhbPackage then
  begin
    result := FhbIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.RchPackage then
  begin
    result := RchIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.EvtPackage then
  begin
    result := EvtIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.EtsPackage then
  begin
    result := EtsIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.ResPackage then
  begin
    result := ResIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.LakPackage then
  begin
    result := LakIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.SfrPackage then
  begin
    result := SfrIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.UzfPackage then
  begin
    result := UzfIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.GmgPackage then
  begin
    result := GmgIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.SipPackage then
  begin
    result := SipIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.De4Package then
  begin
    result := De4IsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.HobPackage then
  begin
    result := HobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.HfbPackage then
  begin
    result := HfbIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.ModPath then
  begin
    result := ModPathIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.ChobPackage then
  begin
    result := ChobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.DrobPackage then
  begin
    result := DrobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.GbobPackage then
  begin
    result := GbobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.RvobPackage then
  begin
    result := RvobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.StobPackage then
  begin
    result := StobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.HufPackage then
  begin
    result := HufIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.Mnw2Package then
  begin
    result := Mnw2IsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.MawPackage then
  begin
    result := MawIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.Mnw1Package then
  begin
    result := Mnw1IsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.BcfPackage then
  begin
    result := BcfIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.SubPackage then
  begin
    result := SubIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.ZoneBudget then
  begin
    result := ZoneBudgetIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.SwtPackage then
  begin
    result := SwtIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.HydmodPackage then
  begin
    result := HydmodIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.UpwPackage then
  begin
    result := UpwIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.Mt3dmsTransObs then
  begin
    result := TobIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.Mt3dmsSourceSink then
  begin
    result := SsmIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.RipPackage then
  begin
    result := RipIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.SfrModflow6Package then
  begin
    result := Sfr6IsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.Mf6ObservationUtility then
  begin
    result := Mf6ObsIsSelected;
  end
  else if APackage = frmGoPhast.PhastModel.ModflowPackages.LakMf6Package then
  begin
    result := LakMf6IsSelected;
  end
  else
  begin
    Assert(False);
  end;
end;

function TPhastModel.ParameterDataSetUsed(Sender: TObject): boolean;
begin
  result := ModflowSteadyParameters.IsDataSetUsed(Sender);
end;

procedure TPhastModel.PasteArgusOneContoursFromClipboard(
  const ClipboardText: string; List: TList);
var
  ArgusContours: TStringList;
  LineIndex: Integer;
  ReadingPoints: boolean;
  AScreenObject: TScreenObject;
  Dummy: TCustomUndo;
  Splitter: TStringList;
  APoint: TPoint2D;
  ScreenObj: TScreenObjectCrack;
  procedure FinalizeScreenObject;
  begin
    if AScreenObject <> nil then
    begin
      ScreenObj := TScreenObjectCrack(AScreenObject);
      ScreenObj.Loaded;
      if AScreenObject.Closed then
      begin
        AScreenObject.SetPropertiesOfEnclosedCells := True;
      end
      else
      begin
        AScreenObject.SetPropertiesOfIntersectedCells := True;
      end;
      AScreenObject.Visible := True;
      AScreenObject.Selected := True;
    end;
  end;
begin
  // Copied from Argus ONE.
  Dummy := nil;
  ArgusContours := TStringList.Create;
  Splitter := TStringList.Create;
  try
    ReadingPoints := False;
    Splitter.Delimiter := #9;
    AScreenObject := nil;
    ArgusContours.Text := ClipboardText;
    for LineIndex := 0 to ArgusContours.Count - 1 do
    begin
      if ReadingPoints then
      begin
        if ArgusContours[LineIndex] = '' then
        begin
          ReadingPoints := false;
          FinalizeScreenObject;
          AScreenObject := nil;
        end
        else
        begin
          Splitter.DelimitedText := ArgusContours[LineIndex];
          Assert(Splitter.Count = 2);
          APoint.x := FortranStrToFloat(Splitter[0]);
          APoint.y := FortranStrToFloat(Splitter[1]);
          Assert(AScreenObject <> nil);
          AScreenObject.AddPoint(APoint, False);
        end;
      end
      else
      begin
        if ArgusContours[LineIndex] = '# X pos'#9'Y pos' then
        begin
          ReadingPoints := True;
          AScreenObject := TScreenObject.CreateWithViewDirection(
            self, vdTop, Dummy, False);
          List.Add(AScreenObject);
          AddScreenObject(AScreenObject);
          AScreenObject.ElevationCount := ecZero;
        end;
      end;
    end;
  finally
    Splitter.Free;
    ArgusContours.Free;
    FinalizeScreenObject;
  end;
end;

procedure TPhastModel.PasteObjectsFromClipboard(List: TList);
var
  ClipboardText: string;
  TestText: string;
begin
  try
    ClipboardText := ClipBoard.AsText;
  except on E: EClipboardException do
    begin
      Beep;
      MessageDlg(E.Message, mtError, [mbOK], 0);
      Exit;
    end;
  end;
  TestText := Copy(ClipboardText, 1, 100);
  if Pos('object TScreenObjectClipboard', TestText) = 1 then
  begin
    PasteModelMuseObjectsFromClipboard(ClipboardText, List);
  end
  else if Pos('## Name:', TestText) >= 1 then
  begin
    PasteArgusOneContoursFromClipboard(ClipboardText, List);
  end;
end;

function TPhastModel.PcgIsSelected: Boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := ModflowPackages.PcgPackage.IsSelected;
  if not result and frmGoPhast.PhastModel.LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.ModflowPackages.PcgPackage.IsSelected;
      end;
    end;
  end;
end;

procedure TPhastModel.NotifyGridColorsChanged(Sender: TObject);
var
  LocalMesh: TSutraMesh3D;
begin
  if Grid <> nil then
  begin
    if Grid.TopDataSet <> nil then
    begin
      Grid.NeedToRecalculateTopCellColors := True;
    end;
    if Grid.FrontDataSet <> nil then
    begin
      Grid.NeedToRecalculateFrontCellColors := True;
    end;
    if Grid.SideDataSet <> nil then
    begin
      Grid.NeedToRecalculateSideCellColors := True;
    end;
  end
  else
  begin
    LocalMesh := Mesh as TSutraMesh3D;
    if LocalMesh <> nil then
    begin
      LocalMesh.NeedToRecalculateTopColors := True;
      LocalMesh.NeedToRecalculateFrontColors := True;
      frmGoPhast.InvalidateImage32AllViews;
    end;
  end;
end;

//procedure TPhastModel.NotifyPestObsGroupNameDestroy(
//  Group: TPestObservationGroup);
//var
//  ChildIndex: Integer;
//begin
//  inherited;
//  for ChildIndex := 0 to ChildModels.Count - 1 do
//  begin
//    ChildModels[ChildIndex].ChildModel.NotifyPestObsGroupNameDestroy(Group);
//  end;
//end;

function TPhastModel.DoNpfUsed(Sender: TObject): boolean;
var
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  result := inherited DoNpfUsed(Sender);
  if not result and LgrUsed then
  begin
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        result := result or ChildModel.DoNpfUsed(Sender);
      end;
    end;
  end;
end;

{ TDataSetItem }
procedure TDataSetItem.Assign(Source: TPersistent);
var
  SourceItem: TDataSetItem;
  ClassType: TDataArrayType;
begin
  if Source is TDataSetItem then
  begin
    Beep;
    SourceItem := TDataSetItem(Source);
    FDataSet.Free;
    ClassType := TDataArrayType(SourceItem.FDataSet.ClassType);
    FDataSet := ClassType.Create(nil);
    FDataSet.Assign(SourceItem.FDataSet);
    FDataSetFormula := SourceItem.FDataSetFormula;
  end
  else
  begin
    inherited;
  end;
end;

function TDataSetItem.GetDataSetClass: string;
begin
  Result := FDataSet.ClassName;
end;

function TDataSetItem.GetDataSetFormula: string;
begin
  Result := FDataSet.Formula;
end;

function TDataSetItem.GetMixtureFormula: string;
begin
  if FDataSet is TCustomPhastDataSet then
  begin
    result := TCustomPhastDataSet(FDataSet).MixtureFormula;
  end
  else
  begin
    result := '';
  end;
end;

function TDataSetItem.GetParameterFormula: string;
begin
  Result := FParameterFormula;
end;

procedure TDataSetItem.SetDataSetClass(const Value: string);
begin
  if Value = 'TDataSet' then
  begin
    { TODO : This is for backwards compatibility. Remove when no longer needed. }
    FDataSet := TDataArrayType(TDataArray).Create
      (frmGoPhast.PhastModel);
  end
  else
  begin
    FDataSet := TDataArrayType(GetClass(Value)).Create
      (frmGoPhast.PhastModel);
  end;

  FDataSet.SetSubComponent(True);
end;

procedure TDataSetItem.UpdateDataSet;
begin
  FDataSet.UpdateWithName(FDataSet.Name);
end;

{ TDataSetCollection }

constructor TDataSetCollection.Create;
begin
  inherited Create(TDataSetItem);
end;

{ TUnits }

procedure TUnits.Assign(Source: TPersistent);
begin
  if Source is TUnits then
  begin
    with TUnits(Source) do
    begin
      self.DefaultTimeUnits := DefaultTimeUnits;
      self.DefaultHorizontalGridUnits := DefaultHorizontalGridUnits;
      self.DefaultVerticalGridUnits := DefaultVerticalGridUnits;
      self.DefaultHeadUnits := DefaultHeadUnits;
      self.DefaultHydraulicConductivityLengthUnits :=
        DefaultHydraulicConductivityLengthUnits;
      self.DefaultHydraulicConductivityTimeUnits :=
        DefaultHydraulicConductivityTimeUnits;
      self.DefaultSpecificStorageUnits := DefaultSpecificStorageUnits;
      self.DefaultDispersivityUnits := DefaultDispersivityUnits;
      self.DefaultFluxLengthUnits := DefaultFluxLengthUnits;
      self.DefaultFluxTimeUnits := DefaultFluxTimeUnits;
      self.DefaultLeakyHydraulicConductivityLengthUnits :=
        DefaultLeakyHydraulicConductivityLengthUnits;
      self.DefaultLeakyHydraulicConductivityTimeUnits :=
        DefaultLeakyHydraulicConductivityTimeUnits;
      self.DefaultLeakyThicknessUnits := DefaultLeakyThicknessUnits;
      self.DefaultWellDiameterUnits := DefaultWellDiameterUnits;
      self.DefaultWellFlowVolumnUnits := DefaultWellFlowVolumnUnits;
      self.DefaultWellFlowTimeUnits := DefaultWellFlowTimeUnits;
      self.DefaultRiverBedHydraulicConductivityLengthUnits :=
        DefaultRiverBedHydraulicConductivityLengthUnits;
      self.DefaultRiverBedHydraulicConductivityTimeUnits :=
        DefaultRiverBedHydraulicConductivityTimeUnits;
      self.DefaultRiverBedThicknessUnits := DefaultRiverBedThicknessUnits;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TUnits.Create;
begin
  DefaultDispersivityUnits := luMeters;
  DefaultFluxLengthUnits := luMeters;
  DefaultHeadUnits := luMeters;
  DefaultHorizontalGridUnits := luMeters;
  DefaultHydraulicConductivityLengthUnits := luMeters;
  DefaultLeakyHydraulicConductivityLengthUnits := luMeters;
  DefaultLeakyThicknessUnits := luMeters;
  DefaultRiverBedHydraulicConductivityLengthUnits := luMeters;
  DefaultRiverBedThicknessUnits := luMeters;
  DefaultVerticalGridUnits := luMeters;
  DefaultWellDiameterUnits := luCentimeters;
  DefaultWellFlowVolumnUnits := vuMeters3;
  DefaultSpecificStorageUnits := iluMeters;
end;

procedure TUnits.SetDefaultDispersivityUnits(const Value: TLengthUnits);
begin
  if FDefaultDispersivityUnits <> Value then
  begin
    FDefaultDispersivityUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultFluxLengthUnits(const Value: TLengthUnits);
begin
  if FDefaultFluxLengthUnits <> Value then
  begin
    FDefaultFluxLengthUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultFluxTimeUnits(const Value: TTimeUnits);
begin
  if FDefaultFluxTimeUnits <> Value then
  begin
    FDefaultFluxTimeUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultHeadUnits(const Value: TLengthUnits);
begin
  if FDefaultHeadUnits <> Value then
  begin
    FDefaultHeadUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultHorizontalGridUnits(const Value: TLengthUnits);
begin
  if FDefaultHorizontalGridUnits <> Value then
  begin
    FDefaultHorizontalGridUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultHydraulicConductivityLengthUnits(
  const Value: TLengthUnits);
begin
  if FDefaultHydraulicConductivityLengthUnits <> Value then
  begin
    FDefaultHydraulicConductivityLengthUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultLeakyHydraulicConductivityLengthUnits(
  const Value: TLengthUnits);
begin
  if FDefaultLeakyHydraulicConductivityLengthUnits <> Value then
  begin
    FDefaultLeakyHydraulicConductivityLengthUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultLeakyHydraulicConductivityTimeUnits(
  const Value: TTimeUnits);
begin
  if FDefaultLeakyHydraulicConductivityTimeUnits <> Value then
  begin
    FDefaultLeakyHydraulicConductivityTimeUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultLeakyThicknessUnits(const Value: TLengthUnits);
begin
  if FDefaultLeakyThicknessUnits <> Value then
  begin
    FDefaultLeakyThicknessUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultRiverBedHydraulicConductivityLengthUnits(
  const Value: TLengthUnits);
begin
  if FDefaultRiverBedHydraulicConductivityLengthUnits <> Value then
  begin
    FDefaultRiverBedHydraulicConductivityLengthUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultRiverBedHydraulicConductivityTimeUnits(
  const Value: TTimeUnits);
begin
  if FDefaultRiverBedHydraulicConductivityTimeUnits <> Value then
  begin
    FDefaultRiverBedHydraulicConductivityTimeUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultRiverBedThicknessUnits(
  const Value: TLengthUnits);
begin
  if FDefaultRiverBedThicknessUnits <> Value then
  begin
    FDefaultRiverBedThicknessUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultSpecificStorageUnits(
  const Value: TInverseLengthUnits);
begin
  if FDefaultSpecificStorageUnits <> Value then
  begin
    FDefaultSpecificStorageUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultTimeUnits(const Value: TTimeUnits);
begin
  if FDefaultTimeUnits <> Value then
  begin
    FDefaultTimeUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultVerticalGridUnits(const Value: TLengthUnits);
begin
  if FDefaultVerticalGridUnits <> Value then
  begin
    FDefaultVerticalGridUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultWellDiameterUnits(const Value: TLengthUnits);
begin
  if FDefaultWellDiameterUnits <> Value then
  begin
    FDefaultWellDiameterUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultWellFlowTimeUnits(const Value: TTimeUnits);
begin
  if FDefaultWellFlowTimeUnits <> Value then
  begin
    FDefaultWellFlowTimeUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultWellFlowVolumnUnits(const Value: TVolumeUnits);
begin
  if FDefaultWellFlowVolumnUnits <> Value then
  begin
    FDefaultWellFlowVolumnUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TUnits.SetDefaultHydraulicConductivityTimeUnits(
  const Value: TTimeUnits);
begin
  if FDefaultHydraulicConductivityTimeUnits <> Value then
  begin
    FDefaultHydraulicConductivityTimeUnits := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

{ TPrintInitial }

procedure TPrintInitial.Assign(Source: TPersistent);
begin
  if Source is TPrintInitial then
  begin
    with TPrintInitial(Source) do
    begin
      self.PrintInitialBoundaryConditions := PrintInitialBoundaryConditions;
      self.PrintInitialComponents := PrintInitialComponents;
      self.PrintInitialConductance := PrintInitialConductance;
      self.PrintInitialEchoInput := PrintInitialEchoInput;
      self.PrintInitialFluidProperties := PrintInitialFluidProperties;
      self.PrintInitialForceChemistryPrint := PrintInitialForceChemistryPrint;
      self.PrintInitialHDF_Chemistry := PrintInitialHDF_Chemistry;
      self.PrintInitialHDF_Heads := PrintInitialHDF_Heads;
      self.PrintInitialHDF_SteadyFlowVelocites :=
        PrintInitialHDF_SteadyFlowVelocites;
      self.PrintInitialHeads := PrintInitialHeads;
      self.PrintInitialMediaProperties := PrintInitialMediaProperties;
      self.PrintInitialSolutionMethod := PrintInitialSolutionMethod;
      self.PrintInitialSteadyFlowVelocities :=
        PrintInitialSteadyFlowVelocities;
      self.PrintInitialWells := PrintInitialWells;
      self.PrintInitialXYZ_Chemistry := PrintInitialXYZ_Chemistry;
      self.PrintInitialXYZ_Components := PrintInitialXYZ_Components;
      self.PrintInitialXYZ_Heads := PrintInitialXYZ_Heads;
      self.PrintInitialXYZ_SteadyFlowVelocities :=
        PrintInitialXYZ_SteadyFlowVelocities;
      self.PrintInitialXYZ_Wells := PrintInitialXYZ_Wells;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TPrintInitial.Create;
begin
  PrintInitialEchoInput := True;
  PrintInitialFluidProperties := True;
  PrintInitialHDF_Chemistry := True;
  PrintInitialHDF_Heads := True;
  PrintInitialHDF_SteadyFlowVelocites := True;
  PrintInitialHeads := True;
  PrintInitialSolutionMethod := True;
  PrintInitialWells := True;
end;

procedure TPrintInitial.SetPrintInitialBoundaryConditions(
  const Value: boolean);
begin
  if FPrintInitialBoundaryConditions <> Value then
  begin
    FPrintInitialBoundaryConditions := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialComponents(const Value: boolean);
begin
  if FPrintInitialComponents <> Value then
  begin
    FPrintInitialComponents := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialConductance(const Value: boolean);
begin
  if FPrintInitialConductance <> Value then
  begin
    FPrintInitialConductance := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialEchoInput(const Value: boolean);
begin
  if FPrintInitialEchoInput <> Value then
  begin
    FPrintInitialEchoInput := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialFluidProperties(
  const Value: boolean);
begin
  if FPrintInitialFluidProperties <> Value then
  begin
    FPrintInitialFluidProperties := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialForceChemistryPrint(
  const Value: boolean);
begin
  if FPrintInitialForceChemistryPrint <> Value then
  begin
    FPrintInitialForceChemistryPrint := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialHDF_Chemistry(const Value: boolean);
begin
  if FPrintInitialHDF_Chemistry <> Value then
  begin
    FPrintInitialHDF_Chemistry := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialHDF_Heads(const Value: boolean);
begin
  if FPrintInitialHDF_Heads <> Value then
  begin
    FPrintInitialHDF_Heads := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialHDF_SteadyFlowVelocites(
  const Value: boolean);
begin
  if FPrintInitialHDF_SteadyFlowVelocites <> Value then
  begin
    FPrintInitialHDF_SteadyFlowVelocites := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialHeads(const Value: boolean);
begin
  if FPrintInitialHeads <> Value then
  begin
    FPrintInitialHeads := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialMediaProperties(
  const Value: boolean);
begin
  if FPrintInitialMediaProperties <> Value then
  begin
    FPrintInitialMediaProperties := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialSolutionMethod(
  const Value: boolean);
begin
  if FPrintInitialSolutionMethod <> Value then
  begin
    FPrintInitialSolutionMethod := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialSteadyFlowVelocities(
  const Value: boolean);
begin
  if FPrintInitialSteadyFlowVelocities <> Value then
  begin
    FPrintInitialSteadyFlowVelocities := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialWells(const Value: boolean);
begin
  if FPrintInitialWells <> Value then
  begin
    FPrintInitialWells := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialXYZ_Chemistry(const Value: boolean);
begin
  if FPrintInitialXYZ_Chemistry <> Value then
  begin
    FPrintInitialXYZ_Chemistry := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialXYZ_Components(
  const Value: boolean);
begin
  if FPrintInitialXYZ_Components <> Value then
  begin
    FPrintInitialXYZ_Components := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialXYZ_Heads(const Value: boolean);
begin
  if FPrintInitialXYZ_Heads <> Value then
  begin
    FPrintInitialXYZ_Heads := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialXYZ_SteadyFlowVelocities(
  const Value: boolean);
begin
  if FPrintInitialXYZ_SteadyFlowVelocities <> Value then
  begin
    FPrintInitialXYZ_SteadyFlowVelocities := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TPrintInitial.SetPrintInitialXYZ_Wells(const Value: boolean);
begin
  if FPrintInitialXYZ_Wells <> Value then
  begin
    FPrintInitialXYZ_Wells := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

{ TGridOptions }

procedure TGridOptions.Assign(Source: TPersistent);
begin
  if Source is TGridOptions then
  begin
    with TGridOptions(Source) do
    begin
      self.ChemicalDimensionX := ChemicalDimensionX;
      self.ChemicalDimensionY := ChemicalDimensionY;
      self.ChemicalDimensionZ := ChemicalDimensionZ;
      self.PrintOrientation := PrintOrientation;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TGridOptions.Create;
begin
  ChemicalDimensionX := True;
  ChemicalDimensionY := True;
  ChemicalDimensionZ := True;
end;

procedure TGridOptions.SetChemicalDimensionX(const Value: boolean);
begin
  if FChemicalDimensionX <> Value then
  begin
    FChemicalDimensionX := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TGridOptions.SetChemicalDimensionY(const Value: boolean);
begin
  if FChemicalDimensionY <> Value then
  begin
    FChemicalDimensionY := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TGridOptions.SetChemicalDimensionZ(const Value: boolean);
begin
  if FChemicalDimensionZ <> Value then
  begin
    FChemicalDimensionZ := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TGridOptions.SetPrintOrientation(
  const Value: TpgPrintOrientation);
begin
  if FPrintOrientation <> Value then
  begin
    FPrintOrientation := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

{ TFluidProperties }

procedure TFluidProperties.Assign(Source: TPersistent);
begin
  if Source is TFluidProperties then
  begin
    with TFluidProperties(Source) do
    begin
      self.FluidCompressibility := FluidCompressibility;
      self.FluidDensity := FluidDensity;
      self.FluidDiffusivity := FluidDiffusivity;
      self.FluidViscosity := FluidViscosity;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TFluidProperties.Create(AOwner: TComponent);
begin
  inherited;
  Initialize;
end;

procedure TFluidProperties.Initialize;
begin
  FFluidCompressibility := 4.7E-10;
  FFluidDensity := 1000;
  FFluidDiffusivity := 1E-9;
  FFluidViscosity := 0.00115;
  FCompressibilitySet := False;
  FDensitySet := False;
  FDiffusivitySet := False;
  FViscositySet := False;
end;

procedure TFluidProperties.Loaded;
begin
  inherited;
  if not FCompressibilitySet then
  begin
    FFluidCompressibility := 0;
  end;
  if not FDensitySet then
  begin
    FFluidDensity := 0;
  end;
  if not FDiffusivitySet then
  begin
    FFluidDiffusivity := 0;
  end;
  if not FViscositySet then
  begin
    FFluidViscosity := 0;
  end;
end;

procedure TFluidProperties.SetFluidCompressibility(const Value: double);
begin
  if FFluidCompressibility <> Value then
  begin
    FFluidCompressibility := Value;
    frmGoPhast.InvalidateModel;
  end;
  FCompressibilitySet := True;
end;

procedure TFluidProperties.SetFluidDensity(const Value: Double);
begin
  if FFluidDensity <> Value then
  begin
    FFluidDensity := Value;
    frmGoPhast.InvalidateModel;
  end;
  FDensitySet := True;
end;

procedure TFluidProperties.SetFluidDiffusivity(const Value: double);
begin
  if FFluidDiffusivity <> Value then
  begin
    FFluidDiffusivity := Value;
    frmGoPhast.InvalidateModel;
  end;
  FDiffusivitySet := True;
end;

procedure TFluidProperties.SetFluidViscosity(const Value: double);
begin
  if FFluidViscosity <> Value then
  begin
    FFluidViscosity := Value;
    frmGoPhast.InvalidateModel;
  end;
  FViscositySet := True;
end;

{ TSolutionOptions }

procedure TSolutionOptions.Assign(Source: TPersistent);
begin
  if Source is TSolutionOptions then
  begin
    with TSolutionOptions(Source) do
    begin
      self.SolverType := SolverType;
      self.SpaceDifferencing := SpaceDifferencing;
      self.TimeDifferencing := TimeDifferencing;
      self.CrossDispersion := CrossDispersion;
      self.Tolerance := Tolerance;
      self.SaveDirections := SaveDirections;
      self.MaximumIterations := MaximumIterations;
      self.RebalanceByCell := RebalanceByCell;
      self.RebalanceFraction := RebalanceFraction;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TSolutionOptions.Create(AOwner: TComponent);
begin
  inherited;
  FRebalanceFraction := TRealStorage.Create;
  Initialize;
end;

destructor TSolutionOptions.Destroy;
begin
  FRebalanceFraction.Free;
  inherited;
end;

procedure TSolutionOptions.Initialize;
begin
  SolverType := psIterative;
  FSpaceDifferencing := 0;
  FTimeDifferencing := 1;
  FCrossDispersion := False;
  FTolerance := 1E-10;
  SaveDirections := 10;
  MaximumIterations := 500;
  FTimeDifferencingSet := False;
  FToleranceSet := False;
  RebalanceByCell := False;
  FRebalanceFraction.Value := 0.5;
end;

procedure TSolutionOptions.Loaded;
begin
  inherited;
  if not FTimeDifferencingSet then
  begin
    FTimeDifferencing := 0;
  end;
  if not FToleranceSet then
  begin
    FTolerance := 0;
  end;
end;

procedure TSolutionOptions.SetCrossDispersion(const Value: boolean);
begin
  if FCrossDispersion <> Value then
  begin
    FCrossDispersion := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetMaximumIterations(const Value: integer);
begin
  if FMaximumIterations <> Value then
  begin
    FMaximumIterations := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetRebalanceByCell(const Value: boolean);
begin
  if FRebalanceByCell <> Value then
  begin
    FRebalanceByCell := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetRebalanceFraction(const Value: TRealStorage);
begin
  if FRebalanceFraction.Value <> Value.Value then
  begin
    FRebalanceFraction.Assign(Value);
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetSaveDirections(const Value: integer);
begin
  if FSaveDirections <> Value then
  begin
    FSaveDirections := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetSolverType(const Value: TPhastSolver);
begin
  if FSolverType <> Value then
  begin
    FSolverType := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetSpaceDifferencing(const Value: double);
begin
  Assert((Value >= 0) and (Value <= 0.5));
  if FSpaceDifferencing <> Value then
  begin
    FSpaceDifferencing := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSolutionOptions.SetTimeDifferencing(const Value: double);
begin
  Assert((Value >= 0.5) and (Value <= 1));
  if FTimeDifferencing <> Value then
  begin
    FTimeDifferencing := Value;
    frmGoPhast.InvalidateModel;
  end;
  FTimeDifferencingSet := True;
end;

procedure TSolutionOptions.SetTolerance(const Value: double);
begin
  if FTolerance <> Value then
  begin
    FTolerance := Value;
    frmGoPhast.InvalidateModel;
  end;
  FToleranceSet := True;
end;

{ TSteadyFlowOptions }

procedure TSteadyFlowOptions.Assign(Source: TPersistent);
begin
  if Source is TSteadyFlowOptions then
  begin
    with TSteadyFlowOptions(Source) do
    begin
      self.SteadyFlow := SteadyFlow;
      self.HeadTolerance := HeadTolerance;
      self.FlowBalanceTolerance := FlowBalanceTolerance;
      self.MinimumTimeStep := MinimumTimeStep;
      self.MaximumTimeStep := MaximumTimeStep;
      self.HeadChangeLimit := HeadChangeLimit;
      self.UseDefaultMinimumTimeStep := UseDefaultMinimumTimeStep;
      self.UseDefaultMaximumTimeStep := UseDefaultMaximumTimeStep;
      self.UseDefaultHeadChangeLimit := UseDefaultHeadChangeLimit;
      self.Iterations := Iterations;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TSteadyFlowOptions.Create;
begin
  HeadTolerance := 1E-5;
  FlowBalanceTolerance := 0.001;
  MinimumTimeStep := 1;
  MaximumTimeStep := 1000;
  HeadChangeLimit := 1;
  FUseDefaultHeadChangeLimit := True;
  FUseDefaultMaximumTimeStep := True;
  FUseDefaultMinimumTimeStep := True;
  FIterations := 100;
end;

procedure TSteadyFlowOptions.SetFlowBalanceTolerance(const Value: double);
begin
  if FFlowBalanceTolerance <> Value then
  begin
    FFlowBalanceTolerance := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetHeadChangeLimit(const Value: double);
begin
  if FHeadChangeLimit <> Value then
  begin
    FHeadChangeLimit := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetHeadTolerance(const Value: double);
begin
  if FHeadTolerance <> Value then
  begin
    FHeadTolerance := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetIterations(const Value: integer);
begin
  if FIterations <> Value then
  begin
    FIterations := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetMaximumTimeStep(const Value: double);
begin
  if FMaximumTimeStep <> Value then
  begin
    FMaximumTimeStep := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetMinimumTimeStep(const Value: double);
begin
  if FMinimumTimeStep <> Value then
  begin
    FMinimumTimeStep := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetSteadyFlow(const Value: boolean);
begin
  if FSteadyFlow <> Value then
  begin
    FSteadyFlow := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetUseDefaultHeadChangeLimit(
  const Value: boolean);
begin
  if FUseDefaultHeadChangeLimit <> Value then
  begin
    FUseDefaultHeadChangeLimit := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetUseDefaultMaximumTimeStep(
  const Value: boolean);
begin
  if FUseDefaultMaximumTimeStep <> Value then
  begin
    FUseDefaultMaximumTimeStep := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TSteadyFlowOptions.SetUseDefaultMinimumTimeStep(
  const Value: boolean);
begin
  if FUseDefaultMinimumTimeStep <> Value then
  begin
    FUseDefaultMinimumTimeStep := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

{ TChemistryOptions }

procedure TChemistryOptions.Assign(Source: TPersistent);
begin
  if Source is TChemistryOptions then
  begin
    with TChemistryOptions(Source) do
    begin
      self.UseKineticReactants := UseKineticReactants;
      self.UseGasPhases := UseGasPhases;
      self.UseEquilibriumPhases := UseEquilibriumPhases;
      self.UseExchange := UseExchange;
      self.UseSolidSolution := UseSolidSolution;
      self.UseSurfaceAssemblages := UseSurfaceAssemblages;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TChemistryOptions.Create;
begin
  FUseSolidSolution := True;
  FUseKineticReactants := True;
  FUseGasPhases := True;
  FUseEquilibriumPhases := True;
  FUseExchange := True;
  FUseSurfaceAssemblages := True;
end;

procedure TChemistryOptions.SetUseEquilibriumPhases(const Value: boolean);
begin
  if FUseEquilibriumPhases <> Value then
  begin
    FUseEquilibriumPhases := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TChemistryOptions.SetUseExchange(const Value: boolean);
begin
  if FUseExchange <> Value then
  begin
    FUseExchange := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TChemistryOptions.SetUseGasPhases(const Value: boolean);
begin
  if FUseGasPhases <> Value then
  begin
    FUseGasPhases := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TChemistryOptions.SetUseKineticReactants(const Value: boolean);
begin
  if FUseKineticReactants <> Value then
  begin
    FUseKineticReactants := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TChemistryOptions.SetUseSolidSolution(const Value: boolean);
begin
  if FUseSolidSolution <> Value then
  begin
    FUseSolidSolution := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

procedure TChemistryOptions.SetUseSurfaceAssemblages(const Value: boolean);
begin
  if FUseSurfaceAssemblages <> Value then
  begin
    FUseSurfaceAssemblages := Value;
    frmGoPhast.InvalidateModel;
  end;
end;

{ TTimeListGroup }

function TTimeListGroup.Add(const TimeList: TPhastTimeList): integer;
begin
  result := FList.Add(TimeList);
end;

function TTimeListGroup.Count: integer;
begin
  result := FList.Count;
end;

constructor TTimeListGroup.Create;
begin
  FList := TList.Create;
end;

destructor TTimeListGroup.Destroy;
begin
  FList.Free;
  inherited;
end;

function TTimeListGroup.GetItems(const Index: integer): TPhastTimeList;
begin
  result := FList[Index];
end;

function TTimeListGroup.IndexOf(const TimeList: TPhastTimeList): integer;
begin
  result := FList.IndexOf(TimeList);
end;

procedure TTimeListGroup.SetItems(const Index: integer;
  const Value: TPhastTimeList);
begin
  FList[Index] := Value;
end;

procedure TTimeListGroup.SetName(const Value: string);
begin
  FName := Value;
end;

{ TProgramLocations }

procedure TProgramLocations.Assign(Source: TPersistent);
var
  SourceLocations: TProgramLocations;
begin
  if Source is TProgramLocations then
  begin
    SourceLocations := TProgramLocations(Source);
    ModflowLocation := SourceLocations.ModflowLocation;
    TextEditorLocation := SourceLocations.TextEditorLocation;
    ModPathLocation := SourceLocations.ModPathLocation;
    ModPathLocationVersion6 := SourceLocations.ModPathLocationVersion6;
    ModPathLocationVersion7 := SourceLocations.ModPathLocationVersion7;
    ModelMonitorLocation := SourceLocations.ModelMonitorLocation;
    PhastLocation := SourceLocations.PhastLocation;
    ZoneBudgetLocation := SourceLocations.ZoneBudgetLocation;
    ZoneBudgetLocationMf6 := SourceLocations.ZoneBudgetLocationMf6;
    ModelMateLocation := SourceLocations.ModelMateLocation;
    ModflowLgrLocation := SourceLocations.ModflowLgrLocation;
    ModflowLgr2Location := SourceLocations.ModflowLgr2Location;
    ModflowNwtLocation := SourceLocations.ModflowNwtLocation;
    Mt3dmsLocation := SourceLocations.Mt3dmsLocation;
    Mt3dUsgsLocation := SourceLocations.Mt3dUsgsLocation;
    Sutra22Location := SourceLocations.Sutra22Location;
    ModflowOwhmLocation := SourceLocations.ModflowOwhmLocation;
    ModflowCfpLocation := SourceLocations.ModflowCfpLocation;
    GmshLocation := SourceLocations.GmshLocation;
    GeompackLocation := SourceLocations.GeompackLocation;
    FootprintLocation := SourceLocations.FootprintLocation;
    Modflow6Location := SourceLocations.Modflow6Location;
    Sutra30Location := SourceLocations.Sutra30Location;
    Sutra40Location := SourceLocations.Sutra40Location;
    PestDirectory := SourceLocations.PestDirectory;
    ModflowOwhmV2Location := SourceLocations.ModflowOwhmV2Location;
  end
  else
  begin
    inherited;
  end;
end;

constructor TProgramLocations.Create;
var
  ADirectory: string;
begin
  FModflowLocation := StrModflowDefaultPath;
  FModPathLocation := StrMpathDefaultPath;
  FModPathLocationV6 := StrMpathDefaultPathVersion6;
  FModPathLocationV7 := StrMpathDefaultPathVersion7;
  PhastLocation := DefaultPhastPath;
  ZoneBudgetLocation := StrZoneBudgetDefaultPath;
  ZoneBudgetLocationMf6 := StrZoneBudgetMf6DefaultPath;
  ModflowLgrLocation := strModflowLgrDefaultPath;
  ModflowLgr2Location := strModflowLgr2DefaultPath;
  ModflowNwtLocation := strModflowNwtDefaultPath;
  Mt3dmsLocation := strMt3dmsDefaultPath;
  Mt3dUsgsLocation := strMt3dUsgsDefaultPath;
  Sutra22Location := KSutraDefaultPath;
  Sutra30Location := KSutra30DefaultPath;
  Sutra40Location := KSutra40DefaultPath;
  ModflowOwhmLocation := DefaultModflowOwhmPath;
  ModflowCfpLocation := strModflowCfpDefaultPath;
  GMshLocation := StrDefaultGmshPath;
  GeompackLocation := StrDefaultGeompackPath;
  Modflow6Location := StrDefaultModflow6Path;
  PestDirectory := StrPestDefaultDir;
  ModflowOwhmV2Location := StrDefaultOwhmV2Path;
  ADirectory := GetCurrentDir;
  try
    SetCurrentDir(ExtractFileDir(ParamStr(0)));
    FModelMonitorLocation :=
      ExpandFileName(StrModelMonitorDefaultPath);
  finally
    SetCurrentDir(ADirectory);
  end;
end;

procedure TProgramLocations.ReadFromIniFile(IniFile: TMemInifile);
var
  ADirectory: string;
  DefaultLocation: string;
  ModelVersion: string;
  function AlternatePath(FileName: string): string;
  var
    ADirectory: string;
  begin
    if Copy(FileName, 1, 3) = 'C:\' then
    begin
      ADirectory := GetCurrentDir;
      try
        SetCurrentDir(ExtractFileDir(ParamStr(0)));
        result :=
          ExpandFileName(Copy(FileName, 4, MAXINT));
      finally
        SetCurrentDir(ADirectory);
      end;
    end
    else
    begin
      result := FileName;
    end;
  end;
begin
  ModflowLocation := IniFile.ReadString(StrProgramLocations, StrMODFLOW2005,
    StrModflowDefaultPath);
  if (ModflowLocation = '') or not FileExists(ModflowLocation) then
  begin
    if FileExists(StrModflowDefaultPath) then
    begin
      ModflowLocation := StrModflowDefaultPath;
    end
    else if FileExists(AlternatePath(StrModflowDefaultPath)) then
    begin
      ModflowLocation := AlternatePath(StrModflowDefaultPath);
    end;
  end;

  TextEditorLocation := IniFile.ReadString(StrProgramLocations,
    StrTextEditor, '');

  ModPathLocation := IniFile.ReadString(StrProgramLocations, StrMODPATH,
    StrMpathDefaultPath);
  if (ModPathLocation = '') or not FileExists(ModPathLocation) then
  begin
    if FileExists(StrMpathDefaultPath) then
    begin
      ModPathLocation := StrMpathDefaultPath;
    end
    else if FileExists(AlternatePath(StrMpathDefaultPath)) then
    begin
      ModPathLocation := AlternatePath(StrMpathDefaultPath);
    end;
  end;

  ModPathLocationVersion6 := IniFile.ReadString(StrProgramLocations,
    StrMODPATHVersion6, StrMpathDefaultPathVersion6);
  if (ModPathLocationVersion6 = '') or not FileExists(ModPathLocationVersion6) then
  begin
    if FileExists(StrMpathDefaultPathVersion6) then
    begin
      ModPathLocationVersion6 := StrMpathDefaultPathVersion6;
    end
    else if FileExists(AlternatePath(StrMpathDefaultPathVersion6)) then
    begin
      ModPathLocationVersion6 := AlternatePath(StrMpathDefaultPathVersion6);
    end;
  end;

  ModPathLocationVersion7 := IniFile.ReadString(StrProgramLocations,
    StrMODPATHVersion7, StrMpathDefaultPathVersion7);
  if (ModPathLocationVersion7 = '') or not FileExists(ModPathLocationVersion7) then
  begin
    if FileExists(StrMpathDefaultPathVersion7) then
    begin
      ModPathLocationVersion7 := StrMpathDefaultPathVersion7;
    end
    else if FileExists(AlternatePath(StrMpathDefaultPathVersion7)) then
    begin
      ModPathLocationVersion7 := AlternatePath(StrMpathDefaultPathVersion7);
    end;
  end;

  PhastLocation := IniFile.ReadString(StrProgramLocations, StrPHAST,
    DefaultPhastPath);
  if (PhastLocation = '') or not FileExists(PhastLocation) then
  begin
    if FileExists(DefaultPhastPath) then
    begin
      PhastLocation := DefaultPhastPath;
    end
    else if FileExists(AlternatePath(DefaultPhastPath)) then
    begin
      PhastLocation := AlternatePath(DefaultPhastPath);
    end;
  end;

  ZoneBudgetLocation := IniFile.ReadString(StrProgramLocations, StrZonebudget,
    StrZoneBudgetDefaultPath);
  if (ZoneBudgetLocation = '') or not FileExists(ZoneBudgetLocation) then
  begin
    if FileExists(StrZoneBudgetDefaultPath) then
    begin
      ZoneBudgetLocation := StrZoneBudgetDefaultPath;
    end
    else if FileExists(AlternatePath(StrZoneBudgetDefaultPath)) then
    begin
      ZoneBudgetLocation := AlternatePath(StrZoneBudgetDefaultPath);
    end;
  end;

  ZoneBudgetLocationMf6 := IniFile.ReadString(StrProgramLocations, StrZonebudgetMf6,
    StrZoneBudgetMf6DefaultPath);
  if (ZoneBudgetLocationMf6 = '') or not FileExists(ZoneBudgetLocationMf6) then
  begin
    if FileExists(StrZoneBudgetMf6DefaultPath) then
    begin
      ZoneBudgetLocationMf6 := StrZoneBudgetMf6DefaultPath;
    end
    else if FileExists(AlternatePath(StrZoneBudgetMf6DefaultPath)) then
    begin
      ZoneBudgetLocationMf6 := AlternatePath(StrZoneBudgetMf6DefaultPath);
    end;
  end;

  ModelMateLocation := IniFile.ReadString(StrProgramLocations, StrModelMate,
    StrModelMateDefaultPath);
  if (ModelMateLocation = '') or not FileExists(ModelMateLocation) then
  begin
    if FileExists(StrModelMateDefaultPath) then
    begin
      ModelMateLocation := StrModelMateDefaultPath;
    end
    else if FileExists(AlternatePath(StrModelMateDefaultPath)) then
    begin
      ModelMateLocation := AlternatePath(StrModelMateDefaultPath);
    end;
  end;

  ModflowLgrLocation := IniFile.ReadString(StrProgramLocations, strModflowLgr,
    strModflowLgrDefaultPath);
  if (ModflowLgrLocation = '') or not FileExists(ModflowLgrLocation) then
  begin
    if FileExists(strModflowLgrDefaultPath) then
    begin
      ModflowLgrLocation := strModflowLgrDefaultPath;
    end
    else if FileExists(AlternatePath(strModflowLgrDefaultPath)) then
    begin
      ModflowLgrLocation := AlternatePath(strModflowLgrDefaultPath);
    end;
  end;

  ModflowLgr2Location := IniFile.ReadString(StrProgramLocations, strModflowLgr2,
    strModflowLgr2DefaultPath);
  if (ModflowLgr2Location = '') or not FileExists(ModflowLgr2Location) then
  begin
    if FileExists(strModflowLgr2DefaultPath) then
    begin
      ModflowLgr2Location := strModflowLgr2DefaultPath;
    end
    else if FileExists(AlternatePath(strModflowLgr2DefaultPath)) then
    begin
      ModflowLgr2Location := AlternatePath(strModflowLgr2DefaultPath);
    end;
  end;

  ModflowNwtLocation := IniFile.ReadString(StrProgramLocations, strModflowNWT,
    strModflowNwtDefaultPath);
  if (ModflowNwtLocation = '') or not FileExists(ModflowNwtLocation) then
  begin
    if FileExists(strModflowNwtDefaultPath) then
    begin
      ModflowNwtLocation := strModflowNwtDefaultPath;
    end
    else if FileExists(AlternatePath(strModflowNwtDefaultPath)) then
    begin
      ModflowNwtLocation := AlternatePath(strModflowNwtDefaultPath);
    end;
  end;

  ModflowOwhmLocation := IniFile.ReadString(StrProgramLocations, strModflowOWHM,
    DefaultModflowOwhmPath);
  if (ModflowOwhmLocation = '') or not FileExists(ModflowOwhmLocation) then
  begin
    if FileExists(DefaultModflowOwhmPath) then
    begin
      ModflowOwhmLocation := DefaultModflowOwhmPath;
    end
    else if FileExists(AlternatePath(DefaultModflowOwhmPath)) then
    begin
      ModflowOwhmLocation := AlternatePath(DefaultModflowOwhmPath);
    end;
  end;

  ModflowCfpLocation := IniFile.ReadString(StrProgramLocations, strModflowCFP,
    strModflowCfpDefaultPath);
  if (ModflowCfpLocation = '') or not FileExists(ModflowCfpLocation) then
  begin
    if FileExists(strModflowCfpDefaultPath) then
    begin
      ModflowCfpLocation := strModflowCfpDefaultPath;
    end
    else if FileExists(AlternatePath(strModflowCfpDefaultPath)) then
    begin
      ModflowCfpLocation := AlternatePath(strModflowCfpDefaultPath);
    end;
  end;

  Mt3dmsLocation := IniFile.ReadString(StrProgramLocations, StrMT3DMS,
    strMt3dmsDefaultPath);
  if (Mt3dmsLocation = '') or not FileExists(Mt3dmsLocation) then
  begin
    if FileExists(strMt3dmsDefaultPath) then
    begin
      Mt3dmsLocation := strMt3dmsDefaultPath;
    end
    else if FileExists(AlternatePath(strMt3dmsDefaultPath)) then
    begin
      Mt3dmsLocation := AlternatePath(strMt3dmsDefaultPath);
    end;
  end;

  Mt3dUsgsLocation := IniFile.ReadString(StrProgramLocations, StrMt3dUsgs,
    strMt3dUsgsDefaultPath);
  if (Mt3dUsgsLocation = '') or not FileExists(Mt3dUsgsLocation) then
  begin
    if FileExists(strMt3dUsgsDefaultPath) then
    begin
      Mt3dUsgsLocation := strMt3dUsgsDefaultPath;
    end
    else if FileExists(AlternatePath(strMt3dUsgsDefaultPath)) then
    begin
      Mt3dUsgsLocation := AlternatePath(strMt3dUsgsDefaultPath);
    end;
  end;

  Sutra22Location := IniFile.ReadString(StrProgramLocations, KSutra22,
    KSutraDefaultPath);
  if (Sutra22Location = '') or not FileExists(Sutra22Location) then
  begin
    if FileExists(KSutraDefaultPath) then
    begin
      Sutra22Location := KSutraDefaultPath;
    end
    else if FileExists(AlternatePath(KSutraDefaultPath)) then
    begin
      Sutra22Location := AlternatePath(KSutraDefaultPath);
    end;
  end;

  Sutra30Location := IniFile.ReadString(StrProgramLocations, KSutra30,
    KSutra30DefaultPath);
  if (Sutra30Location = '') or not FileExists(Sutra30Location) then
  begin
    if FileExists(KSutra30DefaultPath) then
    begin
      Sutra30Location := KSutra30DefaultPath;
    end
    else if FileExists(AlternatePath(KSutra30DefaultPath)) then
    begin
      Sutra30Location := AlternatePath(KSutra30DefaultPath);
    end;
  end;

  Sutra40Location := IniFile.ReadString(StrProgramLocations, KSutra40,
    KSutra40DefaultPath);
  if (Sutra40Location = '') or not FileExists(Sutra40Location) then
  begin
    if FileExists(KSutra40DefaultPath) then
    begin
      Sutra40Location := KSutra40DefaultPath;
    end
    else if FileExists(AlternatePath(KSutra40DefaultPath)) then
    begin
      Sutra40Location := AlternatePath(KSutra40DefaultPath);
    end;
  end;

  GmshLocation := IniFile.ReadString(StrProgramLocations, StrGmsh,
    StrDefaultGmshPath);
  if (GmshLocation = '') or not FileExists(GmshLocation) then
  begin
    if FileExists(StrDefaultGmshPath) then
    begin
      GmshLocation := StrDefaultGmshPath;
    end
    else if FileExists(AlternatePath(StrDefaultGmshPath)) then
    begin
      GmshLocation := AlternatePath(StrDefaultGmshPath);
    end;
  end;

  GeompackLocation := IniFile.ReadString(StrProgramLocations, StrGeompack,
    StrDefaultGeompackPath);
  if (GeompackLocation = '') or not FileExists(GeompackLocation) then
  begin
    if FileExists(StrDefaultGeompackPath) then
    begin
      GeompackLocation := StrDefaultGeompackPath;
    end
    else if FileExists(AlternatePath(StrDefaultGeompackPath)) then
    begin
      GeompackLocation := AlternatePath(StrDefaultGeompackPath);
    end;
  end;

  FootprintLocation := IniFile.ReadString(StrProgramLocations, StrFootprint,
    StrDefaultFootprintPath);
  if (FootprintLocation = '') or not FileExists(FootprintLocation) then
  begin
    if FileExists(StrDefaultFootprintPath) then
    begin
      FootprintLocation := StrDefaultFootprintPath;
    end
    else if FileExists(AlternatePath(StrDefaultFootprintPath)) then
    begin
      FootprintLocation := AlternatePath(StrDefaultFootprintPath);
    end;
  end;

  Modflow6Location := IniFile.ReadString(StrProgramLocations, StrModflow6,
    StrDefaultModflow6Path);
  if (Modflow6Location = '') or not FileExists(Modflow6Location) then
  begin
    if FileExists(StrDefaultModflow6Path) then
    begin
      Modflow6Location := StrDefaultModflow6Path;
    end
    else if FileExists(AlternatePath(StrDefaultModflow6Path)) then
    begin
      Modflow6Location := AlternatePath(StrDefaultModflow6Path);
    end;
  end;

  ModflowOwhmV2Location := IniFile.ReadString(StrProgramLocations, strModflowOWHM_V2,
    StrDefaultOwhmV2Path);
  if (ModflowOwhmV2Location = '') or not FileExists(ModflowOwhmV2Location) then
  begin
    if FileExists(StrDefaultOwhmV2Path) then
    begin
      ModflowOwhmV2Location := StrDefaultOwhmV2Path;
    end
    else if FileExists(AlternatePath(StrDefaultOwhmV2Path)) then
    begin
      ModflowOwhmV2Location := AlternatePath(StrDefaultOwhmV2Path);
    end;
  end;

  PestDirectory := IniFile.ReadString(StrProgramLocations, StrPestDir,
    StrPestDefaultDir);
  if (PestDirectory = '') or not DirectoryExists(PestDirectory) then
  begin
    if DirectoryExists(StrPestDefaultDir) then
    begin
      PestDirectory := StrPestDefaultDir;
    end
    else if FileExists(AlternatePath(StrPestDefaultDir)) then
    begin
      PestDirectory := AlternatePath(StrPestDefaultDir);
    end;
  end;


  ADirectory := GetCurrentDir;
  try
    SetCurrentDir(ExtractFileDir(ParamStr(0)));
    DefaultLocation :=
      ExpandFileName(StrModelMonitorDefaultPath);

    ModelVersion := IniFile.ReadString(StrVersion, StrModelMuseVersion, '');
    if FileExists(DefaultLocation) and (ModelVersion <> IModelVersion) then
    begin
      ModelMonitorLocation := DefaultLocation;
    end
    else
    begin
      ModelMonitorLocation := IniFile.ReadString(StrProgramLocations,
        StrModelMonitor, DefaultLocation);
    end;
  finally
    SetCurrentDir(ADirectory);
  end;
end;

function TProgramLocations.GetTextEditorLocation: string;
begin
  if FTextEditorLocation = '' then
  begin
    result := StrNotepadexe;
  end
  else
  begin
    result := FTextEditorLocation
  end;
end;

procedure TProgramLocations.SetFootprintLocation(const Value: string);
begin
  FFootprintLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetGeompackLocation(const Value: string);
begin
  FGeompackLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetGmshLocation(const Value: string);
begin
  FGmshLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModelMateLocation(const Value: string);
begin
  FModelMateLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModelMonitorLocation(const Value: string);
begin
  FModelMonitorLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflow6Location(const Value: string);
begin
  FModflow6Location := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowCfpLocation(const Value: string);
begin
  FModflowCfpLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowFmpLocation(const Value: string);
begin
  FModflowFmpLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowLgr2Location(const Value: string);
begin
  FModflowLgr2Location := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowLgrLocation(const Value: string);
begin
  FModflowLgrLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowLocation(const Value: string);
begin
  FModflowLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowNwtLocation(const Value: string);
begin
  FModflowNwtLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModflowOwhmV2Location(const Value: string);
begin
  FModflowOwhmV2Location := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModPathLocation(const Value: string);
begin
  FModPathLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModPathLocationV6(const Value: string);
begin
  FModPathLocationV6 := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetModPathLocationV7(const Value: string);
begin
  FModPathLocationV7 := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetMt3dmsLocation(const Value: string);
begin
  FMt3dmsLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetMt3dUsgsLocation(const Value: string);
begin
  FMt3dUsgsLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetPestDirectory(const Value: string);
begin
  FPestDirectory := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetPhastLocation(const Value: string);
begin
  FPhastLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetSutra22Location(const Value: string);
begin
  FSutra22Location := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetSutra30Location(const Value: string);
begin
  FSutra30Location := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetSutra40Location(const Value: string);
begin
  FSutra40Location := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetZoneBudgetLocation(const Value: string);
begin
  FZoneBudgetLocation := RemoveQuotes(Value);
end;

procedure TProgramLocations.SetZoneBudgetLocationMf6(const Value: string);
begin
  FZoneBudgetLocationMf6 := Value;
end;

procedure TProgramLocations.WriteToIniFile(IniFile: TMemInifile);
begin
  IniFile.WriteString(StrVersion, StrModelMuseVersion, IModelVersion);

  IniFile.WriteString(StrProgramLocations, StrMODFLOW2005, ModflowLocation);
  IniFile.WriteString(StrProgramLocations, StrTextEditor, TextEditorLocation);
  IniFile.WriteString(StrProgramLocations, StrMODPATH, ModPathLocation);
  IniFile.WriteString(StrProgramLocations, StrMODPATHVersion6, ModPathLocationVersion6);
  IniFile.WriteString(StrProgramLocations, StrMODPATHVersion7, ModPathLocationVersion7);
  IniFile.WriteString(StrProgramLocations, StrModelMonitor, ModelMonitorLocation);
  IniFile.WriteString(StrProgramLocations, StrPHAST, PhastLocation);
  IniFile.WriteString(StrProgramLocations, StrZonebudget, ZoneBudgetLocation);
  IniFile.WriteString(StrProgramLocations, StrZonebudgetMf6, ZoneBudgetLocationMf6);
  IniFile.WriteString(StrProgramLocations, StrModelMate, ModelMateLocation);
  IniFile.WriteString(StrProgramLocations, strModflowLgr, ModflowLgrLocation);
  IniFile.WriteString(StrProgramLocations, strModflowLgr2, ModflowLgr2Location);
  IniFile.WriteString(StrProgramLocations, strModflowNWT, ModflowNwtLocation);
  IniFile.WriteString(StrProgramLocations, StrMT3DMS, Mt3dmsLocation);
  IniFile.WriteString(StrProgramLocations, StrMt3dUsgs, Mt3dUsgsLocation);
  IniFile.WriteString(StrProgramLocations, KSutra22, Sutra22Location);
  IniFile.WriteString(StrProgramLocations, KSutra30, Sutra30Location);
  IniFile.WriteString(StrProgramLocations, KSutra40, Sutra40Location);
  IniFile.WriteString(StrProgramLocations, strModflowOWHM, ModflowOwhmLocation);
  IniFile.WriteString(StrProgramLocations, strModflowCFP, ModflowCfpLocation);
  IniFile.WriteString(StrProgramLocations, StrGmsh, GmshLocation);
  IniFile.WriteString(StrProgramLocations, StrGeompack, GeompackLocation);
  IniFile.WriteString(StrProgramLocations, StrFootprint, FootprintLocation);
  IniFile.WriteString(StrProgramLocations, StrModflow6, Modflow6Location);
  IniFile.WriteString(StrProgramLocations, StrPestDir, PestDirectory);
  IniFile.WriteString(StrProgramLocations, strModflowOWHM_V2, ModflowOwhmV2Location);
end;

{ TLookUpList }

constructor TLookUpList.Create;
begin
  inherited;
  FLastIndex := -1;
end;

constructor TCustomModel.Create(AnOwner: TComponent);
begin
  inherited;
  FInputObservations := TInputObservationObjectList.Create;
  FInputObservationDataSets := TStringList.Create;
  FInputObservationDataSets.Sorted := True;
  FInputObservationDataSets.Duplicates := dupIgnore;
  FInputObsInstructionFileNames := TStringList.Create;
  FInputObsInstructionFiles := TStringList.Create;

  FCanDrawContours := True;
  FSutraPestScripts := TStringList.Create;
  FPestTemplateLines := TStringList.Create;
  FPestTemplateLines.Sorted := True;
  FPestTemplateLines.Duplicates := dupIgnore;
  FKrigfactorsScriptLines := TStringList.Create;

  FBinaryFiles := TStringList.Create;
  FBinaryFiles.Duplicates := dupIgnore;
  FBinaryFiles.Sorted := True;

  FModpathOutputFiles := TStringList.Create;
  TStringList(FModpathOutputFiles).Duplicates := dupIgnore;
  TStringList(FModpathOutputFiles).Sorted := True;

  FModpathInputFiles := TStringList.Create;
  TStringList(FModpathInputFiles).Duplicates := dupIgnore;
  TStringList(FModpathInputFiles).Sorted := True;

  FZoneBudgetOutputFiles := TStringList.Create;
  TStringList(FZoneBudgetOutputFiles).Duplicates := dupIgnore;
  TStringList(FZoneBudgetOutputFiles).Sorted := True;

  FZoneBudgetInputFiles := TStringList.Create;
  TStringList(FZoneBudgetInputFiles).Duplicates := dupIgnore;
  TStringList(FZoneBudgetInputFiles).Sorted := True;

  FMt3dmsInputFiles := TStringList.Create;
  TStringList(FMt3dmsInputFiles).Duplicates := dupIgnore;
  TStringList(FMt3dmsInputFiles).Sorted := True;

  FExternalFiles := TStringList.Create;
  TStringList(FExternalFiles).Duplicates := dupIgnore;
  TStringList(FExternalFiles).Sorted := True;

  FMt3dmsOutputFiles := TStringList.Create;
  TStringList(FMt3dmsOutputFiles).Duplicates := dupIgnore;
  TStringList(FMt3dmsOutputFiles).Sorted := True;

  FModelOutputFiles := TStringList.Create;
  TStringList(FModelOutputFiles).Duplicates := dupIgnore;
  TStringList(FModelOutputFiles).Sorted := True;

  FSwiObsExtractorInputFiles := TStringList.Create;
  TStringList(FSwiObsExtractorInputFiles).Duplicates := dupIgnore;
  TStringList(FSwiObsExtractorInputFiles).Sorted := True;

  FSwiObsExtractorOutputFiles := TStringList.Create;
  TStringList(FSwiObsExtractorOutputFiles).Duplicates := dupIgnore;
  TStringList(FSwiObsExtractorOutputFiles).Sorted := True;

  FUnitNumbers := TUnitNumbers.Create(self);
  FCrossSection := TCrossSection.Create(self);
  FCrossSection.OnUpToDateSet := CrossSectionChanged;
  FGages := TStringList.Create;
  FHfbDisplayer:= THfbDisplayer.Create(self);
  FHfbDisplayer.OnNeedToUpdate := UpdateHfb;

  FModflowOptions := TModflowOptions.Create(DoInvalidate);
  FPValFile := TStringList.Create;
  FPvalTemplate := TStringList.Create;
  FPestPValFile := TStringList.Create;
  FPestPvalTemplate := TStringList.Create;
  FTimeLists := TList.Create;
  FTransientZoneArrays := TObjectList.Create;
  FTransientMultiplierArrays := TObjectList.Create;
  FDataArrayManager:= TDataArrayManager.Create(self);
  FParsers := TList.Create;
  FrpTopFormulaCompiler := TRbwParser.Create(self);
  FParsers.Add(FrpTopFormulaCompiler);
  FrpFrontFormulaCompiler := TRbwParser.Create(self);
  FParsers.Add(FrpFrontFormulaCompiler);
  FrpSideFormulaCompiler := TRbwParser.Create(self);
  FParsers.Add(FrpSideFormulaCompiler);
  FrpThreeDFormulaCompiler := TRbwParser.Create(self);
  FParsers.Add(FrpThreeDFormulaCompiler);
  FrpTopFormulaCompilerNodes := TRbwParser.Create(self);
  FParsers.Add(FrpTopFormulaCompilerNodes);
  FrpFrontFormulaCompilerNodes := TRbwParser.Create(self);
  FParsers.Add(FrpFrontFormulaCompilerNodes);
  FrpSideFormulaCompilerNodes := TRbwParser.Create(self);
  FParsers.Add(FrpSideFormulaCompilerNodes);
  FrpThreeDFormulaCompilerNodes := TRbwParser.Create(self);
  FParsers.Add(FrpThreeDFormulaCompilerNodes);

  FModflowNameFileLines := TStringList.Create;
  FBatchFileAdditionsBeforeModel := TStringList.Create;
  FBatchFileAdditionsAfterModel := TStringList.Create;
  FModflowPackages := TModflowPackages.Create(self);
  FModflowPackages.LpfPackage.IsSelected := True;
  FModflowGrid := TModflowGrid.Create(self);

  FHeadFluxObservations := TFluxObservationGroups.Create(self);
  FRiverObservations := TFluxObservationGroups.Create(self);
  FDrainObservations := TFluxObservationGroups.Create(self);
  FGhbObservations := TFluxObservationGroups.Create(self);
  FStrObservations := TFluxObservationGroups.Create(self);

  FHeadFluxObservations.FluxObservationType := fotHead;
  FRiverObservations.FluxObservationType := fotRiver;
  FDrainObservations.FluxObservationType := fotDrain;
  FGhbObservations.FluxObservationType := fotGHB;
  FStrObservations.FluxObservationType := fotSTR;

  FMt3dmsHeadMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsHeadMassFluxObservations.FluxObservationType := mfotHead;

  FMt3dmsWellMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsWellMassFluxObservations.FluxObservationType := mfotWell;

  FMt3dmsMassLoadingMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsMassLoadingMassFluxObservations.FluxObservationType := mfotMassLoading;

  FMt3dmsGhbMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsGhbMassFluxObservations.FluxObservationType := mfotGHB;

  FMt3dmsRivMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsRivMassFluxObservations.FluxObservationType := mfotRiver;

  FMt3dmsResMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsResMassFluxObservations.FluxObservationType := mfotReservoir;

  FMt3dmsRchMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsRchMassFluxObservations.FluxObservationType := mfotRecharge;

  FMt3dmsDrtMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsDrtMassFluxObservations.FluxObservationType := mfotDRT;

  FMt3dmsEtsMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsEtsMassFluxObservations.FluxObservationType := mfotETS;

  FMt3dmsEvtMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsEvtMassFluxObservations.FluxObservationType := mfotEVT;

  FMt3dmsDrnMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsDrnMassFluxObservations.FluxObservationType := mfotDrain;

  FMt3dmsLakMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsLakMassFluxObservations.FluxObservationType := mfotLake;

  FMt3dmsStrMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsStrMassFluxObservations.FluxObservationType := mfotSTR;

  FMt3dmsFhbHeadMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsFhbHeadMassFluxObservations.FluxObservationType := mfotFHB_Head;

  FMt3dmsFhbFlowMassFluxObservations := TMt3dmsFluxObservationGroups.Create(self);
  FMt3dmsFhbFlowMassFluxObservations.FluxObservationType := mfotFHB_Flow;

  FSutraFluxObs := TSutraFluxObs.Create(self);

  FHydrogeologicUnits := THydrogeologicUnits.Create(self);
  FFilesToArchive := TStringList.Create;
  TStringList(FFilesToArchive).Duplicates := dupIgnore;
  TStringList(FFilesToArchive).Sorted := True;
  FModelInputFiles := TStringList.Create;
  TStringList(FModelInputFiles).Duplicates := dupIgnore;
  TStringList(FModelInputFiles).Sorted := True;
  FModflowWettingOptions := TWettingOptions.Create(DoInvalidate);

  FTopGridObserver:= TObserver.Create(nil);
  FThreeDGridObserver:= TObserver.Create(nil);
  FTopGridObserver.Name := 'TopGridObserver';
  FThreeDGridObserver.Name := 'ThreeDGridObserver';
  FThreeDGridObserver.OnUpToDateSet := DiscretizationChangedEvent;

  FTopGridObserver.TalksTo(FThreeDGridObserver);

  FHufKxNotifier := TObserver.Create(nil);
  FHufKxNotifier.Name := 'HufKxNotifier';
  FHufKyNotifier := TObserver.Create(nil);
  FHufKyNotifier.Name := 'HufKyNotifier';
  FHufKzNotifier := TObserver.Create(nil);
  FHufKzNotifier.Name := 'HufKzNotifier';
  FHufSsNotifier := TObserver.Create(nil);
  FHufSsNotifier.Name := 'HufSsNotifier';
  FHufSyNotifier := TObserver.Create(nil);
  FHufSyNotifier.Name := 'HufSyNotifier';

  FSutraOptions := TSutraOptions.Create(self);
  FSutraOutputControl := TSutraOutputControl.Create(DoInvalidate);

  FSwrTabFiles := TTabFileCollection.Create(self);
  FSwrReachGeometry := TReachGeometryCollection.Create(self);
  FSwrStructures := TStructureCollection.Create(self);
  FSwrObservations := TSwrObsCollection.Create(DoInvalidate);

  FDataArrayManager.DefinePackageDataArrays;
  CreateModflowDisplayTimeLists;

  FSutraSpecPressureTimeList := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute: FSutraSpecPressureTimeList.Name := StrSpecifiedPressure;
    tcSoluteHead: FSutraSpecPressureTimeList.Name := StrSutraSpecifiedHead;
    tcEnergy, tcFreezing: FSutraSpecPressureTimeList.Name := StrSpecifiedPressure;
    else Assert(False);
  end;
  FSutraSpecPressureTimeList.OnTimeListUsed := DoSutraUsed;
  FSutraSpecPressureTimeList.OnInitialize := InitializeSutraSpecPres;
  AddTimeList(FSutraSpecPressureTimeList);

  FSutraSpecPresUTimeList := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute: FSutraSpecPresUTimeList.Name := StrAssocPresConc;
    tcSoluteHead: FSutraSpecPresUTimeList.Name := StrAssocHeadConc;
    tcEnergy, tcFreezing: FSutraSpecPresUTimeList.Name := StrAssocPresTemp;
    else Assert(False);
  end;
  FSutraSpecPresUTimeList.OnTimeListUsed := DoSutraUsed;
  FSutraSpecPresUTimeList.OnInitialize := InitializeSutraSpecPres;
  AddTimeList(FSutraSpecPresUTimeList);

  FSutraConcTempTimeList := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraConcTempTimeList.Name := StrSpecifiedConc;
    tcEnergy, tcFreezing: FSutraConcTempTimeList.Name := StrSpecifiedTemp;
    else Assert(False);
  end;
  FSutraConcTempTimeList.OnTimeListUsed := DoSutraUsed;
  FSutraConcTempTimeList.OnInitialize := InitializeSutraSpecifiedConcTemp;
  AddTimeList(FSutraConcTempTimeList);


  FSutraFluidFluxTimeList := TSutraMergedTimeList.Create(self);
  FSutraFluidFluxTimeList.Name := StrFluidFlux;
  FSutraFluidFluxTimeList.OnTimeListUsed := DoSutraUsed;
  FSutraFluidFluxTimeList.OnInitialize := InitializeSutraFluidFlux;
  AddTimeList(FSutraFluidFluxTimeList);

  FSutraFluidFluxUTimeList := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraFluidFluxUTimeList.Name := StrFluxAssocPresConc;
    tcEnergy, tcFreezing: FSutraFluidFluxUTimeList.Name := StrFluxAssocPresTemp;
    else Assert(False);
  end;
  FSutraFluidFluxUTimeList.OnTimeListUsed := DoSutraUsed;
  FSutraFluidFluxUTimeList.OnInitialize := InitializeSutraFluidFlux;
  AddTimeList(FSutraFluidFluxUTimeList);

  FSutraMassEnergyFluxTimeList := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraMassEnergyFluxTimeList.Name := StrMassFlux;
    tcEnergy, tcFreezing: FSutraMassEnergyFluxTimeList.Name := StrEnergyFlux;
    else Assert(False);
  end;
  FSutraMassEnergyFluxTimeList.OnTimeListUsed := DoSutraUsed;
  FSutraMassEnergyFluxTimeList.OnInitialize := InitializeSutraMassEnergyFlux;
  AddTimeList(FSutraMassEnergyFluxTimeList);

  FSutraGenFlowPress1 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenFlowPress1.Name := StrLowerPressureValue;
    tcEnergy, tcFreezing: FSutraGenFlowPress1.Name := StrLowerHeadValue;
    else Assert(False);
  end;
  FSutraGenFlowPress1.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenFlowPress1.OnInitialize := InitializeSutraGeneralFlow;
  AddTimeList(FSutraGenFlowPress1);

  FSutraGenFlowPress2 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenFlowPress2.Name := StrHigherPressureValue;
    tcEnergy, tcFreezing: FSutraGenFlowPress2.Name := StrHigherHeadValue;
    else Assert(False);
  end;
  FSutraGenFlowPress2.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenFlowPress2.OnInitialize := InitializeSutraGeneralFlow;
  AddTimeList(FSutraGenFlowPress2);

  FSutraGenFlowRate1 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenFlowRate1.Name := StrLowerRateP;
    tcEnergy, tcFreezing: FSutraGenFlowRate1.Name := StrLowerRateH;
    else Assert(False);
  end;
  FSutraGenFlowRate1.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenFlowRate1.OnInitialize := InitializeSutraGeneralFlow;
  AddTimeList(FSutraGenFlowRate1);

  FSutraGenFlowRate2 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenFlowRate2.Name := StrHigherRateP;
    tcEnergy, tcFreezing: FSutraGenFlowRate2.Name := StrHigherRateH;
    else Assert(False);
  end;
  FSutraGenFlowRate2.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenFlowRate2.OnInitialize := InitializeSutraGeneralFlow;
  AddTimeList(FSutraGenFlowRate2);

  FSutraGenFlowU1 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute: FSutraGenFlowU1.Name := StrLowerConcentrationP;
    tcSoluteHead: FSutraGenFlowU1.Name := StrLowerConcentrationH;
    tcEnergy, tcFreezing: FSutraGenFlowU1.Name := StrLowerTemperature;
    else Assert(False);
  end;
  FSutraGenFlowU1.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenFlowU1.OnInitialize := InitializeSutraGeneralFlow;
  AddTimeList(FSutraGenFlowU1);

  FSutraGenFlowU2 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute: FSutraGenFlowU2.Name := StrHigherConcentrationP;
    tcSoluteHead: FSutraGenFlowU2.Name := StrHigherConcentrationH;
    tcEnergy, tcFreezing: FSutraGenFlowU2.Name := StrHigherTemperature;
    else Assert(False);
  end;
  FSutraGenFlowU2.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenFlowU2.OnInitialize := InitializeSutraGeneralFlow;
  AddTimeList(FSutraGenFlowU2);

  FSutraGenTranU1 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenTranU1.Name := StrLowerConcentrationValue;
    tcEnergy, tcFreezing: FSutraGenTranU1.Name := StrLowerTemperatureValue;
    else Assert(False);
  end;
  FSutraGenTranU1.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenTranU1.OnInitialize := InitializeSutraGeneralTransport;
  AddTimeList(FSutraGenTranU1);

  FSutraGenTranU2 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenTranU2.Name := StrHigherConcentrationValue;
    tcEnergy, tcFreezing: FSutraGenTranU2.Name := StrHigherTemperatureValue;
    else Assert(False);
  end;
  FSutraGenTranU2.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenTranU2.OnInitialize := InitializeSutraGeneralTransport;
  AddTimeList(FSutraGenTranU2);

  FSutraGenTranQU1 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenTranQU1.Name := StrMassFlowAtLowerConcentration;
    tcEnergy, tcFreezing: FSutraGenTranQU1.Name := StrEnergyFlowAtLowerTemperature;
    else Assert(False);
  end;
  FSutraGenTranQU1.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenTranQU1.OnInitialize := InitializeSutraGeneralTransport;
  AddTimeList(FSutraGenTranQU1);

  FSutraGenTranQU2 := TSutraMergedTimeList.Create(self);
  case SutraOptions.TransportChoice of
    tcSolute, tcSoluteHead: FSutraGenTranQU2.Name := StrMassFlowAtHigherConcentration;
    tcEnergy, tcFreezing: FSutraGenTranQU2.Name := StrEnergyFlowAtHigherTemperature;
    else Assert(False);
  end;
  FSutraGenTranQU2.OnTimeListUsed := Sutra30OrAboveUsed;
  FSutraGenTranQU2.OnInitialize := InitializeSutraGeneralTransport;
  AddTimeList(FSutraGenTranQU2);

  FFootPrintGrid := TFootprintGrid.Create(self);

  FDisvGrid := TModflowDisvGrid.Create(self);
  FModflowGlobalObservationComparisons := TGlobalObservationComparisons.Create(DoInvalidate);
  FSutraGlobalObservationComparisons := TGlobalObservationComparisons.Create(DoInvalidate);
  FModflow6GlobalObservationComparisons := TGlobalObservationComparisons.Create(DoInvalidate);

  FVelocityVectors := TVectorCollection.Create(self);

  FPilotPointDataArrays := TDataArrayList.Create;
  FPilotPointData := TStoredPilotParamDataCollection.Create;

  FPestObsCollection := TPestObsCollection.Create(self);
//  FPestBoundaryDataArrays := TDictionary<string, TDataArray>.Create;

  FMt3dObsCollection := TMt3dObsCollection.Create(self);

  //  @name is implemented as a @link(TMf6GwtNameWriters).
  FMf6GwtNameWriters := TMf6GwtNameWriters.Create;

end;

procedure TCustomModel.UpdateSutraTimeListNames;
begin
  case SutraOptions.TransportChoice of
    tcSolute:
      begin
        FSutraSpecPressureTimeList.Name := StrSpecifiedPressure;
        FSutraConcTempTimeList.Name := StrSpecifiedConc;
        FSutraSpecPresUTimeList.Name := StrAssocPresConc;
        FSutraFluidFluxUTimeList.Name := StrFluxAssocPresConc;
        FSutraMassEnergyFluxTimeList.Name := StrMassFlux;
        FSutraGenFlowPress1.Name := StrLowerPressureValue;
        FSutraGenFlowPress2.Name := StrHigherPressureValue;
        FSutraGenFlowRate1.Name := StrLowerRateP;
        FSutraGenFlowRate2.Name := StrHigherRateP;
        FSutraGenFlowU1.Name := StrLowerConcentrationP;
        FSutraGenFlowU2.Name := StrHigherConcentrationP;
        FSutraGenTranU1.Name := StrLowerConcentrationValue;
        FSutraGenTranU2.Name := StrHigherConcentrationValue;
        FSutraGenTranQU1.Name := StrMassFlowAtLowerConcentration;
        FSutraGenTranQU2.Name := StrMassFlowAtHigherConcentration;
      end;
    tcSoluteHead:
      begin
        FSutraSpecPressureTimeList.Name := StrSutraSpecifiedHead;
        FSutraConcTempTimeList.Name := StrSpecifiedConc;
        FSutraSpecPresUTimeList.Name := StrAssocHeadConc;
        FSutraFluidFluxUTimeList.Name := StrFluxAssocPresConc;
        FSutraMassEnergyFluxTimeList.Name := StrMassFlux;
        FSutraGenFlowPress1.Name := StrLowerHeadValue;
        FSutraGenFlowPress2.Name := StrHigherHeadValue;
        FSutraGenFlowRate1.Name := StrLowerRateH;
        FSutraGenFlowRate2.Name := StrHigherRateH;
        FSutraGenFlowU1.Name := StrLowerConcentrationH;
        FSutraGenFlowU2.Name := StrHigherConcentrationH;
        FSutraGenTranU1.Name := StrLowerConcentrationValue;
        FSutraGenTranU2.Name := StrHigherConcentrationValue;
        FSutraGenTranQU1.Name := StrMassFlowAtLowerConcentration;
        FSutraGenTranQU2.Name := StrMassFlowAtHigherConcentration;
      end;
    tcEnergy, tcFreezing:
      begin
        FSutraSpecPressureTimeList.Name := StrSpecifiedPressure;
        FSutraConcTempTimeList.Name := StrSpecifiedTemp;
        FSutraSpecPresUTimeList.Name := StrAssocPresTemp;
        FSutraFluidFluxUTimeList.Name := StrFluxAssocPresTemp;
        FSutraMassEnergyFluxTimeList.Name := StrEnergyFlux;
        FSutraGenFlowPress1.Name := StrLowerPressureValue;
        FSutraGenFlowPress2.Name := StrHigherPressureValue;
        FSutraGenFlowRate1.Name := StrLowerRateP;
        FSutraGenFlowRate2.Name := StrHigherRateP;
        FSutraGenFlowU1.Name := StrLowerTemperature;
        FSutraGenFlowU2.Name := StrHigherTemperature;
        FSutraGenTranU1.Name := StrLowerTemperatureValue;
        FSutraGenTranU2.Name := StrHigherTemperatureValue;
        FSutraGenTranQU1.Name := StrEnergyFlowAtLowerTemperature;
        FSutraGenTranQU2.Name := StrEnergyFlowAtHigherTemperature;
      end
    else Assert(False);
  end;
end;

procedure TCustomModel.InitializeSutraMassEnergyFlux(Sender: TObject);
var
  BoundaryWriter: TSutraBoundaryWriter;
  Dummy: TSutraMergedTimeList;
begin
  Dummy := TSutraMergedTimeList.Create(self);
  BoundaryWriter := TSutraBoundaryWriter.Create(Self, etDisplay, sbtMassEnergySource);
  try
    BoundaryWriter.UpdateMergeLists(Dummy,
      FSutraMassEnergyFluxTimeList);
  finally
    BoundaryWriter.Free;
    Dummy.Free;
  end;
end;


procedure TCustomModel.InitializeSutraSpecifiedConcTemp(Sender: TObject);
var
  BoundaryWriter: TSutraBoundaryWriter;
  Dummy: TSutraMergedTimeList;
begin
  Dummy := TSutraMergedTimeList.Create(self);
  BoundaryWriter := TSutraBoundaryWriter.Create(Self, etDisplay, sbtSpecConcTemp);
  try
    BoundaryWriter.UpdateMergeLists(Dummy,
      FSutraConcTempTimeList);
  finally
    BoundaryWriter.Free;
    Dummy.Free;
  end;
end;

procedure TCustomModel.InitializeSutraFluidFlux(Sender: TObject);
var
  BoundaryWriter: TSutraBoundaryWriter;
begin
  BoundaryWriter := TSutraBoundaryWriter.Create(Self, etDisplay, sbtFluidSource);
  try
    BoundaryWriter.UpdateMergeLists(FSutraFluidFluxTimeList,
      FSutraFluidFluxUTimeList);
  finally
    BoundaryWriter.Free;
  end;
end;

procedure TCustomModel.InitializeSutraGeneralFlow(Sender: TObject);
var
  GenFlowWriter: TSutraGeneralFlowWriter;
  FlowList: TList<IGeneralFlowNodes>;
  DataArrayP1: TSutraBoundaryDisplayDataArray;
  DataArrayP2: TSutraBoundaryDisplayDataArray;
  DataArrayFlow1: TSutraBoundaryDisplayDataArray;
  DataArrayFlow2: TSutraBoundaryDisplayDataArray;
  DataArrayU1: TSutraBoundaryDisplayDataArray;
  DataArrayU2: TSutraBoundaryDisplayDataArray;
  NodeIndex: Integer;
  FlowNodes: TArray<TGeneralFlowNode>;
  ANode: TGeneralFlowNode;
begin
  GenFlowWriter := TSutraGeneralFlowWriter.Create(Self, etDisplay);
  try
    FlowList := TList<IGeneralFlowNodes>.Create;
    try
      GenFlowWriter.UpdateDisplay(FlowList);

      Assert(FlowList.Count in [0,1]);

      FSutraGenFlowPress1.Clear;
      DataArrayP1 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayP1.DataType := rdtDouble;
      DataArrayP1.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayP1.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayP1.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayP1.AddMethod := vamAveragedDelayed;
      FSutraGenFlowPress1.Add(ThreeDDisplayTime, DataArrayP1,
        TBooleanSparseDataSet.Create(self));

      FSutraGenFlowPress2.Clear;
      DataArrayP2 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayP2.DataType := rdtDouble;
      DataArrayP2.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayP2.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayP2.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayP2.AddMethod := vamAveragedDelayed;
      FSutraGenFlowPress2.Add(ThreeDDisplayTime, DataArrayP2,
        TBooleanSparseDataSet.Create(self));

      FSutraGenFlowRate1.Clear;
      DataArrayFlow1 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayFlow1.DataType := rdtDouble;
      DataArrayFlow1.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayFlow1.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayFlow1.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayFlow1.AddMethod := vamAveragedDelayed;
      FSutraGenFlowRate1.Add(ThreeDDisplayTime, DataArrayFlow1,
        TBooleanSparseDataSet.Create(self));

      FSutraGenFlowRate2.Clear;
      DataArrayFlow2 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayFlow2.DataType := rdtDouble;
      DataArrayFlow2.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayFlow2.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayFlow2.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayFlow2.AddMethod := vamAveragedDelayed;
      FSutraGenFlowRate2.Add(ThreeDDisplayTime, DataArrayFlow2,
        TBooleanSparseDataSet.Create(self));

      FSutraGenFlowU1.Clear;
      DataArrayU1 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayU1.DataType := rdtDouble;
      DataArrayU1.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayU1.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayU1.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayU1.AddMethod := vamAveragedDelayed;
      FSutraGenFlowU1.Add(ThreeDDisplayTime, DataArrayU1,
        TBooleanSparseDataSet.Create(self));

      FSutraGenFlowU2.Clear;
      DataArrayU2 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayU2.DataType := rdtDouble;
      DataArrayU2.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayU2.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayU2.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayU2.AddMethod := vamAveragedDelayed;
      FSutraGenFlowU2.Add(ThreeDDisplayTime, DataArrayU2,
        TBooleanSparseDataSet.Create(self));

      if FlowList.Count > 0 then
      begin
        FlowNodes := FlowList[0].ToArray;
        for NodeIndex := 0 to Length(FlowNodes) - 1 do
        begin
          ANode := FlowNodes[NodeIndex];
          if ANode.Active then
          begin
            DataArrayP1.AddDataValue(ANode.P1.Annotation, ANode.P1.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayP2.AddDataValue(ANode.P2.Annotation, ANode.P2.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayFlow1.AddDataValue(ANode.Q1.Annotation, ANode.Q1.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayFlow2.AddDataValue(ANode.Q2.Annotation, ANode.Q2.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayU1.AddDataValue(ANode.U1.Annotation, ANode.U1.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayU2.AddDataValue(ANode.U2.Annotation, ANode.U2.Value,
              ANode.FCol, 0, ANode.FLayer);
          end;
        end;
      end;

      DataArrayP1.ComputeAverage;
      DataArrayP1.UpToDate := True;
      FSutraGenFlowPress1.UpToDate := True;

      DataArrayP2.ComputeAverage;
      DataArrayP2.UpToDate := True;
      FSutraGenFlowPress2.UpToDate := True;

      DataArrayFlow1.ComputeAverage;
      DataArrayFlow1.UpToDate := True;
      FSutraGenFlowRate1.UpToDate := True;

      DataArrayFlow2.ComputeAverage;
      DataArrayFlow2.UpToDate := True;
      FSutraGenFlowRate2.UpToDate := True;

      DataArrayU1.ComputeAverage;
      DataArrayU1.UpToDate := True;
      FSutraGenFlowU1.UpToDate := True;

      DataArrayU2.ComputeAverage;
      DataArrayU2.UpToDate := True;
      FSutraGenFlowU2.UpToDate := True;
    finally
      FlowList.Free;
    end;
  finally
    GenFlowWriter.Free;
  end;
end;

procedure TCustomModel.InitializeSutraGeneralTransport(Sender: TObject);
var
  GenTransportWriter: TSutraGeneralTransportWriter;
  FlowList: TList<IGeneralTransportNodes>;
  DataArrayTranU1: TSutraBoundaryDisplayDataArray;
  DataArrayTranU2: TSutraBoundaryDisplayDataArray;
  DataArrayTranQU1: TSutraBoundaryDisplayDataArray;
  DataArrayTranQU2: TSutraBoundaryDisplayDataArray;
//  DataArrayU1: TSutraBoundaryDisplayDataArray;
//  DataArrayU2: TSutraBoundaryDisplayDataArray;
  NodeIndex: Integer;
  FlowNodes: TArray<TGeneralTransportNode>;
  ANode: TGeneralTransportNode;
begin
  GenTransportWriter := TSutraGeneralTransportWriter.Create(Self, etDisplay);
  try
    FlowList := TList<IGeneralTransportNodes>.Create;
    try
      GenTransportWriter.UpdateDisplay(FlowList);

      Assert(FlowList.Count in [0, 1]);

      FSutraGenTranU1.Clear;
      DataArrayTranU1 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayTranU1.DataType := rdtDouble;
      DataArrayTranU1.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayTranU1.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayTranU1.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayTranU1.AddMethod := vamAveragedDelayed;
      FSutraGenTranU1.Add(ThreeDDisplayTime, DataArrayTranU1,
        TBooleanSparseDataSet.Create(self));

      FSutraGenTranU2.Clear;
      DataArrayTranU2 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayTranU2.DataType := rdtDouble;
      DataArrayTranU2.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayTranU2.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayTranU2.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayTranU2.AddMethod := vamAveragedDelayed;
      FSutraGenTranU2.Add(ThreeDDisplayTime, DataArrayTranU2,
        TBooleanSparseDataSet.Create(self));

      FSutraGenTranQU1.Clear;
      DataArrayTranQU1 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayTranQU1.DataType := rdtDouble;
      DataArrayTranQU1.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayTranQU1.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayTranQU1.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayTranQU1.AddMethod := vamAveragedDelayed;
      FSutraGenTranQU1.Add(ThreeDDisplayTime, DataArrayTranQU1,
        TBooleanSparseDataSet.Create(self));

      FSutraGenTranQU2.Clear;
      DataArrayTranQU2 := TSutraBoundaryDisplayDataArray.Create(self);
      DataArrayTranQU2.DataType := rdtDouble;
      DataArrayTranQU2.Orientation := dso3D;
      if SutraMesh.MeshType = mt3D then
      begin
        DataArrayTranQU2.UpdateDimensions(SutraMesh.LayerCount+1, 1,
          SutraMesh.Mesh2D.Nodes.Count);
      end
      else
      begin
        DataArrayTranQU2.UpdateDimensions(1, 1, SutraMesh.Mesh2D.Nodes.Count);
      end;
      DataArrayTranQU2.AddMethod := vamAveragedDelayed;
      FSutraGenTranQU2.Add(ThreeDDisplayTime, DataArrayTranQU2,
        TBooleanSparseDataSet.Create(self));

//      FSutraGenFlowU1.Clear;
//      DataArrayU1 := TSutraBoundaryDisplayDataArray.Create(self);
//      DataArrayU1.DataType := rdtDouble;
//      DataArrayU1.Orientation := dso3D;
//      DataArrayU1.UpdateDimensions(Mesh.LayerCount+1, 1, Mesh.Mesh2D.Nodes.Count);
//      DataArrayU1.AddMethod := vamAveragedDelayed;
//      FSutraGenFlowU1.Add(ThreeDDisplayTime, DataArrayU1);
//
//      FSutraGenFlowU2.Clear;
//      DataArrayU2 := TSutraBoundaryDisplayDataArray.Create(self);
//      DataArrayU2.DataType := rdtDouble;
//      DataArrayU2.Orientation := dso3D;
//      DataArrayU2.UpdateDimensions(Mesh.LayerCount+1, 1, Mesh.Mesh2D.Nodes.Count);
//      DataArrayU2.AddMethod := vamAveragedDelayed;
//      FSutraGenFlowU2.Add(ThreeDDisplayTime, DataArrayU2);

      if FlowList.Count > 0 then
      begin
        FlowNodes := FlowList[0].ToArray;
        for NodeIndex := 0 to Length(FlowNodes) - 1 do
        begin
          ANode := FlowNodes[NodeIndex];
          if ANode.Active then
          begin
            DataArrayTranU1.AddDataValue(ANode.FUValue1.Annotation, ANode.FUValue1.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayTranU2.AddDataValue(ANode.FUValue2.Annotation, ANode.FUValue2.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayTranQU1.AddDataValue(ANode.FSoluteEnergyInflow.Annotation, ANode.FSoluteEnergyInflow.Value,
              ANode.FCol, 0, ANode.FLayer);
            DataArrayTranQU2.AddDataValue(ANode.FSoluteEnergyOutflow.Annotation, ANode.FSoluteEnergyOutflow.Value,
              ANode.FCol, 0, ANode.FLayer);
  //          DataArrayU1.AddDataValue(ANode.U1.Annotation, ANode.U1.Value,
  //            ANode.FCol, 0, ANode.FLayer);
  //          DataArrayU2.AddDataValue(ANode.U2.Annotation, ANode.U2.Value,
  //            ANode.FCol, 0, ANode.FLayer);
          end;
        end;
      end;

      DataArrayTranU1.ComputeAverage;
      DataArrayTranU1.UpToDate := True;
      FSutraGenTranU1.UpToDate := True;

      DataArrayTranU2.ComputeAverage;
      DataArrayTranU2.UpToDate := True;
      FSutraGenTranU2.UpToDate := True;

      DataArrayTranQU1.ComputeAverage;
      DataArrayTranQU1.UpToDate := True;
      FSutraGenTranQU1.UpToDate := True;

      DataArrayTranQU2.ComputeAverage;
      DataArrayTranQU2.UpToDate := True;
      FSutraGenTranQU2.UpToDate := True;

//      DataArrayU1.ComputeAverage;
//      DataArrayU1.UpToDate := True;
//      FSutraGenFlowU1.UpToDate := True;
//
//      DataArrayU2.ComputeAverage;
//      DataArrayU2.UpToDate := True;
//      FSutraGenFlowU2.UpToDate := True;
    finally
      FlowList.Free;
    end;
  finally
    GenTransportWriter.Free;
  end;
end;

procedure TCustomModel.InitializeSutraSpecPres(Sender: TObject);
var
  BoundaryWriter: TSutraBoundaryWriter;
begin
  BoundaryWriter := TSutraBoundaryWriter.Create(Self, etDisplay, sbtSpecPress);
  try
    BoundaryWriter.UpdateMergeLists(FSutraSpecPressureTimeList,
      FSutraSpecPresUTimeList);
  finally
    BoundaryWriter.Free;
  end;
end;

//procedure TCustomModel.UpdateSutraSpecPresUseList(Sender: TObject;
//  NewUseList: TStringList);
//var
//  ScreenObjectIndex: Integer;
//  ScreenObject: TScreenObject;
//  Item: TCustomModflowBoundaryItem;
//  ValueIndex: Integer;
//  ParamIndex: Integer;
//  ParamItem: TModflowParamItem;
//  Boundary: TSutraSpecifiedPressureBoundary;
//  DataIndex: integer;
//  LocalModel: TPhastModel;
//begin
//  // Use DataIndex = 0 for concentration/temperature.
//  // Use DataIndex = 1 for specified pressure or specified fluid flux.
//  DataIndex := 1;
//
//  if Self is TPhastModel then
//  begin
//    LocalModel := TPhastModel(Self);
//  end
//  else
//  begin
//    LocalModel := (Self as TChildModel).ParentModel as TPhastModel;
//  end;
//
//  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
//  begin
//    ScreenObject := ScreenObjects[ScreenObjectIndex];
//    if ScreenObject.Deleted then
//    begin
//      Continue;
//    end;
//    Boundary := ScreenObject.SutraBoundaries.SpecifiedPressure;
//    if (Boundary <> nil) and Boundary.Used then
//    begin
//      for ValueIndex := 0 to Boundary.Values.Count -1 do
//      begin
//        Item := Boundary.Values[ValueIndex] as TCustomModflowBoundaryItem;
//        LocalModel.UpdateUseList(DataIndex, NewUseList, Item);
//      end;
//    end;
//  end;
//end;

function TCustomModel.DataSetLayerToModflowLayer(
  DataSetLayer: integer): integer;
begin
  result := LayerStructure.DataSetLayerToModflowLayer(DataSetLayer);
end;

destructor TCustomModel.Destroy;
begin
  FMf6GwtNameWriters.Free;
  FPestObsCollection.Free;
  FMt3dObsCollection.Free;
//  FPestBoundaryDataArrays.Free;
  FPestParamDictionay.Free;
  FPilotPointData.Free;
  FPilotPointDataArrays.Free;
  FVelocityVectors.Free;

  FModflow6GlobalObservationComparisons.Free;
  FSutraGlobalObservationComparisons.Free;
  FModflowGlobalObservationComparisons.Free;
  FLakScreenObjects.Free;
  FMawScreenObjects.Free;
  FSfrScreenObjects.Free;
  FUzfMf6ScreenObjects.Free;

  FDisvGrid.Free;
  FBinaryFiles.Free;
  FFootPrintGrid.Free;

  FSwrObservations.Free;
  FSwrStructures.Free;
  FSwrReachGeometry.Free;
  FSwrTabFiles.Free;
  FSutraSpecPressureTimeList.Free;
  FSutraSpecPresUTimeList.Free;
  FSutraConcTempTimeList.Free;
  FSutraFluidFluxTimeList.Free;
  FSutraFluidFluxUTimeList.Free;
  FSutraMassEnergyFluxTimeList.Free;
  FSutraGenFlowPress1.Free;
  FSutraGenFlowPress2.Free;
  FSutraGenFlowRate1.Free;
  FSutraGenFlowRate2.Free;
  FSutraGenFlowU1.Free;
  FSutraGenFlowU2.Free;

  FSutraGenTranU1.Free;
  FSutraGenTranU2.Free;
  FSutraGenTranQU1.Free;
  FSutraGenTranQU2.Free;
  //  FChangedDataArrayNames.Free;
//  FBoundaryDataSets.Free;
//  FDataSets.Free;
//  FDataSetsToCache.Free;

  FSutraMesh.Free;
  FSutraOutputControl.Free;
  FSutraOptions.Free;
//  FSfrStreamLinkPlot.Free;
  FModflowWettingOptions.Free;
  FFilesToArchive.Free;
  FModelInputFiles.Free;
  FGrid := nil;
  FModflowGrid.Free;
  FModflowPackages.Free;
  FBatchFileAdditionsAfterModel.Free;
  FBatchFileAdditionsBeforeModel.Free;
  FModflowNameFileLines.Free;

  FSutraFluxObs.Free;
  FMt3dmsHeadMassFluxObservations.Free;
  FMt3dmsWellMassFluxObservations.Free;
  FMt3dmsMassLoadingMassFluxObservations.Free;
  FMt3dmsGhbMassFluxObservations.Free;
  FMt3dmsRivMassFluxObservations.Free;
  FMt3dmsResMassFluxObservations.Free;
  FMt3dmsRchMassFluxObservations.Free;
  FMt3dmsDrtMassFluxObservations.Free;
  FMt3dmsEtsMassFluxObservations.Free;
  FMt3dmsEvtMassFluxObservations.Free;
  FMt3dmsDrnMassFluxObservations.Free;
  FMt3dmsLakMassFluxObservations.Free;
  FMt3dmsStrMassFluxObservations.Free;
  FMt3dmsFhbHeadMassFluxObservations.Free;
  FMt3dmsFhbFlowMassFluxObservations.Free;

  FHeadFluxObservations.Free;
  FStrObservations.Free;
  FRiverObservations.Free;
  FDrainObservations.Free;
  FGhbObservations.Free;
  FHydrogeologicUnits.Free;
  FParsers.Free;
  FDataArrayManager.Free;
  FTransientMultiplierArrays.Free;
  FTransientZoneArrays.Free;
  FTimeLists.Free;
  FMfHobHeads.Free;
  FMt3dTobCond.Free;
  FHfbDisplayer.Free;
  FHfbWriter.Free;
  FUnitNumbers.Free;
  FPValFile.Free;
  FPvalTemplate.Free;
  FPestPValFile.Free;
  FPestPvalTemplate.Free;
  FModflowOptions.Free;
  FHeadObsResults.Free;
  FGages.Free;
  FPathLine.Free;
  FTimeSeries.Free;
  FEndPoints.Free;
  FreeAndNil(FCrossSection);
  FModpathOutputFiles.Free;
  FModpathInputFiles.Free;
  FZoneBudgetOutputFiles.Free;
  FZoneBudgetInputFiles.Free;
  FMt3dmsInputFiles.Free;
  FMt3dmsOutputFiles.Free;
  FModelOutputFiles.Free;
  FExternalFiles.Free;
  FSwiObsExtractorInputFiles.Free;
  FSwiObsExtractorOutputFiles.Free;

  FKrigfactorsScriptLines.Free;
  FPestTemplateLines.Free;
  FSutraPestScripts.Free;

  FInputObsInstructionFiles.Free;
  FInputObsInstructionFileNames.Free;
  FInputObservationDataSets.Free;
  FInputObservations.Free;
  inherited;
end;

procedure TCustomModel.DoDetermineKyFromAnisotropy(Sender: TObject);
var
  KyDataArray: TDataArray;
  LayerIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  KxDataArray: TDataArray;
  KyOverKxDataArray: TDataArray;
  Annotation: String;
begin
  Annotation := Format(StrSetByMultiplying, [rsKx, KKyOverKx]);
  Assert(Sender <> nil);
  KyDataArray := Sender as TDataArray;
  KyDataArray.UpdateDimensions(LayerCount, RowCount, ColumnCount, True);
  Assert(KyDataArray.Name = rsKy);
  KxDataArray := DataARrayManager.GetDataSetByName(rsKx);
  KyOverKxDataArray := DataARrayManager.GetDataSetByName(KKyOverKx);
  for LayerIndex := 0 to KyDataArray.LayerCount - 1 do
  begin
    for RowIndex := 0 to KyDataArray.RowCount - 1 do
    begin
      for ColIndex := 0 to KyDataArray.ColumnCount - 1 do
      begin
        KyDataArray.RealData[LayerIndex,RowIndex,ColIndex] :=
          KxDataArray.RealData[LayerIndex,RowIndex,ColIndex]
          * KyOverKxDataArray.RealData[LayerIndex,RowIndex,ColIndex];
        KyDataArray.Annotation[LayerIndex,RowIndex,ColIndex] := Annotation;
      end;
    end;
  end;
  KyDataArray.UptoDate := True;
end;

procedure TCustomModel.DoDetermineKzFromAnisotropy(Sender: TObject);
var
  KzDataArray: TDataArray;
  LayerIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  KxDataArray: TDataArray;
  KzOverKxDataArray: TDataArray;
  Annotation: String;
begin
  Annotation := Format(StrSetByMultiplying, [rsKx, KKzOverKx]);
  Assert(Sender <> nil);
  KzDataArray := Sender as TDataArray;
  KzDataArray.UpdateDimensions(LayerCount, RowCount, ColumnCount, True);
  Assert(KzDataArray.Name = rsKz);
  KxDataArray := DataARrayManager.GetDataSetByName(rsKx);
  KzOverKxDataArray := DataARrayManager.GetDataSetByName(KKzOverKx);
  for LayerIndex := 0 to KzDataArray.LayerCount - 1 do
  begin
    for RowIndex := 0 to KzDataArray.RowCount - 1 do
    begin
      for ColIndex := 0 to KzDataArray.ColumnCount - 1 do
      begin
        KzDataArray.RealData[LayerIndex,RowIndex,ColIndex] :=
          KxDataArray.RealData[LayerIndex,RowIndex,ColIndex]
          * KzOverKxDataArray.RealData[LayerIndex,RowIndex,ColIndex];
        KzDataArray.Annotation[LayerIndex,RowIndex,ColIndex] := Annotation;
      end;
    end;
  end;
  KzDataArray.UptoDate := True;
end;

procedure TCustomModel.EndGridChange;
begin
  if Grid <> nil then
  begin
    Grid.EndGridChange;
  end;
end;

function TCustomModel.TestModpathOK(Model: TCustomModel): Boolean;
begin
  result := True;
  if (ModflowOutputControl.SaveCellFlows = csfNone)
    or (ModflowOutputControl.BudgetFrequency <> 1)
    or (ModflowOutputControl.BudgetFrequencyChoice <> fcTimeSteps)
    or (not ModflowOutputControl.HeadOC.SaveInExternalFile)
    or (ModflowOutputControl.HeadOC.Frequency <> 1)
    or (ModflowOutputControl.HeadOC.FrequencyChoice <> fcTimeSteps) then
  begin
    Beep;
    if (MessageDlg(StrMODPATHRequiresTha,
      mtWarning, [mbYes, mbNo], 0, mbNo) <> mrYes) then
    begin
      frmGoPhast.miOutputControlClick(nil);
      result := false;
    end;
  end;
  if result and (Model.ModflowPackages.ModPath.MpathVersion = mp6) then
  begin
    if ModflowOutputControl.HeadOC.SaveInExternalFile
      and (ModflowOutputControl.HeadOC.OutputFileType <> oftBinary) then
    begin
      Beep;
    if (MessageDlg(StrMODPATHVersion6Re,
      mtWarning, [mbYes, mbNo], 0, mbNo) <> mrYes) then
    begin
      frmGoPhast.miOutputControlClick(nil);
      result := false;
    end;
    end;
  end;
end;

function TCustomModel.TimeToTimeStepTimes(ATime: double; out StartTime,
  EndTime: double): Boolean;
var
  Period: Integer;
  Step: Integer;
  StressPeriod: TModflowStressPeriod;
  TimeStep: TTimeStep;
begin
  result := False;
  ModflowStressPeriods.TimeToPeriodAndStep(ATime, Period, Step);
  if (Period < 0) or (Step < 0) then
  begin
    Exit;
  end;
  result := True;
  StressPeriod := ModflowStressPeriods[Period];
  TimeStep := StressPeriod.GetTimeStep(Step);
  StartTime := TimeStep.StartTime;
  EndTime := TimeStep.EndTime;
end;

function TCustomModel.DoTranspirationFractionUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticTranspirationFractionArrayUsed(nil);
end;

function TCustomModel.TRPT: TOneDRealArray;
begin
  result := LayerStructure.TRPT;
end;

function TCustomModel.TRPV: TOneDRealArray;
begin
  result := LayerStructure.TRPV;
end;

function TCustomModel.DoEquilibriumPhasesUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender) and ChemistryOptions.UseEquilibriumPhases;
end;

procedure TCustomModel.SetModflowGrid(const Value: TModflowGrid);
begin
  FModflowGrid.Assign(Value);
  DoInvalidate(self);
end;

procedure TCustomModel.SetModflowLocation(const Value: string);
begin
  case ModelSelection of
    msModflow:
      ProgramLocations.ModflowLocation := Value;
    msModflowLGR:
      ProgramLocations.ModflowLgrLocation := Value;
    msModflowLGR2:
      ProgramLocations.ModflowLgr2Location := Value;
    msModflowNWT:
      ProgramLocations.ModflowNwtLocation := Value;
    msModflowFmp:
      ProgramLocations.ModflowOwhmLocation := Value;
    msModflowCfp:
      ProgramLocations.ModflowCfpLocation := Value;
    msModflow2015:
      ProgramLocations.Modflow6Location := Value;
   msModflowOwhm2:
      ProgramLocations.ModflowOwhmV2Location := Value;
    else Assert(False);
  end;
end;

procedure TCustomModel.SetModflowPackages(const Value: TModflowPackages);
begin
  FModflowPackages.Assign(Value);
end;

procedure TCustomModel.SetAlternateSolver(const Value: boolean);
begin
  if FAlternateSolver <> Value then
  begin
    FAlternateSolver := Value;
    DoInvalidate(self);
  end;
end;

function TCustomModel.DoSeparatedDecaySolidUsedPerSpecies(
  Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      if AChemItem.Name = StrGweTemperature then
      begin
        if DataArray = nil then
        begin
          result := True;
        end
        else
        begin
          result := AChemItem.DecaySolidDataArrayName = DataArray.Name;
        end;
      end;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := GweUsed and ModflowPackages.GweEstPackage.IsSelected
    and ModflowPackages.GweEstPackage.ZeroOrderDecaySolid;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TCustomModel.DoSeparatedDecayWaterUsedPerSpecies(
  Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      if AChemItem.Name = StrGweTemperature then
      begin
        if DataArray = nil then
        begin
          result := True;
        end
        else
        begin
          result := AChemItem.DecayWaterDataArrayName = DataArray.Name;
        end;
      end;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := GweUsed and ModflowPackages.GweEstPackage.IsSelected
    and ModflowPackages.GweEstPackage.ZeroOrderDecayWater;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TCustomModel.DoSeparatedDensitySolidUsedPerSpecies(
  Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      if AChemItem.Name = StrGweTemperature then
      begin
        if DataArray = nil then
        begin
          result := True;
        end
        else
        begin
          result := AChemItem.DensitySolidDataArrayName = DataArray.Name;
        end;
      end;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := GweUsed and ModflowPackages.GweEstPackage.IsSelected;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TCustomModel.DoSeparatedHeatCapacitySolidUsedPerSpecies(
  Sender: TObject): boolean;
var
  DataArray: TDataArray;
  function DataArrayUsed(ChemSpecies: TCustomChemSpeciesCollection): boolean;
  var
    Index: Integer;
    AChemItem: TChemSpeciesItem;
  begin
    result := False;
    for Index := 0 to ChemSpecies.Count - 1 do
    begin
      AChemItem := ChemSpecies[Index];
      if AChemItem.Name = StrGweTemperature then
      begin
        if DataArray = nil then
        begin
          result := True;
        end
        else
        begin
          result := AChemItem.HeatCapacitySolidDataArrayName = DataArray.Name;
        end;
      end;
      if result then
      begin
        Exit;
      end;
    end;
  end;
begin
  result := GweUsed and ModflowPackages.GweEstPackage.IsSelected;
  if result then
  begin
    DataArray := Sender as TDataArray;
    result := DataArrayUsed(MobileComponents)
  end;
end;

function TCustomModel.DoSeparatedHorizontalTransverseDispersionUsed(
  Sender: TObject): boolean;
begin
  result := DoGwtDispUsed(Sender)
    and (ModflowPackages.GwtDispersionPackage.TransverseDispTreatement = dtSeparate)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtCombined)
end;

function TCustomModel.DoSeparatedHorizontalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ADataArray: TDataArray;
begin
  result := GwtDispUsedPerSpecies(Sender)
    and (ModflowPackages.GwtDispersionPackage.TransverseDispTreatement = dtSeparate)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate);
  if not result then
  begin
    if (Sender <> nil) and DoGweCndUsed(Sender)  then
    begin
      ADataArray := Sender as TDataArray;
      result := Pos(StrGweTemperature, ADataArray.Name) > 0;
    end;
  end;
end;

function TCustomModel.DoSeparatedLongitudinalDispersionUsed(
  Sender: TObject): boolean;
var
  ADataArray: TDataArray;
begin
  result := (DoGwtDispUsed(Sender)
    and (ModflowPackages.GwtDispersionPackage.LongitudinalDispTreatement = dtSeparate))
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtCombined);
//  if not result then
//  begin
//    if (Sender <> nil) and DoGweCndUsed(Sender)  then
//    begin
//      ADataArray := Sender as TDataArray;
//      result := Pos(StrGweTemperature, ADataArray.Name) > 0;
//    end;
//  end;
end;

function TCustomModel.DoSeparatedLongitudinalDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ADataArray: TDataArray;
begin
  result := (GwtDispUsedPerSpecies(Sender)
    and (ModflowPackages.GwtDispersionPackage.LongitudinalDispTreatement = dtSeparate)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate));
  if not result then
  begin
    if (Sender <> nil) and DoGweCndUsed(Sender)  then
    begin
      ADataArray := Sender as TDataArray;
      result := Pos(StrGweTemperature, ADataArray.Name) > 0;
    end;
  end;
end;

function TCustomModel.DoSeparatedThermalConductivityUsedPerSpecies(
  Sender: TObject): boolean;
var
  ADataArray: TDataArray;
begin
  result := False;
    if (Sender <> nil) and DoGweCndUsed(Sender)  then
  begin
    ADataArray := Sender as TDataArray;
    result := Pos(StrGweTemperature, ADataArray.Name) > 0;
  end;
end;

procedure TCustomModel.SetAlternateFlowPackage(const Value: boolean);
begin
  if FAlternateFlowPackage <> Value then
  begin
    FAlternateFlowPackage := Value;
    DoInvalidate(self);
  end;
end;

procedure TCustomModel.SetBatchFileAdditionsBeforeModel(const Value: TStrings);
begin
  if not FBatchFileAdditionsBeforeModel.Equals(Value) then
  begin
    DoInvalidate(self);
  end;
  FBatchFileAdditionsBeforeModel.Assign(Value);
end;

procedure TCustomModel.SetCanDrawContours(const Value: Boolean);
begin
  FCanDrawContours := Value;
end;

procedure TPhastModel.SetColorSchemesI(
  const Value: IUserDefinedColorSchemeCollection);
begin
  SetColorSchemes(Value as TUserDefinedColorSchemeCollection);
end;

procedure TCustomModel.SetCrossSection(const Value: TCrossSection);
begin
  FCrossSection.Assign(Value);
end;

procedure TCustomModel.SetBatchFileAdditionsAfterModel(const Value: TStrings);
begin
  if not FBatchFileAdditionsAfterModel.Equals(Value) then
  begin
    DoInvalidate(self);
  end;
  FBatchFileAdditionsAfterModel.Assign(Value);
end;

procedure TCustomModel.SetModflowNameFileLines(const Value: TStrings);
begin
  FModflowNameFileLines.Assign(Value);
  DoInvalidate(self);
end;

procedure TCustomModel.SetModflowOptions(const Value: TModflowOptions);
begin
  if Value <> FModflowOptions then
  begin
    FModflowOptions.Assign(Value);
  end;
end;

procedure TCustomModel.SetHeadFluxObservations(const Value: TFluxObservationGroups);
begin
  FHeadFluxObservations.Assign(Value);
end;

procedure TCustomModel.CreateHeadObsResults;
begin
  if FHeadObsResults = nil then
  begin
    FHeadObsResults := THeadObsCollection.Create(self);
  end;
end;

procedure TCustomModel.SetHeadObsResults(const Value: THeadObsCollection);
begin
  CreateHeadObsResults;
  FHeadObsResults.Assign(Value);
  if Assigned(OnHeadOBsChanged) then
  begin
    OnHeadOBsChanged(self);
  end;
end;

procedure TCustomModel.SetRiverObservations(const Value: TFluxObservationGroups);
begin
  FRiverObservations.Assign(Value);
end;

procedure TCustomModel.SetMf2005ObsGroupNames;
var
  ItemIndex: Integer;
  ObsGroup: TFluxObservationGroup;
  ObsGroups: TPestObservationGroups;
  procedure HandleObsGroup(ObsGroup: TFluxObservationGroup; GroupName: string);
  var
    ItemPos: Integer;
  begin
    if (ObsGroup.PestObservationGroup = nil)
      and (ObsGroup.ObservationGroup = '') then
    begin
      ObsGroup.ObservationGroup := GroupName;
    end
    else
    begin
      ItemPos := ObsGroups.IndexOf(ObsGroup.PestObservationGroup);
      if ItemPos < 0 then
      begin
        ObsGroup.PestObservationGroup := nil;
        ObsGroup.ObservationGroup := ObsGroup.ObservationGroup;
      end
      else
      begin
        ObsGroup.PestObservationGroup := ObsGroups[ItemPos];
      end;
    end;
  end;
begin
  ObsGroups := PestProperties.ObservationGroups;
  if (ObsGroups.Count = 0) and (ModelSelection in Modflow2005Selection) then
  begin
    ObsGroups.Add.ObsGroupName := StrCHOBflows;
    ObsGroups.Add.ObsGroupName := StrGHBflows;
    ObsGroups.Add.ObsGroupName := StrDRNflows;
    ObsGroups.Add.ObsGroupName := StrRIVflows;
    ObsGroups.Add.ObsGroupName := StrSTRflows;
    ObsGroups.Add.ObsGroupName := StrHeads;
    ObsGroups.Add.ObsGroupName := StrHeadChanges;
  end;
  for ItemIndex := 0 to HeadFluxObservations.Count - 1 do
  begin
    ObsGroup := HeadFluxObservations[ItemIndex];
    HandleObsGroup(ObsGroup, StrCHOBflows);
  end;

  for ItemIndex := 0 to DrainObservations.Count - 1 do
  begin
    ObsGroup := DrainObservations[ItemIndex];
    HandleObsGroup(ObsGroup, StrDRNflows);
  end;

  for ItemIndex := 0 to GhbObservations.Count - 1 do
  begin
    ObsGroup := GhbObservations[ItemIndex];
    HandleObsGroup(ObsGroup, StrGHBflows);
  end;

  for ItemIndex := 0 to RiverObservations.Count - 1 do
  begin
    ObsGroup := RiverObservations[ItemIndex];
    HandleObsGroup(ObsGroup, StrRIVflows);
  end;

  for ItemIndex := 0 to StreamObservations.Count - 1 do
  begin
    ObsGroup := StreamObservations[ItemIndex];
    HandleObsGroup(ObsGroup, StrSTRflows);
  end;
  UpdateHobGroupNames;
end;

procedure TCustomModel.SetDisplayColumn(const Value: integer);
begin
  Grid.DisplayColumn := Value;
end;

procedure TCustomModel.SetDisplayLayer(const Value: integer);
begin
  Grid.DisplayLayer := Value;
end;

procedure TCustomModel.SetDisplayRow(const Value: integer);
begin
  Grid.DisplayRow := Value;
end;

procedure TCustomModel.SetDisvGrid(const Value: TModflowDisvGrid);
begin
  FDisvGrid.Assign(Value);
end;

procedure TCustomModel.SetSelectedColumn(const Value: integer);
begin
  case ModelSelection of
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflow2015, msFootPrint, msModflowOwhm2:
      begin
        if not DisvUsed then
        begin
          Grid.SelectedColumn := Value;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        // do nothing
      end;
  else
    Assert(False);
  end;
end;

procedure TCustomModel.SetSelectedLayer(const Value: integer);
begin
  if Grid <> nil then
  begin
    Grid.SelectedLayer := Value;
  end
  else if DrawMesh <> nil then
  begin
    DrawMesh.SelectedLayer := Value;
  end
//  case ModelSelection of
//    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
//      msModflowFmp, msModflowCfp, msModflow2015:
//      begin
//        if DisvGrid.SelectedLayer:= Value; then
//        begin
//        end
//        else
//        begin
//          Grid.SelectedLayer:= Value;
//        end;
//      end;
//    msSutra22, msSutra30:
//      begin
//        if Mesh <> nil then
//        begin
//          SutraMesh.SelectedLayer := Value;
//        end;
//      end;
//    msFootPrint: ; // do nothing.
  else
  begin
    Assert(False);
  end;
end;

procedure TCustomModel.SetSelectedRow(const Value: integer);
begin
  case ModelSelection of
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflow2015, msFootPrint, msModflowOwhm2:
      begin
        if not DisvUsed then
        begin
          Grid.SelectedRow := Value;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        // do nothing
      end;
  else
    Assert(False);
  end;
end;

procedure TCustomModel.SetSideContourDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        Grid.SideContourDataSet := Value;
      end;
	msModflow2015:
	  begin
        ModflowGrid.SideContourDataSet := Value;
	  end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
  if Value <> nil then
  begin
    ContourLegend.ValueSource := Value;
  end;
end;

procedure TCustomModel.SetSideDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        Grid.SideDataSet := Value;
      end;
	msModflow2015:
	  begin
        ModflowGrid.SideDataSet := Value;
	  end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
end;

procedure TCustomModel.SetSideTimeList(const Value: TCustomTimeList);
begin
  FSideTimeList := Value;
end;

procedure TCustomModel.SetStrObservations(const Value: TFluxObservationGroups);
begin
  FStrObservations.Assign(Value);
end;

procedure TCustomModel.SetSutraFluxObs(const Value: TSutraFluxObs);
begin
  FSutraFluxObs.Assign(Value);
end;

procedure TCustomModel.SetSutraGlobalObservationComparisons(
  const Value: TGlobalObservationComparisons);
begin
  FSutraGlobalObservationComparisons.Assign(Value);
end;

procedure TCustomModel.SetSutraMesh(const Value: TSutraMesh3D);
begin
  if FSutraMesh = nil then
  begin
    FSutraMesh := TSutraMesh3D.Create(self);
    FSutraMesh.OnMeshTypeChanged := frmGoPhast.SutraMeshTypeChanged;
  end;
  FSutraMesh.Assign(Value);
end;

procedure TCustomModel.SetSutraOptions(const Value: TSutraOptions);
begin
  FSutraOptions.Assign(Value);
end;

procedure TCustomModel.SetSutraOutputControl(const Value: TSutraOutputControl);
begin
  FSutraOutputControl.Assign(Value);
end;

procedure TCustomModel.SetTopContourDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        Grid.TopContourDataSet := Value;
      end;
    msModflow2015:
      begin
        ModflowGrid.TopContourDataSet := Value;
        DisvGrid.TopContourDataSet := Value;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          SutraMesh.TopContourDataSet := Value;
        end;
      end;
    else
       Assert(False);
  end;
  if Value <> nil then
  begin
    ContourLegend.ValueSource := Value;
  end;
end;

procedure TCustomModel.SetTopDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        Grid.TopDataSet := Value;
      end;
    msModflow2015:
      begin
        ModflowGrid.TopDataSet := Value;
        DisvGrid.TopDataSet := Value;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          SutraMesh.TopDataSet := Value;
        end;
      end;
    else
       Assert(False);
  end;
end;

procedure TCustomModel.SetTopTimeList(const Value: TCustomTimeList);
begin
  FTopTimeList := Value;
end;

procedure TCustomModel.SetDrainObservations(const Value: TFluxObservationGroups);
begin
  FDrainObservations.Assign(Value);
end;

//procedure TCustomModel.SetGeoRefFileName(const Value: string);
//begin
//  if FGeoRefFileName <> Value then
//  begin
//    FGeoRefFileName := Value;
//    Invalidate(nil);
//  end;
//end;

procedure TCustomModel.SetGhbObservations(const Value: TFluxObservationGroups);
begin
  FGhbObservations.Assign(Value);
end;

procedure TCustomModel.SetModflow6GlobalObservationComparisons(
  const Value: TGlobalObservationComparisons);
begin
  FModflow6GlobalObservationComparisons.Assign(Value);
end;

procedure TCustomModel.SetModflowGlobalObservationComparisons(
  const Value: TGlobalObservationComparisons);
begin
  FModflowGlobalObservationComparisons.Assign(Value);
end;

procedure TCustomModel.SetHydrogeologicUnits(const Value: THydrogeologicUnits);
begin
  FHydrogeologicUnits.Assign(Value);
end;

procedure TCustomModel.SetFilesToArchive(const Value: TStrings);
begin
  FFilesToArchive.Assign(Value);
  DoInvalidate(self);
end;

procedure TCustomModel.SetFootPrintGrid(const Value: TFootPrintGrid);
begin
  FFootPrintGrid.Assign(Value);
end;

procedure TCustomModel.SetFrontContourDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        Grid.FrontContourDataSet := Value;
      end;
	  msModflow2015:
	    begin
        ModflowGrid.FrontContourDataSet := Value;
        DisvGrid.FrontContourDataSet := Value;
	    end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
  if Value <> nil then
  begin
    ContourLegend.ValueSource := Value;
  end;
end;

procedure TCustomModel.SetFrontDataSet(const Value: TDataArray);
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        Grid.FrontDataSet := Value;
      end;
	  msModflow2015:
	    begin
        ModflowGrid.FrontDataSet := Value;
        DisvGrid.FrontDataSet := Value;
	    end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
end;

procedure TCustomModel.SetFrontTimeList(const Value: TCustomTimeList);
begin
  FFrontTimeList := Value;
end;

procedure TCustomModel.SetMf6GridType(const Value: TMf6GridType);
begin
  if FMf6GridType <> Value then
  begin
    FMf6GridType := Value;
    if FMf6GridType = mgtStructured then
    begin
      FGrid := ModflowGrid;
//      ThreeDGridObserver.OnUpToDateSet := ModflowGrid.NotifyGridChanged;
    end
    else
    begin
      FGrid := nil;
//      ThreeDGridObserver.OnUpToDateSet := DisvGrid.NotifyMeshChanged;
    end;
    UpdateAllDataArrayDimensions;
    if Assigned(OnGridTypeChanged) then
    begin
      OnGridTypeChanged(self);
    end;
    DataArrayManager.InvalidateAllDataSets;
    ThreeDGridObserver.UpToDate := False;
  end;
end;

procedure TCustomModel.SetModelInputFiles(const Value: TStrings);
begin
  FModelInputFiles.Assign(Value);
  DoInvalidate(self);
end;

procedure TCustomModel.SetModelOutputFiles(const Value: TStrings);
begin
  FModelOutputFiles.Assign(Value);
end;

procedure TCustomModel.SetFileName(const Value: string);
var
  ModNameIndex: integer;
begin
  if FFileName <> Value then
  begin
    ModNameIndex := FFilesToArchive.IndexOf(FFileName);
    if ModNameIndex >= 0 then
    begin
      FFilesToArchive.Delete(ModNameIndex);
    end;
    FFileName := Value;
    FFilesToArchive.Add(FFileName);
    DoInvalidate(self);
  end;
end;

procedure TCustomModel.SetModflowWettingOptions(const Value: TWettingOptions);
begin
  FModflowWettingOptions.Assign(Value);
end;

procedure TCustomModel.SetModpathInputFiles(const Value: TStrings);
begin
  FModpathInputFiles.Assign(Value);
end;

procedure TCustomModel.SetModpathOutputFiles(const Value: TStrings);
begin
  FModpathOutputFiles.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsInputFiles(const Value: TStrings);
begin
  FMt3dmsInputFiles.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsOutputFiles(const Value: TStrings);
begin
  FMt3dmsOutputFiles.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsDrnMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsDrnMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsDrtMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsDrtMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsEtsMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsEtsMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsEvtMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsEvtMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsFhbFlowMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsFhbFlowMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsFhbHeadMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsFhbHeadMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsGhbMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsGhbMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsHeadMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsHeadMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsLakMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsLakMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsMassLoadingMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsMassLoadingMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsRchMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsRchMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsResMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsResMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsRivMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsRivMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dmsStrMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsStrMassFluxObservations.Assign(Value)
end;

procedure TCustomModel.SetMt3dmsWellMassFluxObservations(
  const Value: TMt3dmsFluxObservationGroups);
begin
  FMt3dmsWellMassFluxObservations.Assign(Value);
end;

procedure TCustomModel.SetMt3dObsCollection(const Value: TMt3dObsCollection);
begin
  FMt3dObsCollection.Assign(Value);
end;

procedure TCustomModel.SetNameFileWriter(const Value: TObject);
begin
  if Assigned(Value) then
  begin
    Assert(Value is TCustomNameFileWriter);
  end;
  FNameFileWriter := Value;
end;

procedure TCustomModel.AddModelInputFile(const FileName: string);
begin
  if ModelInputFiles.IndexOf(FileName) < 0 then
  begin
    ModelInputFiles.Add(FileName);
    DoInvalidate(self);
  end;
end;

procedure TCustomModel.AddModelOutputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FModelOutputFiles);
end;

function TCustomModel.CreateBlockFormulaObject(
  Orientation: TDataSetOrientation): TObject;
var
  resultObject: TFormulaObject;
begin
  resultObject := FormulaManager.Add;
  case Orientation of
    dsoTop:
      begin
        resultObject.Parser := rpTopFormulaCompiler;
      end;
    dso3D:
      begin
        resultObject.Parser := rpThreeDFormulaCompiler;
      end;
    else Assert(False);
  end;
  result := resultObject;
end;

function TCustomModel.CreateBlockFormulaObjectI(
  Orientation: TDataSetOrientation): IFormulaObject;
begin
  result := FormulaManager.Add;
  case Orientation of
    dsoTop:
      begin
        result.Parser := rpTopFormulaCompiler;
      end;
    dso3D:
      begin
        result.Parser := rpThreeDFormulaCompiler;
      end;
    else Assert(False);
  end;
end;

procedure TCustomModel.CreateBoundariesForMeshCreator(MeshCreator: TQuadMeshCreator; List: TList; Exag: Extended);
var
  NodeTree: TRbwQuadTree;
  ScreenObject: TScreenObject;
  Data: TPointerArray;
  SizePosition: Integer;
  InvalidMesh: Boolean;
  MaxY: Double;
  PointItem: TPointValuesItem;
  Epsilon: Double;
  SectionIndex: Integer;
  CellSize: Real;
  NodeIndex: Integer;
  SearchY: Double;
  MaxX: Double;
  StartIndex: Integer;
  EndIndex: Integer;
  FirstNode: TNode;
  NodeList: TNodeList;
  MinY: Double;
  MinX: Double;
  NodeScreenObjectsList: TList;
  ANode: TNode;
  ScreenObjectIndex: Integer;
  ALocation: TPoint2D;
  SearchX: Double;
  ABoundary: TBoundary;
begin
  InvalidMesh := False;
  MeshCreator.NodeAdjustmentMethod := namGiuliani;
  MeshCreator.RenumberingAlgorithm := SutraMesh.Mesh2D.MeshGenControls.RenumberingAlgorithm;
  NodeTree := TRbwQuadTree.Create(nil);
  NodeList := TNodeList.Create;
  NodeScreenObjectsList := TList.Create;
  try
    if List.Count > 0 then
    begin
      ScreenObject := List[0];
      MaxX := ScreenObject.MaxX;
      MinX := ScreenObject.MinX;
      MaxY := ScreenObject.MaxY;
      MinY := ScreenObject.MinY;
    end
    else
    begin
      MaxX := 0;
      MinX := 0;
      MaxY := 0;
      MinY := 0;
    end;
    for ScreenObjectIndex := 0 to List.Count - 1 do
    begin
      ScreenObject := List[ScreenObjectIndex];
      MaxX := Max(MaxX, ScreenObject.MaxX);
      MinX := Min(MinX, ScreenObject.MinX);
      MaxY := Max(MaxY, ScreenObject.MaxY);
      MinY := Min(MinY, ScreenObject.MinY);
    end;
    Epsilon := Sqrt(Sqr(MaxX - MinX) + Sqr(MaxY - MinY)) / 1E+07;
    for ScreenObjectIndex := 0 to List.Count - 1 do
    begin
      ScreenObject := List[ScreenObjectIndex];
      for SectionIndex := 0 to ScreenObject.SectionCount - 1 do
      begin
        ABoundary := MeshCreator.AddBoundary(ScreenObject.CellSize);
        FirstNode := nil;
        StartIndex := ScreenObject.SectionStart[SectionIndex];
        EndIndex := ScreenObject.SectionEnd[SectionIndex];
        if ScreenObject.SectionClosed[SectionIndex] then
        begin
          Dec(EndIndex);
        end;
        for NodeIndex := StartIndex to EndIndex do
        begin
          ALocation := ScreenObject.Points[NodeIndex];
          ANode := nil;
          if NodeTree.Count > 0 then
          begin
            SearchX := ALocation.x;
            SearchY := ALocation.y;
            NodeTree.FindClosestPointsData(SearchX, SearchY, Data);
            if (Abs(SearchX - ALocation.x) < Epsilon) and (Abs(SearchY - ALocation.y) < Epsilon) then
            begin
              ANode := Data[0];
              //                  if ScreenObject.CellSize < ANode.DesiredSpacing then
              begin
                ANode.DesiredSpacing := ScreenObject.CellSize;
              end;
            end;
          end;
          if ANode = nil then
          begin
            CellSize := ScreenObject.CellSize;
            PointItem := ScreenObject.PointPositionValues.GetItemByPosition(NodeIndex);
            if PointItem <> nil then
            begin
              SizePosition := PointItem.IndexOfName(StrMeshElementSize);
              if SizePosition >= 0 then
              begin
                CellSize := (PointItem.Values.Items[SizePosition] as TPointValue).Value;
              end;
            end;
            ANode := TNode.Create(MeshCreator, CellSize);
            ANode.Location := ALocation;
            ANode.Y := ANode.Y * Exag;
            NodeTree.AddPoint(ALocation.x, ALocation.y, ANode);
            NodeList.Add(ANode);
            NodeScreenObjectsList.Add(ScreenObject);
          end;
          if FirstNode = nil then
          begin
            FirstNode := ANode;
          end;
          ABoundary.AddNode(ANode);
        end;
        if ScreenObject.SectionClosed[SectionIndex] then
        begin
          ABoundary.AddNode(FirstNode);
        end;
      end;
    end;
    { TODO -cSUTRA : Consider moving this inside TQuadMeshCreator.GenerateMesh }
    for NodeIndex := 0 to NodeList.Count - 1 do
    begin
      ANode := NodeList[NodeIndex];
      StartIndex := List.IndexOf(NodeScreenObjectsList[NodeIndex]) + 1;
      for ScreenObjectIndex := StartIndex to List.Count - 1 do
      begin
        ScreenObject := List[ScreenObjectIndex];
        //            if (ScreenObject <> NodeScreenObjectsList[NodeIndex])
        //              and (ANode.DesiredSpacing > ScreenObject.CellSize) then
        begin
          SearchX := ANode.x;
          SearchY := ANode.y / Exag;
          if ScreenObject.IsPointInside(SearchX, SearchY, SectionIndex) then
          begin
            ANode.DesiredSpacing := ScreenObject.CellSize;
          end;
        end;
      end;
    end;
  finally
    NodeTree.Free;
    NodeList.Free;
    NodeScreenObjectsList.Free;
  end;
  SutraMesh.Mesh2D.MeshGenControls.Apply;
end;

procedure TCustomModel.FillListWithMeshSpecificationScreenObjects(var ErrorMessage: string; List: TList);
var
  ScreenObject: TScreenObject;
  BiggestIndex: Integer;
  ObjectArea: Real;
  ScreenObjectIndex: Integer;
  Area: Double;
begin
  ErrorMessage := '';
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    ScreenObject := ScreenObjects[ScreenObjectIndex];
    if ScreenObject.CellSizeUsed and (ScreenObject.ViewDirection = vdTop) and not ScreenObject.Deleted then
    begin
      List.Add(ScreenObject);
    end;
  end;
  if List.Count = 0 then
  begin
    ErrorMessage := StrNoObjects;
    Exit;
  end;
  Area := 0;
  BiggestIndex := -1;
  for ScreenObjectIndex := 0 to List.Count - 1 do
  begin
    ScreenObject := List[ScreenObjectIndex];
    ObjectArea := ScreenObject.ScreenObjectArea;
    if ObjectArea > Area then
    begin
      Area := ObjectArea;
      BiggestIndex := ScreenObjectIndex;
    end;
  end;
  if BiggestIndex < 0 then
  begin
    ErrorMessage := StrNoPolygons;
    Exit;
  end;
  if BiggestIndex > 0 then
  begin
    List.Exchange(0, BiggestIndex);
  end;
end;

procedure TCustomModel.TestAddModelModelFile(AFileName: string; FileNames: TStrings);
begin
  if FileNames.IndexOf(AFileName) < 0 then
  begin
    FileNames.Add(AFileName)
  end;
end;

procedure TCustomModel.AddModpathInputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FModpathInputFiles);
end;

procedure TCustomModel.AddModpathOutputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FModpathOutputFiles);
end;

procedure TCustomModel.AddMt3dmsInputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FMt3dmsInputFiles);
end;

procedure TCustomModel.AddMt3dmsOutputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FMt3dmsOutputFiles);
end;

procedure TCustomModel.AddSwiObsExtInputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FSwiObsExtractorInputFiles);
end;

procedure TCustomModel.AddSwiObsExtOutputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FSwiObsExtractorOutputFiles);
end;

procedure TCustomModel.AddBinaryFile(AFileName: string);
begin
  FBinaryFiles.Add(AFileName);
end;

function TCustomModel.AddDataSet(const DataSet: TDataArray): Integer;
begin
  result := DataArrayManager.AddDataSet(DataSet);
end;

function TCustomModel.DoAddedDemandUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticAddedDemandArrayUsed(nil);
end;

procedure TCustomModel.AddExternalFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FExternalFiles);
end;

procedure TCustomModel.AddFilesToDeleteToBatchFile(BatchFile: TStrings;
  const BatchFileName: string);
var
  FileIndex: Integer;
  FileToDelete: string;
begin
  if PestUsed then
  begin
    for FileIndex := 0 to FilesToDelete.Count - 1 do
    begin
      FileToDelete := FilesToDelete[FileIndex];
      FileToDelete := ExtractRelativePath(BatchFileName, FileToDelete);
      BatchFile.Add(Format(StrIfExist0sDel, [FileToDelete]));
    end;
    for FileIndex := 0 to ModelOutputFiles.Count - 1 do
    begin
      FileToDelete := ModelOutputFiles[FileIndex];
      if ExtractFileExt(FileToDelete) = '.grb' then
      begin
        Continue;
      end;
      FileToDelete := ExtractRelativePath(BatchFileName, FileToDelete);
      BatchFile.Add(Format(StrIfExist0sDel, [FileToDelete]));
    end;
  end;
end;

procedure TCustomModel.AddFileToArchive(const FileName: string);
begin
  if FilesToArchive.IndexOf(FileName) < 0 then
  begin
    FilesToArchive.Add(FileName);
    DoInvalidate(self);
  end;
end;

function TCustomModel.AddFormulaObject: IFormulaObject;
begin
  result := FormulaManager.Add;
end;

procedure TCustomModel.AddInputObsDataSet(DataArray: TDataArray);
begin
  Assert(DataArray <> nil);
  FInputObservationDataSets.Add(DataArray.Name);
end;

procedure TCustomModel.AddInputObsInstructionFile(AFileName: string);
begin
  FInputObsInstructionFiles.Add(AFileName);
end;

procedure TCustomModel.AddInputObsInstructionFileName(AFileName: string);
begin
  FInputObsInstructionFileNames.Add(AFileName);
end;

procedure TCustomModel.InternalClear;
var
  Index: Integer;
  DataSet: TDataArray;
begin
  InputObservationDataSets.Clear;
  ClearViewedItems;

  FModpathOutputFiles.Clear;
  FModpathInputFiles.Clear;
  FZoneBudgetOutputFiles.Clear;
  FZoneBudgetInputFiles.Clear;
  FMt3dmsInputFiles.Clear;
  FExternalFiles.Clear;
  FMt3dmsOutputFiles.Clear;
  FModelOutputFiles.Clear;
  FSwiObsExtractorInputFiles.Clear;
  FSwiObsExtractorOutputFiles.Clear;

  if FootprintProperties <> nil then
  begin
    FootprintProperties.StopTalkingToAnyone;
  end;
  FSwrReachGeometry.Clear;
  FSwrTabFiles.Clear;
  FSwrStructures.Clear;
  FSwrObservations.Clear;
  if FDisvGrid <> nil then
  begin
    FDisvGrid.Clear;
  end;
  if FSutraMesh <> nil then
  begin
    FSutraMesh.Clear;
  end;
  if PhastGrid <> nil then
  begin
    if PhastGrid.TopGridObserver <> nil then
    begin
      PhastGrid.TopGridObserver.StopTalkingToAnyone;
    end;
    if PhastGrid.ThreeDGridObserver <> nil then
    begin
      PhastGrid.ThreeDGridObserver.StopTalkingToAnyone;
    end;
  end;
  if ModflowGrid <> nil then
  begin
    if ModflowGrid.TopGridObserver <> nil then
    begin
      ModflowGrid.TopGridObserver.StopTalkingToAnyone;
    end;
    if ModflowGrid.ThreeDGridObserver <> nil then
    begin
      ModflowGrid.ThreeDGridObserver.StopTalkingToAnyone;
    end;
  end;
  if FootprintGrid <> nil then
  begin
    if FootprintGrid.TopGridObserver <> nil then
    begin
      FootprintGrid.TopGridObserver.StopTalkingToAnyone;
    end;
    if FootprintGrid.ThreeDGridObserver <> nil then
    begin
      FootprintGrid.ThreeDGridObserver.StopTalkingToAnyone;
    end;
  end;
  FCrossSection.Clear;
  for Index := 0 to FDataArrayManager.DataSetCount - 1 do
  begin
    DataSet := FDataArrayManager.DataSets[Index];
    DataSet.StopTalkingToAnyone;
  end;
  for Index := 0 to FDataArrayManager.BoundaryDataSetCount - 1 do
  begin
    DataSet := FDataArrayManager.BoundaryDataSets[Index];
    DataSet.StopTalkingToAnyone;
  end;
  AllObserversStopTalking;
  FModflowOptions.Clear;
  FDataArrayManager.ClearDataSetsToCache;
  ClearAllTimeLists;
  FreeAndNil(FPathline);
  FreeAndNil(FTimeSeries);
  FreeAndNil(FEndPoints);
  FreeAndNil(FHeadObsResults);
  if ParamGroups <> nil then
  begin
    ParamGroups.Clear;
  end;
  ModflowGlobalObservationComparisons.Clear;
  SutraGlobalObservationComparisons.Clear;

  VelocityVectors.Clear;
  FPilotPointData.Clear;
  FPestObsCollection.Clear;
  FMt3dObsCollection.Clear;
  ClearInputObservationDataSets;
end;

procedure TCustomModel.GenerateIrregularMesh(var ErrorMessage: string);
var
  List: TList;
  ScreenObjectIndex: integer;
  ScreenObject: TScreenObject;
  Area: double;
  BiggestIndex: Integer;
  ObjectArea: Real;
  MeshCreator: TQuadMeshCreator;
  SectionIndex: Integer;
  NodeIndex: Integer;
  ABoundary: TBoundary;
  ANode: TNode;
  FirstNode: TNode;
  SutraNode: TSutraNode2D;
  AdjustIndex: Integer;
  MeshNode: INode;
  ElementIndex: Integer;
  SutraElement: TSutraElement2D;
  MeshElement: IElement;
  StartIndex: Integer;
  EndIndex: Integer;
  Exag: Extended;
  InvalidMesh: boolean;
  OuterElementIndex: integer;
  OuterElement: TSutraElement2D;
  InnerElementIndex: integer;
  InnerElement: TSutraElement2D;
  InnerNodeIndex: integer;
  NodeTree: TRbwQuadTree;
  ALocation: TPoint2D;
  Data: TPointerArray;
  SearchX: double;
  SearchY: double;
  NodeList: TNodeList;
  NodeScreenObjectsList: TList;
  MaxX: double;
  MinX: double;
  MaxY: double;
  MinY: double;
  Epsilon: double;
  CellSize: Real;
  PointItem: TPointValuesItem;
  SizePosition: Integer;
begin
  if SutraMesh.MeshType = mtProfile then
  begin
    Exag := frmGoPhast.PhastModel.Exaggeration;
  end
  else
  begin
    Exag := 1;
  end;
  List := TList.Create;
  try
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObject := ScreenObjects[ScreenObjectIndex];
      if ScreenObject.CellSizeUsed and (ScreenObject.ViewDirection = vdTop)
        and not ScreenObject.Deleted then
      begin
        List.Add(ScreenObject);
      end;
    end;
    if List.Count = 0 then
    begin
      ErrorMessage := StrNoObjects;
      Exit;
    end;
    Area := 0;
    BiggestIndex := -1;
    for ScreenObjectIndex := 0 to List.Count - 1 do
    begin
      ScreenObject := List[ScreenObjectIndex];
      ObjectArea := ScreenObject.ScreenObjectArea;
      if ObjectArea > Area then
      begin
        Area := ObjectArea;
        BiggestIndex := ScreenObjectIndex;
      end;
    end;
    if BiggestIndex < 0 then
    begin
      ErrorMessage := StrNoPolygons;
      Exit;
    end;

    if BiggestIndex > 0 then
    begin
      List.Exchange(0, BiggestIndex);
    end;

    MeshCreator := TQuadMeshCreator.Create;
    try
      InvalidMesh := False;
      MeshCreator.NodeAdjustmentMethod := namGiuliani;
      MeshCreator.RenumberingAlgorithm := SutraMesh.Mesh2D.MeshGenControls.RenumberingAlgorithm;

      NodeTree := TRbwQuadTree.Create(nil);
      NodeList := TNodeList.Create;
      NodeScreenObjectsList := TList.Create;
      try
        if List.Count > 0 then
        begin
          ScreenObject := List[0];
          MaxX := ScreenObject.MaxX;
          MinX := ScreenObject.MinX;
          MaxY := ScreenObject.MaxY;
          MinY := ScreenObject.MinY;
        end
        else
        begin
          MaxX := 0;
          MinX := 0;
          MaxY := 0;
          MinY := 0;
        end;
        for ScreenObjectIndex := 0 to List.Count - 1 do
        begin
          ScreenObject := List[ScreenObjectIndex];
          MaxX := Max(MaxX, ScreenObject.MaxX);
          MinX := Min(MinX, ScreenObject.MinX);
          MaxY := Max(MaxY, ScreenObject.MaxY);
          MinY := Min(MinY, ScreenObject.MinY);
        end;
        Epsilon := Sqrt(Sqr(MaxX-MinX) + Sqr(MaxY-MinY))/1e7;
        for ScreenObjectIndex := 0 to List.Count - 1 do
        begin
          ScreenObject := List[ScreenObjectIndex];
          for SectionIndex := 0 to ScreenObject.SectionCount - 1 do
          begin
            ABoundary := MeshCreator.AddBoundary(ScreenObject.CellSize);
            FirstNode := nil;
            StartIndex := ScreenObject.SectionStart[SectionIndex];
            EndIndex := ScreenObject.SectionEnd[SectionIndex];
            if ScreenObject.SectionClosed[SectionIndex] then
            begin
              Dec(EndIndex);
            end;
            for NodeIndex := StartIndex to EndIndex do
            begin
              ALocation := ScreenObject.Points[NodeIndex];
              ANode := nil;
              if NodeTree.Count > 0 then
              begin
                SearchX := ALocation.x;
                SearchY := ALocation.y;
                NodeTree.FindClosestPointsData(SearchX, SearchY, Data);
                if (Abs(SearchX - ALocation.x)<Epsilon) and (Abs(SearchY - ALocation.y)<Epsilon) then
                begin
                  ANode := Data[0];
//                  if ScreenObject.CellSize < ANode.DesiredSpacing then
                  begin
                    ANode.DesiredSpacing := ScreenObject.CellSize;
                  end;
                end;
              end;

              if ANode = nil then
              begin
                CellSize := ScreenObject.CellSize;
                PointItem := ScreenObject.PointPositionValues.
                  GetItemByPosition(NodeIndex);
                if PointItem <> nil then
                begin
                  SizePosition := PointItem.IndexOfName(StrMeshElementSize);
                  if SizePosition >= 0 then
                  begin
                    CellSize := (PointItem.Values.Items[SizePosition] as TPointValue).Value;
                  end;
                end;

                ANode := TNode.Create(MeshCreator, CellSize);
                ANode.Location := ALocation;
                ANode.Y := ANode.Y*Exag;
                NodeTree.AddPoint(ALocation.x, ALocation.y, ANode);
                NodeList.Add(ANode);
                NodeScreenObjectsList.Add(ScreenObject);
              end;
              if FirstNode = nil then
              begin
                FirstNode := ANode;
              end;
              ABoundary.AddNode(ANode);
            end;
            if ScreenObject.SectionClosed[SectionIndex] then
            begin
              ABoundary.AddNode(FirstNode);
            end;
          end;
        end;
        { TODO -cSUTRA : Consider moving this inside TQuadMeshCreator.GenerateMesh }
        for NodeIndex := 0 to NodeList.Count - 1 do
        begin
          ANode := NodeList[NodeIndex];
          StartIndex := List.IndexOf(NodeScreenObjectsList[NodeIndex])+1;
          for ScreenObjectIndex := StartIndex to List.Count - 1 do
          begin
            ScreenObject := List[ScreenObjectIndex];
//            if (ScreenObject <> NodeScreenObjectsList[NodeIndex])
//              and (ANode.DesiredSpacing > ScreenObject.CellSize) then
            begin
              SearchX := ANode.x;
              SearchY := ANode.y/Exag;
              if ScreenObject.IsPointInside(SearchX, SearchY, SectionIndex) then
              begin
                ANode.DesiredSpacing := ScreenObject.CellSize;
              end;
            end;
          end;
        end;
      finally
        NodeTree.Free;
        NodeList.Free;
        NodeScreenObjectsList.Free;
      end;

      SutraMesh.Mesh2D.MeshGenControls.Apply;

      try
      MeshCreator.GenerateMesh;
      except on E: EAssertionFailed do
        begin
          InvalidMesh := True;
          Beep;
          MessageDlg(StrThereWasAnErrorG, mtError, [mbOK], 0);
          Exit;
        end;
      end;

      for AdjustIndex := 1 to 5 do
      begin
        MeshCreator.AdjustNodes;
      end;

      if FSutraMesh = nil then
      begin
        FSutraMesh := TSutraMesh3D.Create(self);
        FSutraMesh.OnMeshTypeChanged := frmGoPhast.SutraMeshTypeChanged;
        if Self is TPhastModel then
        begin
          TPhastModel(Self).SutraLayerStructure.Loaded;
        end;
      end;
      FSutraMesh.BeginUpdate;
      try
        FSutraMesh.Mesh2D.BeginUpdate;
        try
          FSutraMesh.Clear;
          FSutraMesh.Mesh2D.Nodes.Capacity := MeshCreator.NodeCount;
          FSutraMesh.Mesh2D.Elements.Capacity := MeshCreator.ElementCount;
          for NodeIndex := 0 to MeshCreator.NodeCount - 1 do
          begin
            SutraNode := FSutraMesh.Mesh2D.Nodes.Add;
            MeshNode := MeshCreator.Nodes[NodeIndex];
            SutraNode.AssignINode(MeshNode);
            SutraNode.Y := SutraNode.Y/Exag;
          end;
          for ElementIndex := 0 to MeshCreator.ElementCount - 1 do
          begin
            SutraElement := FSutraMesh.Mesh2D.Elements.Add;
            MeshElement := MeshCreator.Elements[ElementIndex];
            SutraElement.AssignIElement(MeshElement);
//            SutraElement.SetCorrectOrienatation;
          end;

          for NodeIndex := 0 to FSutraMesh.Mesh2D.Nodes.Count - 1 do
          begin
            SutraNode := FSutraMesh.Mesh2D.Nodes[NodeIndex];
            for OuterElementIndex := SutraNode.ElementCount - 2 downto 0 do
            begin
              OuterElement := SutraNode.Elements[OuterElementIndex];
              for InnerElementIndex := SutraNode.ElementCount - 1 downto OuterElementIndex+1 do
              begin
                InnerElement := SutraNode.Elements[InnerElementIndex];
                if OuterElement.HasSameNodes(InnerElement) then
                begin
//                  SutraNode.RemoveElement(InnerElement);
                  for InnerNodeIndex := 0 to InnerElement.Nodes.Count - 1 do
                  begin
                    InnerElement.Nodes[InnerNodeIndex].Node.RemoveElement(InnerElement);
                  end;
                  InnerElement.Free;
                end;
              end;
            end;
          end;
        finally
          FSutraMesh.Mesh2D.EndUpdate;
        end;

        for ElementIndex := 0 to FSutraMesh.Mesh2D.Elements.Count - 1 do
        begin
          SutraElement := FSutraMesh.Mesh2D.Elements[ElementIndex];
          if SutraElement.Nodes.Count <> 4 then
          begin
            InvalidMesh := True;
          end
          else
          begin
            if not SutraElement.ElementOK then
            begin
              InvalidMesh := True;
            end;
          end;
          if InvalidMesh then
          begin
            break;
          end;
        end;

      finally
        DataArrayManager.InvalidateAllDataSets;
        DataArrayManager.CreateInitialDataSets;

        FSutraMesh.EndUpdate;
      end;
      frmGoPhast.InvalidateGrid;

      if (frmMeshInformation <> nil) and frmMeshInformation.Visible then
      begin
        frmMeshInformation.GetData
      end;
      if InvalidMesh then
      begin
        Application.ProcessMessages;
//        try
//          MeshCreator.CheckInvalidElements;
//        except
//          on E: EInvalidElement do
//          begin
            Beep;
            MessageDlg(StrOneOrMoreInvalid, mtError, [mbOK], 0);
//            if ShowAForm(TfrmMeshGenerationControlVariables) = mrOK then
//            begin
//              GenerateIrregularMesh(ErrorMessage);
//              Exit;
//            end;
//          end;
//        end;

      end;
    finally
      MeshCreator.Free;
    end;
  finally
    List.Free;
  end;
end;


procedure TCustomModel.GenerateMeshUsingGeompack(var ErrorMessage: string);
var
  List: TList;
  MeshCreator: TQuadMeshCreator;
  NodeIndex: Integer;
  SutraNode: TSutraNode2D;
  MeshNode: INode;
  ElementIndex: Integer;
  SutraElement: TSutraElement2D;
  MeshElement: IElement;
  Exag: Extended;
  InvalidMesh: boolean;
  OuterElementIndex: integer;
  OuterElement: TSutraElement2D;
  InnerElementIndex: integer;
  InnerElement: TSutraElement2D;
  InnerNodeIndex: integer;
  CellSize: Real;
  GeomPackOptions: TGeompackOptions;
  OuterBoundary: TScreenObject;
  ScreenObjectArea: Real;
begin
  if SutraMesh.MeshType = mtProfile then
  begin
    Exag := frmGoPhast.PhastModel.Exaggeration;
  end
  else
  begin
    Exag := 1;
  end;
  List := TList.Create;
  try
    FillListWithMeshSpecificationScreenObjects(ErrorMessage, List);
    if ErrorMessage <> '' then
    begin
      Exit;
    end;

    GeomPackOptions := SutraMesh.Mesh2D.MeshGenControls.GeomPackOptions;
    if GeomPackOptions.AutomaticeElementCount then
    begin
      OuterBoundary := List[0];
      Assert(OuterBoundary.CellSizeUsed);
      CellSize := OuterBoundary.CellSize;
      ScreenObjectArea := OuterBoundary.ScreenObjectArea;
      GeomPackOptions.DesiredElementCount := Round(ScreenObjectArea/Sqr(CellSize)*Exag);
    end;

    MeshCreator := TQuadMeshCreator.Create;
    try
      CreateBoundariesForMeshCreator(MeshCreator, List, Exag);
      MeshCreator.GenerateMeshWithGeomPackPP(ProgramLocations.GeompackLocation,
        Exag, SutraMesh.Mesh2D.MeshGenControls.GeomPackOptions, ErrorMessage);

      SutraMesh.ElevationsNeedUpdating := True;
      SutraMesh.CheckUpdateElevations;

      Exit;

      if FSutraMesh = nil then
      begin
        FSutraMesh := TSutraMesh3D.Create(self);
        FSutraMesh.OnMeshTypeChanged := frmGoPhast.SutraMeshTypeChanged;
        if Self is TPhastModel then
        begin
          TPhastModel(Self).SutraLayerStructure.Loaded;
        end;
      end;
      FSutraMesh.BeginUpdate;
      try
        FSutraMesh.Mesh2D.BeginUpdate;
        try
          FSutraMesh.Clear;
          FSutraMesh.Mesh2D.Nodes.Capacity := MeshCreator.NodeCount;
          FSutraMesh.Mesh2D.Elements.Capacity := MeshCreator.ElementCount;
          for NodeIndex := 0 to MeshCreator.NodeCount - 1 do
          begin
            SutraNode := FSutraMesh.Mesh2D.Nodes.Add;
            MeshNode := MeshCreator.Nodes[NodeIndex];
            SutraNode.AssignINode(MeshNode);
            SutraNode.Y := SutraNode.Y/Exag;
          end;
          for ElementIndex := 0 to MeshCreator.ElementCount - 1 do
          begin
            SutraElement := FSutraMesh.Mesh2D.Elements.Add;
            MeshElement := MeshCreator.Elements[ElementIndex];
            SutraElement.AssignIElement(MeshElement);
//            SutraElement.SetCorrectOrienatation;
          end;

          for NodeIndex := 0 to FSutraMesh.Mesh2D.Nodes.Count - 1 do
          begin
            SutraNode := FSutraMesh.Mesh2D.Nodes[NodeIndex];
            for OuterElementIndex := SutraNode.ElementCount - 2 downto 0 do
            begin
              OuterElement := SutraNode.Elements[OuterElementIndex];
              for InnerElementIndex := SutraNode.ElementCount - 1 downto OuterElementIndex+1 do
              begin
                InnerElement := SutraNode.Elements[InnerElementIndex];
                if OuterElement.HasSameNodes(InnerElement) then
                begin
//                  SutraNode.RemoveElement(InnerElement);
                  for InnerNodeIndex := 0 to InnerElement.Nodes.Count - 1 do
                  begin
                    InnerElement.Nodes[InnerNodeIndex].Node.RemoveElement(InnerElement);
                  end;
                  InnerElement.Free;
                end;
              end;
            end;
          end;
        finally
          FSutraMesh.Mesh2D.EndUpdate;
        end;

        InvalidMesh := False;
        for ElementIndex := 0 to FSutraMesh.Mesh2D.Elements.Count - 1 do
        begin
          SutraElement := FSutraMesh.Mesh2D.Elements[ElementIndex];
          if SutraElement.Nodes.Count <> 4 then
          begin
            InvalidMesh := True;
          end
          else
          begin
            if not SutraElement.ElementOK then
            begin
              InvalidMesh := True;
            end;
          end;
          if InvalidMesh then
          begin
            break;
          end;
        end;

     finally
        DataArrayManager.InvalidateAllDataSets;
        DataArrayManager.CreateInitialDataSets;

        FSutraMesh.EndUpdate;
      end;
      frmGoPhast.InvalidateGrid;

      if (frmMeshInformation <> nil) and frmMeshInformation.Visible then
      begin
        frmMeshInformation.GetData
      end;
      if InvalidMesh then
      begin
        Application.ProcessMessages;
//        try
//          MeshCreator.CheckInvalidElements;
//        except
//          on E: EInvalidElement do
//          begin
            Beep;
            MessageDlg(StrOneOrMoreInvalid, mtError, [mbOK], 0);
//            if ShowAForm(TfrmMeshGenerationControlVariables) = mrOK then
//            begin
//              GenerateIrregularMesh(ErrorMessage);
//              Exit;
//            end;
//          end;
//        end;

      end;
    finally
      MeshCreator.Free;
    end;
  finally
    List.Free;
  end;
end;


procedure TCustomModel.GenerateMeshUsingGmsh(var ErrorMessage: string);
var
  List: TList;
//  Area: double;
//  BiggestIndex: Integer;
//  ObjectArea: Real;
  MeshCreator: TQuadMeshCreator;
  NodeIndex: Integer;
  SutraNode: TSutraNode2D;
//  AdjustIndex: Integer;
  MeshNode: INode;
  ElementIndex: Integer;
  SutraElement: TSutraElement2D;
  MeshElement: IElement;
  Exag: Extended;
  InvalidMesh: boolean;
  OuterElementIndex: integer;
  OuterElement: TSutraElement2D;
  InnerElementIndex: integer;
  InnerElement: TSutraElement2D;
  InnerNodeIndex: integer;
begin
  if SutraMesh.MeshType = mtProfile then
  begin
    Exag := frmGoPhast.PhastModel.Exaggeration;
  end
  else
  begin
    Exag := 1;
  end;
  List := TList.Create;
  try
    FillListWithMeshSpecificationScreenObjects(ErrorMessage, List);
    if ErrorMessage <> '' then
    begin
      Exit;
    end;

    MeshCreator := TQuadMeshCreator.Create;
    try
      CreateBoundariesForMeshCreator(MeshCreator, List, Exag);

      MeshCreator.GenerateMeshWithGmsh(ProgramLocations.GmshLocation, ErrorMessage, Exag);
      if ErrorMessage <> '' then
      begin
        Exit;
      end;

      SutraMesh.ElevationsNeedUpdating := True;
      SutraMesh.CheckUpdateElevations;

      Exit;

      if FSutraMesh = nil then
      begin
        FSutraMesh := TSutraMesh3D.Create(self);
        FSutraMesh.OnMeshTypeChanged := frmGoPhast.SutraMeshTypeChanged;
        if Self is TPhastModel then
        begin
          TPhastModel(Self).SutraLayerStructure.Loaded;
        end;
      end;
      FSutraMesh.BeginUpdate;
      try
        FSutraMesh.Mesh2D.BeginUpdate;
        try
          FSutraMesh.Clear;
          FSutraMesh.Mesh2D.Nodes.Capacity := MeshCreator.NodeCount;
          FSutraMesh.Mesh2D.Elements.Capacity := MeshCreator.ElementCount;
          for NodeIndex := 0 to MeshCreator.NodeCount - 1 do
          begin
            SutraNode := FSutraMesh.Mesh2D.Nodes.Add;
            MeshNode := MeshCreator.Nodes[NodeIndex];
            SutraNode.AssignINode(MeshNode);
            SutraNode.Y := SutraNode.Y/Exag;
          end;
          for ElementIndex := 0 to MeshCreator.ElementCount - 1 do
          begin
            SutraElement := FSutraMesh.Mesh2D.Elements.Add;
            MeshElement := MeshCreator.Elements[ElementIndex];
            SutraElement.AssignIElement(MeshElement);
//            SutraElement.SetCorrectOrienatation;
          end;

          for NodeIndex := 0 to FSutraMesh.Mesh2D.Nodes.Count - 1 do
          begin
            SutraNode := FSutraMesh.Mesh2D.Nodes[NodeIndex];
            for OuterElementIndex := SutraNode.ElementCount - 2 downto 0 do
            begin
              OuterElement := SutraNode.Elements[OuterElementIndex];
              for InnerElementIndex := SutraNode.ElementCount - 1 downto OuterElementIndex+1 do
              begin
                InnerElement := SutraNode.Elements[InnerElementIndex];
                if OuterElement.HasSameNodes(InnerElement) then
                begin
//                  SutraNode.RemoveElement(InnerElement);
                  for InnerNodeIndex := 0 to InnerElement.Nodes.Count - 1 do
                  begin
                    InnerElement.Nodes[InnerNodeIndex].Node.RemoveElement(InnerElement);
                  end;
                  InnerElement.Free;
                end;
              end;
            end;
          end;
        finally
          FSutraMesh.Mesh2D.EndUpdate;
        end;

        InvalidMesh := False;
        for ElementIndex := 0 to FSutraMesh.Mesh2D.Elements.Count - 1 do
        begin
          SutraElement := FSutraMesh.Mesh2D.Elements[ElementIndex];
          if SutraElement.Nodes.Count <> 4 then
          begin
            InvalidMesh := True;
          end
          else
          begin
            if not SutraElement.ElementOK then
            begin
              InvalidMesh := True;
            end;
          end;
          if InvalidMesh then
          begin
            break;
          end;
        end;

      finally
        DataArrayManager.InvalidateAllDataSets;
        DataArrayManager.CreateInitialDataSets;
        FSutraMesh.ElevationsNeedUpdating := true;

        FSutraMesh.EndUpdate;
      end;
      frmGoPhast.InvalidateGrid;

      if (frmMeshInformation <> nil) and frmMeshInformation.Visible then
      begin
        frmMeshInformation.GetData
      end;
      if InvalidMesh then
      begin
        Application.ProcessMessages;
//        try
//          MeshCreator.CheckInvalidElements;
//        except
//          on E: EInvalidElement do
//          begin
            Beep;
            MessageDlg(StrOneOrMoreInvalid, mtError, [mbOK], 0);
//            if ShowAForm(TfrmMeshGenerationControlVariables) = mrOK then
//            begin
//              GenerateIrregularMesh(ErrorMessage);
//              Exit;
//            end;
//          end;
//        end;

      end;
    finally
      MeshCreator.Free;
    end;
  finally
    List.Free;
  end;
end;

procedure TCustomModel.GenerateFishNetMesh(var ErrorMessage: string);
begin
end;

procedure TCustomModel.FixSutraMeshEdge;
var
  Edges: TRbwQuadTree;
  ElementIndex: Integer;
  AnElement: TSutraElement2D;
  Node1: TSutraNode2D;
  NodeIndex: Integer;
  Node2: TSutraNode2D;
  LowerNumber: double;
  HigherNumber: double;
  LowerNodeList: TList;
  HigherNodeList: TList;
  LowNode: TSutraNode2D;
  HighNode: TSutraNode2D;
  DataArray: TPointerArray;
begin
  Edges := TRbwQuadtree.Create(nil);
  LowerNodeList := TList.Create;
  HigherNodeList := TList.Create;
  try
    Edges.XMin := 0;
    Edges.YMin := 0;
    Edges.XMax := SutraMesh.Mesh2D.Nodes.Count;
    Edges.YMax := SutraMesh.Mesh2D.Nodes.Count;
    for ElementIndex := 0 to SutraMesh.Mesh2D.Elements.Count - 1 do
    begin
      AnElement := SutraMesh.Mesh2D.Elements[ElementIndex];
      Node1 := AnElement.Nodes[3].Node;
      for NodeIndex := 0 to AnElement.Nodes.Count - 1 do
      begin
        Node2 := AnElement.Nodes[NodeIndex].Node;
        if Node1.EdgeNode and Node2.EdgeNode then
        begin
          if Node1.Number < Node2.Number then
          begin
            LowNode := Node1;
            HighNode := Node2;
          end
          else
          begin
            LowNode := Node2;
            HighNode := Node1;
          end;
          LowerNodeList.Add(LowNode);
          HigherNodeList.Add(HighNode);
          LowerNumber := LowNode.Number;
          HigherNumber := HighNode.Number;
          Edges.AddPoint(LowerNumber, HigherNumber, nil);
        end;
        Node1 := Node2;
      end;
    end;
    for NodeIndex := 0 to LowerNodeList.Count - 1 do
    begin
      LowNode := LowerNodeList[NodeIndex];
      HighNode := HigherNodeList[NodeIndex];
      LowNode.NodeType := ntInner;
      HighNode.NodeType := ntInner;
    end;
    for NodeIndex := 0 to LowerNodeList.Count - 1 do
    begin
      LowNode := LowerNodeList[NodeIndex];
      HighNode := HigherNodeList[NodeIndex];
      LowerNumber := LowNode.Number;
      HigherNumber := HighNode.Number;
      Edges.FindClosestPointsData(LowerNumber, HigherNumber, DataArray);
      if Length(DataArray) = 1 then
      begin
        LowNode.NodeType := ntEdge;
        HighNode.NodeType := ntEdge;
      end;
    end;
  finally
    HigherNodeList.Free;
    LowerNodeList.Free;
    Edges.Free;
  end;
end;

procedure TCustomModel.GenerateSutraMesh(var ErrorMessage: string);
var
  MeshGenControls: TMeshGenerationControls;
begin
  ErrorMessage := '';
  SutraMesh.CanDraw := False;
  SutraMesh.Loading := False;
  try
    MeshGenControls := SutraMesh.Mesh2D.MeshGenControls;
    case MeshGenControls.MeshGenerationMethod of
      mgmFishnet:
        begin
          GenerateFishNetMesh(ErrorMessage);
        end;
      mgmIrregular:
        begin
          GenerateIrregularMesh(ErrorMessage);
        end;
      mgmGmsh:
        begin
          GenerateMeshUsingGmsh(ErrorMessage);
        end;
      mgmGeompack:
        begin
          GenerateMeshUsingGeompack(ErrorMessage);
        end;
      else
        Assert(False);
    end;

    FixSutraMeshEdge;

    DataArrayManager.UpdateDataSetDimensions;
    if (frmMeshInformation <> nil) and frmMeshInformation.Visible then
    begin
      frmMeshInformation.GetData
    end;

  finally
    SutraMesh.CanDraw := True;
  end;
end;

procedure TCustomModel.UpdateDataArrayDimensions(DataArray: TDataArray);
begin
  if (FModelSelection in SutraSelection) and (Mesh <> nil) and (self is TPhastModel) then
  begin
    case DataArray.EvaluatedAt of
      eaBlocks:
        begin
          DataArray.UpdateDimensions(TPhastModel(Self).
            SutraLayerStructure.LayerCount, 1, SutraMesh.Mesh2D.Elements.Count);
        end;
      eaNodes:
        begin
          DataArray.UpdateDimensions(TPhastModel(Self).
            SutraLayerStructure.NodeLayerCount, 1, SutraMesh.Mesh2D.Nodes.Count);
        end;
    else
      Assert(False);
    end;
  end
  else if Grid <> nil then
  begin
    DataArray.UpdateDimensions(Grid.LayerCount, Grid.RowCount, Grid.ColumnCount);
  end
  else if DisvUsed then
  begin
    DataArray.UpdateDimensions(DisvGrid.Layers.Count, 1, DisvGrid.TwoDGrid.ElementCount);
  end
//  else if (FModelSelection in SutraSelection) and (Mesh <> nil) and (self is TPhastModel) then
//  begin
//    case DataArray.EvaluatedAt of
//      eaBlocks:
//        begin
//          DataArray.UpdateDimensions(TPhastModel(Self).
//            SutraLayerStructure.LayerCount, 1, SutraMesh.Mesh2D.Elements.Count);
//        end;
//      eaNodes:
//        begin
//          DataArray.UpdateDimensions(TPhastModel(Self).
//            SutraLayerStructure.NodeLayerCount, 1, SutraMesh.Mesh2D.Nodes.Count);
//        end;
//    else
//      Assert(False);
//    end;
//  end
  else
  begin
    DataArray.UpdateDimensions(-1, -1, -1);
  end;
end;

function TCustomModel.GetElementLocation(Layer, Row,
  Column: Integer): TDualLocation;
var
  APoint: TPoint2D;
  DisvCell: TModflowDisVCell;
//  IDomain: TDataArray;
  AnElement: TSutraElement3D;
//  ActiveDataArray: TDataArray;
begin
  result.RotatedLocation.x := 0;
  result.RotatedLocation.y := 0;
  result.RotatedLocation.z := 0;
  if ModelSelection in SutraSelection then
  begin
    APoint := SutraMesh.Mesh2D.Elements[Column].Center;
    result.RotatedLocation.x := APoint.x;
    result.RotatedLocation.y := APoint.y;
    if SutraMesh.MeshType = mt3D then
    begin
      AnElement := SutraMesh.ElementArray[Layer,Column];
      result.RotatedLocation.z := AnElement.CenterElevation;
    end
    else
    begin
      result.RotatedLocation.z := 0;
    end;
    result.UnRotatedLocation := result.RotatedLocation;
  end
  else if ModelSelection in ModflowSelection then
  begin
    if DisvUsed then
    begin
      APoint := DisvGrid.TwoDGrid.Cells[Column].Location;
      result.RotatedLocation.x := APoint.x;
      result.RotatedLocation.y := APoint.y;
      DisvCell := DisvGrid.Cells[Layer, Column];
      result.RotatedLocation.Z := DisvCell.CenterElevation;
      result.UnRotatedLocation := result.RotatedLocation;
    end
    else
    begin
      result.RotatedLocation := Grid.RotatedThreeDElementCenter
        (ZeroBasedID(Layer,Row,Column));
      result.UnRotatedLocation := Grid.ThreeDElementCenter
        (ZeroBasedID(Layer,Row,Column));
    end;
  end
  else
  begin
    Assert(False);
  end;
end;

function TCustomModel.GetActiveElement(Layer, Row, Column: Integer): Boolean;
var
//  APoint: TPoint2D;
//  DisvCell: TModflowDisVCell;
  IDomain: TDataArray;
  AnElement: TSutraElement3D;
  ActiveDataArray: TDataArray;
begin
  result := False;
  if ModelSelection in SutraSelection then
  begin
    if SutraMesh.MeshType = mt3D then
    begin
      AnElement := SutraMesh.ElementArray[Layer,Column];
      result := AnElement.Active;
    end
    else
    begin
      result := True;
    end;
  end
  else if ModelSelection in ModflowSelection then
  begin
    if ModelSelection = msModflow2015 then
    begin
      IDomain := DataArrayManager.GetDataSetByName(K_IDOMAIN);
      result := IDomain.IntegerData[Layer, Row, Column] > 0;
    end
    else
    begin
      ActiveDataArray := DataArrayManager.GetDataSetByName(rsActive);
      result := ActiveDataArray.BooleanData[Layer, Row, Column];
    end;
  end
  else
  begin
    Assert(False);
  end;
end;

function TCustomModel.GetActiveUsed: TObjectUsedEvent;
begin
  result := DoActiveUsed;
end;

function TCustomModel.GetAddedDemandUsed: TObjectUsedEvent;
begin
  result := DoAddedDemandUsed;
end;

function TCustomModel.GetAquiferPropertiesUsed: TObjectUsedEvent;
begin
  result := DoAquiferPropertiesUsed;
end;

function TCustomModel.GetAssignFootprintBoundarydWithdrawal: TNotifyEvent;
begin
  result := DoAssignFootprintBoundarydWithdrawal;
end;

function TCustomModel.GetAssignModflow6LakeDisplayArrays: TNotifyEvent;
begin
  result := DoAssignModflow6LakeDisplayArrays;
end;

function TCustomModel.GetBcfUsed: TObjectUsedEvent;
begin
  result := DoBcfUsed
end;

function TCustomModel.GetBuoyancyDensityUsed: Boolean;
var
  Buoyancy: TBuoyancyPackage;
begin
  Buoyancy := ModflowPackages.BuoyancyPackage;
  Result := Buoyancy.IsSelected and Buoyancy.DensitySpecified;
end;

function TCustomModel.GetBuoyancyUsed: Boolean;
begin
  Result := ModflowPackages.BuoyancyPackage.IsSelected
end;

function TCustomModel.GetCapillaryFringeUsed: TObjectUsedEvent;
begin
  result := DoCapillaryFringeUsed;
end;

function TCustomModel.GetCfpCadsSelected: TObjectUsedEvent;
begin
  result := DoCfpCadsSelected
end;

function TCustomModel.GetCfpPipes2Selected: TObjectUsedEvent;
begin
  result := DoCfp2PipesSelected;
end;

function TCustomModel.GetCfpPipesSelected: TObjectUsedEvent;
begin
  result := DoCfpPipesSelected;
end;

function TCustomModel.GetChemistryUsed: TObjectUsedEvent;
begin
  result := DoChemistryUsed;
end;

function TCustomModel.GetClearing: Boolean;
begin
  result := FClearing;
end;

function TPhastModel.GetColorSchemesI: IUserDefinedColorSchemeCollection;
begin
  result := GetColorSchemes;
end;

function TCustomModel.GetCombinedHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoCombinedHorizontalTransverseDispersionUsedPerSpecies;
end;

function TCustomModel.GetCompiler(const Orientation: TDataSetOrientation;
      const EvaluatedAt: TEvaluatedAt): TRbwParser;
begin
  result := nil;

  case EvaluatedAt of
    eaBlocks:
      begin
        case Orientation of
          dsoTop:
            begin
              result := rpTopFormulaCompiler;
            end;
          dsoFront:
            begin
              result := rpFrontFormulaCompiler;
            end;
          dsoSide:
            begin
              result := rpSideFormulaCompiler;
            end;
          dso3D:
            begin
              result := rpThreeDFormulaCompiler;
            end;
        else
          Assert(False);
        end;
      end;
    eaNodes:
      begin
        case Orientation of
          dsoTop:
            begin
              result := rpTopFormulaCompilerNodes;
            end;
          dsoFront:
            begin
              result := rpFrontFormulaCompilerNodes;
            end;
          dsoSide:
            begin
              result := rpSideFormulaCompilerNodes;
            end;
          dso3D:
            begin
              result := rpThreeDFormulaCompilerNodes;
            end;
        else
          Assert(False);
        end;
      end;
  else
    Assert(False);
  end;
end;

function TCustomModel.GetConfinedStorageCoefUsed: TObjectUsedEvent;
begin
  result := DoConfinedStorageCoefUsed;
end;

function TCustomModel.GetConfiningBedKzUsed: TObjectUsedEvent;
begin
  result := DoConfiningBedKzUsed;
end;

function TCustomModel.GetConsumptiveUseUsed: TObjectUsedEvent;
begin
  result := DoConsumptiveUseUsed;
end;

function TCustomModel.GetCropCoefficientUsed: TObjectUsedEvent;
begin
  result := DoCropCoefficientUsed;
end;

function TCustomModel.GetCropHasSalinityDemandUsed: TObjectUsedEvent;
begin
  result := DoCropHasSalinityDemandUsed;
end;

function TCustomModel.GetCrossSection: TCrossSection;
begin
  result := FCrossSection
end;

function TCustomModel.GetCSubDataSetsUsed: TObjectUsedEvent;
begin
  result := DoCSubDataSetsUsed;
end;

function TCustomModel.GetCSubInitialElasticStorageUsed: TObjectUsedEvent;
begin
  result := DoCSubInitialElasticStorageUsed;
end;

function TCustomModel.GetCSubInitialRecompressionIndexUsed: TObjectUsedEvent;
begin
  result := DoCSubInitialRecompressionIndexUsed;
end;

function TCustomModel.ParamNamesDataSetUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  NamesPos: Integer;
  BaseArrayName: string;
  BaseArray: TDataArray;
begin
  Assert(Sender <> nil);
  DataArray := Sender as TDataArray;
  NamesPos := Pos(StrParamNameSuffix, DataArray.Name);
  Assert(NamesPos > 0);
  BaseArrayName := Copy(DataArray.Name, 1, NamesPos-1);
  BaseArray := DataArrayManager.GetDataSetByName(BaseArrayName);
  if BaseArray <> nil then
  begin
    result := BaseArray.PestParametersUsed;
    if result and Assigned(BaseArray.OnDataSetUsed) then
    begin
      result := BaseArray.OnDataSetUsed(BaseArray);
    end;
  end
  else
  begin
    result := False
  end;
end;

function TCustomModel.ParamWeightsDataSetUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  NamesPos: Integer;
  BaseArrayName: string;
  BaseArray: TDataArray;
begin
  Assert(Sender <> nil);
  DataArray := Sender as TDataArray;
  NamesPos := Pos(StrWeightSuffix, DataArray.Name);
  Assert(NamesPos > 0);
  BaseArrayName := Copy(DataArray.Name, 1, NamesPos-1);
  BaseArray := DataArrayManager.GetDataSetByName(BaseArrayName);
  if BaseArray <> nil then
  begin
    result := BaseArray.UseValuesForObservations;
    if result and Assigned(BaseArray.OnDataSetUsed) then
    begin
      result := BaseArray.OnDataSetUsed(BaseArray);
    end;
  end
  else
  begin
    result := False
  end;
end;

function TCustomModel.ParserCount: integer;
begin
  result := FParsers.Count;
end;

procedure TCustomModel.ClearParsers;
var
  Parser: TRbwParser;
  Index: Integer;
begin
  for Index := 0 to ParserCount - 1 do
  begin
    Parser := Parsers[Index];
    Parser.ClearExpressions;
    Parser.ClearVariables;
  end;
end;

procedure TCustomModel.ClearPestArrayFileNames;
begin
  DataArrayManager.ClearPestArrayFileNames
end;

procedure TCustomModel.ClearPestParmDictionary;
begin
  FreeAndNil(FPestParamDictionay);
end;

procedure TCustomModel.ClearPestPriorInfoGroupData;
var
  ParamIndex: Integer;
  ASteadyParam: TModflowSteadyParameter;
  AParam: TModflowTransientListParameter;
  AHufParam: THufParameter;
begin
  for ParamIndex := 0 to ModflowSteadyParameters.Count - 1 do
  begin
    ASteadyParam := ModflowSteadyParameters[ParamIndex];
    ASteadyParam.RegularizationGroup := '';
    ASteadyParam.HorizontalSpatialContinuityGroupName := '';
    ASteadyParam.VertSpatialContinuityGroupName := '';

    ASteadyParam.PilotPointObsGrpCollection.Clear;
  end;

  for ParamIndex := 0 to ModflowTransientParameters.Count - 1 do
  begin
    AParam := ModflowTransientParameters[ParamIndex];
    AParam.RegularizationGroup := '';

    AParam.PilotPointObsGrpCollection.Clear;
  end;

  for ParamIndex := 0 to HufParameters.Count - 1 do
  begin
    AHufParam := HufParameters[ParamIndex];
    AHufParam.RegularizationGroup := '';

    AHufParam.PilotPointObsGrpCollection.Clear;
  end;
end;

procedure TCustomModel.ClearPval;
var
  Index: Integer;
begin
  FPValFile.Clear;
  FPvalTemplate.Clear;
  FPestPValFile.Clear;
  FPestPvalTemplate.Clear;
  FilesToDelete.Clear;
  ClearPestParmDictionary;
//  FPestBoundaryDataArrays.Clear;
  for Index := 0 to ModflowSteadyParameters.Count - 1 do
  begin
    ModflowSteadyParameters[Index].AddedToPval := False;
  end;
  if self is TPhastModel then
  begin
    for Index := 0 to ModflowSteadyParameters.Count - 1 do
    begin
      ModflowSteadyParameters[Index].IsUsedInTemplate := False;
    end;
  end;
end;

procedure TCustomModel.ClearViewedItems;
begin
  FrontTimeList := nil;
  SideTimeList := nil;
  TopTimeList := nil;
  ThreeDTimeList := nil;
  FTopDisplayTime := 0;
  FFrontDisplayTime := 0;
  FSideDisplayTime := 0;
  FThreeDDisplayTime := 0;

  ModflowGrid.TopDataSet := nil;
  ModflowGrid.FrontDataSet := nil;
  ModflowGrid.SideDataSet := nil;
  ModflowGrid.ThreeDDataSet := nil;

  ModflowGrid.TopContourDataSet := nil;
  ModflowGrid.FrontContourDataSet := nil;
  ModflowGrid.SideContourDataSet := nil;
  ModflowGrid.ThreeDContourDataSet := nil;

  if Mesh <> nil then
  begin
    (Mesh as TSutraMesh3D).TopDataSet := nil;
//    Mesh.FrontDataSet := nil;
//    Mesh.SideDataSet := nil;
    (Mesh as TSutraMesh3D).ThreeDDataSet := nil;
  end;
end;

function TCustomModel.GetParsers(Index: integer): TRbwParser;
begin
  result := FParsers[Index];
end;

function TCustomModel.GetScreenObjectInterface(
  const Index: integer): IScreenObject;
begin
  result := GetScreenObjects(index);
end;

function TCustomModel.GetScreenObjectInterfaceByName(
  AName: string): IScreenObject;
begin
  result := GetScreenObjectByName(AName);
end;

function TCustomModel.GetSelectedColumn: integer;
begin
  if Grid <> nil then
  begin
    result := Grid.SelectedColumn;
  end
  else
  begin
    result := 0;
  end;
end;

function TCustomModel.GetSelectedLayer: integer;
begin
  result := 0;
  if Grid <> nil then
  begin
    result := Grid.SelectedLayer;
  end
  else if DrawMesh <> nil then
  begin
    result := DrawMesh.SelectedLayer;
  end;
end;

function TCustomModel.GetSelectedRow: integer;
begin
  if Grid <> nil then
  begin
    result := Grid.SelectedRow;
  end
  else
  begin
    result := 0;
  end;
end;

function TCustomModel.GetSeparatedDecaySolidUsed: TObjectUsedEvent;
begin
  result := DoSeparatedDecaySolidUsedPerSpecies;
end;

function TCustomModel.GetSeparatedDecayWaterUsed: TObjectUsedEvent;
begin
  result := DoSeparatedDecayWaterUsedPerSpecies;
end;

function TCustomModel.GetSeparatedDensitySolidUsed: TObjectUsedEvent;
begin
  result := DoSeparatedDensitySolidUsedPerSpecies;
end;

function TCustomModel.GetSeparatedHeatCapacitySolidUsed: TObjectUsedEvent;
begin
  result := DoSeparatedHeatCapacitySolidUsedPerSpecies;
end;

function TCustomModel.GetSeparatedHorizontalTransverseDispersionUsed: TObjectUsedEvent;
begin
  result := DoSeparatedHorizontalTransverseDispersionUsed;
end;

function TCustomModel.GetSeparatedHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoSeparatedHorizontalTransverseDispersionUsedPerSpecies;
end;

function TCustomModel.GetSeparatedLongitudinalDispersionUsed: TObjectUsedEvent;
begin
  result := DoSeparatedLongitudinalDispersionUsed;
end;

function TCustomModel.GetSeparatedLongitudinalDispersionUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoSeparatedLongitudinalDispersionUsedPerSpecies;
end;

function TCustomModel.GetSeparatedThermalConductivityUsed: TObjectUsedEvent;
begin
  result := DoSeparatedThermalConductivityUsedPerSpecies;
end;

function TCustomModel.GetSeparateGwtUsed: Boolean;
begin
  result := GwtUsed and ModflowPackages.GwtProcess.SeparateGwt;
end;

function TCustomModel.GetSfrMf6Selected: TObjectUsedEvent;
begin
  result := DoSfrMf6Selected;
end;

function TCustomModel.GetSftUsed: TObjectUsedEvent;
begin
  result := DoSftUsed
end;

function TCustomModel.GetShortestHorizontalBlockEdge(Layer, Row,
  Column: Integer): double;
begin
  if DisvUsed then
  begin
    result := DisvGrid.ShortestHorizontalBlockEdge[ZeroBasedID(Layer, Row, Column)];
  end
  else
  begin
    result := Grid.ShortestHorizontalBlockEdge[ZeroBasedID(Layer, Row, Column)];
  end;
end;

function TCustomModel.GetShouldKyBeDeterminedFromAnisotropy: TCheckUsageEvent;
begin
  result := DoShouldKyBeDeterminedFromAnisotropy;
end;

function TCustomModel.GetShouldKzBeDeterminedFromAnisotropy: TCheckUsageEvent;
begin
  result := DoShouldKzBeDeterminedFromAnisotropy;
end;

function TCustomModel.GetSideContourDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        if Grid <> nil then
        begin
          result := Grid.SideContourDataSet;
        end
        else
        begin
          result := nil;
        end;
      end;
    msModflow2015:
      begin
        if Grid <> nil then
        begin
          result := Grid.SideContourDataSet;
        end
        else
        begin
          result := nil
        end;
      end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetSideDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        result := Grid.SideDataSet;
      end;
    msModflow2015:
      begin
        if Grid <> nil then
        begin
          result := Grid.SideDataSet;
        end
        else
        begin
          result := nil
        end;
      end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetSoilIDUsed: TObjectUsedEvent;
begin
  result := DoSoilIDUsed;
end;

function TCustomModel.GetSolidSolutionUsed: TObjectUsedEvent;
begin
  result := DoSolidSolutionUsed;
end;

function TCustomModel.GetSpecificStorageUsed: TObjectUsedEvent;
begin
  result := DoSpecificStorageUsed;
end;

function TCustomModel.GetSpecificYieldUsed: TObjectUsedEvent;
begin
  result := DoSpecificYieldUsed;
end;

function TCustomModel.GetStorageSelected: TObjectUsedEvent;
begin
  Result := DoStorageSelected;
end;

function TCustomModel.GetSurfaceKUsed: TObjectUsedEvent;
begin
  result := DoSurfaceKUsed;
end;

function TCustomModel.GetSurfacesUsed: TObjectUsedEvent;
begin
  result := DoSurfacesUsed;
end;

function TCustomModel.GetSutra3DModel: TObjectUsedEvent;
begin
  result := DoSutra3DModel;
end;

function TCustomModel.GetSutra4EnergyOrSorptionUsed: TObjectUsedEvent;
begin
  result := DoSutra4EnergyOrSorptionUsed
end;

function TCustomModel.GetSutra4EnergyUsed: TObjectUsedEvent;
begin
  result := DoSutra4EnergyUsed;
end;

function TCustomModel.GetSutra4FreezingUsed: TObjectUsedEvent;
begin
  result := DoSutra4FreezingUsed;
end;

function TCustomModel.GetSutra4ProductionUsed: TObjectUsedEvent;
begin
  result := DoSutra4ProductionUsed;
end;

function TCustomModel.GetSutra4SoluteUsed: TObjectUsedEvent;
begin
  result := DoSutra4SoluteUsed;
end;

function TCustomModel.GetSutra4Used: TObjectUsedEvent;
begin
  result := DoSutra4Used;
end;

function TCustomModel.GetSutraConcentrationUsed: TObjectUsedEvent;
begin
  result := DoSutraConcentrationUsed
end;

function TCustomModel.GetSutraHydraulicConductivityUsed: TObjectUsedEvent;
begin
  result := DoSutraHydraulicConductivityUsed;
end;

function TCustomModel.GetSutraLakeBottomUsed: TObjectUsedEvent;
begin
  result := DoSutraLakeBottomUsed;
end;

function TCustomModel.GetSutraLakesUsed: Boolean;
begin
  result := (ModelSelection in [msSutra30, msSutra40])
          and SutraOptions.LakeOptions.UseLakes;
end;

function TCustomModel.GetSutraLakeUsed: TObjectUsedEvent;
begin
  result := DoSutraLakeUsed;
end;

function TCustomModel.GetSutraMesh: TSutraMesh3D;
begin
  if FSutraMesh = nil then
  begin
    FSutraMesh := TSutraMesh3D.Create(self);
    FSutraMesh.OnMeshTypeChanged := frmGoPhast.SutraMeshTypeChanged;
    if not (csLoading in ComponentState) then
    begin
      if Self is TPhastModel then
      begin
        TPhastModel(Self).SutraLayerStructure.Loaded;
      end;
    end;
  end;
  result := FSutraMesh;
end;

function TCustomModel.GetSutraMiddleHydraulicConductivityUsed: TObjectUsedEvent;
begin
  result := DoSutraMiddleHydraulicConductivityUsed;
end;

function TCustomModel.GetSutraMiddlePermeabilityUsed: TObjectUsedEvent;
begin
  result := DoSutraMiddlePermeabilityUsed;
end;

function TCustomModel.GetSutraPermeabilityUsed: TObjectUsedEvent;
begin
  result := DoSutraPermeabilityUsed;
end;

function TCustomModel.GetSutraTemperatureUsed: TObjectUsedEvent;
begin
  result := DoSutraTemperatureUsed;
end;

function TCustomModel.GetSutraThicknessUsed: TObjectUsedEvent;
begin
  result := DoSutraThicknessUsed;
end;

function TCustomModel.GetSutraUnsatRegionUsed: TObjectUsedEvent;
begin
  result := DoSutraUnsatRegionUsed;
end;

function TCustomModel.GetSutraUsed: TObjectUsedEvent;
begin
  result := DoSutraUsed;
end;

function TCustomModel.GetSwtOffsetsUsed: TObjectUsedEvent;
begin
  result := DoSwtOffsetsUsed;
end;

function TCustomModel.GetSwtSelected: TObjectUsedEvent;
begin
  result := DoSwtSelected;
end;

function TCustomModel.GetSwtSpecifiedUsed: TObjectUsedEvent;
begin
  result := DoSwtSpecifiedUsed;
end;

procedure TCustomModel.Clear;
begin
  FClearing := True;
  try
    InternalClear;
  finally
    FClearing := False;
  end;
end;

procedure TCustomModel.ClearExpressionsAndVariables;
begin
  rpTopFormulaCompiler.ClearExpressions;
  rpTopFormulaCompiler.ClearVariables;
  rpFrontFormulaCompiler.ClearExpressions;
  rpFrontFormulaCompiler.ClearVariables;
  rpSideFormulaCompiler.ClearExpressions;
  rpSideFormulaCompiler.ClearVariables;
  rpThreeDFormulaCompiler.ClearExpressions;
  rpThreeDFormulaCompiler.ClearVariables;
  rpTopFormulaCompilerNodes.ClearExpressions;
  rpTopFormulaCompilerNodes.ClearVariables;
  rpFrontFormulaCompilerNodes.ClearExpressions;
  rpFrontFormulaCompilerNodes.ClearVariables;
  rpSideFormulaCompilerNodes.ClearExpressions;
  rpSideFormulaCompilerNodes.ClearVariables;
  rpThreeDFormulaCompilerNodes.ClearExpressions;
  rpThreeDFormulaCompilerNodes.ClearVariables;
end;

function TCustomModel.Farm4ProcessUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected;
end;

function TCustomModel.DoFarmProcess4SteadyCropsUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.IsSelected
    and (ModflowPackages.FarmLandUse.CropLocation = rstStatic)
    and (ModflowPackages.FarmLandUse.LandUseOption = luoSingle);
    ;
end;

function TCustomModel.DoFarmProcess4SteadyFarmsUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and not (ModflowPackages.FarmProcess4.Farms.FarmOption = foTransient);
end;

function TCustomModel.DoFarmProcess4SteadyPrecipUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and (ModflowPackages.FarmClimate4.StaticPrecipUsed(Sender));
end;


function TCustomModel.DoFarmProcess4SteadArrayAddedDemandRunoffSplitUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmProcess4.SteadyArrayAddedDemandRunoffSplitDisplayUsed(nil);
end;

function TCustomModel.DoFarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmProcess4.SteadyArrayBarePrecipitationConsumptionFractionDisplayUsed(nil);
end;

function TCustomModel.DoFarmProcess4SteadArrayBareRunoffFractionUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmProcess4.SteadyArrayBareRunoffFractionDisplayUsed(nil);
end;

function TCustomModel.DoFarmProcess4SteadArrayEfficiencyImprovementUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmProcess4.SteadyArrayEfficiencyImprovmentUsed(nil);
end;

function TCustomModel.DoFarmProcess4SteadArrayEfficiencyUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmProcess4.SteadyArrayEfficiencyUsed;
end;


function TCustomModel.DoFarmProcess4SteadyRefETUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and (ModflowPackages.FarmClimate4.StaticEvapUsed(Sender));
end;

function TCustomModel.FarmProcess4TransientAddedDemandIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientAddedDemandArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientAddedDemandMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientAddedDemandMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientAddedDemandRunoffSplitArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.TransientArrayAddedDemandRunoffSplitDisplayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientBareEvapArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.TransientBareEvapUsed(nil);
end;

function TCustomModel.FarmProcess4TransientBarePrecipitationConsumptionFractionArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.TransientArrayBarePrecipitationConsumptionFractionDisplayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientBareRunoffFractionArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.TransientArrayBareRunoffFractionDisplayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientConsumptiveUseIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientConsumptiveUseArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientConsumptiveUseMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientConsumptiveUseMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientCropCoefficientIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientCropCoefficientarrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientCropCoefficientMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientCropCoefficientMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientCropsUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.IsSelected
    and (ModflowPackages.FarmLandUse.CropLocation = rstTransient)
    and (ModflowPackages.FarmLandUse.LandUseOption = luoSingle);
end;

function TCustomModel.FarmProcess4TransientDirectRechargeArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.TransientDirectRechargeUsed(nil);
end;

function TCustomModel.FarmProcess4TransientEfficiencyArrayUsed(
  Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and FarmProcess4TransientEfficiencyArrayIsSelected
end;

function TCustomModel.FarmProcess4TransientEfficiencyImprovementArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.TransientArrayEfficiencyImprovementUsed(nil);
end;

function TCustomModel.FarmProcess4TransientEvaporationIrrigationFractionIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientEvaporationIrrigationFractionArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientEvaporationIrrigationFractionMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientEvaporationIrrigationFractionMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientFarmsUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and (ModflowPackages.FarmProcess4.Farms.FarmOption = foTransient);
end;

function TCustomModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientFractionOfIrrigToSurfaceWaterArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientFractionOfIrrigToSurfaceWaterMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientFractionOfIrrigToSurfaceWaterMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientFractionOfPrecipToSurfaceWaterArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientFractionOfPrecipToSurfaceWaterMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientFractionOfPrecipToSurfaceWaterMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientCropHasSalinityDemandIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.IsSelected
    and ModflowPackages.FarmSalinityFlush.TransientCropHasSalinityDemandArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientCropHasSalinityDemandMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.IsSelected
    and ModflowPackages.FarmSalinityFlush.TransientCropHasSalinityDemandMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientIrrigationIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientIrrigationArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientIrrigationMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientIrrigationMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientLandUseAreaFractionIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientLandUseAreaFractionArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientLandUseAreaFractionMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientLandUseAreaFractionMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientNrdInfilLocIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmSurfaceWater4.TransientNrdInfilLocationUsed(nil);
end;

function TCustomModel.FarmProcess4TransientPrecipPotConsumptionArrayIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.TransientPrecipPotConsumptionUsed(nil);
end;

function TCustomModel.FarmProcess4TransientRootDepthIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientRootDepthArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientRootDepthMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientRootDepthMultArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientTranspirationFractionIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientTranspirationFractionArrayUsed(nil);
end;

function TCustomModel.FarmProcess4TransientTranspirationFractionMultIsSelected: Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.TransientTranspirationFractionMultArrayUsed(nil);
end;

function TCustomModel.FarmProcessUsed(Sender: TObject): boolean;
begin
  result := DoModflowUsed(Sender) and ModflowPackages.FarmProcess.IsSelected;
end;

function TCustomModel.FhbIsSelected: Boolean;
begin
  result := ModflowPackages.FhbPackage.IsSelected;
end;

procedure TCustomModel.FillObsInterfaceItemList(List: TObservationInterfaceList;
  IncludeComparisons: Boolean = False);
var
  ItemIndex: Integer;
  AnItem: IObservationItem;
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  HeadObservations: THobBoundary;
  FluxIndex: Integer;
  FluxObsGroup: TFluxObservationGroup;
  ObsList: TObservationList;
  ObsIndex: Integer;
begin
  ObsList := TObservationList.Create;
  try
    FillObsItemList(ObsList, IncludeComparisons);
    List.Capacity := ObsList.Count + FInputObservations.Count;
    for ItemIndex := 0 to ObsList.Count - 1 do
    begin
      AnItem := ObsList[ItemIndex];
      List.Add(AnItem);
    end;
    for ItemIndex := 0 to FInputObservations.Count - 1 do
    begin
      AnItem := FInputObservations[ItemIndex];
      List.Add(AnItem);
    end;
    if ModelSelection in Modflow2005Selection then
    begin
      if ModflowPackages.HobPackage.IsSelected then
      begin
        for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
        begin
          AScreenObject := ScreenObjects[ScreenObjectIndex];
          if AScreenObject.Deleted then
          begin
            Continue;
          end;
          HeadObservations := AScreenObject.ModflowHeadObservations;
          if HeadObservations <> nil then
          begin
            for ObsIndex := 0 to HeadObservations.Values.Count - 1 do
            begin
              AnItem := HeadObservations.Values[ObsIndex];
              List.Add(AnItem);
            end;
          end;
        end;
      end;

      if ModflowPackages.ChobPackage.IsSelected then
      begin
        for FluxIndex := 0 to HeadFluxObservations.Count - 1 do
        begin
          FluxObsGroup := HeadFluxObservations[FluxIndex];
          for ObsIndex := 0 to FluxObsGroup.ObservationTimes.Count - 1 do
          begin
            AnItem := FluxObsGroup.ObservationTimes[ObsIndex];
            List.Add(AnItem);
          end;
        end;
      end;

      if ModflowPackages.DrobPackage.IsSelected then
      begin
        for FluxIndex := 0 to DrainObservations.Count - 1 do
        begin
          FluxObsGroup := DrainObservations[FluxIndex];
          for ObsIndex := 0 to FluxObsGroup.ObservationTimes.Count - 1 do
          begin
            AnItem := FluxObsGroup.ObservationTimes[ObsIndex];
            List.Add(AnItem);
          end;
        end;
      end;

      if ModflowPackages.GbobPackage.IsSelected then
      begin
        for FluxIndex := 0 to GhbObservations.Count - 1 do
        begin
          FluxObsGroup := GhbObservations[FluxIndex];
          for ObsIndex := 0 to FluxObsGroup.ObservationTimes.Count - 1 do
          begin
            AnItem := FluxObsGroup.ObservationTimes[ObsIndex];
            List.Add(AnItem);
          end;
        end;
      end;

      if ModflowPackages.RvobPackage.IsSelected then
      begin
        for FluxIndex := 0 to RiverObservations.Count - 1 do
        begin
          FluxObsGroup := RiverObservations[FluxIndex];
          for ObsIndex := 0 to FluxObsGroup.ObservationTimes.Count - 1 do
          begin
            AnItem := FluxObsGroup.ObservationTimes[ObsIndex];
            List.Add(AnItem);
          end;
        end;
      end;

      if ModflowPackages.StobPackage.IsSelected then
      begin
        for FluxIndex := 0 to StreamObservations.Count - 1 do
        begin
          FluxObsGroup := StreamObservations[FluxIndex];
          for ObsIndex := 0 to FluxObsGroup.ObservationTimes.Count - 1 do
          begin
            AnItem := FluxObsGroup.ObservationTimes[ObsIndex];
            List.Add(AnItem);
          end;
        end;
      end;
    end;
  finally
    ObsList.Free;
  end;
end;


procedure TCustomModel.FillObsItemList(List: TObservationList;
  IncludeComparisons: Boolean = False);
var
  ObjectIndex: Integer;
  AScreenObject: TScreenObject;
  Mnw2Observations: TMnw2Observations;
  ObsIndex: Integer;
  AnObs: TCustomObservationItem;
  LakObservations: TLakeObservations;
  SfrObservations: TSfrObservations;
  SutraStateObs: TSutraStateObservations;
  GroupIndex: Integer;
  FluxGroup: TCustomSutraFluxObservationGroup;
  ItemIndex: Integer;
  Item: TCustomObservationItem;
  CalibrationObservations: TMf6CalibrationObservations;
  ModflowSubObservations: TSubObservations;
  ModflowSwtObservations: TSwtObservations;
  ObservationGroup: TCustomSutraFluxObservations;
  ObsComparisons: TGlobalObservationComparisons;
  ModflowSwiObservations: TSwiObsBoundary;
begin
  for ObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[ObjectIndex];
    if AScreenObject.Deleted then
    begin
      Continue;
    end;

    if (ModelSelection in ModflowSelection) then
    begin
      if ModelSelection = msModflow2015 then
      begin
        if (AScreenObject.Modflow6Obs <> nil)
          and AScreenObject.Modflow6Obs.Used then
        begin
          CalibrationObservations :=
            AScreenObject.Modflow6Obs.CalibrationObservations;
          for ObsIndex := 0 to CalibrationObservations.Count - 1 do
          begin
            AnObs := CalibrationObservations[ObsIndex];
            List.Add(AnObs);
          end;
          if IncludeComparisons then
          begin
            for ObsIndex := 0 to CalibrationObservations.Comparisons.Count - 1 do
            begin
              AnObs := CalibrationObservations.Comparisons[ObsIndex];
              List.Add(AnObs);
            end;
          end;
        end;
      end
      else
      begin
        if ModflowPackages.Mnw2Package.IsSelected then
        begin
          if (AScreenObject.ModflowMnw2Boundary <> nil)
            and AScreenObject.ModflowMnw2Boundary.Used
            and (AScreenObject.ModflowMnw2Boundary.Observations.Count > 0) then
          begin
            Mnw2Observations := AScreenObject.ModflowMnw2Boundary.Observations;
            for ObsIndex := 0 to Mnw2Observations.Count - 1 do
            begin
              AnObs := Mnw2Observations[ObsIndex];
              List.Add(AnObs);
            end;
            if IncludeComparisons then
            begin
              for ObsIndex := 0 to Mnw2Observations.Comparisons.Count - 1 do
              begin
                AnObs := Mnw2Observations.Comparisons[ObsIndex];
                List.Add(AnObs);
              end;
            end;
          end;
        end;

        if ModflowPackages.LakPackage.IsSelected then
        begin
          if (AScreenObject.ModflowLakBoundary <> nil)
            and AScreenObject.ModflowLakBoundary.Used
            and (AScreenObject.ModflowLakBoundary.Observations.Count > 0) then
          begin
            LakObservations := AScreenObject.ModflowLakBoundary.Observations;
            for ObsIndex := 0 to LakObservations.Count - 1 do
            begin
              AnObs := LakObservations[ObsIndex];
              List.Add(AnObs);
            end;
            if IncludeComparisons then
            begin
              for ObsIndex := 0 to LakObservations.Comparisons.Count - 1 do
              begin
                AnObs := LakObservations.Comparisons[ObsIndex];
                List.Add(AnObs);
              end;
            end;
          end;
        end;

        if ModflowPackages.SfrPackage.IsSelected then
        begin
          if (AScreenObject.ModflowSfrBoundary <> nil)
            and AScreenObject.ModflowSfrBoundary.Used
            and (AScreenObject.ModflowSfrBoundary.Observations.Count > 0) then
          begin
            SfrObservations := AScreenObject.ModflowSfrBoundary.Observations;
            for ObsIndex := 0 to SfrObservations.Count - 1 do
            begin
              AnObs := SfrObservations[ObsIndex];
              List.Add(AnObs);
            end;
            if IncludeComparisons then
            begin
              for ObsIndex := 0 to SfrObservations.Comparisons.Count - 1 do
              begin
                AnObs := SfrObservations.Comparisons[ObsIndex];
                List.Add(AnObs);
              end;
            end;
          end;

          if (AScreenObject.ModflowStreamGage <> nil)
            and AScreenObject.ModflowStreamGage.Used
            and (AScreenObject.ModflowStreamGage.Observations.Count > 0) then
          begin
            SfrObservations := AScreenObject.ModflowStreamGage.Observations;
            for ObsIndex := 0 to SfrObservations.Count - 1 do
            begin
              AnObs := SfrObservations[ObsIndex];
              List.Add(AnObs);
            end;
            if IncludeComparisons then
            begin
              for ObsIndex := 0 to SfrObservations.Comparisons.Count - 1 do
              begin
                AnObs := SfrObservations.Comparisons[ObsIndex];
                List.Add(AnObs);
              end;
            end;
          end;
        end;

        if ModflowPackages.SubPackage.IsSelected  then
        begin
          if (AScreenObject.ModflowSubObservations <> nil)
            and AScreenObject.ModflowSubObservations.Used
            and (AScreenObject.ModflowSubObservations.Count > 0) then
          begin
            ModflowSubObservations := AScreenObject.ModflowSubObservations;
            for ObsIndex := 0 to ModflowSubObservations.Count - 1 do
            begin
              AnObs := ModflowSubObservations[ObsIndex];
              List.Add(AnObs);
            end;
            if IncludeComparisons then
            begin
              for ObsIndex := 0 to ModflowSubObservations.Comparisons.Count - 1 do
              begin
                AnObs := ModflowSubObservations.Comparisons[ObsIndex];
                List.Add(AnObs);
              end;
            end;
          end;
        end;

        if ModflowPackages.SwtPackage.IsSelected  then
        begin
          if (AScreenObject.ModflowSwtObservations <> nil)
            and AScreenObject.ModflowSwtObservations.Used
            and (AScreenObject.ModflowSwtObservations.Count > 0) then
          begin
            ModflowSwtObservations := AScreenObject.ModflowSwtObservations;
            for ObsIndex := 0 to ModflowSwtObservations.Count - 1 do
            begin
              AnObs := ModflowSwtObservations[ObsIndex];
              List.Add(AnObs);
            end;
            if IncludeComparisons then
            begin
              for ObsIndex := 0 to ModflowSwtObservations.Comparisons.Count - 1 do
              begin
                AnObs := ModflowSwtObservations.Comparisons[ObsIndex];
                List.Add(AnObs);
              end;
            end;
          end;
        end;

        if ModflowPackages.SwiPackage.IsSelected  then
        begin
          if (AScreenObject.ModflowSwiObservations <> nil)
            and AScreenObject.ModflowSwiObservations.Used
            and (AScreenObject.ModflowSwiObservations.Values.Count > 0) then
          begin
            ModflowSwiObservations := AScreenObject.ModflowSwiObservations;
            for ObsIndex := 0 to ModflowSwiObservations.Values.Count - 1 do
            begin
              AnObs := (ModflowSwiObservations.Values.Items[ObsIndex]
                as TSwiObsItem).PestObsItem;
              List.Add(AnObs);
            end;
          end;
        end;
      end;
    end;

    if (ModelSelection in SutraSelection) then
    begin
      SutraStateObs := AScreenObject.SutraBoundaries.SutraStateObs;
      if SutraStateObs.Used and (SutraStateObs.Count > 0)then
      begin
        for ObsIndex := 0 to SutraStateObs.Count - 1 do
        begin
          AnObs := SutraStateObs[ObsIndex];
          List.Add(AnObs);
        end;
        if IncludeComparisons then
        begin
          for ObsIndex := 0 to SutraStateObs.Comparisons.Count - 1 do
          begin
            AnObs := SutraStateObs.Comparisons[ObsIndex];
            List.Add(AnObs);
          end;
        end;
      end;
    end;

  end;

  if (ModelSelection in SutraSelection) then
  begin
    for GroupIndex := 0 to SutraFluxObs.SpecPres.Count - 1 do
    begin
      FluxGroup := SutraFluxObs.SpecPres[GroupIndex];
      ObservationGroup := FluxGroup.ObservationGroup;
      for ItemIndex := 0 to ObservationGroup.Count - 1 do
      begin
        Item := ObservationGroup[ItemIndex];
        List.Add(Item);
      end;
      if IncludeComparisons then
      begin
        for ObsIndex := 0 to ObservationGroup.Comparisons.Count - 1 do
        begin
          AnObs := ObservationGroup.Comparisons[ObsIndex];
          List.Add(AnObs);
        end;
      end;
    end;
    for GroupIndex := 0 to SutraFluxObs.FluidFlow.Count - 1 do
    begin
      FluxGroup := SutraFluxObs.FluidFlow[GroupIndex];
      ObservationGroup := FluxGroup.ObservationGroup;
      for ItemIndex := 0 to ObservationGroup.Count - 1 do
      begin
        Item := ObservationGroup[ItemIndex];
        List.Add(Item);
      end;
      if IncludeComparisons then
      begin
        for ObsIndex := 0 to ObservationGroup.Comparisons.Count - 1 do
        begin
          AnObs := ObservationGroup.Comparisons[ObsIndex];
          List.Add(AnObs);
        end;
      end;
    end;
  end;

  if IncludeComparisons then
  begin
    ObsComparisons := nil;
    if frmGoPhast.ModelSelection = msModflow2015 then
    begin
      ObsComparisons := frmGoPhast.PhastModel.Modflow6GlobalObservationComparisons;
    end
    else if frmGoPhast.ModelSelection in ModflowSelection then
    begin
      ObsComparisons := frmGoPhast.PhastModel.ModflowGlobalObservationComparisons;
    end
    else if frmGoPhast.ModelSelection in SutraSelection then
    begin
      ObsComparisons := frmGoPhast.PhastModel.SutraGlobalObservationComparisons;
    end
    else
    begin
      Assert(False);
    end;
    for ObsIndex := 0 to ObsComparisons.Count - 1 do
    begin
      AnObs := ObsComparisons[ObsIndex];
      List.Add(AnObs);
    end;
  end;

end;

procedure TCustomModel.FillCompilerList(CompilerList: TList);
begin
  CompilerList.Add(rpFrontFormulaCompiler);
  CompilerList.Add(rpFrontFormulaCompilerNodes);
  CompilerList.Add(rpSideFormulaCompiler);
  CompilerList.Add(rpSideFormulaCompilerNodes);
  CompilerList.Add(rpThreeDFormulaCompiler);
  CompilerList.Add(rpThreeDFormulaCompilerNodes);
  CompilerList.Add(rpTopFormulaCompiler);
  CompilerList.Add(rpTopFormulaCompilerNodes);
end;

procedure TCustomModel.FillFluxObsList(List: TFluxObservationList);
var
  index: Integer;
begin
  if not (ModelSelection in Modflow2005Selection) then
  begin
    Exit;
  end;
  if ModflowPackages.ChobPackage.IsSelected then
  begin
    for index := 0 to HeadFluxObservations.Count - 1 do
    begin
      List.Add(HeadFluxObservations[index]);
    end;
  end;

  if ModflowPackages.DrobPackage.IsSelected then
  begin
    for index := 0 to DrainObservations.Count - 1 do
    begin
      List.Add(DrainObservations[index]);
    end;
  end;

  if ModflowPackages.GbobPackage.IsSelected then
  begin
    for index := 0 to GhbObservations.Count - 1 do
    begin
      List.Add(GhbObservations[index]);
    end;
  end;

  if ModflowPackages.RvobPackage.IsSelected then
  begin
    for index := 0 to RiverObservations.Count - 1 do
    begin
      List.Add(RiverObservations[index]);
    end;
  end;

  if ModflowPackages.StobPackage.IsSelected then
  begin
    for index := 0 to StreamObservations.Count - 1 do
    begin
      List.Add(StreamObservations[index]);
    end;
  end;
end;

procedure TCustomModel.FillHobList(List: THobList);
var
  ScreenObjectIndex: Integer;
  AScreemObject: TScreenObject;
  Hob: THobBoundary;
  ItemIndex: Integer;
  HobItem: THobItem;
begin
  if (ModelSelection in Modflow2005Selection)
    and ModflowPackages.HobPackage.IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreemObject := ScreenObjects[ScreenObjectIndex];
      if AScreemObject.Deleted then
      begin
        Continue;
      end;
      Hob := AScreemObject.ModflowHeadObservations;
      if Hob <> nil then
      begin
        for ItemIndex := 0 to Hob.Values.Count - 1 do
        begin
          HobItem := Hob.Values.Items[ItemIndex] as THobItem;
          List.Add(HobItem);
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateHobGroupNames;
var
  ScreenObjectIndex: Integer;
  AScreemObject: TScreenObject;
  Hob: THobBoundary;
  HobItem: THobItem;
  ItemIndex: Integer;
begin
  for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    AScreemObject := ScreenObjects[ScreenObjectIndex];
    if AScreemObject.Deleted then
    begin
      Continue;
    end;
    Hob := AScreemObject.ModflowHeadObservations;
    if Hob <> nil then
    begin
      for ItemIndex := 0 to Hob.Values.Count - 1 do
      begin
        HobItem := Hob.Values.Items[ItemIndex] as THobItem;
        if HobItem.ObservationGroup = '' then
        begin
          if (ItemIndex > 0) and (Hob.MultiObsMethod = momHeadAndDrawdown) then
          begin
            HobItem.ObservationGroup := StrHeadChanges;
          end
          else
          begin
            HobItem.ObservationGroup := StrHeads;
          end;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.FinalizePvalAndTemplate(FileName: string);
var
  TemplateFileName: string;
  PValFileName: string;
  Comment: string;
  FirstLine: string;
  UseWithMF2005: Boolean;
begin
  if (FPValFile.Count > 0) or (FPestPValFile.Count > 0) or PestUsed then
  begin
    UseWithMF2005 := FPValFile.Count > 0;
    if PackageGeneratedExternally('PVAL') then
    begin
      Exit;
    end;
    FirstLine := IntToStr(FPValFile.Count);
    if (ModelSelection in [msModflowFmp, msModflowOwhm2])
      and ModflowOutputControl.PrintInputArrays then
    begin
      FirstLine := FirstLine + ' PROPPRINT';
    end;

    FPValFile.Insert(0, FirstLine);
    FPvalTemplate.Insert(0, FirstLine);

    Comment := '# PVAL file created on ' + DateToStr(Now) + ' by '
      + ProgramName + ' version ' + IModelVersion + '.';
    FPValFile.Insert(0, Comment);
    FPvalTemplate.Insert(0, Comment);

    FPValFile.AddStrings(FPestPValFile);
    FPvalTemplate.AddStrings(FPestPvalTemplate);

    FPvalTemplate.Insert(0, 'jtf ' + UcodeDelimiter);

    PValFileName := ChangeFileExt(FileName, StrPvalExt);
    TemplateFileName := ChangeFileExt(FileName, StrJtf);

    FPValFile.WriteBOM := False;
    FPValFile.SaveToFile(PValFileName);
    FPvalTemplate.WriteBOM := False;
    FPvalTemplate.SaveToFile(TemplateFileName);

    if UseWithMF2005 and (ModelSelection in Modflow2005Selection) then
    begin
      TCustomModflowWriter.WriteToNameFile('PVAL',
        UnitNumbers.UnitNumber(StrPval), PValFileName, foInput, self);
    end;

    AddModelInputFile(PValFileName);
    AddModelInputFile(TemplateFileName);

    if PestUsed then
    begin
      TemplateFileName := ChangeFileExt(FileName, StrPtf);
      // hard coded to used UcodeDelimiter instead of PestProperties.TemplateCharacter.
//      FTemplate[0] := 'ptf ' + PestProperties.TemplateCharacter;
      FPvalTemplate[0] := 'ptf ' + UcodeDelimiter;
      FPvalTemplate.SaveToFile(TemplateFileName);
      AddModelInputFile(TemplateFileName);
    end;
  end;
end;

procedure TPhastModel.SetGeoRef(const Value: TGeoRef);
begin
  FGeoRef.Assign(Value);
end;

procedure TPhastModel.SetGlobalVariables(const Value: TGlobalVariables);
begin
  SetGlobalVariablesI(Value);
end;

procedure TPhastModel.SetGlobalVariablesI(const Value: IGlobalVariables);
var
  OldVariables: TStringList;
  NewVariables: TStringList;
  CompilerList: TList;
  Variable: IGlobalVariable;
  OldVariable: IGlobalVariable;
  NewVariable: IGlobalVariable;
  Index: integer;
  NewIndex: integer;
  ChildIndex: integer;
  ChildModel: TChildModel;
  procedure RemoveVariable(Variable: IGlobalVariable);
  var
    Index: Integer;
    Compiler: TRbwParser;
    VariableIndex: integer;
    CompilerVariable: TCustomVariable;
  begin
    for Index := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[Index];
      VariableIndex := Compiler.IndexOfVariable(Variable.Name);
      Assert(VariableIndex >= 0);
//      if VariableIndex >= 0 then
      begin
        CompilerVariable := Compiler.Variables[VariableIndex] as TCustomVariable;
        Compiler.RemoveVariable(CompilerVariable);
      end;
    end;
    Variable.UpToDate := False;
  end;
  procedure UpdateGlobalVariable(Variable: IGlobalVariable);
  var
    CompilerIndex: Integer;
    Compiler: TRbwParser;
    VariableIndex: integer;
    CompilerVariable: TCustomVariable;
    ValueChanged: boolean;
    RealVariable: TRealVariable;
    IntegerVariable: TIntegerVariable;
    BooleanVariable: TBooleanVariable;
    StringVariable: TStringVariable;
  begin
    ValueChanged := False;
    for CompilerIndex := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[CompilerIndex];
      VariableIndex := Compiler.IndexOfVariable(Variable.Name);
      if VariableIndex < 0 then
      begin
        case Variable.Format of
          rdtDouble:
            begin
              Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                Variable.RealValue, Variable.Name);
            end;
          rdtInteger:
            begin
              Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                Variable.IntegerValue, Variable.Name);
            end;
          rdtBoolean:
            begin
              Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                Variable.BooleanValue, Variable.Name);
            end;
          rdtString:
            begin
              Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                Variable.StringValue, Variable.Name);
            end;
          else Assert(False);
        end;
      end
      else
      begin
        CompilerVariable := Compiler.Variables[VariableIndex]
          as TCustomVariable;
        case Variable.Format of
          rdtDouble:
            begin
              RealVariable := CompilerVariable as TRealVariable;
              if (CompilerIndex = 0)
                and (RealVariable.Value <> Variable.RealValue) then
              begin
                ValueChanged := True;
              end;
              RealVariable.Value := Variable.RealValue;
            end;
          rdtInteger:
            begin
              IntegerVariable := CompilerVariable as TIntegerVariable;
              if (CompilerIndex = 0)
                and (IntegerVariable.Value <> Variable.IntegerValue) then
              begin
                ValueChanged := True;
              end;
              IntegerVariable.Value := Variable.IntegerValue;
            end;
          rdtBoolean:
            begin
              BooleanVariable := CompilerVariable as TBooleanVariable;
              if (CompilerIndex = 0)
                and (BooleanVariable.Value <> Variable.BooleanValue) then
              begin
                ValueChanged := True;
              end;
              BooleanVariable.Value := Variable.BooleanValue;
            end;
          rdtString:
            begin
              StringVariable := CompilerVariable as TStringVariable;
              if (CompilerIndex = 0)
                and (StringVariable.Value <> Variable.StringValue) then
              begin
                ValueChanged := True;
              end;
              StringVariable.Value := Variable.StringValue;
            end;
          else Assert(False);
        end;
      end;
    end;
    if ValueChanged then
    begin
      Variable.UpToDate := False;
      Variable.UpToDate := True;
    end;
  end;
begin
  NewVariables := TStringList.Create;
  try
    OldVariables := TStringList.Create;
    CompilerList := TList.Create;
    try
      FillCompilerList(CompilerList);
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          ChildModel.FillCompilerList(CompilerList);
        end;
      end;

      for Index := 0 to FGlobalVariables.Count - 1 do
      begin
        Variable := FGlobalVariables[Index];
        OldVariables.AddObject(UpperCase(Variable.Name), Variable as TObject);
      end;
      for Index := 0 to Value.Count - 1 do
      begin
        Variable := Value[Index];
        NewVariables.AddObject(UpperCase(Variable.Name), Variable as TObject);
      end;
      OldVariables.Sort;
      NewVariables.Sort;
      for Index := 0 to OldVariables.Count - 1 do
      begin
        NewIndex := NewVariables.IndexOf(OldVariables[Index]);
        if NewIndex < 0 then
        begin
          Variable := OldVariables.Objects[Index] as TGlobalVariable;
          RemoveVariable(Variable);
        end
        else
        begin
          OldVariable := OldVariables.Objects[Index] as TGlobalVariable;
          NewVariable := NewVariables.Objects[NewIndex] as TGlobalVariable;
          if OldVariable.Format <> NewVariable.Format then
          begin
            RemoveVariable(OldVariable);
          end;
        end;
      end;

      for Index := 0 to NewVariables.Count - 1 do
      begin
        Variable := NewVariables.Objects[Index] as TGlobalVariable;
        UpdateGlobalVariable(Variable);
      end;

    finally
      CompilerList.Free;
      OldVariables.Free;
    end;

  finally
    NewVariables.Free;
  end;

  FGlobalVariables.Assign(Value as TGlobalVariables);
end;

procedure TPhastModel.RefreshGlobalVariables(CompilerList: TList);
var
  Compiler: TRbwParser;
  Variable: IGlobalVariable;
  CompilerIndex: Integer;
  VariableIndex: Integer;
  VariablePosition: integer;
  ExistingVariable: TCustomValue;
  DataSetNames: TStringList;
  Index: integer;
  Item: TDataSetItem;
  ADataSet: TDataArray;
  SearchName: String;
begin
  DataSetNames := TStringList.Create;
  try
    for Index := 0 to FDataSetCollection.Count - 1 do
    begin
      Item := FDataSetCollection.Items[Index] as TDataSetItem;
      ADataSet := Item.FDataSet;
      SearchName := ADataSet.Name;
      DataSetNames.Add(SearchName);

      if SearchName = OldLongDispersivityName then
      begin
        DataSetNames.Add(OldLongDispersivityName);
      end
      else if SearchName = OldHorizontal_Transv_Dispersivity then
      begin
        DataSetNames.Add(OldHorizontal_Transv_Dispersivity);
      end
      else if SearchName = OldVertical_Transv_Dispersivity then
      begin
        DataSetNames.Add(OldVertical_Transv_Dispersivity);
      end;
    end;
    DataSetNames.CaseSensitive := False;
    DataSetNames.Sorted := True;

    for VariableIndex := GlobalVariablesI.Count - 1 downto 0 do
    begin
      Variable := GlobalVariablesI[VariableIndex];
      if DataSetNames.IndexOf(Variable.Name) >= 0 then
      begin
        frmErrorsAndWarnings.AddWarning(self, StrIllegalGlobalVaria,
          Format(StrAGlobalVariableNa, [Variable.Name]));
        GlobalVariablesI.Delete(VariableIndex);
      end;
    end;

    for CompilerIndex := 0 to CompilerList.Count - 1 do
    begin
      Compiler := CompilerList[CompilerIndex];
      for VariableIndex := 0 to GlobalVariablesI.Count - 1 do
      begin
        Variable := GlobalVariablesI[VariableIndex];
        VariablePosition := Compiler.IndexOfVariable(Variable.Name);
        if VariablePosition < 0 then
        begin
          case Variable.Format of
            rdtDouble:
              begin
                Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                  Variable.RealValue, Variable.Name);
              end;
            rdtInteger:
              begin
                Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                  Variable.IntegerValue, Variable.Name);
              end;
            rdtBoolean:
              begin
                Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                  Variable.BooleanValue, Variable.Name);
              end;
            rdtString:
              begin
                Compiler.CreateVariable(Variable.Name, StrGlobalVariables,
                  Variable.StringValue, Variable.Name);
              end;
          else
            Assert(False);
          end;
        end
        else
        begin
          ExistingVariable := Compiler.Variables[VariablePosition];
          case Variable.Format of
            rdtDouble: (ExistingVariable as TRealVariableClass).Value :=
              Variable.RealValue;
            rdtInteger: (ExistingVariable as TIntegerVariable).Value :=
              Variable.IntegerValue;
            rdtBoolean: (ExistingVariable as TBooleanVariable).Value :=
              Variable.BooleanValue;
            rdtString: (ExistingVariable as TStringVariableClass).Value :=
              Variable.StringValue;
            else Assert(False);
          end;
        end;

      end;
    end;
  finally
    DataSetNames.Free;
  end;
end;

procedure TPhastModel.CreateGlobalVariables;
var
  CompilerList: TList;
begin
  CompilerList := TList.Create;
  try
    FillCompilerList(CompilerList);
    RefreshGlobalVariables(CompilerList);
  finally
    CompilerList.Free;
  end;
end;

procedure TCustomModel.CreateVariables(const DataSet: TDataArray);
var
  TempCompiler: TRbwParser;
  Local3DCompiler: TRbwParser;
  VarIndex: integer;
  Variable: TCustomValue;
  LocalModel: TPhastModel;
  ChildIndex: Integer;
  ChildItem: TChildModelItem;
begin
  TempCompiler := GetCompiler(DataSet.Orientation,
    DataSet.EvaluatedAt);

  Local3DCompiler := nil;
  case DataSet.EvaluatedAt of
    eaBlocks:
      begin
        Local3DCompiler := rpThreeDFormulaCompiler;
      end;
    eaNodes:
      begin
        Local3DCompiler := rpThreeDFormulaCompilerNodes;
      end;
  else
    Assert(False);
  end;

  VarIndex := TempCompiler.IndexOfVariable(DataSet.Name);
  if VarIndex >= 0 then
  begin
    Variable := TempCompiler.Variables[VarIndex];
    if (Variable.ResultType <> DataSet.DataType) then
    begin
      TempCompiler.RemoveVariable(Variable as TCustomVariable);
      if TempCompiler <> Local3DCompiler then
      begin
        VarIndex := Local3DCompiler.IndexOfVariable(DataSet.Name);
        if VarIndex >= 0 then
        begin
          Variable := Local3DCompiler.Variables[VarIndex];
          Local3DCompiler.RemoveVariable(Variable as TCustomVariable);
        end;
      end;
      VarIndex := -1;
    end;
  end;
  if VarIndex < 0 then
  begin
    case DataSet.Datatype of
      rdtDouble:
        begin
          TempCompiler.CreateVariable(DataSet.Name,
            DataSet.FullClassification, 0.0, DataSet.DisplayName);
          if TempCompiler <> Local3DCompiler then
          begin
            Local3DCompiler.CreateVariable(DataSet.Name,
              DataSet.FullClassification, 0.0, DataSet.DisplayName);
          end;
        end;
      rdtInteger:
        begin
          TempCompiler.CreateVariable(DataSet.Name,
            DataSet.FullClassification, 0, DataSet.DisplayName);
          if TempCompiler <> Local3DCompiler then
          begin
            Local3DCompiler.CreateVariable(DataSet.Name,
              DataSet.FullClassification, 0, DataSet.DisplayName);
          end;
        end;
      rdtBoolean:
        begin
          TempCompiler.CreateVariable(DataSet.Name,
            DataSet.FullClassification, False, DataSet.DisplayName);
          if TempCompiler <> Local3DCompiler then
          begin
            Local3DCompiler.CreateVariable(DataSet.Name,
              DataSet.FullClassification, False, DataSet.DisplayName);
          end;
        end;
      rdtString:
        begin
          TempCompiler.CreateVariable(DataSet.Name,
            DataSet.FullClassification, '', DataSet.DisplayName);
          if TempCompiler <> Local3DCompiler then
          begin
            Local3DCompiler.CreateVariable(DataSet.Name,
              DataSet.FullClassification, '', DataSet.DisplayName);
          end;
        end;
    else
      Assert(False);
    end;
  end
  else
  begin
    Variable := TempCompiler.Variables[VarIndex];
    Assert(SameText(Variable.Name, DataSet.Name));
    Assert(Variable.ResultType = DataSet.DataType);
    Variable.Classification := DataSet.FullClassification;
    if TempCompiler <> Local3DCompiler then
    begin
      VarIndex := Local3DCompiler.IndexOfVariable(DataSet.Name);
      Variable := Local3DCompiler.Variables[VarIndex];
      Assert(SameText(Variable.Name, DataSet.Name));
      Assert(Variable.ResultType = DataSet.DataType);
      Variable.Classification := DataSet.FullClassification;
    end;
  end;
  if self is TPhastModel then
  begin
    LocalModel := TPhastModel(self);
    for ChildIndex := 0 to LocalModel.ChildModels.Count - 1 do
    begin
      ChildItem := LocalModel.ChildModels[ChildIndex];
      if ChildItem.ChildModel <> nil then
      begin
        ChildItem.ChildModel.CreateVariables(DataSet);
      end;
    end;
  end;
end;

function TCustomModel.DoCropCoefficientUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticCropCoefficientArrayUsed(nil);
end;

function TCustomModel.CropCount: integer;
begin
  result := FmpCrops.Count;
end;

procedure TCustomModel.CrossSectionChanged(Sender: TObject);
begin
  if (csDestroying in ComponentState) or Clearing then
  begin
    Exit;
  end;
  Assert(Sender = FCrossSection);
  if not FCrossSection.UpToDate then
  begin
    FCrossSection.UpToDate := True;
    if Assigned(FOnCrossSectionChanged) then
    begin
      FOnCrossSectionChanged(self);
    end;
  end;
end;

function TCustomModel.DoCSubDataSetsUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = MsModflow2015)
    and (ModflowPackages.CSubPackage.IsSelected)
end;

function TCustomModel.DoCSubInitialElasticStorageUsed(Sender: TObject): boolean;
begin
  result := DoCSubDataSetsUsed(Sender)
    and (ModflowPackages.CSubPackage.CompressionMethod = coElasticSpecificStorage);
end;

function TCustomModel.DoCSubInitialRecompressionIndexUsed(
  Sender: TObject): boolean;
begin
  result := DoCSubDataSetsUsed(Sender)
    and (ModflowPackages.CSubPackage.CompressionMethod = coRecompression);
end;

function TCustomModel.CSubInterbedDataArrayUsed(Sender: TObject): boolean;
begin
  result := DoCSubDataSetsUsed(Sender) and ModflowPackages.CSubPackage.Interbeds.DataArrayUsed(Sender as TDataArray);
end;

procedure TCustomModel.RemoveVariables(const DataSet: TDataArray);
begin
  RemoveVariables(DataSet.Name, DataSet.Orientation,
    DataSet.EvaluatedAt);
end;

procedure TCustomModel.SetEdgeDisplay(const Value: TCustomModflowGridEdgeDisplay);
begin
  FEdgeDisplay := Value;
end;

procedure TCustomModel.DoOnNodeActiveDataSetChanged(Sender: TObject);
var
  NodeActiveDataArray: TDataArray;
begin
  if FUpdatingMeshElevations then
  begin
    Exit;
  end;
  NodeActiveDataArray := Sender as TDataArray;
  Assert(NodeActiveDataArray <> nil);
  Assert(NodeActiveDataArray.Name = kNodeActive);
  if (not NodeActiveDataArray.UpToDate) and (SutraMesh <> nil) then
  begin
    FUpdatingMeshElevations := True;
//    SutraMesh.BeginUpdate;
    try
      SutraMesh.ElevationsNeedUpdating := True;
//      SutraMesh.ThreeDGridObserver.StopsTalkingTo(NodeActiveDataArray);
      try
//        SutraMesh.CheckUpdateElevations;
      finally
//        SutraMesh.ThreeDGridObserver.TalksTo(NodeActiveDataArray);

      end;
    finally
//      SutraMesh.EndUpdate;

      SutraMesh.NeedToRecalculateTopColors := True;
      SutraMesh.NeedToRecalculateFrontColors := True;
      frmGoPhast.frameTopView.ZoomBox.InvalidateImage32;
      frmGoPhast.frameFrontView.ZoomBox.InvalidateImage32;
      DiscretizationChanged;
      FUpdatingMeshElevations := False;
    end;
  end;
end;

procedure TCustomModel.DoOnActiveDataSetChanged(Sender: TObject);
var
  ActiveDataArray: TDataArray;
  DataArray: TDataArray;
begin
  ActiveDataArray := Sender as TDataArray;
  Assert(ActiveDataArray <> nil);
  Assert(ActiveDataArray.Name = rsActive);
  if Grid <> nil then
  begin
    DataArray := ThreeDDataSet;
    if (DataArray <> nil) and DataArray.Limits.ActiveOnly then
    begin
      if (not ActiveDataArray.UpToDate)
        and (not (csDestroying in ComponentState)) then
      begin
        Grid.NeedToRecalculate3DCellColors := True;
        ThreeDGridObserver.UpToDate := False;
        ThreeDGridObserver.UpToDate := True;
      end;
    end
    else if (EdgeDisplay <> nil)
      and EdgeDisplay.Limits[EdgeDisplay.DataToPlot].ActiveOnly then
    begin
      if (not ActiveDataArray.UpToDate)
        and (not (csDestroying in ComponentState)) then
      begin
        Grid.NeedToRecalculate3DCellColors := True;
        ThreeDGridObserver.UpToDate := False;
        ThreeDGridObserver.UpToDate := True;
      end;
    end;
  end
  else if DisvUsed then
  begin
    DataArray := ThreeDDataSet;
    if (DataArray <> nil) and DataArray.Limits.ActiveOnly then
    begin
      if (not ActiveDataArray.UpToDate)
        and (not (csDestroying in ComponentState)) then
      begin
        DisvGrid.NeedToRecalculateTopColors := True;
        DisvGrid.NeedToRecalculateFrontColors := True;
        ThreeDGridObserver.UpToDate := False;
        ThreeDGridObserver.UpToDate := True;
      end;
    end
    else if (EdgeDisplay <> nil)
      and EdgeDisplay.Limits[EdgeDisplay.DataToPlot].ActiveOnly then
    begin
      if (not ActiveDataArray.UpToDate)
        and (not (csDestroying in ComponentState)) then
      begin
        DisvGrid.NeedToRecalculateTopColors := True;
        DisvGrid.NeedToRecalculateFrontColors := True;
        ThreeDGridObserver.UpToDate := False;
        ThreeDGridObserver.UpToDate := True;
      end;
    end;
  end;
end;

procedure TCustomModel.OnTopSutraMeshChanged(Sender: TObject);
begin
  if (ModelSelection in SutraSelection) and (FSutraMesh <> nil) then
  begin
    if not ThreeDGridObserver.UpToDate then
    begin
      frmGoPhast.FrontDiscretizationChanged := True;
      FSutraMesh.ElevationsNeedUpdating := True;
    end;
  end;
end;

function TCustomModel.DoOptionalDataSet(Sender: TObject): boolean;
begin
  result := False;
end;

procedure TCustomModel.AllObserversStopTalking;
begin
  FTopGridObserver.StopTalkingToAnyone;
  FThreeDGridObserver.StopTalkingToAnyone;
  FHufSyNotifier.StopTalkingToAnyone;
  FHufSsNotifier.StopTalkingToAnyone;
  FHufKzNotifier.StopTalkingToAnyone;
  FHufKyNotifier.StopTalkingToAnyone;
  FHufKxNotifier.StopTalkingToAnyone;
  if FootprintProperties <> nil then
  begin
    FootprintProperties.StopTalkingToAnyone;
  end;
end;

procedure TCustomModel.FreeHufNotifiers;
begin
  FHufSyNotifier.Free;
  FHufSsNotifier.Free;
  FHufKzNotifier.Free;
  FHufKyNotifier.Free;
  FHufKxNotifier.Free;
end;

procedure TCustomModel.FreeSfrWriter;
begin
  FreeAndNil(SfrWriter);
  FreeAndNil(LakWriter);
  FreeAndNil(FarmWriter3);
  FreeAndNil(FarmWriter4);
end;

function TCustomModel.DoFractionOfIrrigToSurfaceWaterUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticFractionOfIrrigToSurfaceWaterArrayUsed(nil);
end;

function TCustomModel.DoFractionOfPrecipToSurfaceWaterUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticFractionOfPrecipToSurfaceWaterArrayUsed(nil);
end;

procedure TCustomModel.FreeGridNotifiers;
begin
  FTopGridObserver.Free;
  FTopGridObserver := nil;
  FThreeDGridObserver.Free;
  FThreeDGridObserver := nil;
end;

function TCustomModel.DoAquiferPropertiesUsed(Sender: TObject): boolean;
var
  HufUsed: Boolean;
begin
  HufUsed := ModflowPackages.HufPackage.IsSelected
    and (ModelSelection in ModflowSelection)
    and (ModelSelection <> msModflow2015);
  result := ModflowOrPhastUsed(Sender)
    and ((ModelSelection = msPhast) or not HufUsed);
end;

procedure TCustomModel.Assign(Source: TPersistent);
var
  SourceModel: TCustomModel;
begin
  if Source is TCustomModel then
  begin
    SourceModel := TCustomModel(Source);
    AlternateFlowPackage := SourceModel.AlternateFlowPackage;
    AlternateSolver := SourceModel.AlternateSolver;
    BatchFileAdditionsAfterModel := SourceModel.BatchFileAdditionsAfterModel;
    BatchFileAdditionsBeforeModel := SourceModel.BatchFileAdditionsBeforeModel;
    if (not (Source is TPhastModel)) or (not (self is TChildModel)) then
    begin
      ModflowNameFileLines := SourceModel.ModflowNameFileLines;
    end;
    ModflowPackages := SourceModel.ModflowPackages;
    HeadFluxObservations := SourceModel.HeadFluxObservations;
    DrainObservations := SourceModel.DrainObservations;
    GhbObservations := SourceModel.GhbObservations;
    RiverObservations := SourceModel.RiverObservations;
    StreamObservations := SourceModel.StreamObservations;
    HydrogeologicUnits := SourceModel.HydrogeologicUnits;
    FilesToArchive := SourceModel.FilesToArchive;
    ModelInputFiles := SourceModel.ModelInputFiles;
    ModelFileName := SourceModel.ModelFileName;
    ModflowWettingOptions := SourceModel.ModflowWettingOptions;
    GlobalVariablesI := SourceModel.GlobalVariablesI;
    ModflowOptions := SourceModel.ModflowOptions;
    HeadObsResults := SourceModel.HeadObsResults;
    Mt3dmsHeadMassFluxObservations := SourceModel.Mt3dmsHeadMassFluxObservations;
    Mt3dmsWellMassFluxObservations := SourceModel.Mt3dmsWellMassFluxObservations;
    Mt3dmsDrnMassFluxObservations := SourceModel.Mt3dmsDrnMassFluxObservations;
    Mt3dmsRivMassFluxObservations := SourceModel.Mt3dmsRivMassFluxObservations;
    Mt3dmsGhbMassFluxObservations := SourceModel.Mt3dmsGhbMassFluxObservations;
    Mt3dmsRchMassFluxObservations := SourceModel.Mt3dmsRchMassFluxObservations;
    Mt3dmsEvtMassFluxObservations := SourceModel.Mt3dmsEvtMassFluxObservations;
    Mt3dmsMassLoadingMassFluxObservations := SourceModel.Mt3dmsMassLoadingMassFluxObservations;
    Mt3dmsResMassFluxObservations := SourceModel.Mt3dmsResMassFluxObservations;
    Mt3dmsLakMassFluxObservations := SourceModel.Mt3dmsLakMassFluxObservations;
    Mt3dmsDrtMassFluxObservations := SourceModel.Mt3dmsDrtMassFluxObservations;
    Mt3dmsEtsMassFluxObservations := SourceModel.Mt3dmsEtsMassFluxObservations;
    Mt3dmsStrMassFluxObservations := SourceModel.Mt3dmsStrMassFluxObservations;
    Mt3dmsFhbHeadMassFluxObservations := SourceModel.Mt3dmsFhbHeadMassFluxObservations;
    Mt3dmsFhbFlowMassFluxObservations := SourceModel.Mt3dmsFhbFlowMassFluxObservations;
    SutraFluxObs := SourceModel.SutraFluxObs;
    SwrTabFiles := SourceModel.SwrTabFiles;
    SwrReachGeometry := SourceModel.SwrReachGeometry;
    SwrStructures := SourceModel.SwrStructures;
    SwrObservations := SourceModel.SwrObservations;
    ModflowGlobalObservationComparisons := SourceModel.ModflowGlobalObservationComparisons;
    SutraGlobalObservationComparisons := SourceModel.SutraGlobalObservationComparisons;

    PilotPointData := SourceModel.PilotPointData;
    PestObsCollection := SourceModel.PestObsCollection;
//    GeoRefFileName := SourceModel.GeoRefFileName;

    OnCrossSectionChanged := SourceModel.OnCrossSectionChanged;
//    SfrStreamLinkPlot := SourceModel.SfrStreamLinkPlot;
  end
  else
  begin
    inherited;
  end;
end;

procedure TCustomModel.DoAssignFootprintBoundarydWithdrawal(Sender: TObject);
begin
  FootprintProperties.AssignFootprintBoundarydWithdrawal(Sender);
end;

procedure TCustomModel.DoAssignModflow6LakeDisplayArrays(Sender: TObject);
var
  LakeMf6Writer: TModflowLAKMf6Writer;
begin
  LakeMf6Writer := TModflowLAKMf6Writer.Create(Self, etDisplay);
  try
    LakeMf6Writer.UpdateDisplay;
  finally
    LakeMf6Writer.Free;
  end;
end;

//procedure TCustomModel.AssignFootprintDistributedWithdrawals(Sender: TObject);
//begin
//  FootprintProperties.AssignFootprintDistributedWithdrawals(Sender);
//end;

function TCustomModel.DoKineticsUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender) and ChemistryOptions.UseKineticReactants;
end;

function TCustomModel.DoKyUsed(Sender: TObject): boolean;
begin
  result := False;
  case ModelSelection of
    msUndefined: result := false;
    msPhast: result := True;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT, msModflowFmp,
      msModflowCfp, msModflowOwhm2:
      begin
        result := ModflowPackages.LpfPackage.IsSelected
          or ModflowPackages.UpwPackage.IsSelected;
      end;
    msSutra22, msSutra30, msSutra40: result := false;
    msFootPrint: result := false;
    msModflow2015:
      begin
        result := ModflowPackages.NpfPackage.IsSelected
          and not ModflowPackages.NpfPackage.UseHorizontalAnisotropy;
      end;
    else Assert(False);
  end;
end;

function TCustomModel.DoKzUsed(Sender: TObject): boolean;
var
  LayerGroupIndex: Integer;
  LayerGroup: TLayerGroup;
  ParamIndex: Integer;
  Param: TModflowSteadyParameter;
  VK_Used: Boolean;
  VaniUsed: Boolean;
  VkcbUsed: Boolean;
begin
  result := True;
  case ModelSelection of
    msUndefined: result := False;
    msPhast: result := True;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        if ModflowPackages.HufPackage.IsSelected then
        begin
          result := False;
          Exit;
        end;
        if ModflowPackages.LpfPackage.IsSelected
          or ModflowPackages.UpwPackage.IsSelected then
        begin
          VK_Used := False;
          VaniUsed := False;
          VkcbUsed := False;
          for ParamIndex := 0 to ModflowSteadyParameters.Count - 1 do
          begin
            Param := ModflowSteadyParameters[ParamIndex];
            if Param.ParameterType = ptLPF_VK then
            begin
              VK_Used := True;
            end
            else if Param.ParameterType = ptLPF_VANI then
            begin
              VaniUsed := True;
            end
            else if Param.ParameterType = ptLPF_VKCB then
            begin
              VkcbUsed := True;
            end
          end;

          result := False;
          for LayerGroupIndex := 1 to LayerStructure.Count - 1 do
          begin
            LayerGroup := LayerStructure[LayerGroupIndex];
            if LayerGroup.RunTimeSimulated then
            begin
              case LayerGroup.VerticalHydraulicConductivityMethod of
                0: result := not VK_Used; // 0 means use vertical hydraulic conductivity
                1: result := not VaniUsed; // 1 means user vertical anisotropy
                else Assert(False);
              end;
              if result then
              begin
                break;
              end;
            end
            else
            begin
              if not VkcbUsed then
              begin
                result := True;
                break;
              end;
            end;
          end;
        end;
      end;
    msModflow2015:
      begin
        result := ModflowPackages.NpfPackage.IsSelected
          and not ModflowPackages.NpfPackage.UseVerticalAnisotropy;
      end;
    msSutra22, msSutra30, msSutra40, msFootPrint: result := False;
    else Assert(False);
  end;
end;

function TCustomModel.PointToCell(EvalAt: TEvaluatedAt;
  APoint: TPoint2D): T2DTopCell;
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2,
      msModflowNWT, msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        result := Grid.TopContainingCell(APoint, EvalAt, False);
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        case EvalAt of
          eaBlocks:
            begin
              result := SutraMesh.Mesh2D.Elements.TopContainingElement(APoint);
            end;
          eaNodes:
            begin
              result := SutraMesh.Mesh2D.Nodes.TopContainingCell(APoint);
            end;
          else
            Assert(False);
        end;
      end;
    msModflow2015:
      begin
        if DisvUsed then
        begin
          result := DisvGrid.TopContainingCellOrElement(APoint, EvalAt);
        end
        else
        begin
          result := Grid.UnconstrainedTopContainingCell(APoint, EvalAt, True);
        end;
      end;
    else
      Assert(False);
  end;
end;

function TCustomModel.DoPorosityUsed(Sender: TObject): boolean;
var
  SpeciesIndex: Integer;
  MstPackage: TGwtMstPackage;
begin
  result := (ModelSelection = msPhast);
  if not result then
  begin
    if (ModelSelection in ModflowSelection) then
    begin
      result := ModflowPackages.ModPath.IsSelected
        or ModflowPackages.Mt3dBasic.SimulateWithMt3D;
    end;
    if not result and GwtUsed then
    begin
      for SpeciesIndex := 0 to ModflowPackages.GwtPackages.Count - 1 do
      begin
        MstPackage := ModflowPackages.GwtPackages[SpeciesIndex].GwtMst;
        result := (MstPackage <> nil) and MstPackage.IsSelected
           and not MstPackage.SeparatePorosity;
        if result then
        begin
          Exit;
        end;
      end;
    end;
  end;


//    and (ModflowPackages.ModPath.IsSelected or ModflowPackages.Mt3dBasic.IsSelected));
end;

function TCustomModel.DoPotentialEvapBareUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmClimate4.StaticBareEvapUsed(nil);
end;

function TCustomModel.DoSpecificStorageUsed(Sender: TObject): boolean;
begin
  result := False;
  case ModelSelection of
    msUndefined: result := False;
    msPhast: result := True;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        if ModflowPackages.LpfPackage.IsSelected
          or ModflowPackages.BcfPackage.IsSelected
          or ModflowPackages.UpwPackage.IsSelected then
        begin
          result := ModflowStressPeriods.TransientModel;
        end
        else
        begin
          result := False;
        end;
      end;
    msModflow2015:
      begin
        // Specific storage is used in the formula for confined storage.
        result := ModflowPackages.StoPackage.IsSelected;
//          and (ModflowPackages.StoPackage.StorageChoice = scSpecificStorage)
      end;
    msSutra22, msSutra30, msSutra40, msFootPrint: result := False;
    else Assert(False);
  end;
end;

function TCustomModel.DoChemistryUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msPhast) and SoluteTransport;
end;

function TCustomModel.DoInitialWaterTableUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msPhast) and FreeSurface and UseWaterTable;
end;

function TCustomModel.DoInitialHeadUsed(Sender: TObject): boolean;
begin
  result := ((ModelSelection = msPhast) and not DoInitialWaterTableUsed(Sender))
    or ((ModelSelection in SutraSelection)
    and (SutraOptions.TransportChoice = tcSoluteHead));
end;

function TCustomModel.DoSurfaceKUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmSoil4.SurfaceKArrayUsed(nil);
end;

function TCustomModel.DoSurfacesUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender) and ChemistryOptions.UseSurfaceAssemblages;
end;

function TCustomModel.Sutra30OrAboveUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in [msSutra30, msSutra40])
end;

function TCustomModel.DoSutra3DModel(Sender: TObject): boolean;
begin
  result := False;
  if (frmGoPhast.PhastModel <> nil) then
  begin
    result := DoSutraUsed(Sender)
      and (frmGoPhast.PhastModel.SutraMesh.MeshType = mt3D);
  end;
end;

function TCustomModel.DoSutra4SoluteUsed(Sender: TObject): boolean;
begin
  result := DoSutra4Used(Sender) and  SutraOptions.ProductionUsed
    and (SutraOptions.TransportChoice in [tcSolute, tcSoluteHead]);
end;

function TCustomModel.Sutra4SorptionUsed(Sender: TObject): boolean;
var
  RegionIndex: Integer;
  ARegion: TRegionalProperty;
//  AdsorptionModel: TSorptionModel;
begin
  result := False;
  for RegionIndex := 0 to SutraOptions.RegionalProperties.Count - 1 do
  begin
    ARegion := SutraOptions.RegionalProperties[RegionIndex];
    result := ARegion.AdsorptionProperties.AdsorptionModel
      <> TSorptionModel.smNone;
    if result then
    begin
      Exit;
    end;
  end;
end;

function TCustomModel.DoSutra4EnergyOrSorptionUsed(Sender: TObject): boolean;
begin
  result := DoSutra4Used(Sender) and
    ((SutraOptions.TransportChoice in [tcEnergy, tcFreezing])
    or Sutra4SorptionUsed(Sender));
end;

function TCustomModel.DoSutra4EnergyUsed(Sender: TObject): boolean;
begin
  result := DoSutra4Used(Sender) and (SutraOptions.TransportChoice in [tcEnergy, tcFreezing]);
end;

function TCustomModel.DoSutra4FreezingUsed(Sender: TObject): boolean;
begin
  result := DoSutra4Used(Sender) and  SutraOptions.ProductionUsed
    and (SutraOptions.TransportChoice = tcFreezing);
end;

function TCustomModel.DoSutra4ProductionUsed(Sender: TObject): boolean;
begin
  result := DoSutra4Used(nil) and SutraOptions.ProductionUsed;
end;

function TCustomModel.DoSutra4Used(Sender: TObject): boolean;
begin
  result := ModelSelection = msSutra40;
end;

function TCustomModel.DoSutraConcentrationUsed(Sender: TObject): boolean;
begin
  result := DoSutraUsed(Sender)
    and (SutraOptions.TransportChoice in [tcSolute, tcSoluteHead]);
end;

function TCustomModel.DoSutraTemperatureUsed(Sender: TObject): boolean;
begin
  result := DoSutraUsed(Sender) and (SutraOptions.TransportChoice in [tcEnergy, tcFreezing]);
end;

function TCustomModel.DoSutraUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in SutraSelection)
end;

function TCustomModel.DoSutraHydraulicConductivityUsed(Sender: TObject): boolean;
begin
  result := DoSutraUsed(Sender)
    and (SutraOptions.TransportChoice = tcSoluteHead);
end;

function TCustomModel.DoSutraLakeBottomUsed(Sender: TObject): boolean;
begin
  result := DoSutraLakeUsed(Sender)
    and (not SutraOptions.LakeOptions.AllNodesLakes)
    and SutraOptions.LakeOptions.SpecifyLakeBottom
end;

function TCustomModel.DoSutraLakeUsed(Sender: TObject): boolean;
begin
  result := Sutra30OrAboveUsed(Sender) and (SutraMesh.MeshType = mt3d)
    and SutraOptions.LakeOptions.UseLakes;

end;

function TCustomModel.DoSutraMiddleHydraulicConductivityUsed(Sender: TObject): boolean;
begin
  result := DoSutraHydraulicConductivityUsed(Sender)
    and DoSutra3DModel(Sender);
end;

function TCustomModel.DoSutraPermeabilityUsed(Sender: TObject): boolean;
begin
  result := DoSutraUsed(Sender)
    and (SutraOptions.TransportChoice in [tcSolute, tcEnergy, tcFreezing]);
end;

function TCustomModel.DoSutraMiddlePermeabilityUsed(Sender: TObject): boolean;
begin
  result := DoSutraPermeabilityUsed(Sender)
    and DoSutra3DModel(Sender);
end;

function TCustomModel.DoSutraThicknessUsed(Sender: TObject): boolean;
begin
  result := DoSutraUsed(Sender) and (FSutraMesh <> nil)
    and (FSutraMesh.MeshType in [mt2D, mtProfile]);
end;

function TCustomModel.DoSutraUnsatRegionUsed(Sender: TObject): boolean;
begin
  result := DoSutraUsed(Sender)
    and ((SutraOptions.SaturationChoice = scUnsaturated)
    or DoSutra4Used(Sender));
end;

function TCustomModel.DoActiveUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    or (ModelSelection in [msPhast, msFootPrint]);
end;

function TCustomModel.ModflowOrPhastUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    or (ModelSelection = msPhast);
end;

function TCustomModel.DoExchangeUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender) and ChemistryOptions.UseExchange;
end;

function TCustomModel.DoGasPhaseUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender) and ChemistryOptions.UseGasPhases;
end;

function TCustomModel.DoSoilIDUsed(Sender: TObject): boolean;
begin
  result := FarmProcessUsed(Sender);
  if not result then
  begin
    result := (ModelSelection = msModflowOwhm2)
      and ModflowPackages.FarmProcess4.IsSelected
      and ModflowPackages.FarmSoil4.IsSelected
      and (FmpSoils.Count > 0);
  end;
end;

function TCustomModel.DoSolidSolutionUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender) and ChemistryOptions.UseSolidSolution;
end;

function TCustomModel.DoReservoirLayerUsed(Sender: TObject): boolean;
begin
  result := DoReservoirPackageUsed(Sender)
    and (ModflowPackages.ResPackage.LayerOption = loSpecified);
end;

function TCustomModel.DoReservoirPackageUsed(Sender: TObject): boolean;
begin
  result := DoModflowUsed(Sender)and (ModelSelection <> msModflow2015)
    and ModflowPackages.ResPackage.IsSelected;
end;

function TCustomModel.DoLakePackageUsed(Sender: TObject): boolean;
begin
  result := DoModflowUsed(Sender) and (ModelSelection <> msModflow2015)
    and ModflowPackages.LakPackage.IsSelected;
end;

function TCustomModel.DoLakMf6Selected(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.LakMf6Package.IsSelected;
end;

function TCustomModel.LakScreenObjects: TStringList;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  if FLakScreenObjects = nil then
  begin
    FLakScreenObjects := TStringList.Create;
  end
  else
  begin
    FLakScreenObjects.Clear;
  end;
  if ModflowPackages.LakMf6Package.IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if (not AScreenObject.Deleted)
        and (AScreenObject.ModflowLak6 <> nil)
        and (AScreenObject.ModflowLak6 .Used) then
      begin
        FLakScreenObjects.addObject(AScreenObject.Name, AScreenObject);
      end;
    end;
  end;
  result := FLakScreenObjects;
end;

function TCustomModel.DoLandUseAreaFractionUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticLandUseAreaFractionArrayUsed(nil);
end;

function TCustomModel.DoLandUseCellsToPrintUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.IsSelected
    and (lupPrintRowCol IN ModflowPackages.FarmLandUse.LandUsePrints);
end;

function TCustomModel.DoUzfPackageUsed(Sender: TObject): boolean;
begin
  result := DoModflowUsed(Sender) and (ModelSelection <> msModflow2015)
    and ModflowPackages.UzfPackage.IsSelected;
end;

function TCustomModel.DoUzfResidualWaterContentUsed(Sender: TObject): boolean;
begin
  result := DoUzfPackageUsed(Sender);
  if result then
  begin
      result := ModflowPackages.UzfPackage.SpecifyResidualWaterContent
        and (ModelSelection in [msModflow, msModflowLGR2,  msModflowNWT,
        msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2]);
  end;
end;

function TCustomModel.UzfSeepageUsed: boolean;
begin
  result := ModflowPackages.UzfPackage.IsSelected
    and ModflowPackages.Mt3dBasic.IsSelected
    and ModflowPackages.Mt3dmsSourceSink.IsSelected
    and (ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS);
end;

procedure TCustomModel.UpdateAllDataArrayDimensions;
var
  Index: Integer;
  DataSet: TDataArray;
begin
  for Index := 0 to FDataArrayManager.DataSetCount - 1 do
  begin
    DataSet := FDataArrayManager.DataSets[Index] as TDataArray;
    UpdateDataArrayDimensions(DataSet);
  end;
end;

function TCustomModel.DoUzfSurfKUsed(Sender: TObject): boolean;
begin
  result := DoUzfPackageUsed(Sender) and
    ModflowPackages.UzfPackage.SpecifySurfaceK { (NWT_Format = nf1_1)
    and ModflowPackages.UzfPackage.SpecifySurfaceK;}
end;

function TCustomModel.DoUzfUnsatVertKUsed(Sender: TObject): boolean;
var
  IUZFOPT: integer;
begin
  result := False;
  if DoUzfPackageUsed(Sender) then
  begin
    IUZFOPT := ModflowPackages.UzfPackage.VerticalKSource;
    if not (ModflowPackages.LpfPackage.IsSelected
      or ModflowPackages.UpwPackage.IsSelected) then
    begin
      IUZFOPT := 1;
    end;
    result := IUZFOPT = 1;
  end;
end;

function TCustomModel.UztUsed(Sender: TObject): boolean;
begin
  result := DoMt3dMS_StrictUsed(Sender) and ModflowPackages.UzfPackage.IsSelected
    and ModflowPackages.Mt3dBasic.IsSelected
    and (ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS)
    and ModflowPackages.Mt3dUnsatTransport.IsSelected;
end;

function TCustomModel.DoModflowUsed(Sender: TObject): boolean;
begin
  result := ModelSelection in ModflowSelection;
end;

function TCustomModel.DoRootDepthUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticRootDepthArrayUsed(nil);
end;

function TCustomModel.DoRouteUzfDischarge(Sender: TObject): boolean;
begin
  result := DoUzfPackageUsed(Sender)
    and ModflowPackages.UzfPackage.RouteDischargeToStreams
    and (ModflowPackages.SfrPackage.IsSelected
    or ModflowPackages.LakPackage.IsSelected
    or ModflowPackages.SwrPackage.IsSelected
    );
end;

function TCustomModel.RowCount: Integer;
begin
  if Grid <> nil then
  begin
    result := Grid.RowCount;
  end
  else
  begin
    result := 1;
  end;
end;

function TCustomModel.DoUzfInitialInfiltrationUsed(Sender: TObject): boolean;
begin
  result := DoUzfPackageUsed(Sender);
  if result then
  begin
      result := ModflowStressPeriods.CompletelyTransient or
        (ModflowPackages.UzfPackage.SpecifyInitialWaterContent
        and (ModelSelection in [msModflow, msModflowLGR2, msModflowNWT,
        msModflowFmp, msModflowCfp, msModflow2015, msModflowOwhm2]));
  end;
end;

function TCustomModel.DoUzfMf6PackageUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.UzfMf6Package.IsSelected;
end;

function TCustomModel.UzfMf6ScreenObjects: TStringList;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  if FUzfMf6ScreenObjects = nil then
  begin
    FUzfMf6ScreenObjects := TStringList.Create;
  end
  else
  begin
    FUzfMf6ScreenObjects.Clear;
  end;
  if ModflowPackages.UzfMf6Package.IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if (not AScreenObject.Deleted)
        and (AScreenObject.ModflowUzfMf6Boundary <> nil)
        and (AScreenObject.ModflowUzfMf6Boundary .Used) then
      begin
        FUzfMf6ScreenObjects.addObject(AScreenObject.Name, AScreenObject);
      end;
    end;
  end;
  result := FUzfMf6ScreenObjects;
end;

function TCustomModel.DoModflowInitialHeadUsed(Sender: TObject): boolean;
begin
  result := DoModflowUsed(Sender) and (ModflowOptions.InitialHeadFileName = '');
end;

function TCustomModel.ModflowLayerBottomDescription(
  const LayerID: integer): string;
begin
  result := LayerStructure.ModflowLayerBottomDescription(LayerID)
end;

function TCustomModel.ModflowLayerCount: integer;
begin
  result := LayerStructure.ModflowLayerCount
end;

function TCustomModel.ModflowLayerToDataSetLayer(
  ModflowLayer: integer): integer;
begin
  result := LayerStructure.ModflowLayerToDataSetLayer(ModflowLayer);
end;

function TCustomModel.DoConfiningBedKzUsed(Sender: TObject): boolean;
var
  UnitIndex: Integer;
  LayerGroup: TLayerGroup;
begin
  result := ((ModflowPackages.LpfPackage.IsSelected
    or ModflowPackages.UpwPackage.IsSelected)
    and
    (ModflowSteadyParameters.CountParameters([ptLPF_VKCB]) = 0))
    or ModflowPackages.BcfPackage.IsSelected;
  if result then
  begin
    result := False;
    for UnitIndex := 1 to LayerStructure.Count - 1 do
    begin
      LayerGroup := LayerStructure[UnitIndex];
      result := not LayerGroup.RunTimeSimulated;
      if result then break;
    end;
  end;
end;

function TCustomModel.DoConsumptiveUseUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticConsumptiveUseArrayUsed(nil);
end;

procedure TCustomModel.ConvertSfr;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  SfrSegments: array of TScreenObject;
  SegNumber: Integer;
  ParamItem: TSfrParamIcalcItem;
  UpstreamObject: TScreenObject;
  DiversionItem: TSDiversionItem;
  TimeIndex: Integer;
  SfrItem: TSfrSegmentFlowItem;
  Sfr6Item: TSfrMf6Item;
//  Diversions: TStringList;
begin
  if ModflowPackages.SfrPackage.IsSelected
    and not ModflowPackages.SfrModflow6Package.IsSelected then
  begin
    ModflowPackages.SfrModflow6Package.IsSelected := True;
    SetLength(SfrSegments, ScreenObjectCount+1);
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      AScreenObject.ConvertSfr;
      if AScreenObject.ModflowSfr6Boundary <> nil then
      begin
        SegNumber := AScreenObject.ModflowSfr6Boundary.SegmentNumber;
        if SegNumber >= Length(SfrSegments) then
        begin
          SetLength(SfrSegments, SegNumber+1);
        end;
        Assert(SfrSegments[SegNumber] = nil);
        SfrSegments[SegNumber] := AScreenObject;
      end;
    end;

    // assign diversions.
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if AScreenObject.ModflowSfr6Boundary <> nil then
      begin
        Assert(AScreenObject.ModflowSfrBoundary  <> nil);
        ParamItem := AScreenObject.ModflowSfrBoundary.ParamIcalc[0] as TSfrParamIcalcItem;
        // ParamItem.DiversionSegment < 0 is a diversion from a lake.
        if ParamItem.DiversionSegment > 0 then
        begin
          Assert(ParamItem.DiversionSegment < Length(SfrSegments));
//          Assert(ParamItem.DiversionSegment > 0);
          UpstreamObject := SfrSegments[ParamItem.DiversionSegment];
          Assert(UpstreamObject <> nil);
          Assert(UpstreamObject.ModflowSfr6Boundary <> nil);
          DiversionItem := UpstreamObject.ModflowSfr6Boundary.Diversions.Add;
          DiversionItem.Assign(ParamItem);
          Assert(AScreenObject.ModflowSfrBoundary.SegmentFlows.Count
            = UpstreamObject.ModflowSfr6Boundary.Values.Count);

          for TimeIndex := 0 to AScreenObject.ModflowSfrBoundary.SegmentFlows.Count - 1 do
          begin
            SfrItem := AScreenObject.ModflowSfrBoundary.SegmentFlows[TimeIndex] as TSfrSegmentFlowItem;
            Sfr6Item := UpstreamObject.ModflowSfr6Boundary.Values[TimeIndex] as TSfrMf6Item;
            Sfr6Item.DiversionCount := Sfr6Item.DiversionCount+1;
            Sfr6Item.DiversionFormulas[Sfr6Item.DiversionCount-1] := SfrItem.Flow;

            Sfr6Item := AScreenObject.ModflowSfr6Boundary.Values[TimeIndex] as TSfrMf6Item;
            Sfr6Item.UpstreamFraction := '0';
          end;
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.ConvertStr;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
  StrSegments: array of TScreenObject;
  SegNumber: Integer;
  StrItem: TStrItem;
  UpstreamObject: TScreenObject;
  DiversionItem: TSDiversionItem;
  TimeIndex: Integer;
  Sfr6Item: TSfrMf6Item;
begin
  if ModflowPackages.StrPackage.IsSelected
    and not ModflowPackages.SfrModflow6Package.IsSelected then
  begin
    ModflowPackages.SfrModflow6Package.IsSelected := True;
    SetLength(StrSegments, ScreenObjectCount+1);
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      AScreenObject.ConvertStr;
      if AScreenObject.ModflowSfr6Boundary <> nil then
      begin
        SegNumber := AScreenObject.ModflowSfr6Boundary.SegmentNumber;
        if SegNumber >= Length(StrSegments) then
        begin
          SetLength(StrSegments, SegNumber+1);
        end;
        Assert(StrSegments[SegNumber] = nil);
        StrSegments[SegNumber] := AScreenObject;
      end;
    end;

    // assign diversions.
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if AScreenObject.ModflowSfr6Boundary <> nil then
      begin
        Assert(AScreenObject.ModflowStrBoundary  <> nil);
        StrItem := AScreenObject.ModflowStrBoundary.Values[0] as TStrItem;
        // StrItem.DiversionSegment < 0 is a diversion from a lake.
        if StrItem.DiversionSegment > 0 then
        begin
          Assert(StrItem.DiversionSegment < Length(StrSegments));
//          Assert(StrItem.DiversionSegment > 0);
          UpstreamObject := StrSegments[StrItem.DiversionSegment];
          Assert(UpstreamObject <> nil);
          Assert(UpstreamObject.ModflowSfr6Boundary <> nil);
          DiversionItem := UpstreamObject.ModflowSfr6Boundary.Diversions.Add;
          DiversionItem.Assign(StrItem);
          Assert(AScreenObject.ModflowStrBoundary.Values.Count
            = UpstreamObject.ModflowSfr6Boundary.Values.Count);

          for TimeIndex := 0 to AScreenObject.ModflowStrBoundary.Values.Count - 1 do
          begin
            StrItem := AScreenObject.ModflowStrBoundary.Values[TimeIndex] as TStrItem;
            Sfr6Item := UpstreamObject.ModflowSfr6Boundary.Values[TimeIndex] as TSfrMf6Item;
            Sfr6Item.DiversionCount := Sfr6Item.DiversionCount+1;
            Sfr6Item.DiversionFormulas[Sfr6Item.DiversionCount-1] := StrItem.Flow;
          end;
        end;
      end;
    end;
  end;
end;

function TCustomModel.DoVertAnisotropyMf6Used(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflow2015)
    and (ModflowPackages.NpfPackage.IsSelected)
    and ModflowPackages.NpfPackage.UseVerticalAnisotropy
end;

function TCustomModel.DoVerticalAnisotropyUsed(Sender: TObject): boolean;
var
  UnitIndex: Integer;
  LayerGroup: TLayerGroup;
begin
  result := False;
  if ModflowPackages.LpfPackage.IsSelected
    or ModflowPackages.UpwPackage.IsSelected then
  begin
    for UnitIndex := 1 to LayerStructure.Count - 1 do
    begin
      LayerGroup := LayerStructure[UnitIndex];
      if LayerGroup.RunTimeSimulated then
      begin
        result := LayerGroup.VerticalHydraulicConductivityMethod <> 0;
        if result then break;
      end;
    end;
  end;
end;

function TCustomModel.DoVerticalTransverseDispersionUsed(
  Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender)
    or (DoGwtDispUsed(Sender)
    and ModflowPackages.GwtDispersionPackage.UseTransverseDispForVertFlow)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtCombined)
end;

function TCustomModel.DoVerticalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
begin
  result := (GwtDispUsedPerSpecies(Sender)
    and ModflowPackages.GwtDispersionPackage.UseTransverseDispForVertFlow
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate))
end;

function TCustomModel.DoCropHasSalinityDemandUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.IsSelected
    and ModflowPackages.FarmSalinityFlush.StaticCropHasSalinityDemandArrayUsed(nil);
end;

function TCustomModel.DoHorizAnisotropyMf6Used(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflow2015)
    and (ModflowPackages.NpfPackage.IsSelected)
    and ModflowPackages.NpfPackage.UseHorizontalAnisotropy
end;

function TCustomModel.DoHorizontalAnisotropyUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection);
  if result then
  begin
    if ModelSelection = msModflow2015 then
    begin
      result := False;
    end
    else
    begin
      result := (ModflowPackages.LpfPackage.IsSelected
        or ModflowPackages.UpwPackage.IsSelected);
    end;
  end;
end;

function TCustomModel.DoHorizontalTransverseDispersionUsed(
  Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender)
    or (DoGwtDispUsed(Sender)
    and (ModflowPackages.GwtDispersionPackage.TransverseDispTreatement = dtCombined))
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtCombined)
end;

function TCustomModel.DoHorizontalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
begin
  result := (GwtDispUsedPerSpecies(Sender)
    and (ModflowPackages.GwtDispersionPackage.TransverseDispTreatement = dtCombined)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate))
end;

function TCustomModel.DoSpecificYieldUsed(Sender: TObject): boolean;
var
  UnitIndex: Integer;
  LayerGroup: TLayerGroup;
begin
  Result := False;
  if ModelSelection in ModflowSelection then
  begin
    if ModelSelection = msModflow2015 then
    begin
      result := ModflowPackages.StoPackage.IsSelected;
    end
    else
    begin
      result := ((ModflowPackages.LpfPackage.IsSelected
        or ModflowPackages.UpwPackage.IsSelected)
        and
        (ModflowSteadyParameters.CountParameters([ptLPF_SY]) = 0))
        or ModflowPackages.BcfPackage.IsSelected;
      if result then
      begin
        result := ModflowStressPeriods.TransientModel
      end;
      if result then
      begin
        result := False;
        for UnitIndex := 1 to LayerStructure.Count - 1 do
        begin
          LayerGroup := LayerStructure[UnitIndex];
          if LayerGroup.RunTimeSimulated then
          begin
            result := LayerGroup.AquiferType <> 0;
            if result then break;
          end;
        end;
      end;
    end;
  end;
end;

function TCustomModel.DoStorageSelected(Sender: TObject): boolean;
begin
  result := DoModflow6Selected(Sender) and
    ModflowPackages.StoPackage.IsSelected;
end;

function TCustomModel.StoreDisvGrid: Boolean;
begin
  result := // ((ModelSelection <> msModflow2015) or DisvUsed) and
    ((DisvGrid.TwoDGrid.ElementCount > 0)
    and (DisvGrid.Layers.Count > 0));
end;

function TCustomModel.StoreDrainObservations: Boolean;
begin
  result := FDrainObservations.Count > 0;
end;

function TCustomModel.StoreDrnMassFluxObservations: Boolean;
begin
  result := FMt3dmsDrnMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreDrtMassFluxObservations: Boolean;
begin
  result := FMt3dmsDrtMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreEtsMassFluxObservations: Boolean;
begin
  result := FMt3dmsEtsMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreEvtMassFluxObservations: Boolean;
begin
  result := FMt3dmsEvtMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreFhbFlowMassFluxObservations: Boolean;
begin
  result := FMt3dmsFhbFlowMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreFhbHeadMassFluxObservations: Boolean;
begin
  result := FMt3dmsFhbHeadMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreGhbMassFluxObservations: Boolean;
begin
  result := FMt3dmsGhbMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreGhbObservations: Boolean;
begin
  result := FGhbObservations.Count > 0;
end;

function TCustomModel.StoreHeadFluxObservations: Boolean;
begin
  result := FHeadFluxObservations.Count > 0;
end;

function TCustomModel.StoreHeadMassFluxObservations: Boolean;
begin
  result := FMt3dmsHeadMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreHeadObsResults: boolean;
begin
  Result := (FHeadObsResults <> nil) and (FHeadObsResults.Count > 0);
end;

function TCustomModel.StoreHydrogeologicUnits: Boolean;
begin
  result := FHydrogeologicUnits.Count > 0;
end;

function TCustomModel.StoreLakMassFluxObservations: Boolean;
begin
  result := FMt3dmsLakMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreLinkedRaster: Boolean;
begin
  result := LinkedRasters.Count > 0;
end;

function TCustomModel.StoreMassLoadingMassFluxObservations: Boolean;
begin
  result := FMt3dmsMassLoadingMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreRchMassFluxObservations: Boolean;
begin
  result := FMt3dmsRchMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreResMassFluxObservations: Boolean;
begin
  result := FMt3dmsResMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreRiverObservations: Boolean;
begin
  result := FRiverObservations.Count > 0;
end;

function TCustomModel.StoreRivMassFluxObservations: Boolean;
begin
  result := FMt3dmsRivMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreStrMassFluxObservations: Boolean;
begin
  result := FMt3dmsStrMassFluxObservations.Count > 0;
end;

function TCustomModel.StoreStrObservations: Boolean;
begin
  result := FStrObservations.Count > 0;
end;

function TCustomModel.StoreWellMassFluxObservations: Boolean;
begin
  result := FMt3dmsWellMassFluxObservations.Count > 0;
end;

function TCustomModel.DoWetDryUsed(Sender: TObject): boolean;
begin
  result := ModflowWettingOptions.WettingActive;
  if result and (ModelSelection in
    [msModflowNWT, msModflowFmp, msModflowOwhm2]) then
  begin
    result := not ModflowPackages.UpwPackage.IsSelected;
  end;
end;

function TCustomModel.DoModpathBudgetNeeded(Sender: TObject): boolean;
begin
  result := ModpathUsed(Sender);
  if result and (ModflowPackages.ModPath.MpathVersion <> mp7) then
  begin
    result := (ModflowPackages.ModPath.BudgetChecking = bcList);
  end;
end;

function TCustomModel.DoModpathRetardationNeeded(Sender: TObject): boolean;
begin
  result := ModpathUsed(Sender)
    and (ModflowPackages.ModPath.RetardationOption = roUsed);
end;

function TCustomModel.DoModpathZonesNeeded(Sender: TObject): boolean;
begin
  result :=  (ModelSelection in ModflowSelection)
    and ModflowPackages.ModPath.IsSelected;
  if result and (ModflowPackages.ModPath.MpathVersion in [mp6, mp7]) then
  begin
    result := ModflowPackages.ModPath.StopInZone;
  end;
end;

function TCustomModel.ModpathUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.ModPath.IsSelected;
end;

function TCustomModel.DoHufReferenceSurfaceNeeded(Sender: TObject): boolean;
begin
  { TODO : In LGR, this function may need to updated. }
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.HufPackage.IsSelected
    and (ModflowPackages.HufPackage.ReferenceChoice = hrcReferenceLayer)
    and (HufParameters.CountParameters([ptHUF_KDEP]) > 0);
end;

function TCustomModel.DoBcfUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and (ModelSelection <> msModflow2015)
    and ModflowPackages.BcfPackage.IsSelected
end;

procedure TCustomModel.BeginGridChange;
begin
  if Grid <> nil then
  begin
    Grid.BeginGridChange
  end;
end;

function TCustomModel.ColumnCount: Integer;
begin
  if Grid <> nil then
  begin
    result := Grid.ColumnCount;
  end
  else if Mesh3D <> nil then
  begin
    result := Mesh3D.Mesh2DI.ElementCount;
  end
  else
  begin
    result := 0;
  end;
end;

function TCustomModel.DoCombinedHorizontalTransverseDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ADataArray: TDataArray;
begin
  result := GwtDispUsedPerSpecies(Sender)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate);
  if not result then
  begin
    if (Sender <> nil) and DoGweCndUsed(Sender)  then
    begin
      ADataArray := Sender as TDataArray;
      result := Pos(StrGweTemperature, ADataArray.Name) > 0;
    end;
  end;
end;

function TCustomModel.DoConfinedStorageCoefUsed(Sender: TObject): boolean;
begin
  result := False;
  case ModelSelection of
    msUndefined: result := False;
    msPhast, msSutra22, msSutra30, msSutra40, msFootPrint: result := False;
    msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        if ModflowPackages.BcfPackage.IsSelected then
        begin
          result := ModflowStressPeriods.TransientModel;
        end
        else
        begin
          result := False;
        end;
      end;
    msModflow2015:
      begin
        result := ModflowPackages.StoPackage.IsSelected
          and (ModflowPackages.StoPackage.StorageChoice = scStorageCoefficient);
      end;
    else Assert(False);
  end;
end;

function TCustomModel.DoHufSelected(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and (ModelSelection <> msModflow2015)
    and ModflowPackages.HufPackage.IsSelected
end;

function TCustomModel.DoHufStorageUsed(Sender: TObject): boolean;
begin
  result := DoHufSelected(Sender)
    and ModflowStressPeriods.TransientModel;
end;

function TCustomModel.DoZetaUsed(Sender: TObject): boolean;
var
  DataArray: TDataArray;
  AnInt: Integer;
begin
  result := SwiUsed(Sender);
  if result then
  begin
    if Sender = nil then
    begin
      Exit
    end;
    Assert(Sender <> nil);
    DataArray := Sender as TDataArray;
    Assert(Pos(KActive_Surface_Elevation, DataArray.Name) = 1);
    Result := False;
    if TryStrToInt(Copy(DataArray.Name,
      Length(KActive_Surface_Elevation)+1, MaxInt), AnInt) then
    begin
      result := AnInt <= ModflowPackages.SwiPackage.NumberOfSurfaces;
    end;
  end;
end;

function TCustomModel.DoZoneBudgetSelected(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.ZoneBudget.IsSelected
end;

function TCustomModel.DoSwtSelected(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and (ModelSelection <> msModflow2015)
    and ModflowPackages.SwtPackage.IsSelected
end;

function TCustomModel.DoSwiObsUsed(Sender: TObject): boolean;
begin
  result := SwiUsed(Sender)
    and (ModflowPackages.SwiPackage.ObsChoice <> socNone);
end;

function TCustomModel.DoSwiUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in [msModflow, msModflowNWT])
    and ModflowPackages.SwiPackage.IsSelected;
end;

function TCustomModel.DoSwtOffsetsUsed(Sender: TObject): boolean;
begin
  result := DoSwtSelected(Sender)
    and (ModflowPackages.SwtPackage.PreconsolidationSource = pcOffsets);
end;

function TCustomModel.DoSwtSpecifiedUsed(Sender: TObject): boolean;
begin
  result := DoSwtSelected(Sender)
    and (ModflowPackages.SwtPackage.PreconsolidationSource = pcSpecified);
end;

procedure TCustomModel.Loaded;
begin
  inherited;
  if DisvGrid <> nil then
  begin
    DisvGrid.Loaded;
  end;
  ModflowPackages.Loaded;
  DataArrayManager.Loaded;
  UpdateGwtConc;
end;

function TCustomModel.DoLongitudinalDispersionUsed(Sender: TObject): boolean;
begin
  result := DoChemistryUsed(Sender)
    or (DoMt3dMS_StrictUsed(Sender) and ModflowPackages.Mt3dmsDispersion.IsSelected);

  if not result then
  begin
    result := (DoGwtDispUsed(Sender)
    and (ModflowPackages.GwtDispersionPackage.LongitudinalDispTreatement = dtCombined))
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtCombined)
  end;

end;

function TCustomModel.DoLongitudinalDispersionUsedPerSpecies(
  Sender: TObject): boolean;
var
  ADataArray: TDataArray;
begin
  result :=(DoMt3dMS_StrictUsed(Sender) and ModflowPackages.Mt3dmsDispersion.IsSelected)
    or (GwtDispUsedPerSpecies(Sender)
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate));

  if not result then
  begin
    if (Sender <> nil) and DoGweCndUsed(Sender)  then
    begin
      ADataArray := Sender as TDataArray;
      result := Pos(StrGweTemperature, ADataArray.Name) > 0;
    end;
  end;

end;

function TCustomModel.Mt3dIsSelected: Boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
end;

function TCustomModel.DoMt3dMSBulkDensityUsed(Sender: TObject): boolean;
begin
  result := DoMt3dMS_StrictUsed(Sender) and ModflowPackages.Mt3dmsChemReact.IsSelected
    and ((ModflowPackages.Mt3dmsChemReact.SorptionChoice in [scLinear,
    scFreundlich, scLangmuir, scFirstOrderKinetic, scDualDomainWithSorption,
    scDualWithDifferingConstants])
    or (ModflowPackages.Mt3dmsChemReact.ReactionChoice = rcKinetic));
end;

function TCustomModel.DoMt3dMSImmobPorosityUsed(Sender: TObject): boolean;
begin
  result := DoMt3dMS_StrictUsed(Sender) and ModflowPackages.Mt3dmsChemReact.IsSelected
    and (ModflowPackages.Mt3dmsChemReact.SorptionChoice in
    [scDualDomainNoSorption, scDualDomainWithSorption,
    scDualWithDifferingConstants]);
end;

//function TCustomModel.Mt3dMSUsed(Sender: TObject): boolean;
//begin
//  result := (ModelSelection in ModflowSelection)
//    and ModflowPackages.Mt3dBasic.IsSelected;
//end;

function TCustomModel.DoMt3dMS_StrictUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in ModflowSelection)
    and ModflowPackages.Mt3dBasic.IsSelected
    and (ModflowPackages.Mt3dBasic.Mt3dVersion in [mvUSGS, mvMS]);
end;

function TCustomModel.DoMt3d_LktIsSelected(Sender: TObject): Boolean;
begin
  result := ModflowPackages.Mt3dLkt.IsSelected;
end;

function TCustomModel.MultipleAddedDemandUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.AddedDemand.FarmOption = foStatic)
    and (FarmLandUse.AddedDemand.ArrayList = alArray);
end;

function TCustomModel.MultipleConsumptiveUseUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.ConsumptiveUse.FarmOption = foStatic)
    and (FarmLandUse.ConsumptiveUse.ArrayList = alArray);
end;

function TCustomModel.MultipleCropCoefficientUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.CropCoeff.FarmOption = foStatic)
    and (FarmLandUse.CropCoeff.ArrayList = alArray);
end;

function TCustomModel.MultipleEvaporationIrrigationUsed(
  Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.EvapIrrigationFraction.FarmOption = foStatic)
    and (FarmLandUse.EvapIrrigationFraction.ArrayList = alArray);
end;

function TCustomModel.MultipleGroundwaterRootInteractionUsed(
  Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.GroundwaterRootInteraction.FarmOption = foStatic)
    and (FarmLandUse.GroundwaterRootInteraction.ArrayList = alArray);
end;

function TCustomModel.MultipleCropHasSalinityDemandUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
  FarmSalinityFlush: TFarmProcess4SalinityFlush;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  FarmSalinityFlush := ModflowPackages.FarmSalinityFlush;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected
    and FarmSalinityFlush.IsSelected
    and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmSalinityFlush.CropSalinityDemandChoice.FarmOption = foStatic)
    and (FarmSalinityFlush.CropSalinityDemandChoice.ArrayList = alArray);
end;

function TCustomModel.MultipleIrrigationUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.Irrigation.FarmOption = foStatic)
    and (FarmLandUse.Irrigation.ArrayList = alArray)
    and (IrrigationTypes.Count > 0)
    ;
end;

function TCustomModel.MultipleLandUseFractionsUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.LandUseFraction.FarmOption = foStatic)
    and (FarmLandUse.LandUseFraction.ArrayList = alArray);
end;

function TCustomModel.MultipleRootDepthUsed(Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.RootDepth.FarmOption = foStatic)
    and (FarmLandUse.RootDepth.ArrayList = alArray);
end;

function TCustomModel.MultipleSWLossFractionIrrigationUsed(
  Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.FractionOfIrrigationToSurfaceWater.FarmOption = foStatic)
    and (FarmLandUse.FractionOfIrrigationToSurfaceWater.ArrayList = alArray);
end;

function TCustomModel.MultipleSWLossFractionPrecipUsed(
  Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.FractionOfPrecipToSurfaceWater.FarmOption = foStatic)
    and (FarmLandUse.FractionOfPrecipToSurfaceWater.ArrayList = alArray);
end;

function TCustomModel.MultipleTranspirationFractionUsed(
  Sender: TObject): Boolean;
var
  FarmLandUse: TFarmProcess4LandUse;
begin
  FarmLandUse := ModflowPackages.FarmLandUse;
  result := (ModelSelection = msModflowOwhm2)
    and FarmLandUse.IsSelected and (FarmLandUse.LandUseOption = luoMultiple)
    and (FarmLandUse.TranspirationFraction.FarmOption = foStatic)
    and (FarmLandUse.TranspirationFraction.ArrayList = alArray);
end;

function TCustomModel.DoNpfUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.NpfPackage.IsSelected;
end;

function TCustomModel.DoNrdInfilLocationUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmSurfaceWater4.StaticNrdInfilLocationUsed(nil);
end;

procedure TCustomModel.NotifyHufKx;
begin
  HufKxNotifier.UpToDate := False;
  HufKxNotifier.UpToDate := True;
end;

procedure TCustomModel.NotifyHufKy;
begin
  HufKyNotifier.UpToDate := False;
  HufKyNotifier.UpToDate := True;
end;

procedure TCustomModel.NotifyHufKz;
begin
  HufKxNotifier.UpToDate := False;
  HufKxNotifier.UpToDate := True;
end;

procedure TCustomModel.NotifyHufSS;
begin
  HufSsNotifier.UpToDate := False;
  HufSsNotifier.UpToDate := True;
end;

procedure TCustomModel.NotifyHufSy;
begin
  HufSyNotifier.UpToDate := False;
  HufSyNotifier.UpToDate := True;
end;

function TCustomModel.NumberOfMt3dChemComponents: integer;
begin
  if (MobileComponents <> nil) and (ImmobileComponents <> nil) then
  begin
    result := MobileComponents.Count + ImmobileComponents.Count;
  end
  else
  begin
    result := 0;
  end;
end;

function TCustomModel.NWT_Format: TNwtFormat;
var
//  MfNwtDateVersion1_0_9: TDateTime;
  NwtDate: TDateTime;
  M2005Date: TDateTime;
begin
  result := nf1_0;
  if ModelSelection = msModflowNWT then
  begin
    if TFile.Exists(ProgramLocations.ModflowNwtLocation) then
    begin
//      MfNwtDateVersion1_0_9 := EncodeDate(2014,6,23);
      NwtDate := Trunc(TFile.GetLastWriteTime(ProgramLocations.ModflowNwtLocation));
      if NwtDate > MfNwtDateVersion1_0_9 then
      begin
        result := nf1_1;
      end;
    end;
  end
  else if ModelSelection = msModflow then
  begin
    if TFile.Exists(ProgramLocations.ModflowLocation) then
    begin
//      MfNwtDateVersion1_0_9 := EncodeDate(2014,6,23);
      M2005Date := Trunc(TFile.GetLastWriteTime(ProgramLocations.ModflowLocation));
      if M2005Date >= Mf2005DateVersion1_12 then
      begin
        result := nf1_1;
      end;
    end;
  end

end;

function TCustomModel.Trpy: TOneDRealArray;
begin
  result := LayerStructure.Trpy;
end;

function TCustomModel.TvkIsSelected: Boolean;
begin
  result := ModflowPackages.TvkPackage.IsSelected;
end;

function TCustomModel.TvsIsSelected: Boolean;
begin
  result := ModflowPackages.TvsPackage.IsSelected
    and ModflowPackages.StoPackage.IsSelected;
end;

function TCustomModel.TwoDElementCenter(const Column, Row: integer): TPoint2D;
var
  LocalGrid: TCustomModelGrid;
  LocalMesh: TSutraMesh3D;
begin
  LocalGrid := Grid;
  if LocalGrid <> nil then
  begin
    result := LocalGrid.TwoDElementCenter(Column, Row);
  end
  else if DisvUsed then
  begin
    result := DisvGrid.TwoDGrid.Cells[Column].Location;
  end
  else
  begin
    LocalMesh := Mesh as TSutraMesh3D;
    Assert(LocalMesh <> nil);
    Assert(Row = 0);
    result := LocalMesh.Mesh2D.Elements[Column].Center;
  end;
end;

function TCustomModel.TwoDElementCorner(const Column, Row: integer): TPoint2D;
var
  LocalGrid: TCustomModelGrid;
  LocalMesh: TSutraMesh3D;
begin
  LocalGrid := Grid;
  if LocalGrid <> nil then
  begin
    result := LocalGrid.TwoDElementCorner(Column, Row);
  end
  else
  begin
    LocalMesh := Mesh as TSutraMesh3D;
    Assert(LocalMesh <> nil);
    Assert(Row = 0);
    result := LocalMesh.Mesh2D.Nodes[Column].Location;
  end;
end;

function TCustomModel.CheckMt3dTimes(ShowWarning: Boolean): boolean;
var
  ModflowEndTime: Double;
  MbResult: Integer;
  TimeIndex: Integer;
  Mt3dmsEndTime: Double;
begin
  result := Mt3dmsTimes.Count >= 1;
  if result then
  begin
    ModflowEndTime := ModflowFullStressPeriods[
      ModflowFullStressPeriods.Count - 1].EndTime;
    Mt3dmsEndTime := Mt3dmsTimes[Mt3dmsTimes.Count - 1].EndTime;
    if Mt3dmsEndTime < ModflowEndTime then
    begin
      if ShowWarning then
      begin
        MbResult := Application.MessageBox(PChar(Format(StrTheFinalTimeSpeci,
          [Mt3dmsEndTime, ModflowEndTime])), PChar(StrTimesDoNotMatch),
          MB_ICONASTERISK or MB_YESNOCANCEL);
      end
      else
      begin
        MbResult := idYes
      end;
      if MbResult = idYes then
      begin
        for TimeIndex := ModflowFullStressPeriods.Count - 1 downto 0 do
        begin
          if ModflowFullStressPeriods[TimeIndex].EndTime > Mt3dmsEndTime then
          begin
            ModflowFullStressPeriods.Delete(TimeIndex);
          end
          else
          begin
            break;
          end;
        end;
      end;
      result := not (MbResult in [0,IDCANCEL]);
    end;
  end
  else
  begin
    if ShowWarning then
    begin
      MessageDlg(StrNoStressPeriods, mtError, [mbOK], 0);
    end;
  end;
end;

function TCustomModel.IndenticalTransientArray(DataArray: TDataArray; DataArrays: TList;
      var CachedIndex: integer): TDataArray;
var
  Index: Integer;
  ADataArray: TDataArray;
  CachedDataArray: TDataArray;
begin
  // On entry DataArrays is a list of temporary TDataArray's
  // that have already had their Hash's computed.
  // CachedIndex is the location in DataArrays of the last
  // TDataArray that was identified in DataArrays via this procedure.
  Assert(DataArray <> nil);
  result := nil;
  CachedDataArray := nil;
  try
    DataArray.ComputeHash;
    // First check the most likely result.
    if (CachedIndex > 0)
      and (CachedIndex < DataArrays.Count) then
    begin
      CachedDataArray := DataArrays[CachedIndex];
      if CachedDataArray.Hash = DataArray.Hash then
      begin
        // If the Hash's are identical it is extremely likely
        // but not certain that the data are identical too.
        // Compare the two arrays to make absolutely sure they are
        // the same.
        if DataArray.IdenticalDataArrayContents(CachedDataArray) then
        begin
          result := CachedDataArray;
          CachedDataArray := nil;
          Exit;
        end;
      end;
    end;
    // No identical array was found so check all the arrays in the list.
    // The most recent array is the one most likely to be identical.
    for Index := DataArrays.Count - 1 downto 0 do
    begin
      if Index = CachedIndex then
      begin
        // This one has already been checked so skip it.
        Continue;
      end;
      ADataArray := DataArrays[Index];
      if ADataArray.Hash = DataArray.Hash then
      begin
        if DataArray.IdenticalDataArrayContents(ADataArray) then
        begin
          result := ADataArray;
          CachedIndex := Index;
          Exit;
        end;
        // ADataArray had the same Hash as DataArray.
        // The data had to be restored to to compare it's contents
        // so Cache it again.
        ADataArray.CacheData;
      end;
    end;

  finally
    if (CachedDataArray <> nil) and (result <> nil) then
    begin
      // a different data array was found so CachedDataArray
      // won't be checked first next time.
      // Cache its data.
      CachedDataArray.CacheData;
    end;
  end;
end;

function TCustomModel.IndenticalTransientMultiplierArray(DataArray: TDataArray): TDataArray;
begin
  result := IndenticalTransientArray(DataArray,
    TransientMultiplierArrays, FCachedMultiplierArrayIndex);
end;

function TCustomModel.IndenticalTransientZoneArray(DataArray: TDataArray): TDataArray;
begin
  result := IndenticalTransientArray(DataArray,
    TransientZoneArrays, FCachedZoneArrayIndex);
end;

function TCustomModel.IndexOfMt3dmsSpeciesName(
  const AChemSpecies: string): integer;
begin
  result := MobileComponents.IndexOfName(AChemSpecies);
  if result < 0 then
  begin
    result := ImmobileComponents.IndexOfName(AChemSpecies);
    if result >= 0 then
    begin
      result := result + MobileComponents.Count;
    end;
  end;
end;

resourcestring
  StrAllotmentTooEarly = 'The specified times for allotments include times '
    + 'before the beginning of the first stress period.';
  StrAllotmentTooLate = 'The specified times for allotments include times '
    + 'after the end of the last stress period.';
  StrWhenUsingZonebudge = 'When using ZoneBudget with MODFLOW-OWHM version 2' +
  ', be sure to use the modified version that comes with MODFLOW-OWHM versio' +
  'n 2';
  StrTheVersionOfZoneB = 'The version of ZoneBudget for MODFLOW-OWHM is typic' +
  'ally in <root>\postprocessors\zonebudget where <root> is the base directo' +
  'ry for MODFLOW-OWHM. Set the location of ZoneBudget in the "Model|MODFLOW' +
  ' Program Locations" dialog box.';
  StrNoInputDataSetOb = 'No input data set observations for the following da' +
  'ta sets because all the weights were 0.';
  StrMoreThan200Input = 'More than 200 input data set observations for the f' +
  'ollowing data sets. Excessive numbers of observations can cause excessive' +
  ' memory use by PEST.';
  StrUnableToExportThe = 'Unable to export the input for SvdaPrep because th' +
  'e file "%s" does not exist. It is normally created in "File|Export|PEST|' +
  'Calculate Number of Super-Parameters".';

procedure TCustomModel.UpdateAllotmentFullStressPeriods(TimeList: TRealList);
var
  PhastModel: TPhastModel;
  TestFirstTime: double;
  LastTestTime: double;
  OutOfStartRange, OutOfEndRange: Boolean;
begin
  if (not ModflowPackages.FarmProcess.IsSelected)
    or (ModflowPackages.FarmProcess.SurfaceWaterAllotment <> swaEqual) then
  begin
    Exit;
  end;

  TestFirstTime := TimeList.First;
  LastTestTime := TimeList.Last;
  if self is TChildModel then
  begin
    PhastModel := TChildModel(self).ParentModel as TPhastModel;
  end
  else
  begin
    PhastModel := self as TPhastModel;
  end;
  OutOfStartRange := False;
  OutOfEndRange := False;

  PhastModel.FmpAllotment.UpdateTimes(TimeList, TestFirstTime, LastTestTime,
      OutOfStartRange, OutOfEndRange);

  if OutOfStartRange then
  begin
    frmErrorsAndWarnings.AddWarning(self,
      StrAnyTimesBeforeThe, StrAllotmentTooEarly);
  end;

  if OutOfEndRange then
  begin
    frmErrorsAndWarnings.AddWarning(self,
      StrAnyTimesAfterThe, StrAllotmentTooLate);
  end;
end;

procedure TCustomModel.UpdateCropFullStressPeriods(TimeList: TRealList);
var
  CropOutOfStartRange: TStringList;
  CropOutOfEndRange: TStringList;
  CropIndex: integer;
  PhastModel: TPhastModel;
  ACrop: TCropItem;
  SpressPeriodCount: integer;
  TestFirstTime: double;
  LastTestTime: double;
  OutOfStartRange, OutOfEndRange: Boolean;
  StressPeriod: TModflowStressPeriod;
  FirstTime: double;
  ErrorMessage: string;
  LastTime: double;
begin
  if not ModflowPackages.FarmProcess.IsSelected then
  begin
    Exit;
  end;

  CropOutOfStartRange := TStringList.Create;
  CropOutOfEndRange := TStringList.Create;
  try
    TestFirstTime := TimeList.First;
    LastTestTime := TimeList.Last;
    if self is TChildModel then
    begin
      PhastModel := TChildModel(self).ParentModel as TPhastModel;
    end
    else
    begin
      PhastModel := self as TPhastModel;
    end;
    for CropIndex := 0 to PhastModel.FmpCrops.Count - 1 do
    begin
      ACrop := PhastModel.FmpCrops[CropIndex];
      SpressPeriodCount := TimeList.Count;
      ACrop.UpdateTimes(TimeList, TestFirstTime, LastTestTime,
        OutOfStartRange, OutOfEndRange);
      if OutOfStartRange then
      begin
        CropOutOfStartRange.Add(ACrop.CropName);
      end;
      if OutOfEndRange then
      begin
        CropOutOfEndRange.Add(ACrop.CropName);
      end;
      if SpressPeriodCount <> TimeList.Count then
      begin
        frmErrorsAndWarnings.AddWarning(self, StrCropAddedTimes, ACrop.CropName);
      end;
    end;

    if CropOutOfStartRange.Count > 0 then
    begin
      if ModflowStressPeriods.Count > 0 then
      begin
        StressPeriod := ModflowStressPeriods.First;
        if TimeList.Count > 0 then
        begin
          FirstTime := TimeList.First;
        end
        else
        begin
          FirstTime := 0;
        end;
        ErrorMessage := Format(StrTheBeginningOfTheCrop,
          [StressPeriod.StartTime, FirstTime]);
        CropOutOfStartRange.Insert(0, ErrorMessage);

        frmErrorsAndWarnings.AddWarning(self,
          StrAnyTimesBeforeThe, CropOutOfStartRange.Text);
      end
      else
      begin
        frmErrorsAndWarnings.AddError(self, StrMODFLOWStressPerio,
          StrSelectModelMODFLO);
      end;
    end;

    if CropOutOfEndRange.Count > 0 then
    begin
      if ModflowStressPeriods.Count > 0 then
      begin
        StressPeriod := ModflowStressPeriods.Last;
        if TimeList.Count > 0 then
        begin
          LastTime := TimeList.Last;
        end
        else
        begin
          LastTime := 0;
        end;
        ErrorMessage := Format(StrTheEndOfTheLastCrop,
          [StressPeriod.StartTime, LastTime]);
        CropOutOfEndRange.Insert(0, ErrorMessage);

        frmErrorsAndWarnings.AddWarning(self,
          StrAnyTimesAfterThe, CropOutOfEndRange.Text);
      end
      else
      begin
        frmErrorsAndWarnings.AddError(self, StrMODFLOWStressPerio,
          StrSelectModelMODFLO);
      end;
    end;
  finally
    CropOutOfStartRange.Free;
    CropOutOfEndRange.Free;
  end;
end;

procedure TCustomModel.UpdateMawSteadyData(Sender: TObject);
var
  MawWriter: TModflowMAW_Writer;
begin
  frmProgressMM.ShouldContinue := True;
  MawWriter := TModflowMAW_Writer.Create(Self, etDisplay);
  try
    MawWriter.UpdateSteadyData;
  finally
    MawWriter.Free;
  end;
end;

procedure TCustomModel.UpdateModflowFullStressPeriods;
var
  TimeList: TRealList;
  TimeIndex: integer;
  StressPeriod, NewStressPeriod: TModflowStressPeriod;
  ScreenObjectIndex, StressPeriodIndex: Integer;
  ScreenObject: TScreenObject;
  StartTime, EndTime: double;
  FirstTime: Double;
  DeletedTimes: Boolean;
  TestFirstTime: Double;
  LastTestTime: Double;
  OutOfStartRange: Boolean;
  OutOfEndRange: Boolean;
  OutOfStartRangeScreenObjects: TStringList;
  OutOfEndRangeScreenObjects: TStringList;
  ErrorMessage: string;
  SpressPeriodCount: Integer;
  MtTime: TMt3dmsTimeItem;
  OutOfRangeMt3dTime: Boolean;
  ShowUzfLakeWarning: boolean;
  UzfLakUsed: boolean;
begin
  if FUpdatingFullStressPeriods then
  begin
    Exit;
  end;
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrAnyTimesAfterThe);
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrAnyTimesBeforeThe);
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrAddedTimes);
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrMultiplierWarning);
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrCropAddedTimes);
  frmErrorsAndWarnings.RemoveErrorGroup(self, StrInvalidStressPerio);
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrNoStressPeriodsWe);

  if ModflowStressPeriods.Count = 0 then
  begin
    frmErrorsAndWarnings.AddWarning(self, StrNoStressPeriodsWe,
      StrStressPeriodAdded);
    StressPeriod := ModflowStressPeriods.Add as TModflowStressPeriod;
    StressPeriod.StartTime := -1;
    StressPeriod.EndTime := 0;
    StressPeriod.StressPeriodType := sptSteadyState;
    StressPeriod.MaxLengthOfFirstTimeStep := 1;
    StressPeriod.DrawDownReference := True;
    StressPeriod.TimeStepMultiplier := 1;
  end;

  ModflowFullStressPeriods.Clear;
  TimeList := TRealList.Create;
  try
    FUpdatingFullStressPeriods := True;
    TimeList.Sort;
    ShowUzfLakeWarning := False;
    UzfLakUsed := ModflowPackages.UzfPackage.IsSelected
      or ModflowPackages.LakPackage.IsSelected;
    for TimeIndex := 0 to ModflowStressPeriods.Count - 1 do
    begin
      StressPeriod := ModflowStressPeriods[TimeIndex];
      TimeList.AddUnique(StressPeriod.StartTime);
      TimeList.AddUnique(StressPeriod.EndTime);
      if StressPeriod.StartTime >= StressPeriod.EndTime then
      begin
        frmErrorsAndWarnings.AddError(self, StrInvalidStressPerio,
          StrInModelMuseAllStr);
      end;
      if UzfLakUsed and (StressPeriod.TimeStepMultiplier <> 1) then
      begin
        ShowUzfLakeWarning := True;
      end;
    end;
    if ShowUzfLakeWarning then
    begin
      frmErrorsAndWarnings.AddWarning(self, StrMultiplierWarning,
        StrMultiplierFullWarning);
    end;
    TestFirstTime := TimeList[0];
    LastTestTime := TimeList[TimeList.Count-1];

    OutOfRangeMt3dTime := False;
    for TimeIndex := 0 to Mt3dmsTimes.Count - 1 do
    begin
      MtTime := Mt3dmsTimes[TimeIndex];
      if (MtTime.StartTime >= TestFirstTime)
        and (MtTime.StartTime <= LastTestTime) then
      begin
        TimeList.AddUnique(MtTime.StartTime);
      end
      else
      begin
        OutOfRangeMt3dTime := True;
      end;
      if (MtTime.EndTime >= TestFirstTime)
        and (MtTime.EndTime <= LastTestTime) then
      begin
        TimeList.AddUnique(MtTime.EndTime);
      end
      else
      begin
        OutOfRangeMt3dTime := True;
      end;
    end;

    Assert(TimeList.Count >= 1);
    if TimeList.Count >= 2 then
    begin
      F_SP_Epsilon := (TimeList[1] - TimeList[0]);
    end
    else
    begin
      F_SP_Epsilon := 0;
    end;
    for TimeIndex := 2 to TimeList.Count - 1 do
    begin
      F_SP_Epsilon := Min(F_SP_Epsilon,
        TimeList[TimeIndex] - TimeList[TimeIndex-1]);
    end;
    F_SP_Epsilon := F_SP_Epsilon*TimeEpsilon;
    F_SP_Epsilon := Max(0, F_SP_Epsilon);

    if OutOfRangeMt3dTime then
    begin
      frmErrorsAndWarnings.AddWarning(self,
        StrInvalidTimesForMT, StrTheStressPeriodsD);
    end;

    if ((ModelSelection = msModflowFmp) and
      ModflowPackages.FarmProcess.IsSelected)
      or ((ModelSelection = msModflowOwhm2) and
      ModflowPackages.FarmProcess4.IsSelected)
      then
    begin
      { TODO -cOWHMV2 : The following may need to be updated for MODFLOW OWHM version 2. }
      UpdateCropFullStressPeriods(TimeList);
      UpdateAllotmentFullStressPeriods(TimeList);
      UpdateFarmsFullStressPeriods(TimeList);
      UpdateIrrigationTypesFullStressPeriods(TimeList)
    end;

    OutOfStartRangeScreenObjects := TStringList.Create;
    OutOfEndRangeScreenObjects := TStringList.Create;
    try

      for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
      begin
        ScreenObject := ScreenObjects[ScreenObjectIndex];
        if ScreenObject.Deleted then
        begin
          Continue;
        end;
        SpressPeriodCount := TimeList.Count;
        ScreenObject.UpdateModflowTimes(TimeList,
          TestFirstTime, LastTestTime, OutOfStartRange, OutOfEndRange);
        if not frmProgressMM.ShouldContinue then
        begin
          Exit;
        end;
        if OutOfStartRange then
        begin
          OutOfStartRangeScreenObjects.Add(ScreenObject.Name);
        end;
        if OutOfEndRange then
        begin
          OutOfEndRangeScreenObjects.Add(ScreenObject.Name);
        end;
        if SpressPeriodCount <> TimeList.Count then
        begin
          frmErrorsAndWarnings.AddWarning(self, StrAddedTimes,
            ScreenObject.Name, ScreenObject);
        end;
      end;

      // In the 64-bit version, TRealList.AddUnique can result in values
      // being added that should not have been added.
      for TimeIndex := TimeList.Count - 1 downto 1 do
      begin
        if TimeList[TimeIndex] - TimeList[TimeIndex-1] < F_SP_Epsilon then
        begin
          TimeList.Delete(TimeIndex);
        end;
      end;

      DeletedTimes := False;
      StressPeriod := ModflowStressPeriods[0];
      FirstTime := 0;
      While TimeList.Count > 0 do
      begin
        if TimeList[0] < StressPeriod.StartTime then
        begin
          if not DeletedTimes then
          begin
            FirstTime := TimeList[0]
          end;
          TimeList.Delete(0);
          DeletedTimes := True;
        end
        else
        begin
          break;
        end;
      end;

      if DeletedTimes then
      begin
        ErrorMessage := Format(StrTheBeginningOfThe,
          [StressPeriod.StartTime, FirstTime]);
        OutOfStartRangeScreenObjects.Insert(0, ErrorMessage);

        frmErrorsAndWarnings.AddWarning(self,
          StrAnyTimesBeforeThe, OutOfStartRangeScreenObjects.Text);
      end;

      TimeIndex := 0;
      for StressPeriodIndex := 0 to ModflowStressPeriods.Count - 1 do
      begin
        if (TimeIndex+1 >= TimeList.Count) and (TimeList.Count > 1) then
        begin
          break;
        end;
        StressPeriod := ModflowStressPeriods[StressPeriodIndex];
        StartTime := TimeList[TimeIndex];
        if TimeList.Count > 1 then
        begin
          EndTime := TimeList[TimeIndex+1];
        end
        else
        begin
          EndTime := StartTime;
        end;
        While (EndTime <= StressPeriod.EndTime) do
        begin
          NewStressPeriod :=
            ModflowFullStressPeriods.Add as TModflowStressPeriod;
          NewStressPeriod.Assign(StressPeriod);
          NewStressPeriod.StartTime := StartTime;
          NewStressPeriod.EndTime := EndTime;
          NewStressPeriod.PeriodLength :=
            NewStressPeriod.EndTime - NewStressPeriod.StartTime;
          Inc(TimeIndex);
          if TimeIndex+1 >= TimeList.Count then
          begin
            break;
          end;
          StartTime := TimeList[TimeIndex];
          EndTime := TimeList[TimeIndex+1];
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
        end;
      end;

      StressPeriod := ModflowStressPeriods[ModflowStressPeriods.Count - 1];
      EndTime := TimeList[TimeList.Count -1];
      if EndTime > StressPeriod.EndTime then
      begin
        ErrorMessage := Format(StrTheEndOfTheLast,
          [StressPeriod.EndTime, EndTime]);
        OutOfEndRangeScreenObjects.Insert(0, ErrorMessage);
        frmErrorsAndWarnings.AddWarning(self,
          StrAnyTimesAfterThe,OutOfEndRangeScreenObjects.Text);
      end;
    finally
      OutOfEndRangeScreenObjects.Free;
      OutOfStartRangeScreenObjects.Free;
    end;

  finally
    TimeList.Free;
    FUpdatingFullStressPeriods := False;
  end;
end;

procedure TCustomModel.AddTimeList(TimeList: TCustomTimeList);
begin
  if FTimeLists.IndexOf(TimeList) < 0 then
  begin
    FTimeLists.Add(TimeList);
  end;
end;

//procedure TCustomModel.AddUsedPestDataArray(ADataArray: TDataArray);
//begin
//  if not FPestBoundaryDataArrays.ContainsKey(ADataArray.Name) then
//  begin
//    FPestBoundaryDataArrays.Add(ADataArray.Name, ADataArray);
//  end;
//end;

procedure TCustomModel.AddZoneBudgetInputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FZoneBudgetInputFiles);
end;

procedure TCustomModel.AddZoneBudgetOutputFile(AFileName: string);
begin
  TestAddModelModelFile(AFileName, FZoneBudgetOutputFiles);
end;

procedure TCustomModel.AdjustCellPosition(ACellAssignment: TCellAssignment);
begin
  // do nothing;
end;

procedure TCustomModel.AdjustResKvArray(Sender: TObject);
begin
  AdjustDataArray(Sender as TDataArray);
end;

procedure TCustomModel.AdjustCellPosition(AValueCell: TValueCell);
begin
  // do nothing
end;

procedure TCustomModel.GetDefaultOutputFileExtension(var Extension: string);
begin
  if ModflowOutputControl.HeadOC.SaveInExternalFile then
  begin
    case ModflowOutputControl.HeadOC.OutputFileType of
      oftText:
        begin
          Extension := StrFhd;
        end;
      oftBinary:
        begin
          Extension := StrBhd;
        end;
    else
      Assert(False);
    end;
  end
  else if ModflowOutputControl.DrawdownOC.SaveInExternalFile then
  begin
    case ModflowOutputControl.DrawdownOC.OutputFileType of
      oftText:
        begin
          Extension := StrFdn;
        end;
      oftBinary:
        begin
          Extension := StrBdn;
        end;
    else
      Assert(False);
    end;
  end
  else if ModflowOutputControl.SaveCellFlows in [csfBinary, csfBoth] then
  begin
    Extension := StrCbcExt;
  end
  else
  begin
    Extension := '';
  end;
end;

function TCustomModel.GetDetermineKyFromAnisotropy: TNotifyEvent;
begin
  result := DoDetermineKyFromAnisotropy;
end;

function TCustomModel.GetDetermineKzFromAnisotropy: TNotifyEvent;
begin
  result := DoDetermineKzFromAnisotropy;
end;

function TCustomModel.RelativeFileName(const FullFileName: string): string;
var
  BaseDir: string;
begin
  Result := FullFileName;
  BaseDir := ModelFileName;
  if BaseDir <> '' then
  begin
    BaseDir := ExtractFileDir(BaseDir);
    BaseDir := IncludeTrailingPathDelimiter(BaseDir);
    Result := ExtractRelativePath(BaseDir, Result);
  end;
end;

procedure TCustomModel.RemoveFormulaObject(FormulaObject: TFormulaObject;
  OnRemoveSubscription, OnRestoreSubscription: TChangeSubscription;
  Subject: TObject);
begin
  FormulaManager.Remove(FormulaObject, OnRemoveSubscription,
    OnRestoreSubscription, Subject);
end;

procedure TCustomModel.RemoveFormulaObject(FormulaObject: IFormulaObject;
  OnRemoveSubscription, OnRestoreSubscription: TChangeSubscription;
  Subject: TObject);
begin
  RemoveFormulaObject(FormulaObject as TFormulaObject,
    OnRemoveSubscription, OnRestoreSubscription, Subject);
end;

procedure TCustomModel.RemoveTimeList(TimeList: TCustomTimeList);
begin
  FTimeLists.Remove(TimeList);
  if TimeList = ThreeDTimeList then
  begin
    ThreeDTimeList := nil;
    ThreeDDataSet := nil;
    TopDataSet := nil;
    FrontDataSet := nil;
    SideDataSet := nil;

  end;
  if TimeList = TopTimeList then
  begin
    TopTimeList := nil;
    TopDataSet := nil;
  end;
  if TimeList = FrontTimeList then
  begin
    FrontTimeList := nil;
    FrontDataSet := nil;
  end;
  if TimeList = SideTimeList then
  begin
    SideTimeList := nil;
    SideDataSet := nil;
  end;
end;

procedure TCustomModel.RemoveVariables(const DataSetName: String;
  Orientation: TDataSetOrientation; EvaluatedAt: TEvaluatedAt);
var
  TempCompiler: TRbwParser;
  Local3DCompiler: TRbwParser;
  VarIndex: integer;
  Variable: TCustomVariable;
  LocalModel: TPhastModel;
  ChildIndex: Integer;
  ChildItem: TChildModelItem;
begin
  TempCompiler := GetCompiler(Orientation,
    EvaluatedAt);

  Local3DCompiler := nil;
  case EvaluatedAt of
    eaBlocks:
      begin
        Local3DCompiler := rpThreeDFormulaCompiler;
      end;
    eaNodes:
      begin
        Local3DCompiler := rpThreeDFormulaCompilerNodes;
      end;
  else
    Assert(False);
  end;
  VarIndex := TempCompiler.IndexOfVariable(DataSetName);
  if VarIndex >= 0 then
  begin
    Variable := TempCompiler.Variables[VarIndex] as TCustomVariable;
    TempCompiler.RemoveVariable(Variable);
  end;
  if TempCompiler <> Local3DCompiler then
  begin
    VarIndex := Local3DCompiler.IndexOfVariable(DataSetName);
    if VarIndex >= 0 then
    begin
      Variable := Local3DCompiler.Variables[VarIndex] as TCustomVariable;
      Local3DCompiler.RemoveVariable(Variable);
    end;
  end;
  if self is TPhastModel then
  begin
    LocalModel := TPhastModel(self);
    for ChildIndex := 0 to LocalModel.ChildModels.Count - 1 do
    begin
      ChildItem := LocalModel.ChildModels[ChildIndex];
      if ChildItem.ChildModel <> nil then
      begin
        ChildItem.ChildModel.RemoveVariables(DataSetName, Orientation, EvaluatedAt);
      end;
    end;
  end;
end;

procedure TCustomModel.RemoveVariables(const DataSet: IDataArray);
begin
  RemoveVariables(DataSet as TDataArray);
end;

function TCustomModel.GetTimeLists(Index: integer): TCustomTimeList;
begin
  result := FTimeLists[Index];
end;

function TCustomModel.GetTimeListCount: integer;
begin
  result := FTimeLists.Count;
end;

function TCustomModel.GetThreeDGridObserver: TObserver;
begin
  result := FThreeDGridObserver;
end;

function TCustomModel.GetTimeListByName(const AName: string): TCustomTimeList;
var
  Index: Integer;
  TimeList: TCustomTimeList;
begin
  Assert(AName <> '');
  result := nil;
  for Index := 0 to FTimeLists.Count - 1 do
  begin
    TimeList := FTimeLists[Index];
    if TimeList.Name = AName then
    begin
      result := TimeList;
      Exit;
    end;
  end;
end;

procedure TCustomModel.ClearAllTimeLists;
var
  Index: Integer;
  TimeList: TModflowBoundaryDisplayTimeList;
begin
  for Index := 0 to FTimeLists.Count - 1 do
  begin
    TimeList := FTimeLists[Index];
    TimeList.Invalidate;
    TimeList.Clear;
  end;
end;

procedure TCustomModel.ClearBinaryFiles;
begin
  FBinaryFiles.Clear;
end;

procedure TPhastModel.SetObservationPurpose(const Value: TObservationPurpose);
begin
  if FObservationPurpose <> Value then
  begin
    FObservationPurpose := Value;
    DoInvalidate(self);
  end;
end;

procedure TCustomModel.InitializeTobDisplay(Sender: TObject);
var
  TobWriter: TMt3dmsTobWriter;
  List: TModflowBoundListOfTimeLists;
begin
  Mt3dTobCond.CreateDataSets;

  List := TModflowBoundListOfTimeLists.Create;
  TobWriter := TMt3dmsTobWriter.Create(Self, etDisplay);
  try
    List.Add(Mt3dTobCond);
    TobWriter.UpdateDisplay(List, [0], ObservationPurpose);
  finally
    TobWriter.Free;
    List.Free;
  end;
  Mt3dTobCond.ComputeAverage;
  if frmErrorsAndWarnings.HasMessages then
  begin
    frmErrorsAndWarnings.Show;
  end;
end;

procedure TCustomModel.InitializeHobDisplay(Sender: TObject);
var
  HobWriter: TModflowHobWriter;
  List: TModflowBoundListOfTimeLists;
begin
  MfHobHeads.CreateDataSets;

  List := TModflowBoundListOfTimeLists.Create;
  HobWriter := TModflowHobWriter.Create(Self, etDisplay);
  try
    List.Add(MfHobHeads);
    HobWriter.UpdateDisplay(List, [0], ObservationPurpose);
  finally
    HobWriter.Free;
    List.Free;
  end;
  MfHobHeads.ComputeAverage;
  if frmErrorsAndWarnings.HasMessages then
  begin
    frmErrorsAndWarnings.Show;
  end;
end;

procedure TCustomModel.InitializeSfrWriter(EvaluationType: TEvaluationType);
begin
  FreeAndNil(SfrWriter);
  FreeAndNil(LakWriter);
  FreeAndNil(FarmWriter3);
  FreeAndNil(FarmWriter4);
  SfrWriter := TModflowSFR_Writer.Create(self, EvaluationType);
  LakWriter := TModflowLAK_Writer.Create(self, EvaluationType);
  FarmWriter3 := TModflowFmpWriter.Create(self, EvaluationType);
  FarmWriter4 := TModflowFmp4Writer.Create(self, EvaluationType);
end;

function TCustomModel.MawScreenObjects: TStringList;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  if FMawScreenObjects = nil then
  begin
    FMawScreenObjects := TStringList.Create;
  end
  else
  begin
    FMawScreenObjects.Clear;
  end;
  if ModflowPackages.MawPackage.IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if (not AScreenObject.Deleted)
        and (AScreenObject.ModflowMawBoundary <> nil)
        and (AScreenObject.ModflowMawBoundary .Used) then
      begin
        FMawScreenObjects.addObject(AScreenObject.Name, AScreenObject);
      end;
    end;
  end;
  result := FMawScreenObjects;
end;

function TCustomModel.DoMawSelected(Sender: TObject): Boolean;
begin
  result := ModflowPackages.MawPackage.IsSelected;
end;

function TCustomModel.MaxColumnCount: Integer;
begin
  if Grid <> nil then
  begin
    result := Grid.ColumnCount+1;
  end
  else if Mesh3D <> nil then
  begin
    result := Mesh3D.Mesh2DI.NodeCount;
  end
  else
  begin
    result := 0;
  end;
end;

function TCustomModel.Mf6GweUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.GweProcess.IsSelected
end;

function TCustomModel.Mf6GwtUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.GwtProcess.IsSelected
//    and (ModflowPackages.Mt3dBasic.Mt3dVersion = mvMf6Gwt);
end;

function TCustomModel.Mf6ObsIsSelected: Boolean;
begin
  result := (ModelSelection = msModflow2015)
    and ModflowPackages.Mf6ObservationUtility.IsSelected;
end;

procedure TCustomModel.ModelObserversStopTalkingTo(Observer: TObserver);
begin
  FTopGridObserver.StopsTalkingTo(Observer);
  FThreeDGridObserver.StopsTalkingTo(Observer);
  FHufSyNotifier.StopsTalkingTo(Observer);
  FHufSsNotifier.StopsTalkingTo(Observer);
  FHufKzNotifier.StopsTalkingTo(Observer);
  FHufKyNotifier.StopsTalkingTo(Observer);
  FHufKxNotifier.StopsTalkingTo(Observer);

end;

function TCustomModel.DoModflow6Selected(Sender: TObject): boolean;
begin
  result := ModelSelection = msModflow2015;
end;

function TCustomModel.ModflowConfiningBedCount: integer;
begin
  result := LayerStructure.ModflowConfiningBedCount;
end;

function TCustomModel.Mt3dmsTobPackageUsed(Sender: TObject): boolean;
begin
  result := ModflowPackages.Mt3dmsTransObs.IsSelected and
    ModflowPackages.Mt3dBasic.IsSelected;
end;

function TCustomModel.ModflowHobPackageUsed(Sender: TObject): boolean;
begin
  result := ModflowPackages.HobPackage.IsSelected;
end;

function TCustomModel.GetMawSelected: TObjectUsedEvent;
begin
  Result := DoMawSelected;
end;

function TCustomModel.GetMesh: IMesh;
begin
  if ModelSelection in SutraSelection then
  begin
    result := SutraMesh;
  end
  else
  begin
    result := nil;
  end;
end;

function TCustomModel.GetMesh3D: IMesh3D;
begin
  if ModelSelection in SutraSelection then
  begin
    result := SutraMesh;
  end
  else if DisvUsed then
  begin
    result := DisvGrid;
  end
  else
  begin
    result := nil;
  end;
end;

function TCustomModel.GetMt3dMSBulkDensityUsed: TObjectUsedEvent;
begin
  result := DoMt3dMSBulkDensityUsed;
end;

function TCustomModel.GetMt3dMSImmobPorosityUsed: TObjectUsedEvent;
begin
  result := DoMt3dMSImmobPorosityUsed;
end;

function TCustomModel.GetMt3dMS_StrictUsed: TObjectUsedEvent;
begin
  result := DoMt3dMS_StrictUsed;
end;

function TCustomModel.GetMt3dSpecesName(const Index: Integer): string;
begin
  if Index < MobileComponents.Count then
  begin
    result := MobileComponents[Index].Name;
  end
  else
  begin
    result := ImMobileComponents[Index - MobileComponents.Count].Name;
  end;
end;

procedure TCustomModel.GetMt3dTobCondUseList(Sender: TObject;
  NewUseList: TStringList);
begin
  NewUseList.Add(rsActive);
  // do nothing
end;


function TCustomModel.GetMt3d_LktIsSelected: TObjectUsedEvent;
begin
  Result := DoMt3d_LktIsSelected;
end;

function TCustomModel.GetNpfUsed: TObjectUsedEvent;
begin
  result := DoNpfUsed
end;

function TCustomModel.GetInputObsInstructionFileNames: TStrings;
begin
  result := FInputObsInstructionFileNames;
end;

function TCustomModel.GetNrdInfilLocationUsed: TObjectUsedEvent;
begin
  result := DoNrdInfilLocationUsed;
end;

function TCustomModel.GetMf6TimesSeriesI: ITimesSeriesCollections;
begin
  result := Mf6TimesSeries;
end;

procedure TCustomModel.GetMfHobHeadsUseList(Sender: TObject;
  NewUseList: TStringList);
begin
  NewUseList.Add(rsActive);
  // do nothing
end;

function TCustomModel.GetMobileComponentCount: Integer;
begin
  result := MobileComponents.Count;
end;

function TCustomModel.GetModelInputFiles: TStrings;
var
  index: Integer;
  ATabFile: string;
begin
  if DoSwrSelected(nil) then
  begin
    for index := 0 to SwrTabFiles.Count - 1 do
    begin
      ATabFile := SwrTabFiles[index].FullTabFileName;
      if (ATabFile <> '') and (FModelInputFiles.IndexOf(ATabFile) < 0) then
      begin
        FModelInputFiles.Add(ATabFile);
      end;
    end;
  end;
  for index := FModelInputFiles.Count - 1 downto 0 do
  begin
    if Trim(FModelInputFiles[index]) = '' then
    begin
      FModelInputFiles.Delete(Index);
    end;
  end;
  result := FModelInputFiles;
end;

function TCustomModel.GetModflow6Selected: TObjectUsedEvent;
begin
  result := DoModflow6Selected;
end;

function TCustomModel.GetModflowInitialHeadUsed: TObjectUsedEvent;
begin
  result := DoModflowInitialHeadUsed;
end;

function TCustomModel.GetModflowLocation: string;
begin
  case ModelSelection of
    msModflow: result := ProgramLocations.ModflowLocation;
    msModflowLGR: result := ProgramLocations.ModflowLgrLocation;
    msModflowLGR2: result := ProgramLocations.ModflowLgr2Location;
    msModflowNWT: result := ProgramLocations.ModflowNwtLocation;
    msModflowFmp: result := ProgramLocations.ModflowOwhmLocation;
    msModflowCfp: result := ProgramLocations.ModflowCfpLocation;
    msModflow2015: result := ProgramLocations.Modflow6Location;
    msModflowOwhm2: result := ProgramLocations.ModflowOwhmV2Location;
    else result := ProgramLocations.ModflowLocation;
  end;
end;

function TCustomModel.GetModflowOptions: TModflowOptions;
begin
  result := FModflowOptions;
end;

function TCustomModel.GetModflowPackages: TModflowPackages;
begin
  result := FModflowPackages
end;

function TCustomModel.GetModflowUsed: TObjectUsedEvent;
begin
  result := DoModflowUsed;
end;

function TCustomModel.GetModpathBudgetNeeded: TObjectUsedEvent;
begin
  result := DoModpathBudgetNeeded;
end;

function TCustomModel.GetModPathLocation: string;
begin
  Result := '';
  case ModflowPackages.ModPath.MpathVersion of
    mp5: result := ProgramLocations.ModPathLocation;
    mp6: result := ProgramLocations.ModPathLocationVersion6;
    mp7: result := ProgramLocations.ModPathLocationVersion7;
    else Assert(False);
  end;
end;

function TCustomModel.GetModpathRetardationNeeded: TObjectUsedEvent;
begin
  result := DoModpathRetardationNeeded;
end;

function TCustomModel.GetModpathZonesNeeded: TObjectUsedEvent;
begin
  result := DoModpathZonesNeeded;
end;

function TCustomModel.GetObserverByName(const ObserverName: string): TObserver;
begin
  result := FDataArrayManager.GetDataSetByName(ObserverName);
  if result = nil then
  begin
    result := GlobalVariablesI.GetVariableByName(ObserverName) as TObserver;
  end;
end;

function TCustomModel.GetObsGroupFromName(const Value: string): IObservationGroup;
var
  ObservationGroups: TPestObservationGroups;
begin
  ObservationGroups := PestProperties.PriorInfoObservationGroups;
  result := ObservationGroups.GetObsGroupByName(Value);
end;

function TCustomModel.GetOnActiveDataSetChanged: TNotifyEvent;
begin
  result := DoOnActiveDataSetChanged
end;

function TCustomModel.GetOnNodeActiveDataSetChanged: TNotifyEvent;
begin
  result := DoOnNodeActiveDataSetChanged;
end;

function TCustomModel.GetOptionalDataSet: TObjectUsedEvent;
begin
  result := DoOptionalDataSet;
end;

procedure TCustomModel.CreateModflowDisplayTimeLists;
begin
  FMt3dTobCond := TMt3dmsTobDisplayTimeList.Create(self);
  FMt3dTobCond.OnInitialize := InitializeTobDisplay;
  FMt3dTobCond.OnGetUseList := GetMt3dTobCondUseList;
  FMt3dTobCond.OnTimeListUsed := Mt3dmsTobPackageUsed;
  FMt3dTobCond.Name := StrMt3dTobConcObservations;
  AddTimeList(FMt3dTobCond);

  FMfHobHeads := THobDisplayTimeList.Create(self);
  FMfHobHeads.OnInitialize := InitializeHobDisplay;
  FMfHobHeads.OnGetUseList := GetMfHobHeadsUseList;
  FMfHobHeads.OnTimeListUsed := ModflowHobPackageUsed;
  FMfHobHeads.Name := StrMODFLOWHeadObservations;
  AddTimeList(FMfHobHeads);
end;

function TCustomModel.ProgramName: string;
begin
  result := StrModelName;
end;

procedure TCustomModel.SetUnitNumbers(const Value: TUnitNumbers);
begin
  FUnitNumbers.Assign(Value);
end;

procedure TCustomModel.SetZoneBudgetInputFiles(const Value: TStrings);
begin
  FZoneBudgetInputFiles.Assign(Value);
end;

procedure TCustomModel.SetZoneBudgetOutputFiles(const Value: TStrings);
begin
  FZoneBudgetOutputFiles.Assign(Value);
end;

function TCustomModel.DoSfrMf6Selected(Sender: TObject): Boolean;
begin
  result := ModflowPackages.SfrModflow6Package.IsSelected;
end;

function TCustomModel.DoSftUsed(Sender: TObject): boolean;
begin
  result := (ModelSelection in [msModflowNWT])
    and DoMt3dMS_StrictUsed(Sender)
    and ModflowPackages.Mt3dSft.IsSelected;
end;

function TCustomModel.SfrMf6ScreenObjects: TStringList;
var
  ScreenObjectIndex: Integer;
  AScreenObject: TScreenObject;
begin
  if FSfrScreenObjects = nil then
  begin
    FSfrScreenObjects := TStringList.Create;
  end
  else
  begin
    FSfrScreenObjects.Clear;
  end;
  if ModflowPackages.SfrModflow6Package.IsSelected then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if (not AScreenObject.Deleted)
        and (AScreenObject.ModflowSfr6Boundary <> nil)
        and (AScreenObject.ModflowSfr6Boundary .Used) then
      begin
        FSfrScreenObjects.addObject(AScreenObject.Name, AScreenObject);
      end;
    end;
  end;
  result := FSfrScreenObjects;
end;

procedure TCustomModel.DoShouldActiveBeSetByCellSize(Sender: TObject;
  var ShouldCheck: Boolean);
var
  ActiveDatArray: TDataArray;
  AFormula: String;
  ObjectIndex: integer;
  AScreenObject: TScreenObject;
begin
  ShouldCheck := (Grid <> nil) or DisvUsed;
  if not ShouldCheck then
  begin
    Exit;
  end;
  Assert(Sender <> nil);
  ActiveDatArray := Sender as TDataArray;
  Assert(ActiveDatArray.Name = rsActive);
  AFormula := ActiveDatArray.Formula;
  ShouldCheck := (AFormula = 'True');
  if ShouldCheck then
  begin
    ShouldCheck := False;
    for ObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ObjectIndex];
      if AScreenObject.Deleted then
      begin
        Continue;
      end;

      if AScreenObject.CellSizeUsed and AScreenObject.Closed
        and (AScreenObject.ViewDirection = vdTop) then
      begin
        ShouldCheck := True;
        break;
      end;
    end;
  end;
end;

procedure TCustomModel.DoShouldKyBeDeterminedFromAnisotropy(Sender: TObject;
  var ShouldCheck: Boolean);
begin
  ShouldCheck := DoHorizAnisotropyMf6Used(Sender);
end;

procedure TCustomModel.DoShouldKzBeDeterminedFromAnisotropy(Sender: TObject;
  var ShouldCheck: Boolean);
begin
  ShouldCheck := DoVertAnisotropyMf6Used(Sender);
end;

function TCustomModel.PackageGeneratedExternally(const PackageName: string): boolean;
var
  Index: Integer;
  ALine: string;
  FirstChar: Integer;
  CharIndex: Integer;
  AChar: Char;
  LastChar: Integer;
  APackageName: string;
begin
  result := false;
  for Index := 0 to ModflowNameFileLines.Count - 1 do
  begin
    ALine := ModflowNameFileLines[Index];
    // skip comment lines
    if (Length(ALine) = 0) or (ALine[1] = '#') then
    begin
      Continue;
    end;
    ALine := Trim(ALine);
    FirstChar := Length(ALine)+1;
    for CharIndex := 1 to Length(ALine) do
    begin
      AChar := ALine[CharIndex];
      if not CharInSet(AChar, [',', ' ']) then
      begin
        FirstChar := CharIndex;
        break;
      end;
    end;
    LastChar := Length(ALine);
    for CharIndex := FirstChar + 1 to Length(ALine) do
    begin
      AChar := ALine[CharIndex];
      if CharInSet(AChar, [',', ' ']) then
      begin
        LastChar := CharIndex-1;
        break;
      end;
    end;
    APackageName := Copy(ALine, FirstChar, LastChar-FirstChar+1);
    if SameText(APackageName, PackageName) then
    begin
      result := True;
      Exit;
    end;
  end;
end;

procedure TCustomModel.WriteLAYCB(const DiscretizationWriter: TObject);
begin
  LayerStructure.WriteLAYCB(DiscretizationWriter);
end;

procedure TCustomModel.WritePValAndTemplate(const ParameterName: string;
  const Value: double; Parameter: TModflowParameter;
  DirectAddRequired: Boolean = false);
var
  NewLine: string;
  TemplateLine: string;
  SteadyParam: TModflowSteadyParameter;
begin
  NewLine := ParameterName + ' ' + FortranFloatToStr(Value);
  TemplateLine := ParameterName + ' ' + UcodeDelimiter + ParameterName
      + '                  ' + UcodeDelimiter;
  if Parameter.ParameterType = ptPEST then
  begin
    if Parameter.AddedToPval then
    begin
      Exit;
    end;
    SteadyParam := Parameter as TModflowSteadyParameter;
    if ((not SteadyParam.UsePilotPoints) and SteadyParam.UsedDirectly)
      or DirectAddRequired then
    begin
      Parameter.AddedToPval := True;
      NewLine := '#-- ' + NewLine;
      TemplateLine := '#-- ' + TemplateLine;
      if FPestPValFile.IndexOf(NewLine) < 0 then
      begin
        FPestPValFile.Add(NewLine);
        FPestPvalTemplate.Add(TemplateLine);
      end;
    end;
  end
  else
  begin
    if FPValFile.IndexOf(NewLine) < 0 then
    begin
      FPValFile.Add(NewLine);
      FPvalTemplate.Add(TemplateLine);
    end;
  end;
end;

//function TCustomModel.Xt3DUsed(Sender: TObject): boolean;
//begin
//  result := (ModelSelection = msModflow2015)
//    and ModflowPackages.NpfPackage.IsSelected
//    and ModflowPackages.NpfPackage.UseXT3D;
//end;

procedure TCustomModel.UpdateHfb(Sender: TObject);
var
  PhastModel: TPhastModel;
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  frmProgressMM.Caption := 'Progress';
  frmProgressMM.Show;
  frmProgressMM.ShouldContinue := True;
  if FHfbWriter = nil then
  begin
    FHfbWriter := TModflowHfb_Writer.Create(Self, etDisplay);
  end;
  (FHfbWriter as TModflowHfb_Writer).UpdateDisplay;
  frmProgressMM.Hide;
  if frmErrorsAndWarnings.HasMessages then
  begin
    frmErrorsAndWarnings.Show;
  end;
  if (self is TPhastModel) then
  begin
    PhastModel := TPhastModel(self);
    if PhastModel.LgrUsed then
    begin
      for ChildIndex := 0 to PhastModel.ChildModels.Count - 1 do
      begin
        ChildModel := PhastModel.ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          ChildModel.UpdateHfb(Sender);
        end;
      end;
    end;
  end;
end;

procedure TCustomModel.UpdateIdomain(Sender: TObject);
var
  IDomainArray: TDataArray;
  RowIndex: Integer;
  ColIndex: Integer;
  LayerIndex: Integer;
  LakeMf6Array: TDataArray;
  LakeComment: string;
  BottomLayer: Integer;
  ConnectionTypes: Integer;
begin
  IDomainArray := FDataArrayManager.GetDataSetByName(K_IDOMAIN);
  Assert(IDomainArray <>  nil);
  for RowIndex := 0 to IDomainArray.RowCount - 1 do
  begin
    for ColIndex := 0 to IDomainArray.ColumnCount - 1 do
    begin
      for LayerIndex := 0 to IDomainArray.LayerCount - 1 do
      begin
        if IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] > 0 then
        begin
          break;
        end;
        if IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] < 0 then
        begin
//          if {(LayerIndex > 0) and} (LayerIndex < IDomainArray.LayerCount - 1) then
          begin
            IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] := 0;
            IDomainArray.Annotation[LayerIndex, RowIndex, ColIndex] :=
              StrIDOMAINSetToZeroOver;
          end;
        end;
      end;
      for LayerIndex := IDomainArray.LayerCount - 1 downto 0 do
      begin
        if IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] > 0 then
        begin
          break;
        end;
        if IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] < 0 then
        begin
//          if {(LayerIndex > 0) and} (LayerIndex < IDomainArray.LayerCount - 1) then
          begin
            IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] := 0;
            IDomainArray.Annotation[LayerIndex, RowIndex, ColIndex] :=
              StrIDOMAINSetToZeroUnder;
          end;
        end;
      end;
    end;
  end;

  if (ModelSelection = msModflow2015)
    and ModflowPackages.LakMf6Package.IsSelected then
  begin
    LakeMf6Array := FDataArrayManager.GetDataSetByName(KMf6LakeConnectionTypes);
    LakeMf6Array.Initialize;

    LakeComment := StrAllLakeCellsAreI;
    if DisvUsed then
    begin
      for ColIndex := 0 to DisvGrid.ColumnCount - 1 do
      begin
        BottomLayer := -1;
        for LayerIndex := DisvGrid.LayerCount -1 downto 0 do
        begin
          ConnectionTypes := LakeMf6Array.IntegerData[LayerIndex,0,ColIndex];
          if BottomLayer > -1 then
          begin
            IDomainArray.IntegerData[LayerIndex, 0, ColIndex] := 0;
            IDomainArray.Annotation[LayerIndex,0,ColIndex] := LakeComment;
          end
          else
          begin
            if ConnectionTypes = 2 then
            begin
              BottomLayer := LayerIndex - 1;
            end
            else if ConnectionTypes in [1,3] then
            begin
              BottomLayer := LayerIndex;
              IDomainArray.IntegerData[LayerIndex, 0, ColIndex] := 0;
              IDomainArray.Annotation[LayerIndex,0,ColIndex] := LakeComment;
            end;
          end;
        end;
      end;
    end
    else
    begin
      for ColIndex := 0 to ModflowGrid.ColumnCount - 1 do
      begin
        for RowIndex := 0 to ModflowGrid.RowCount - 1 do
        begin
          BottomLayer := -1;
          for LayerIndex := ModflowGrid.LayerCount -1 downto 0 do
          begin
            ConnectionTypes := LakeMf6Array.IntegerData[LayerIndex,RowIndex,ColIndex];
            if BottomLayer > -1 then
            begin
              IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] := 0;
              IDomainArray.Annotation[LayerIndex,RowIndex,ColIndex] := LakeComment;
            end
            else
            begin
              if ConnectionTypes = 2 then
              begin
                BottomLayer := LayerIndex - 1;
              end
              else if ConnectionTypes in [1,3] then
              begin
                BottomLayer := LayerIndex;
                IDomainArray.IntegerData[LayerIndex, RowIndex, ColIndex] := 0;
                IDomainArray.Annotation[LayerIndex,RowIndex,ColIndex] := LakeComment;
              end;
            end;
          end;
        end;
      end;
    end
  end;

end;

procedure TCustomModel.UpdateIrrigationTypesFullStressPeriods(
  TimeList: TRealList);
var
  PhastModel: TPhastModel;
  TestFirstTime: double;
  LastTestTime: double;
  OutOfStartRange, OutOfEndRange: Boolean;
begin
  if not ModflowPackages.FarmProcess4.IsSelected then
  begin
    Exit;
  end;

  TestFirstTime := TimeList.First;
  LastTestTime := TimeList.Last;

  if self is TChildModel then
  begin
    PhastModel := TChildModel(self).ParentModel as TPhastModel;
  end
  else
  begin
    PhastModel := self as TPhastModel;
  end;

//  PhastModel := self as TPhastModel;;
  OutOfStartRange := False;
  OutOfEndRange := False;

  PhastModel.IrrigationTypes.UpdateTimes(TimeList, TestFirstTime, LastTestTime,
      OutOfStartRange, OutOfEndRange);


//  PhastModel.FmpAllotment.UpdateTimes(TimeList, TestFirstTime, LastTestTime,
//      OutOfStartRange, OutOfEndRange);

  if OutOfStartRange then
  begin
    frmErrorsAndWarnings.AddWarning(self,
      StrAnyTimesBeforeThe, StrIrrigationEarly);
  end;

  if OutOfEndRange then
  begin
    frmErrorsAndWarnings.AddWarning(self,
      StrAnyTimesAfterThe, StrIrrigationLate);
  end;
end;

function TCustomModel.GetDataArrayInterface: ISimpleDataArrayManager;
begin
  result := DataArrayManager;
end;

function TCustomModel.GetDataArrayManager: TDataArrayManager;
begin
  result := FDataArrayManager;
end;

function TCustomModel.GetDataSetByName(const DataSetName: string): TDataArray;
begin
  result := DataArrayManager.GetDataSetByName(DataSetName);
end;

function TCustomModel.GetDataSetCollection: TDataSetCollection;
var
  Index: integer;
  ADataSet: TDataArray;
  Item: TDataSetItem;
begin
  FDataSetCollection.Clear;
  for Index := 0 to FDataArrayManager.DataSetCount - 1 do
  begin
    ADataSet := FDataArrayManager.DataSets[Index];
    Item := FDataSetCollection.Add as TDataSetItem;
    Item.FDataSet := ADataSet;
    ADataSet.SetSubComponent(True);
  end;
  result := FDataSetCollection;
end;

function TCustomModel.GetDirectRechargeUsed: TObjectUsedEvent;
begin
  result := DoDirectRechargeUsed;
end;

function TCustomModel.GetDiscretization: TCustomDiscretization;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        result := Grid;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        result := SutraMesh;
      end;
    msModflow2015:
      begin
        if DisvUsed then
        begin
          result := DisvGrid;
        end
        else
        begin
          result := Grid;
        end;
      end;
  end;
end;

function TCustomModel.GetDiscretiztionElevation(Column, Row, Layer: Integer): Double;
var
  DisvLayer: TModflowIrregularLayer;
  Cell: TModflowDisVCell;
begin
  if Grid <> nil then
  begin
    result := Grid.CellElevation[ZeroBasedID(Layer, Row, Column)];
  end
  else if DisvGrid <> nil then
  begin
    Assert(Row = 0);
    if Layer = 0 then
    begin
      DisvLayer := DisvGrid.Layers[0].Layer;
      Cell := DisvLayer[Column];
      result := Cell.Top;
    end
    else
    begin
      DisvLayer := DisvGrid.Layers[Layer-1].Layer;
      Cell := DisvLayer[Column];
      result := Cell.Bottom;
    end;
  end
  else
  begin
    result := 0;
    Assert(False);
  end;
end;

function TCustomModel.GetDisplayColumn: integer;
begin
  result := Grid.DisplayColumn;
end;

function TCustomModel.GetDisplayLayer: integer;
begin
  result := Grid.DisplayLayer;
end;

function TCustomModel.GetDisplayRow: integer;
begin
  result := Grid.DisplayRow;
end;

function TCustomModel.GetDoShouldActiveBeSetByCellSize: TCheckUsageEvent;
begin
  result := DoShouldActiveBeSetByCellSize;
end;

function TCustomModel.GetDrawMesh: IDrawMesh;
begin
  if ModelSelection in SutraSelection then
  begin
    result := SutraMesh;
  end
  else if DisvUsed then
  begin
    result := DisvGrid;
  end
  else
  begin
    result := nil;
  end;
end;

function TCustomModel.GetHeadObsResults: THeadObsCollection;
begin
  CreateHeadObsResults;
  result := FHeadObsResults;
end;

function TCustomModel.GetHorizAnisotropyMf6Used: TObjectUsedEvent;
begin
  result := DoHorizAnisotropyMf6Used;
end;

function TCustomModel.GetHorizontalAnisotropyUsed: TObjectUsedEvent;
begin
  result := DoHorizontalAnisotropyUsed;
end;

function TCustomModel.GetHorizontalTransverseDispersionUsed: TObjectUsedEvent;
begin
  result := DoHorizontalTransverseDispersionUsed;
end;

function TCustomModel.GetHorizontalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoHorizontalTransverseDispersionUsedPerSpecies;
end;

function TCustomModel.GetHufReferenceSurfaceNeeded: TObjectUsedEvent;
begin
  result := DoHufReferenceSurfaceNeeded;
end;

function TCustomModel.GetHufSelected: TObjectUsedEvent;
begin
  result := DoHufSelected;
end;

function TCustomModel.GetHufStorageUsed: TObjectUsedEvent;
begin
  result := DoHufStorageUsed;
end;

procedure TCustomModel.GetIgnoredSpeciesNames(IgnoredNames: TStringList);
var
  Buoy: TBuoyancyPackage;
  Visc: TViscosityPackage;
begin
  if ModelSelection = msModflow2015 then
  begin
    IgnoredNames.CaseSensitive := False;
    Buoy := ModflowPackages.BuoyancyPackage;
    Visc := ModflowPackages.ViscosityPackage;
    if Buoy.IsSelected and Buoy.DensitySpecified then
    begin
      IgnoredNames.Add(StrDensity);
    end;
    if Visc.IsSelected and Visc.ViscositySpecified then
    begin
      IgnoredNames.Add(StrViscosity);
    end;
  end;
end;

procedure TCustomModel.ClearInputObservationDataSets;
begin
  FInputObservationDataSets.Clear;
  FInputObservations.Clear;
  FInputObsInstructionFileNames.Clear;
  FInputObsInstructionFiles.Clear;
end;

function TCustomModel.GetInitialHeadUsed: TObjectUsedEvent;
begin
  result := DoInitialHeadUsed;
end;

function TCustomModel.GetInitializeActiveDataArrayWithCellSizeObjects: TNotifyEvent;
begin
  result := DoInitializeActiveDataArrayWithCellSizeObjects;
end;

function TCustomModel.GetInitialWaterTableUsed: TObjectUsedEvent;
begin
  result := DoInitialWaterTableUsed;
end;

function TCustomModel.GetInputObservationDataSets: TStrings;
begin
  result := FInputObservationDataSets;
end;

function TCustomModel.GetInputObsInstructionFiles: TStrings;
begin
  result := FInputObsInstructionFiles;
end;

function TCustomModel.GetIrrigationUsed: TObjectUsedEvent;
begin
  result := DoIrrigationUsed;
end;

function TCustomModel.GetItemTopLocation(const EvalAt: TEvaluatedAt;
  const Column, Row: integer): TPoint2D;
begin
  case ModelSelection of
    msUndefined:
      begin
        Assert(False);
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2,
      msModflowNWT, msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        result := Grid.ItemTopLocation[EvalAt, Column, Row];
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        result := SutraMesh.ItemTopLocation[EvalAt, Column, Row];
      end;
    msModflow2015:
      begin
        if DisvUsed then
        begin
          result := DisvGrid.ItemTopLocation[EvalAt, Column, Row];
        end
        else
        begin
          result := Grid.ItemTopLocation[EvalAt, Column, Row];
        end;
      end;
    else
      Assert(False);
  end;
end;

function TCustomModel.GetKineticsUsed: TObjectUsedEvent;
begin
  result := DoKineticsUsed
end;

function TCustomModel.GetKyUsed: TObjectUsedEvent;
begin
  result := DoKyUsed;
end;

function TCustomModel.GetKzUsed: TObjectUsedEvent;
begin
  result := DoKzUsed;
end;

function TCustomModel.GetSwiObsUsed: TObjectUsedEvent;
begin
  result := DoSwiObsUsed;
end;

function TCustomModel.GetSwiUsed: TObjectUsedEvent;
begin
  result := DoSwiUsed;
end;

function TCustomModel.GetSwrSelected: TObjectUsedEvent;
begin
  result := DoSwrSelected;
end;

function TCustomModel.GetLakePackageUsed: TObjectUsedEvent;
begin
  result := DoLakePackageUsed;
end;

function TCustomModel.GetLakMf6Selected: TObjectUsedEvent;
begin
  result := DoLakMf6Selected;
end;

function TCustomModel.GetLandUseAreaFractionUsed: TObjectUsedEvent;
begin
  result := DoLandUseAreaFractionUsed;
end;

function TCustomModel.GetLandUseCellsToPrintUsed: TObjectUsedEvent;
begin
  result := DoLandUseCellsToPrintUsed;
end;

function TCustomModel.GetLayerGroupByLayer(const Layer: integer): TLayerGroup;
begin
  result := LayerStructure.GetLayerGroupByLayer(Layer);
end;

function TCustomModel.GetLayerThickness(Layer, Row, Column: Integer): Double;
begin
  result := DiscretiztionElevation[Column, Row, Layer] -
    DiscretiztionElevation[Column, Row, Layer+1]
end;

function TCustomModel.GetLongitudinalDispersionUsed: TObjectUsedEvent;
begin
  result := DoLongitudinalDispersionUsed;
end;

function TCustomModel.GetLongitudinalDispersionUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoLongitudinalDispersionUsedPerSpecies
end;

function TCustomModel.WettingActive: boolean;
begin
  result := ModflowWettingOptions.WettingActive
    and not ModflowPackages.UpwPackage.IsSelected;
end;

procedure TCustomModel.ChangeFormula(var FormulaObject: IFormulaObject;
  NewFormula: string; EvaluatedAt: TEvaluatedAt; OnRemoveSubscription,
  OnRestoreSubscription: TChangeSubscription; Subject: TObject);
var
  Local3DCompiler: TRbwParser;
  LocalFormulaObject: TFormulaObject;
begin
  Local3DCompiler := nil;
  case EvaluatedAt of
    eaBlocks:
      begin
        Local3DCompiler := rpThreeDFormulaCompiler;
      end;
    eaNodes:
      begin
        Local3DCompiler := rpThreeDFormulaCompilerNodes;
      end;
  else
    Assert(False);
  end;

  LocalFormulaObject := FormulaObject as TFormulaObject;
  ParentModel.FormulaManager.ChangeFormula(LocalFormulaObject,
    NewFormula,
    Local3DCompiler,
    OnRemoveSubscription,
    OnRestoreSubscription, Subject);
  FormulaObject := LocalFormulaObject;

//  FormulaObject := LocalFObject;
end;

procedure TCustomModel.ChangeGlobalVariable(const ParameterName: string;
  const Value: TParameterType);
var
  ChangeGlobal: TDefineGlobalStringObject;
begin
  ChangeGlobal := TDefineGlobalStringObject.Create(
    self, ParameterName, ParameterName, StrParameterType);
  try
    ChangeGlobal.Locked := (Value = ptPEST);
    ChangeGlobal.SetValue(ParameterName);
  finally
    ChangeGlobal.Free;
  end;
end;

function TCustomModel.Chani: TOneDIntegerArray;
begin
  result := LayerStructure.Chani;
end;

function TCustomModel.ChdIsSelected: Boolean;
begin
  result := ModflowPackages.ChdBoundary.IsSelected;
end;

function TCustomModel.CheckWetting: boolean;
var
  Group: TLayerGroup;
  LayerGroupIndex: Integer;
var
  WetErrorMessage: string;
begin
  result := False;
  frmErrorsAndWarnings.RemoveErrorGroup(self, WetError);
  if WettingActive and not ModflowPackages.NpfPackage.IsSelected then
  begin
    result := True;
    for LayerGroupIndex := 1 to LayerStructure.Count - 1 do
    begin
      Group := LayerStructure[LayerGroupIndex];
      if Group.AquiferType in WettableLayers then
      begin
        result := False;
        break;
      end;
    end;
  end;
  if result then
  begin
    if ModflowPackages.LpfPackage.IsSelected
      or ModflowPackages.HufPackage.IsSelected then
    begin
      WetErrorMessage := StrAtLeastOneConvert;
    end
    else if ModflowPackages.BcfPackage.IsSelected then
    begin
      WetErrorMessage := StrAtLeastOneUnconfConvert;
    end
    else
    begin
      Assert(False);
    end;
    frmErrorsAndWarnings.AddError(self, WetError, WetErrorMessage);
  end;
end;

function TCustomModel.FixFileName(AFileName: string): string;
var
  FileName: string;
  FileDir: string;
begin
  result := AFileName;
  FileName := ExtractFileName(AFileName);
  if Pos(' ', FileName) > 0 then
  begin
    FileName := StringReplace(FileName, ' ', '_', [rfReplaceAll]);
  end;
  FileDir := ExtractFileDir(AFileName);
  if FileDir <> '' then
  begin
    FileName := IncludeTrailingPathDelimiter(FileDir) + FileName;
  end;
  result := FileName;
end;

function TCustomModel.DoFootprintSelected(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msFootprint);
end;

procedure TPhastModel.ExportFootprintInput(FileName: string; RunFootprint: boolean);
var
  FootprintInput: TFootPrintFile;
  AGrid: TCustomModelGrid;
  Outline: TPolygon2D;
  RowIndex: integer;
  ColIndex: integer;
  Withdrawals: TDataArray;
  ActiveDataArray: TDataArray;
  DepthRateArray: TDataArray;
  FootPrintBatchFile: TStringList;
  BatchFileName: string;
  GeoRefWriter: TGeoRefWriter;
  RelativePathName: string;
  NetworkDrive: Boolean;
  ModelDirectory: string;
  function EncloseQuotes(AName: string): string;
  begin
    if Pos(' ', AName) > 0 then
    begin
      result := '"' + AName + '"';
    end
    else
    begin
      result := AName;
    end;
  end;
begin
  NetworkDrive := IsNetworkDrive(FileName);
  ModelDirectory := ExtractFileDir(FileName);

  ClearModelFiles;


  frmErrorsAndWarnings.RemoveWarningGroup(self, StrInTheFollowingCel);
  FileName := FixFileName(FileName);

  GeoRefWriter := TGeoRefWriter.Create(Self, etExport);
  try
    GeoRefWriter.WriteFile(FileName, smtMain);
  finally
    GeoRefWriter.Free;
  end;

  FootprintInput := TFootPrintFile.Create;
  try
    AGrid := Grid;
    FootprintInput.NumberOfRows := AGrid.RowCount;
    FootprintInput.NumberOfColumns := AGrid.ColumnCount;
    FootprintInput.ClosureCriterion  := FootprintProperties.ClosureCriterion;
    FootprintInput.CellSize := AGrid.ColumnWidth[0]*AGrid.RowWidth[0];
    FootprintInput.MaxIterations := FootprintProperties.MaxIterations;
    FootprintInput.InitialDistribution :=
      FootprintProperties.PerformInitialRedistribution;
    FootprintInput.RedistributionCriterion :=
      FootprintProperties.RedistributionCriterion;

    SetLength(Outline, 4);
    Outline[0] := AGrid.UnrotatedTwoDElementCorner(0,0);
    Outline[1] := AGrid.UnrotatedTwoDElementCorner(0,AGrid.RowCount);
    Outline[2] := AGrid.UnrotatedTwoDElementCorner(AGrid.ColumnCount,AGrid.RowCount);
    Outline[3] := AGrid.UnrotatedTwoDElementCorner(AGrid.ColumnCount,0);
    FootprintInput.Outline := Outline;

    FootprintInput.GridAngle := AGrid.GridAngle * 180 / Pi;
    RelativePathName := ChangeFileExt(FileName, '.fplst');
    AddModelOutputFile(RelativePathName);
    RelativePathName := ExtractRelativePath(FileName, RelativePathName);
    FootprintInput.ListingFileName := RelativePathName;
//    AddModelOutputFile(FootprintInput.ListingFileName);

    if FootprintProperties.SaveResultsBinary then
    begin
      RelativePathName := ChangeFileExt(FileName, '.fpb');
      AddModelOutputFile(RelativePathName);
      RelativePathName := ExtractRelativePath(FileName, RelativePathName);
      FootprintInput.BinaryFileName := RelativePathName;
    end;
    if FootprintProperties.SaveResultsText then
    begin
      RelativePathName := ChangeFileExt(FileName, '.fpt');
      AddModelOutputFile(RelativePathName);
      RelativePathName := ExtractRelativePath(FileName, RelativePathName);
      FootprintInput.AsciiFileName := RelativePathName
    end;

    Withdrawals := DataArrayManager.GetDataSetByName(KWithdrawals);
    ActiveDataArray := DataArrayManager.GetDataSetByName(rsActive);
    DepthRateArray := DataArrayManager.GetDataSetByName(KDepthRateIndex);
    Assert(Withdrawals <> nil);
    Assert(ActiveDataArray <> nil);
    Assert(DepthRateArray <> nil);
    Withdrawals.Initialize;
    ActiveDataArray.Initialize;
    DepthRateArray.Initialize;

    for RowIndex := 0 to ActiveDataArray.RowCount - 1 do
    begin
      for ColIndex := 0 to ActiveDataArray.ColumnCount - 1 do
      begin
        if ActiveDataArray.BooleanData[0,RowIndex,ColIndex] then
        begin
          if DepthRateArray.RealData[0,RowIndex,ColIndex] <= 0 then
          begin
            frmErrorsAndWarnings.AddWarning(self, StrInTheFollowingCel,
              Format(StrRowCol0d1, [RowIndex+1, ColIndex+1]));
          end;
        end;
      end;
    end;

    for RowIndex := 0 to AGrid.RowCount - 1 do
    begin
      for ColIndex := 0 to AGrid.ColumnCount - 1 do
      begin
        FootprintInput.DepthRateIndex[RowIndex,ColIndex] :=
          DepthRateArray.RealData[0,RowIndex,ColIndex];
        FootprintInput.Active[RowIndex,ColIndex] :=
          ActiveDataArray.BooleanData[0,RowIndex,ColIndex];
        FootprintInput.Withdrawals[RowIndex,ColIndex] :=
          Withdrawals.RealData[0,RowIndex,ColIndex];
      end;
    end;

    FootprintInput.SaveToFile(FileName);
    AddModelInputFile(FileName);

    BatchFileName := IncludeTrailingPathDelimiter(ExtractFileDir(FileName))
      + 'RunFootprint.bat';
    FootPrintBatchFile := TStringList.Create;
    try
      if NetworkDrive then
      begin
        FootPrintBatchFile.Add('pushd ' + ModelDirectory);
      end;
      FootPrintBatchFile.Add(EncloseQuotes(ProgramLocations.FootprintLocation)
         + ' ' + EncloseQuotes(ExtractFileName(FileName)));

      AddOpenListFileLine(FootprintInput.ListingFileName,
        FootprintProperties.OpenInTextEditor, FootPrintBatchFile,
        ProgramLocations);

      if NetworkDrive then
      begin
        FootPrintBatchFile.Add('popd');
      end;

      FootPrintBatchFile.Add('pause');
      FootPrintBatchFile.SaveToFile(BatchFileName);
    finally
      FootPrintBatchFile.Free;
    end;
  finally
    FootprintInput.Free;
  end;

  if RunFootprint then
  begin
    RunAProgram('"' + BatchFileName + '"');
  end;

  SaveArchiveList(ChangeFileExt(FileName, '.axml'));

  if frmErrorsAndWarnings.HasMessages then
  begin
    frmErrorsAndWarnings.Show;
  end;
end;

function TCustomModel.InterpSwiObsDefined: Boolean;
var
  AScreenObject: TScreenObject;
  ScreenObjectIndex: Integer;
begin
  result := False;
  if DoSwiObsUsed(nil) then
  begin
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      AScreenObject := ScreenObjects[ScreenObjectIndex];
      if AScreenObject.Deleted then
      begin
        Continue;
      end;
      if (AScreenObject.ModflowSwiObservations <> nil)
        and AScreenObject.ModflowSwiObservations.Used then
      begin
        result := True;
        break;
      end;
    end;
  end;
end;

procedure TPhastModel.ExportModflowLgrModel(const FileName: string;
  RunModel, ExportModpath, NewBudgetFileForModpath, ExportZoneBudget,
  ShowWarning: boolean);
var
  NumberOfSteps: Integer;
  BatchFileLocation: string;
  ListFileName: string;
  ChildIndex2: Integer;
  ListFileNames: TStringList;
  ChildIndex: Integer;
  ChildModel: TChildModel;
  ChildFileName: string;
begin
  PestTemplateLines.Clear;
  KrigfactorsScriptLines.Clear;
  ClearMnw1FileNames;
  if frmProgressMM = nil then
  begin
    frmProgressMM := TfrmProgressMM.Create(nil);
  end;
  try
    frmFormulaErrors.DelayShowing := True;
    try
      frmProgressMM.Prefix := 'File ';
      frmProgressMM.Caption := 'Exporting MODFLOW-LGR input files';
      frmProgressMM.btnAbort.Visible := True;
      frmProgressMM.ShouldContinue := True;
      frmProgressMM.Show;

      (Grid as TModflowGrid).UpdateCellElevations;
      for ChildIndex := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex].ChildModel;
        if ChildModel <> nil then
        begin
          (ChildModel.Grid as TModflowGrid).UpdateCellElevations;
        end;
      end;

      NumberOfSteps := CountStepsInExport+1;
      for ChildIndex2 := 0 to ChildModels.Count - 1 do
      begin
        ChildModel := ChildModels[ChildIndex2].ChildModel;
        if ChildModel <> nil then
        begin
          NumberOfSteps := NumberOfSteps +
            ChildModels[ChildIndex2].ChildModel.CountStepsInExport;
        end;
      end;

      frmProgressMM.pbProgress.Max := NumberOfSteps;
      frmProgressMM.pbProgress.Position := 0;

      if not PrepareModflowFullStressPeriods(ShowWarning) then
      begin
        Exit;
      end;

      InternalExportModflowLgrFile(FileName);

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      ListFileNames := TStringList.Create;
      try

        ListFileName := (NameFileWriter as TNameFileWriter).ListFileName;
        ListFileNames.Add(ListFileName);
        for ChildIndex := 0 to ChildModels.Count - 1 do
        begin
          ChildModel := ChildModels[ChildIndex].ChildModel;
          if ChildModel <> nil then
          begin
            ListFileName := (ChildModel.NameFileWriter as TNameFileWriter).ListFileName;
            ListFileNames.Add(ListFileName);
          end;
        end;

        BatchFileLocation := WriteModflowBatchFile(
          ProgramLocations,
          ChangeFileExt(FileName, '.lgr'), ListFileNames,
          ModflowOptions.OpenInTextEditor, BatchFileAdditionsBeforeModel,
          BatchFileAdditionsAfterModel, ExportModpath, ExportZoneBudget, self);

        if ExportModpath then
        begin
          if ModflowPackages.Modpath.IsSelected then
          begin
            ExportModpathModel(ChangeFileExt(FileName, '.mpn'), False,
              NewBudgetFileForModpath, True);
          end;
          for ChildIndex := 0 to ChildModels.Count - 1 do
          begin
            ChildModel := ChildModels[ChildIndex].ChildModel;
            if ChildModel <> nil then
            begin
              if ChildModel.ModflowPackages.ModPath.IsSelected then
              begin
                ChildFileName := ChangeFileExt(FileName, '');
                ChildFileName := ChildFileName + '_' + ChildModel.ModelNameForDos;
                ChildModel.ExportModpathModel(ChangeFileExt(ChildFileName, '.mpn'), False,
                  NewBudgetFileForModpath, True);
              end;
            end;
          end;
        end;
        if ExportZoneBudget then
        begin
          if ModflowPackages.ZoneBudget.IsSelected then
          begin
            ExportZoneBudgetModel(ChangeFileExt(FileName, StrZbzones), False, True);
          end;
          for ChildIndex := 0 to ChildModels.Count - 1 do
          begin
            ChildModel := ChildModels[ChildIndex].ChildModel;
            if ChildModel <> nil then
            begin
              if ChildModel.ModflowPackages.ZoneBudget.IsSelected then
              begin
                ChildFileName := ChangeFileExt(FileName, '');
                ChildFileName := ChildFileName + '_' + ChildModel.ModelNameForDos;
                ChildModel.ExportZoneBudgetModel(ChangeFileExt(ChildFileName, StrZbzones), False, True);
              end;
            end;
          end;
        end;

      finally
        ListFileNames.Free;
      end;
      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      if RunModel then
      begin
        RunAProgram('"' + BatchFileLocation + '"');
//        WinExec(PAnsiChar(AnsiString('"' + BatchFileLocation + '"')), SW_SHOW);
      end;
    finally
      frmProgressMM.btnAbort.Visible := False;
      frmProgressMM.Hide;
      if frmProgressMM.Owner = nil then
      begin
        FreeAndNil(frmProgressMM);
      end;
      frmFormulaErrors.DelayShowing := False;
    end;
  except on E: EFCreateError do
    begin
      Beep;
      MessageDlg(E.Message, mtError, [mbOK], 0);
    end;
  end;
end;

procedure TPhastModel.ExportSupCalcInput;
const
  BatchFileName = 'RunSupCalc.bat';
var
  SupCalcBatFile: TStringList;
  SupCalcName: string;
  CaseName: string;
  WorkingDirectory: string;
  PestName: string;
  SupCalcInput: TStringList;
  SupCalcInputName: string;
  TempName: string;
begin
  frmErrorsAndWarnings.RemoveErrorGroup(self, StrSUPCALCNotFound);
  Assert(TFile.Exists(SupCalcProperties.FileName));
  WorkingDirectory := IncludeTrailingPathDelimiter(
    ExtractFileDir(SupCalcProperties.FileName));
  SetCurrentDir(WorkingDirectory);
  CaseName := ExtractFileName(ChangeFileExt(SupCalcProperties.FileName, ''));
  TempName := '';
  if SupCalcProperties.RunPest then
  begin
    TempName := WorkingDirectory + CaseName + '_backup.pst';
    if TFile.Exists(TempName) then
    begin
      TFile.Delete(TempName);
    end;
    TFile.Copy(SupCalcProperties.FileName, TempName);
    ExportPestInput(SupCalcProperties.FileName, pecNone, True);
  end;

  SupCalcName := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory)
    + 'i64supcalc.exe';
  if not TFile.Exists(SupCalcName) then
  begin
    SupCalcName := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory)
      + 'supcalc.exe';
    if not TFile.Exists(SupCalcName) then
    begin
      frmErrorsAndWarnings.AddError(self, StrSUPCALCNotFound,
        Format(StrNeither164supcalce, [ProgramLocations.PestDirectory]));
    end;
  end;
  SupCalcInputName := WorkingDirectory + CaseName + '_SupCalcInput.txt';

  SupCalcInput := TStringList.Create;
  try
    SupCalcInput.Add(ExtractFileName(SupCalcProperties.FileName));
    SupCalcInput.Add(FortranFloatToStr(SupCalcProperties.ExpectedValue));
    SupCalcInput.Add(IntToStr(Ord(SupCalcProperties.Method)+1));
    SupCalcInput.Add('b');
    SupCalcInput.Add(WorkingDirectory + CaseName + '_SupCalcOut.txt');
    SupCalcInput.WriteBOM := False;
    SupCalcInput.SaveToFile(SupCalcInputName);
  finally
    SupCalcInput.Free;
  end;

  SupCalcBatFile := TStringList.Create;
  try
    if SupCalcProperties.RunPest then
    begin
      PestName := GetPestName;
      SupCalcBatFile.Add('"' + PestName + '" ' + CaseName);
      if TFile.Exists(TempName) then
      begin
        SupCalcBatFile.Add('rem Restore backed up PEST control file.');
        SupCalcBatFile.Add('del ' + ExtractFileName(SupCalcProperties.FileName));
        SupCalcBatFile.Add('copy "' + TempName + '" "' + SupCalcProperties.FileName + '"');
      end;
    end;
    SupCalcBatFile.Add('"' + SupCalcName + '" < ' + ExtractFileName(SupCalcInputName));
    SupCalcBatFile.Add('pause');
    SupCalcBatFile.SaveToFile(WorkingDirectory + BatchFileName);
  finally
    SupCalcBatFile.Free;
  end;
  if SupCalcProperties.RunSupCalc then
  begin
    RunAProgram('"' + WorkingDirectory + BatchFileName + '"');
  end;
end;

procedure TPhastModel.ExportSvdaPrep;
var
  PestName: string;
  PestInputFileName: string;
  CaseName: string;
  PreSvdaFileName: string;
  BatchFile: TStringList;
  SvdaPrepInput: TStringList;
  SvdaPrepInputFileName: string;
  SvdaPrepExecutableName: string;
  BatchFileName: string;
  WorkingDirectory: String;
  PestCleanExecutableName: string;
  PestDirectory: string;
  WorkDirParCalcName: string;
  WorkDirPiCalcName: string;
  JcoFileName: string;
  NewJcoFileName: string;
  SvdaFileName: string;
  parcalcFileName: string;
  picalcFileName: string;
begin
  PestDirectory := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory);
  WorkingDirectory := IncludeTrailingPathDelimiter(ExtractFileDir(SvdaPrepProperties.FileName));
  SetCurrentDir(WorkingDirectory);
  ExportPestInput(SvdaPrepProperties.FileName, pecNone);
  PestInputFileName := ChangeFileExt(SvdaPrepProperties.FileName , '.pst');
  JcoFileName := ChangeFileExt(SvdaPrepProperties.FileName , '.jco');
  CaseName := ChangeFileExt(PestInputFileName , '');
  PreSvdaFileName := CaseName + '_Svda.pst';
  SvdaFileName := CaseName + '_PostSvda.pst';
  NewJcoFileName := ChangeFileExt(PreSvdaFileName , '.jco');
  if TFile.Exists(NewJcoFileName) then
  begin
    TFile.Delete(NewJcoFileName);
  end;
  if TFile.Exists(JcoFileName) then
  begin
    TFile.Copy(JcoFileName, NewJcoFileName);
  end
  else
  begin
    MessageDlg(Format(StrUnableToExportThe, [JcoFileName]), mtError, [mbOK], 0);
    Exit;
  end;
  if TFile.Exists(PreSvdaFileName) then
  begin
    TFile.Delete(PreSvdaFileName);
  end;
  CaseName := ExtractFileName(ChangeFileExt(PreSvdaFileName , ''));

  PestInputFileName := ExtractFileName(ChangeFileExt(SvdaPrepProperties.FileName , '.pst'));
  SvdaPrepInputFileName := WorkingDirectory + CaseName + '.SvdaPrepInput';

  SvdaPrepInput := TStringList.Create;
  try
    SvdaPrepInput.Add(CaseName);
    SvdaPrepInput.Add('n');
    SvdaPrepInput.Add(IntToStr(Ord(SvdaPrepProperties.Method)+1));
    SvdaPrepInput.Add(IntToStr(SvdaPrepProperties.NumberOfSuperParameters));
    SvdaPrepInput.Add(ExtractFileName(SvdaFileName));
    SvdaPrepInput.Add('');
    SvdaPrepInput.Add('');
    SvdaPrepInput.Add('');
    SvdaPrepInput.Add('');
    SvdaPrepInput.Add('');
    SvdaPrepInput.Add('');
    SvdaPrepInput.WriteBOM := False;
    SvdaPrepInput.SaveToFile(SvdaPrepInputFileName);
  finally
    SvdaPrepInput.Free;
  end;

  PestName := GetPestName;
  PestCleanExecutableName := PestDirectory + 'pstclean.exe';
  SvdaPrepExecutableName := PestDirectory + 'i64svdaprep.exe';
  if not TFile.Exists(SvdaPrepExecutableName) then
  begin
    SvdaPrepExecutableName := PestDirectory + 'svdaprep.exe';
  end;

  parcalcFileName := PestDirectory + 'i64parcalc.exe';
  if not TFile.Exists(parcalcFileName) then
  begin
    parcalcFileName := PestDirectory + 'parcalc.exe';
  end;

  picalcFileName := PestDirectory + 'i64picalc.exe';
  if not TFile.Exists(picalcFileName) then
  begin
    picalcFileName := PestDirectory + 'picalc.exe';
  end;

  if not TFile.Exists(parcalcFileName) or not TFile.Exists(picalcFileName) then
  begin
    Beep;
    MessageDlg(StrParcalcexeAndPica, mtError, [mbOK], 0);
    Exit;
  end;

  // parcalc and picalc must be in the working directory.
  WorkDirParCalcName := WorkingDirectory + 'parcalc.exe';
  WorkDirPiCalcName := WorkingDirectory + 'picalc.exe';

  if not TFile.Exists(WorkDirParCalcName) then
  begin
    TFile.Copy(parcalcFileName, WorkDirParCalcName)
  end;
  if not TFile.Exists(WorkDirPiCalcName) then
  begin
    TFile.Copy(picalcFileName, WorkDirPiCalcName)
  end;

  BatchFileName := WorkingDirectory + 'RunSvdaPrep.bat';

  BatchFile := TStringList.Create;
  try
    BatchFile.Add(Format('"%0:s" %1:s %2:s',
      [PestCleanExecutableName, ExtractFileName(PestInputFileName),
      ExtractFileName(PreSvdaFileName)]));
    BatchFile.Add(Format('"%0:s" < %1:s',
      [SvdaPrepExecutableName, ExtractFileName(SvdaPrepInputFileName)]));
    if SvdaPrepProperties.RunPest then
    begin
      BatchFile.Add('"' + PestName + '" '
        + ChangeFileExt(ExtractFileName(SvdaFileName), ''));
    end;
    BatchFile.Add('pause');
    BatchFile.SaveToFile(BatchFileName);
  finally
    BatchFile.Free;
  end;

  if SvdaPrepProperties.RunSvdaPrep then
  begin
    RunAProgram(BatchFileName);
  end;

end;

function TPhastModel.ExportParRepInput(FileName: string; RunParRep, RunPest,
  IncludePause: Boolean;
  New_noptmax: Integer = -1): string;
var
  Base: string;
  ExistingPestFile: string;
  BatchFileName: string;
  PestName: string;
  ParRepName: string;
  BatchFile: TStringList;
  ParFileName: string;
begin
  frmErrorsAndWarnings.RemoveErrorGroup(self, StrThePestUtilityFil);
  frmErrorsAndWarnings.RemoveErrorGroup(self, StrParFileNotFound);
// FileName has for form base.par.number;
  Base := ChangeFileExt(FileName, '');
  Base := ChangeFileExt(Base, '');
  ExistingPestFile := ExtractFileName(ChangeFileExt(Base, '.pst'));
  result := ExtractFileName(Base + '_parrep.pst');
  BatchFileName := IncludeTrailingPathDelimiter(ExtractFileDir(FileName))
    + 'RunParRep.bat';

  PestName := GetPestName;

  ParRepName := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory)
    + 'parrep.exe';
  if not TFile.Exists(ParRepName) then
  begin
    frmErrorsAndWarnings.AddError(self, StrThePestUtilityFil,
      Format(StrParrepDoesNotExis, [ParRepName]))
  end;
  ParFileName := ChangeFileExt(FileName, '');
  ParFileName := ChangeFileExt(ParFileName, '.par');
  if not TFile.Exists(ParFileName) then
  begin
    frmErrorsAndWarnings.AddError(self, StrParFileNotFound,
      Format(StrTheParameterFileF, [ParFileName]))
  end;

  BatchFile := TStringList.Create;
  try
    if New_noptmax >= 0 then
    begin
      BatchFile.Add(Format('"%0:s" %1:s %2:s %3:s %4:d', [ParRepName,
        ExtractFileName(FileName), ExistingPestFile, result, New_noptmax]));
    end
    else
    begin
      BatchFile.Add(Format('"%0:s" %1:s %2:s %3:s', [ParRepName,
        ExtractFileName(FileName), ExistingPestFile, result]));
    end;
    if RunPest then
    begin
      BatchFile.Add(Format('"%0:s" %1:s', [PestName, result]));
    end;
    if IncludePause then
    begin
      BatchFile.Add('pause');
    end;
    BatchFile.SaveToFile(BatchFileName);
  finally
    BatchFile.Free;
  end;

  if RunParRep then
  begin
    RunAProgram('"' + BatchFileName + '"');
  end;

end;

procedure TPhastModel.ExportPestInput(FileName: string;
  RunPest: TPestExportChoice; SetNOPTMAX: Boolean = False);
var
  PestControlWriter: TPestControlFileWriter;
  BatchFileName: string;
  PestName: string;
  BatchFile: TStringList;
  PestCheckName: string;
  PestCheckBatchFileName: string;
  PestControlFileName: string;
  LineIndex: Integer;
begin
  frmErrorsAndWarnings.RemoveErrorGroup(self, StrPESTCHEKNotFound);
  frmErrorsAndWarnings.RemoveErrorGroup(self, StrPESTNotFound);
  if not PestUsed then
  begin
    Exit;
  end;
  PestControlWriter := TPestControlFileWriter.Create(Self, etExport);
  try
    PestControlFileName := PestControlWriter.WriteFile(FileName, SetNOPTMAX)
  finally
    PestControlWriter.Free;
  end;

  BatchFileName := IncludeTrailingPathDelimiter(ExtractFileDir(FileName))
    + 'RunPest.bat';
  PestCheckBatchFileName := IncludeTrailingPathDelimiter(ExtractFileDir(FileName))
    + 'RunPestChek.bat';

  PestName := GetPestName;

  PestCheckName := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory)
    + 'I64pestchek.exe';
  if not FileExists(Trim(PestCheckName)) then
  begin
    PestCheckName := IncludeTrailingPathDelimiter(ProgramLocations.PestDirectory)
      + 'pestchek.exe';
    if not FileExists(Trim(PestCheckName)) then
    begin
      frmErrorsAndWarnings.AddError(self, StrPESTCHEKNotFound,
        Format(StrNeitherI64pestchek,
        [ProgramLocations.PestDirectory]))
    end;
  end;

  if PestProperties.PestControlData.PestMode in [pmPrediction, pmPareto] then
  begin
    PestControlFileName := ExportParRepInput(
      ChangeFileExt(PestControlFileName, '.par'), RunPest <> pecNone, False,
      False);
  end;

  if not FileExists(PestName) then
  begin
    //Beep;
    frmErrorsAndWarnings.AddError(self, StrPESTNotFound,
      Format(StrPESTWasNotFoundI, [ProgramLocations.PestDirectory]));
//    MessageDlg(Format(StrPESTWasNotFoundI,
//      [ProgramLocations.PestDirectory]), mtError, [mbOK], 0);
//      Exit;
  end;

  PestName := Format(StrS, [PestName]);
  PestCheckName := Format(StrS, [PestCheckName]);

  BatchFile := TStringList.Create;
  try
    if PestProperties.PestControlData.PestMode in [pmPrediction, pmPareto] then
    begin
      BatchFile.Add('call RunParRep.bat');
      LineIndex := 1;
    end
    else
    begin
      LineIndex := 0;
    end;

    BatchFile.Add(PestName +
      ChangeFileExt(ExtractFileName(PestControlFileName), ''));
    BatchFile.Add('pause');
    BatchFile.SaveToFile(BatchFileName);

    BatchFile[LineIndex] := PestCheckName + ChangeFileExt(ExtractFileName(PestControlFileName), '');
    BatchFile.SaveToFile(PestCheckBatchFileName);
  finally
    BatchFile.Free;
  end;

  case RunPest of
    pecNone: ; // do nothing;
    pecPestCheck:
      begin
        RunAProgram('"' + PestCheckBatchFileName + '"');
      end;
    pecPest:
      begin
        RunAProgram('"' + BatchFileName + '"');
      end;
  end;
end;

procedure TPhastModel.InternalExportModflowLgrFile(const FileName: string);
var
  ChildNameFile: string;
  ChildModel: TChildModel;
  ChildIndex: Integer;
  LgrWriter: TLgrWriter;
begin
  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  LgrWriter := TLgrWriter.Create(Self, etExport);
  try
    LgrWriter.WriteFile(FileName);
  finally
    LgrWriter.Free;
  end;

  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  InitializeGages;

  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  InitializeSfrWriter(etExport);
  try
    ClearPval;
//    FPValFile.Clear;
//    FPvalTemplate.Clear;
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildModel.ClearPval;
      end;
    end;

    Application.ProcessMessages;
    if not frmProgressMM.ShouldContinue then
    begin
      Exit;
    end;
    InternalExportModflowModel(FileName, True);
    for ChildIndex := 0 to ChildModels.Count - 1 do
    begin
      ChildModel := ChildModels[ChildIndex].ChildModel;
      if ChildModel <> nil then
      begin
        ChildNameFile := ChildModel.Child_NameFile_Name(FileName);
        Application.ProcessMessages;
        if not frmProgressMM.ShouldContinue then
        begin
          Exit;
        end;
        ChildModel.InternalExportModflowModel(ChildNameFile, True);
      end;
    end;
  finally
    FreeSfrWriter;
  end;
end;

procedure TPhastModel.InternalExportModflowModel(const FileName: string;
  ExportAllLgr: boolean);
var
  TempDisFileWriter: TTemporalDiscretizationWriter  ;
  GeoRefWriter: TGeoRefWriter;
  Index: Integer;
  Param: TModflowSteadyParameter;
begin
  inherited;

  ClearPestArrayFileNames;

  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  TempDisFileWriter := TTemporalDiscretizationWriter.Create(Self, etExport);
  try
    TempDisFileWriter.WriteFile(FileName);
  finally
    TempDisFileWriter.Free;
  end;

  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  if SimNameWriter <> nil then
  begin
    SimNameWriter.WriteFile(FileName);
  end;

  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  GeoRefWriter := TGeoRefWriter.Create(Self, etExport);
  try
    GeoRefWriter.WriteFile(FileName, smtMain);
  finally
    GeoRefWriter.Free;
  end;

  if PestUsed then
  begin
    for Index := 0 to ModflowSteadyParameters.Count - 1 do
    begin
      Param := ModflowSteadyParameters[Index];
      if (Param.ParameterType = ptPEST)
        and not Param.IsUsedInTemplate then
      begin
        frmErrorsAndWarnings.AddError(self, StrTheFollowingParame,
          Param.ParameterName);
      end;
    end;
  end;

end;

procedure TCustomModel.ExportModflowModel(const FileName: string; RunModel,
  ExportModpath, NewBudgetFileForModpath, ExportZoneBudget, ShowWarning: boolean);
var
  NumberOfSteps: Integer;
  BatchFileLocation: string;
  ListFileName: string;
  ListFileNames: TStringList;
begin
  PestTemplateLines.Clear;
  KrigfactorsScriptLines.Clear;
  if ExtractFileName(ModflowLocation) = 'MF2005_Importer.exe' then
  begin
    Beep;
    MessageDlg(StrMF2005ImporterexeIsNot, mtError, [mbOK], 0);
    Exit;
  end;

  ClearMnw1FileNames;
  if frmProgressMM = nil then
  begin
    frmProgressMM := TfrmProgressMM.Create(nil);
  end;
  try
    // Note: MODFLOW can not read Unicode text files.

    frmFormulaErrors.DelayShowing := True;
    try
      frmProgressMM.Prefix := 'File ';
      frmProgressMM.Caption := 'Exporting MODFLOW input files';
      frmProgressMM.btnAbort.Visible := True;
      frmProgressMM.ShouldContinue := True;
      frmProgressMM.Show;

      NumberOfSteps := CountStepsInExport;

      frmProgressMM.pbProgress.Max := NumberOfSteps;
      frmProgressMM.pbProgress.Position := 0;

      if not PrepareModflowFullStressPeriods(ShowWarning) then
      begin
        Exit;
      end;

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;
      InitializeGages;

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;
      InitializeSfrWriter(etExport);
      try
        ClearPval;
//        FPValFile.Clear;
//        FPvalTemplate.Clear;

        Application.ProcessMessages;
        if not frmProgressMM.ShouldContinue then
        begin
          Exit;
        end;
        if PestUsed then
        begin
          PestProperties.PriorInfoObservationGroups.Clear;
          ClearPestPriorInfoGroupData;
          ModflowSteadyParameters.SetAllParametersUnused;
        end;
        InternalExportModflowModel(FileName, False);
      finally
        FreeSfrWriter;
      end;


      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      if ExportModpath then
      begin
        ExportModpathModel(ChangeFileExt(FileName, '.mpn'), False,
          NewBudgetFileForModpath, True);
      end;
      if ExportZoneBudget then
      begin
        ExportZoneBudgetModel(ChangeFileExt(FileName, StrZbzones), False, True);
      end;

      ExportInputObsDataSets(FileName);

      if self is TPhastModel then
      begin
        TPhastModel(self).ExportPestInput(FileName, pecNone);
      end;

      ListFileNames := TStringList.Create;
      try
        ListFileName := (NameFileWriter as TCustomNameFileWriter).ListFileName;
        ListFileNames.Add(ListFileName);

        BatchFileLocation := WriteModflowBatchFile(
          ProgramLocations,
          ChangeFileExt(FileName, '.nam'), ListFileNames,
          ModflowOptions.OpenInTextEditor, BatchFileAdditionsBeforeModel,
          BatchFileAdditionsAfterModel, ExportModpath, ExportZoneBudget, self);
          //RunZoneBudget.Bat
      finally
        ListFileNames.Free;
      end;

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      if RunModel then
      begin
        RunAProgram('"' + BatchFileLocation + '"');
//        WinExec(PAnsiChar(AnsiString('"' + BatchFileLocation + '"')), SW_SHOW);
      end;
    finally
      InvalidateAllDynamicLists;
      frmProgressMM.btnAbort.Visible := False;
      frmProgressMM.Hide;
      if frmProgressMM.Owner = nil then
      begin
        FreeAndNil(frmProgressMM);
      end;
      frmFormulaErrors.DelayShowing := False;
    end;
  except on E: EFCreateError do
    begin
      Beep;
      MessageDlg(E.Message, mtError, [mbOK], 0);
    end;
  end;
end;

procedure TCustomModel.DoInitializeActiveDataArrayWithCellSizeObjects(
  Sender: TObject);
var
  ActiveDatArray: TDataArray;
  AFormula: String;
  LayerIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  ObjectIndex: Integer;
  AScreenObject: TScreenObject;
  APoint: TPoint2D;
  SectionIndex: Integer;
begin
//  Assert(Grid <> nil);
  Assert(Sender <> nil);
  ActiveDatArray := Sender as TDataArray;
  Assert(ActiveDatArray.Name = rsActive);
  AFormula := ActiveDatArray.Formula;
  Assert(AFormula = 'True');
  for LayerIndex := 0 to ActiveDatArray.LayerCount - 1 do
  begin
    for RowIndex := 0 to ActiveDatArray.RowCount - 1 do
    begin
      for ColIndex := 0 to ActiveDatArray.ColumnCount - 1 do
      begin
        ActiveDatArray.BooleanData[LayerIndex,RowIndex,ColIndex] := False;
        ActiveDatArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
          StrSetToFalseBecause
      end;
    end;
  end;
  {$REGION 'Grid'}
  for ObjectIndex := 0 to ScreenObjectCount - 1 do
  begin
    AScreenObject := ScreenObjects[ObjectIndex];
    if AScreenObject.Deleted then
    begin
      Continue;
    end;

    if AScreenObject.CellSizeUsed and AScreenObject.Closed
      and (AScreenObject.ViewDirection = vdTop) then
    begin
      for RowIndex := 0 to ActiveDatArray.RowCount - 1 do
      begin
        for ColIndex := 0 to ActiveDatArray.ColumnCount - 1 do
        begin
          if Grid <> nil then
          begin
            APoint := Grid.TwoDElementCenter(ColIndex,RowIndex);
          end
          else
          begin
            APoint := DisvGrid.TwoDGrid.Cells[ColIndex].Location;
          end;
          if AScreenObject.IsPointInside(APoint, SectionIndex) then
          begin
            for LayerIndex := 0 to ActiveDatArray.LayerCount - 1 do
            begin
              ActiveDatArray.BooleanData[LayerIndex,RowIndex,ColIndex] := True;
              ActiveDatArray.Annotation[LayerIndex,RowIndex,ColIndex] :=
                Format(StrSetToTrueBecause,
                [AScreenObject.Name]);
            end;
          end;
        end;
      end;
    end;


  end;

  ActiveDatArray.AssignValuesWithScreenObjects;
  {$ENDREGION}
end;

procedure TCustomModel.InitializeGages;
begin
  FGages.Clear;
  UnitNumbers.Initialize;
end;

procedure TCustomModel.ExportHeadObservationsToShapeFile(
  const FileName: string);
begin
  if HeadObsResults.Count = 0 then
  begin
    Exit;
  end;
  HeadObsResults.ExportToShapeFile(FileName);
end;

procedure TCustomModel.ExportInputObsDataSets(RootName: string);
type
  TInputObsLocation = record
    Index: integer;
    Location: TPoint2D;
    Value: double;
    Weight: double;
    Used: Boolean;
  end;
  PInputObsLocation = ^TInputObsLocation;
var
  DataSetName: string;
  DataArrayIndex: Integer;
  DataArray: TDataArray;
  WeightDataSetName: string;
  ObsLocations: TRbwQuadTree;
  DisLimits: TGridLimit;
  InputObsLocations: array of TInputObsLocation;
  ObsCount: Integer;
  AnInputObsLocation: TInputObsLocation;
  Index: Integer;
  Points: TQuadPointInRegionArray;
  ObsDistance: Double;
  WeightDataSet: TDataArray;
  LayerIndex: Integer;
  RowIndex: Integer;
  ColIndex: Integer;
  ObsIndex: Integer;
  QPObsLocation: TQuadPointInRegion;
  APointer: PInputObsLocation;
  InnerIndex: Integer;
  ObsLocation: TInputObsLocation;
  InputObservation: TInputObservation;
  IndObs: TIndividualObs;
  InputObservationLayers: TList<TInputObservation>;
  ObservationCount: Integer;
  DSIndex: Integer;
  ADataArray: TDataArray;
  procedure WriteInputObs;
  var
    ArrayName: string;
    InstructionFileName: string;
    ExtractInstructions: TStreamWriter;
    ObsIndex: Integer;
    AnObs: TInputObservation;
    ItemIndex: Integer;
    obs: TIndividualObs;
    PestInstructions: TStreamWriter;
    Root: string;
    OutputFileName: string;
  begin
    if InputObservationLayers.Count > 0 then  
    begin    
      Root := ExtractFileName(RootName);
      Root := ChangeFileExt(Root, '');
      Root := ChangeFileExt(Root, '');

      ObservationCount := ObservationCount + InputObservationLayers.Count;
//      FilesToDelete
      InstructionFileName := ChangeFileExt(RootName, Format('.%s_%d.ExtractIns',[DataArray.Name, LayerIndex+1]) );
      AddInputObsInstructionFileName(InstructionFileName);
      OutputFileName := ChangeFileExt(InstructionFileName, '.arrayvalues');
      FilesToDelete.Add(OutputFileName);
      ExtractInstructions := TFile.CreateText(InstructionFileName);
      try
        ArrayName := Format('arrays\%s.%s_%d.arrays', [Root,DataArray.Name, LayerIndex+1]);
        ExtractInstructions.WriteLine(ArrayName);
        for ObsIndex := 0 to InputObservationLayers.Count - 1 do
        begin
          AnObs := InputObservationLayers[ObsIndex];
          ExtractInstructions.Write(AnObs.Name);
          for ItemIndex := 0 to AnObs.Count - 1 do
          begin
            obs := AnObs[ItemIndex];
            ExtractInstructions.Write(',');
            ExtractInstructions.Write(obs.Index+1);
            ExtractInstructions.Write(',');
            ExtractInstructions.Write(obs.Weight);
          end;
          ExtractInstructions.WriteLine;
        end;
      finally
        ExtractInstructions.Free;
      end;

      InstructionFileName := ChangeFileExt(RootName,
        Format('.%s_%d.ins', [DataArray.Name, LayerIndex+1]));
      AddInputObsInstructionFile(InstructionFileName);
      PestInstructions := TFile.CreateText(InstructionFileName);
      try
        PestInstructions.WriteLine('pif @');
        for ObsIndex := 0 to InputObservationLayers.Count - 1 do
        begin
          AnObs := InputObservationLayers[ObsIndex];
          PestInstructions.WriteLine(Format(KObsInstruction, [AnObs.Name]));
        end;
      finally
        PestInstructions.Free;
      end;
    end;      
  end;
begin
  for DSIndex := 0 to DataArrayManager.DataSetCount - 1 do
  begin
    ADataArray := DataArrayManager[DSIndex];
    if ADataArray.PestParametersUsed and ADataArray.UseValuesForObservations then
    begin
      AddInputObsDataSet(ADataArray);
    end;
  end;

  DisLimits := DiscretizationLimits(vdTop);
  ObsLocations := TRbwQuadTree.Create(nil);
  InputObservationLayers := TList<TInputObservation>.Create;
  try
    ObsLocations.XMax := DisLimits.MaxX;
    ObsLocations.XMin := DisLimits.MinX;
    ObsLocations.YMax := DisLimits.MaxY;
    ObsLocations.YMin := DisLimits.MinY;
    for DataArrayIndex := 0 to FInputObservationDataSets.Count - 1 do
    begin
      ObservationCount := 0;
      DataSetName := FInputObservationDataSets[DataArrayIndex];
      DataArray := DataArrayManager.GetDataSetByName(DataSetName);
      ObsDistance := DataArray.ObservationDistance;
      Assert(DataArray <> nil);
      Assert(DataArray.PestParametersUsed and DataArray.UseValuesForObservations);
      WeightDataSetName := DataArray.WeightDataSetName;
      WeightDataSet := DataArrayManager.GetDataSetByName(WeightDataSetName);
      Assert(WeightDataSet <> nil);
      if ObsDistance <= 0 then
      begin
        for LayerIndex := 0 to WeightDataSet.LayerCount - 1 do
        begin
          Index := 0;  
          InputObservationLayers.Clear;
          for RowIndex := 0 to WeightDataSet.RowCount - 1 do
          begin
            for ColIndex := 0 to WeightDataSet.ColumnCount - 1 do
            begin
              IndObs.Weight := WeightDataSet.RealData[LayerIndex, RowIndex, ColIndex];
              if IndObs.Weight > 0 then
              begin
                IndObs.Value := DataArray.RealData[LayerIndex, RowIndex, ColIndex];
                IndObs.Index := Index;
                InputObservation := TInputObservation.Create;
                FInputObservations.Add(InputObservation);
                InputObservationLayers.Add(InputObservation);
                InputObservation.Name := Format('%d_%d_%s',
                  [LayerIndex+1, IndObs.Index+1, DataArray.Name]);
                InputObservation.ObservationGroup := DataArray.Name;
                InputObservation.AddIndividualObs(IndObs);
              end;
              Inc(Index);
            end;
          end;
          WriteInputObs;
        end;
      end
      else
      begin
        SetLength(InputObsLocations, DataArray.RowCount * DataArray.ColumnCount);
        for LayerIndex := 0 to WeightDataSet.LayerCount - 1 do
        begin
          Index := 0;  
          ObsCount := 0;
          ObsLocations.Clear;
          InputObservationLayers.Clear;

          for RowIndex := 0 to WeightDataSet.RowCount - 1 do
          begin
            for ColIndex := 0 to WeightDataSet.ColumnCount - 1 do
            begin
              AnInputObsLocation.Weight := WeightDataSet.RealData[LayerIndex, RowIndex, ColIndex];
              if AnInputObsLocation.Weight > 0 then
              begin
                AnInputObsLocation.Value := DataArray.RealData[LayerIndex, RowIndex, ColIndex];
                AnInputObsLocation.Index := Index;
                AnInputObsLocation.Used := False;
                case WeightDataSet.EvaluatedAt of
                  eaBlocks:
                    begin
                      AnInputObsLocation.Location := TwoDElementCenter(ColIndex, RowIndex);
                    end;
                  eaNodes:
                    begin
                      AnInputObsLocation.Location := TwoDElementCorner(ColIndex, RowIndex);
                    end;
                end;
                InputObsLocations[ObsCount] := AnInputObsLocation;
                ObsLocations.AddPoint(AnInputObsLocation.Location.x, 
                  AnInputObsLocation.Location.y, 
                  Addr(InputObsLocations[ObsCount]));
                Inc(ObsCount);
              end;
              Inc(Index);
            end;
          end;

          for ObsIndex := 0 to ObsCount - 1 do
          begin
            AnInputObsLocation := InputObsLocations[ObsIndex];
            if not AnInputObsLocation.Used then
            begin
              InputObservation := TInputObservation.Create;
              FInputObservations.Add(InputObservation);
              InputObservationLayers.Add(InputObservation);
              InputObservation.Name := Format('%d_%d_%s',
                [LayerIndex+1, AnInputObsLocation.Index+1, DataArray.Name]);
              InputObservation.ObservationGroup := DataArray.Name;

              ObsLocations.FindPointsInCircle(AnInputObsLocation.Location.x, 
                AnInputObsLocation.Location.y, ObsDistance, Points);
              for InnerIndex := 0 to Length(Points) - 1 do
              begin
                QPObsLocation := Points[InnerIndex];
                Assert(Length(QPObsLocation.Data) = 1);
                APointer := QPObsLocation.Data[0];
                ObsLocation := APointer^;
                if not ObsLocation.Used then
                begin
                  APointer^.Used := True;
                  IndObs.Index := ObsLocation.Index;
                  IndObs.Value := ObsLocation.Value;
                  IndObs.Weight := ObsLocation.Weight;
                  InputObservation.AddIndividualObs(IndObs);
                end;
              end;
            end;
          end;
          WriteInputObs;
        end;
      end;
      if ObservationCount = 0 then
      begin
        frmErrorsAndWarnings.AddWarning(self, StrNoInputDataSetOb, DataArray.Name);
      end
      else if ObservationCount > 200 then
      begin
        frmErrorsAndWarnings.AddWarning(self, StrMoreThan200Input,
          Format('%s: %d', [DataArray.Name, ObservationCount]));

      end;
    end;
  finally
    ObsLocations.Free;
    InputObservationLayers.Free;
  end;  
end;

procedure TCustomModel.ExportLakePackage(const FileName: string);
var
  LocalNameWriter: TNameFileWriter;
begin
  LocalNameWriter := NameFileWriter as TNameFileWriter;
  Assert(LocalNameWriter <> nil);
  SetCurrentNameFileWriter(LocalNameWriter);
  (LakWriter as TModflowLAK_Writer).WriteFile(FileName, Gages);
  FDataArrayManager.CacheDataArrays;
  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  if ModflowPackages.LakPackage.IsSelected then
  begin
    frmProgressMM.StepIt;
  end;
end;

procedure TCustomModel.ExportUzfPackage(const FileName: string);
var
  UzfWriter: TModflowUzfWriter;
begin
  UzfWriter := TModflowUzfWriter.Create(Self, etExport);
  try
    UzfWriter.WriteFile(FileName);
  finally
    UzfWriter.Free;
  end;
  FDataArrayManager.CacheDataArrays;
  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  if ModflowPackages.UzfPackage.IsSelected then
  begin
    frmProgressMM.StepIt;
  end;
end;

procedure TCustomModel.ExportWellCsv(const FileName: string);
var
  WellWriter: TModflowWEL_Writer;
begin
  frmProgressMM.ShouldContinue := True;
  if not PrepareModflowFullStressPeriods(True) then
  begin
    Exit;
  end;

  WellWriter := TModflowWEL_Writer.Create(self, etExportCsv);
  try
    WellWriter.MvrWriter := nil;
    WellWriter.WriteFile(FileName);
  finally
    WellWriter.Free;
  end;
end;

procedure TCustomModel.EvaluateSfrPackage;
begin
  (SfrWriter as TModflowSFR_Writer).Evaluate;
end;

function TCustomModel.DoEvaporationIrrigationFractionUsed(
  Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticEvaporationIrrigationFractionArrayUsed(nil);
end;

procedure TCustomModel.ExportFarmProcess(const FileName: string);
var
  LocalNameWriter: TNameFileWriter;
begin
  LocalNameWriter := NameFileWriter as TNameFileWriter;
  Assert(LocalNameWriter <> nil);
  SetCurrentNameFileWriter(LocalNameWriter);
  Assert(FarmWriter3 <> nil);
  Assert(FarmWriter4 <> nil);
  (FarmWriter3 as TModflowFmpWriter).WriteFile(FileName);
  (FarmWriter4 as TModflowFmp4Writer).WriteFile(FileName);
  FDataArrayManager.CacheDataArrays;
  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  if ModflowPackages.FarmProcess.IsSelected
    and (ModelSelection = msModflowFmp) then
  begin
    frmProgressMM.StepIt;
  end
  else if ModflowPackages.FarmProcess4.IsSelected
    and (ModelSelection = msModflowOwhm2) then
  begin
    frmProgressMM.StepIt;
  end;
end;

procedure TCustomModel.ExportSfrPackage(const FileName: string);
var
  LocalNameWriter: TNameFileWriter;
begin
  LocalNameWriter := NameFileWriter as TNameFileWriter;
  Assert(LocalNameWriter <> nil);
  SetCurrentNameFileWriter(LocalNameWriter);
  (SfrWriter as TModflowSFR_Writer).WriteFile(FileName, Gages);
  FDataArrayManager.CacheDataArrays;
  Application.ProcessMessages;
  if not frmProgressMM.ShouldContinue then
  begin
    Exit;
  end;
  if ModflowPackages.SfrPackage.IsSelected then
  begin
    frmProgressMM.StepIt;
  end;
end;

procedure TCustomModel.InternalExportModflowModel(const FileName: string;
  ExportAllLgr: boolean);
var
  LocalNameWriter: TNameFileWriter;
  DisWriter: TModflowDiscretizationWriter;
  PestGridSpecificationWriter: TPestGridSpecificationWriter;
  BasicWriter: TModflowBasicWriter;
  PcgWriter: TPcgWriter;
  LPF_Writer: TModflowLPF_Writer;
  HUF_Writer: TModflowHUF_Writer;
  BCF_Writer: TModflowBCF_Writer;
  KDEP_Writer : TModflowKDEP_Writer;
  LVDA_Writer : TModflowLVDA_Writer;
  ChdWriter: TModflowCHD_Writer;
  GhbWriter: TModflowGHB_Writer;
  WellWriter: TModflowWEL_Writer;
  RivWriter: TModflowRIV_Writer;
  DrnWriter: TModflowDRN_Writer;
  DrtWriter: TModflowDRT_Writer;
  RchWriter: TModflowRCH_Writer;
  EvtWriter: TModflowEVT_Writer;
  EtsWriter: TModflowETS_Writer;
  ResWriter: TModflowRES_Writer;
  Mnw2Writer: TModflowMNW2_Writer;
  ZoneWriter: TModflowZoneWriter;
  MultiplierWriter: TModflowMultiplierWriter;
//  BatchFileLocation: string;
  GmgWriter: TGmgWriter;
  SipWriter: TSipWriter;
  De4Writer: TDe4Writer;
  OCWriter: TOutputControlWriter;
  GagWriter: TModflowGAG_Writer;
  HobWriter: TModflowHobWriter;
  HfbWriter: TModflowHfb_Writer;
//  NumberOfSteps: Integer;
  SubWriter: TModflowSUB_Writer;
  SwtWriter: TModflowSWT_Writer;
  HydModWriter: TModflowHydmodWriter;
//  ShouldExit: Boolean;
  MultipUsed: Boolean;
  ZUsed: Boolean;
  NwtWriter: TNwtWriter;
  UPW_Writer: TModflowUPW_Writer;
  ChildIndex: integer;
  LocalPhastModel : TPhastModel;
  ChildModel: TChildModel;
  ChildNameFile: string;
  WriterList: TSfrWriterList;
  ParentPhastModel: TPhastModel;
  LinkWriter: TModflowMt3dmsLinkWriter;
  PcgnWriter: TPcgnWriter;
  StrWriter: TStrWriter;
  FhbWriter: TModflowFhbWriter;
//  FmpWriter: TModflowFmpWriter;
  SwiWriter: TSwiWriter;
  CfpWriter: TModflowCfpWriter;
  SwrWriter: TModflowSwrWriter;
  Mnw1Writer: TModflowMNW1_Writer;
  IcWriter: TModflowStartingHeadsWriter;
  NpfWriter: TNpfWriter;
  StoWriter: TStoPackageWriter;
  ModelData: TModelData;
  ImsWriter: TImsWriter;
  RipWriter: TModflowRipWriter;
  Sfr6Writer: TModflowSFR_MF6_Writer;
  MawWriter: TModflowMAW_Writer;
  DisvWriter: TMf6DisvWriter;
  GncWriter: TModflowGncWriter;
  Obs6_Writer: TModflow6Obs_Writer;
  ParameterIndex: Integer;
  LakeMf6Writer: TModflowLAKMf6Writer;
  ModflowMvrWriter: TModflowMvrWriter;
  UzfMf6Writer: TModflowUzfMf6Writer;
  CSubWriter: TCSubWriter;
  ObsScriptWriter: TGlobalComparisonScriptWriter;
  PestObsExtractorInputWriter: TPestObsExtractorInputWriter;
  SpeciesIndex: Integer;
  GwtNameWriters: TMf6GwtNameWriters;
  GwtIcWriter: TGwtInitialConcWriter;
  DspWriter: TModflowDspWriter;
  AdvWriter: TModflowGwtAdvWriter;
  GwtSsmWriter: TModflowGwtSsmWriter;
  MstWriter: TModflowGwtMstWriter;
  IstWriter: TModflowGwtIstWriter;
  CncWriter: TModflowCncWriter;
  SrcWriter: TModflowSrcWriter;
  ExchangeWriter: TModflowGwfGwtExchangeWriter;
  FmiWriter: TModflowFmiWriter;
  BuoyancyWriter: TBuoyancyWriter;
  ViscosityWriter: TViscosityWriter;
//  ShouldExport: Boolean;
  CndWriter: TModflowCndWriter;
  EstWriter: TModflowGwtMstWriter;
begin
  GwtNameWriters := Mf6GwtNameWriters as TMf6GwtNameWriters;
  GwtNameWriters.Clear;
  if GwtUsed or GweUsed then
  begin
    for SpeciesIndex := 0 to MobileComponents.Count - 1 do
    begin

      if MobileComponents[SpeciesIndex].UsedForGWT then
      begin
        GwtNameWriters.Add(TMf6GwtNameWriter.Create(self, FileName, SpeciesIndex, etExport, '.Gwt_nam'));
      end
      else if GweUsed and (MobileComponents[SpeciesIndex].Name = StrGweTemperature) then
      begin
        { TODO -cGWE : This needs to be updated for GWE. }
        GwtNameWriters.Add(TMf6GwtNameWriter.Create(self, FileName, SpeciesIndex, etExport, '.Gwe_nam'));
      end;
    end;
  end;
  ClearInputObservationDataSets;
  PilotPointData.Clear;

  frmErrorsAndWarnings.RemoveWarningGroup(self, StrTheFollowingObjectNoCells);
  frmErrorsAndWarnings.RemoveWarningGroup(self, StrFileNotFound);

  // Note: MODFLOW can not read Unicode text files.

  for ParameterIndex := 0 to ModflowTransientParameters.Count -1 do
  begin
    ModflowTransientParameters[ParameterIndex].CellCount := 0;
  end;

  Assert(Assigned(NameFileWriter));
  FDirectObservationLines := TStringList.Create;
  FDerivedObservationLines := TStringList.Create;
  FFileNameLines := TStringList.Create;
  try
    LocalNameWriter := NameFileWriter as TNameFileWriter;
    UpdateCurrentModel(self);
    try
      ModflowMvrWriter := nil;
      try
        try
          CheckWetting;

          SetCurrentDir(ExtractFileDir(FileName));
          TransientMultiplierArrays.Clear;
          TransientZoneArrays.Clear;
          ModflowSteadyParameters.ClearArrayNames;

          UsedMultiplierArrayNames.Clear;
          UsedZoneArrayNames.Clear;
          UsedMultiplierArrayNames.Sorted := True;
          UsedZoneArrayNames.Sorted := True;

          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
  //        try
          Assert(LocalNameWriter <> nil);
          SetCurrentNameFileWriter(LocalNameWriter);
          if DisvUsed then
          begin
            DisvWriter := TMf6DisvWriter.Create(self, etExport);
            try
              DisvWriter.WriteFile(FileName);
            finally
              DisvWriter.Free;
            end;
          end
          else
          begin
            DisWriter := TModflowDiscretizationWriter.Create(self, etExport);
            try
              DisWriter.WriteFile(FileName);
            finally
              DisWriter.Free;
            end;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          frmProgressMM.StepIt;

          if not DisvUsed then
          begin
            PestGridSpecificationWriter := TPestGridSpecificationWriter.
              Create(self, etExport);
            try
              PestGridSpecificationWriter.WriteFile(FileName);
            finally
              PestGridSpecificationWriter.Free;
            end;
          end;


          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModelSelection = msModflow2015 then
          begin
            ModelData.ModelType := mtGroundWaterFlow;
            ModelData.ModelName := DisplayName;
            ModelData.SolutionGroup := StrSolutionGroupName;
            ModelData.MaxIterations := ModflowPackages.SmsPackage.SolutionGroupMaxIteration;
            ModelData.ImsFile := TImsWriter.FileName(FileName);
            AddModelInputFile(ModelData.ImsFile);
            ModelData.ModelNameFile := TNameFileWriter.FileName(FileName);

            SimNameWriter.AddModel(ModelData);

            if ModflowPackages.MvrPackage.IsSelected then
            begin
              ModflowMvrWriter := TModflowMvrWriter.
                Create(self, etExport);
              ModflowMvrWriter.Evaluate;
            end;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            IcWriter := TModflowStartingHeadsWriter.Create(self, etExport);
            try
              IcWriter.WriteFile(FileName);
            finally
              IcWriter.Free;
            end;
            FDataArrayManager.CacheDataArrays;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            NpfWriter := TNpfWriter.Create(self, etExport);
            try
              NpfWriter.WriteFile(FileName);
            finally
              NpfWriter.Free;
            end;
            FDataArrayManager.CacheDataArrays;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            Obs6_Writer := TModflow6Obs_Writer.Create(self, etExport);
            try
              Obs6_Writer.WriteFile(FileName);
            finally
              Obs6_Writer.Free;
            end;
            FDataArrayManager.CacheDataArrays;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            GncWriter := TModflowGncWriter.Create(self, etExport);
            try
              GncWriter.WriteFile(FileName);
            finally
              GncWriter.Free;
            end;
            FDataArrayManager.CacheDataArrays;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            StoWriter := TStoPackageWriter.Create(self, etExport);
            try
              StoWriter.WriteFile(FileName);
            finally
              StoWriter.Free;
            end;
            FDataArrayManager.CacheDataArrays;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            ImsWriter := TImsWriter.Create(self, etExport, -1);
            try
              ImsWriter.WriteFile(FileName);
            finally
              ImsWriter.Free;
            end;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;
          end;

          BasicWriter := TModflowBasicWriter.Create(self, etExport);
          try
            BasicWriter.WriteFile(FileName);
          finally
            BasicWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          frmProgressMM.StepIt;

          OCWriter := TOutputControlWriter.Create(self, etExport);
          try
            OCWriter.WriteFile(FileName);
            if GwtUsed then
            begin
              OCWriter.OutputType := otTransport;
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                if MobileComponents[SpeciesIndex].UsedForGWT then
                begin
                  OCWriter.SpeciesIndex := SpeciesIndex;
                  OCWriter.WriteFile(FileName);
                end;
              end;
            end;

            if GweUsed then
            begin
              OCWriter.OutputType := otEnergy;
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                if MobileComponents[SpeciesIndex].Name = StrGweTemperature then
                begin
                  OCWriter.SpeciesIndex := SpeciesIndex;
                  OCWriter.WriteFile(FileName);
                end;
              end;
            end;

          finally
            OCWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          frmProgressMM.StepIt;

          if ModelSelection <> msModflow2015 then
          begin
            if not ModflowPackages.PcgPackage.IsSelected
              and not ModflowPackages.PcgnPackage.IsSelected
              and not ModflowPackages.GmgPackage.IsSelected
              and not ModflowPackages.SipPackage.IsSelected
              and not ModflowPackages.De4Package.IsSelected
              and not ModflowPackages.NwtPackage.IsSelected
              and not TCustomSolverWriter.SolverFileGeneratedExternally(self)
              then
            begin
              frmErrorsAndWarnings.AddError(self, StrNoSolverPackageSe,
                Format(StrYouMustSpecifyA, [StrSolver]));
            end;

            if not ModflowPackages.LpfPackage.IsSelected
              and not ModflowPackages.UpwPackage.IsSelected
              and not ModflowPackages.BcfPackage.IsSelected
              and not ModflowPackages.HufPackage.IsSelected
              and not TCustomFlowPackageWriter.
                FlowPackageFileGeneratedExternally(self)
              then
            begin
              frmErrorsAndWarnings.AddError(self, StrNoFlowPackageSele,
                Format(StrYouMustSpecifyA, [StrFlow]));
            end;
          end;

          PcgWriter := TPcgWriter.Create(self, etExport);
          try
            PcgWriter.WriteFile(FileName);
          finally
            PcgWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.PcgPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          PcgnWriter := TPcgnWriter.Create(self, etExport);
          try
            PcgnWriter.WriteFile(FileName);
          finally
            PcgnWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.PcgnPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          GmgWriter := TGmgWriter.Create(self, etExport);
          try
            GmgWriter.WriteFile(FileName);
          finally
            GmgWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.GmgPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          SipWriter := TSipWriter.Create(self, etExport);
          try
            SipWriter.WriteFile(FileName);
          finally
            SipWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SipPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          De4Writer := TDe4Writer.Create(self, etExport);
          try
            De4Writer.WriteFile(FileName);
          finally
            De4Writer.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.De4Package.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          NwtWriter := TNwtWriter.Create(self, etExport);
          try
            NwtWriter.WriteFile(FileName);
          finally
            NwtWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.NwtPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          LPF_Writer := TModflowLPF_Writer.Create(self, etExport);
          try
            LPF_Writer.WriteFile(FileName);
          finally
            LPF_Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.LpfPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          BCF_Writer := TModflowBCF_Writer.Create(self, etExport);
          try
            BCF_Writer.WriteFile(FileName);
          finally
            BCF_Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.BcfPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          HUF_Writer := TModflowHUF_Writer.Create(self, etExport);
          try
            HUF_Writer.WriteFile(FileName);
          finally
            HUF_Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.HufPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          KDEP_Writer := TModflowKDEP_Writer.Create(self, etExport);
          try
            KDEP_Writer.WriteFile(FileName);
          finally
            KDEP_Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.HufPackage.IsSelected
            and (HufParameters.CountParameters([ptHUF_KDEP]) > 0) then
          begin
            frmProgressMM.StepIt;
          end;

          LVDA_Writer := TModflowLVDA_Writer.Create(self, etExport);
          try
            LVDA_Writer.WriteFile(FileName);
          finally
            LVDA_Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.HufPackage.IsSelected
            and (ModflowSteadyParameters.CountParameters([ptHUF_LVDA]) > 0) then
          begin
            frmProgressMM.StepIt;
          end;

          UPW_Writer := TModflowUPW_Writer.Create(self, etExport);
          try
            UPW_Writer.WriteFile(FileName);
          finally
            UPW_Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.UpwPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          LinkWriter := TModflowMt3dmsLinkWriter.Create(self, etExport);
          try
            LinkWriter.WriteFile(FileName);
          finally
            LinkWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;

          ChdWriter := TModflowCHD_Writer.Create(self, etExport);
          try
            ChdWriter.WriteFile(FileName);
            ChdWriter.WriteFluxObservationFile(FileName, ObservationPurpose);
          finally
            ChdWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.ChdBoundary.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          GhbWriter := TModflowGHB_Writer.Create(self, etExport);
          try
            GhbWriter.MvrWriter := ModflowMvrWriter;
            GhbWriter.WriteFile(FileName);
            GhbWriter.WriteFluxObservationFile(FileName, ObservationPurpose);
          finally
            GhbWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.GhbBoundary.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          WellWriter := TModflowWEL_Writer.Create(self, etExport);
          try
            WellWriter.MvrWriter := ModflowMvrWriter;
            WellWriter.WriteFile(FileName);
          finally
            WellWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.WelPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          RivWriter := TModflowRIV_Writer.Create(self, etExport);
          try
            RivWriter.MvrWriter := ModflowMvrWriter;
            RivWriter.WriteFile(FileName);
            RivWriter.WriteFluxObservationFile(FileName, ObservationPurpose);
          finally
            RivWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.RivPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          DrnWriter := TModflowDRN_Writer.Create(self, etExport);
          try
            DrnWriter.MvrWriter := ModflowMvrWriter;
            DrnWriter.WriteFile(FileName);
            DrnWriter.WriteFluxObservationFile(FileName, ObservationPurpose);
          finally
            DrnWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.DrnPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          DrtWriter := TModflowDRT_Writer.Create(self, etExport);
          try
            DrtWriter.WriteFile(FileName);
          finally
            DrtWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.DrtPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          StrWriter := TStrWriter.Create(self, etExport);
          try
            StrWriter.WriteFile(FileName);
            StrWriter.WriteFluxObservationFile(FileName, ObservationPurpose);
          finally
            StrWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.StrPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          Sfr6Writer := TModflowSFR_MF6_Writer.Create(self, etExport);
          try
            Sfr6Writer.MvrWriter := ModflowMvrWriter;
            Sfr6Writer.WriteFile(FileName);
            if GwtUsed then
            begin
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                Sfr6Writer.WriteSftFile(FileName, SpeciesIndex);
              end;
            end;
          finally
            Sfr6Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SfrModflow6Package.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          MawWriter := TModflowMAW_Writer.Create(self, etExport);
          try
            MawWriter.MvrWriter := ModflowMvrWriter;
            MawWriter.WriteFile(FileName);
            if GwtUsed then
            begin
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                MawWriter.WriteMwtFile(FileName, SpeciesIndex);
              end;
            end;
          finally
            MawWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.MawPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          BuoyancyWriter := TBuoyancyWriter.Create(self, etExport);
          try
            BuoyancyWriter.WriteFile(FileName);
          finally
            BuoyancyWriter.Free;
          end;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.MawPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          ViscosityWriter := TViscosityWriter.Create(self, etExport);
          try
            ViscosityWriter.WriteFile(FileName);
          finally
            ViscosityWriter.Free;
          end;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.MawPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          FhbWriter := TModflowFhbWriter.Create(self, etExport);
          try
            FhbWriter.WriteFile(FileName);
          finally
            FhbWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.FhbPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          RchWriter := TModflowRCH_Writer.Create(self, etExport);
          try
            RchWriter.WriteFile(FileName);
          finally
            RchWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.RchPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          EvtWriter := TModflowEVT_Writer.Create(self, etExport);
          try
            EvtWriter.WriteFile(FileName);
          finally
            EvtWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.EvtPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          EtsWriter := TModflowETS_Writer.Create(self, etExport);
          try
            EtsWriter.WriteFile(FileName);
          finally
            EtsWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.EtsPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          ResWriter := TModflowRES_Writer.Create(self, etExport);
          try
            ResWriter.WriteFile(FileName);
          finally
            ResWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.ResPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          Mnw1Writer := TModflowMNW1_Writer.Create(self, etExport);
          try
            Mnw1Writer.WriteFile(FileName);
          finally
            Mnw1Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.Mnw1Package.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          Mnw2Writer := TModflowMNW2_Writer.Create(self, etExport);
          try
            Mnw2Writer.WriteFile(FileName);
            Mnw2Writer.WriteMnwiFile(FileName);
          finally
            Mnw2Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.Mnw2Package.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          CfpWriter := TModflowCfpWriter.Create(self, etExport);
          try
            CfpWriter.WriteFile(FileName);
          finally
            CfpWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.ConduitFlowProcess.IsSelected
            and (ModelSelection in [msModflowCFP, msModflowOwhm2]) then
          begin
            frmProgressMM.StepIt;
          end;

          SwiWriter := TSwiWriter.Create(self, etExport);
          try
            SwiWriter.WriteFile(FileName);
          finally
            SwiWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SwiPackage.IsSelected
            and (ModelSelection in [msModflow, msModflowNWT]) then
          begin
            frmProgressMM.StepIt;
          end;

          SwrWriter := TModflowSwrWriter.Create(self, etExport);
          try
            SwrWriter.WriteFile(FileName);
          finally
            SwrWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SwrPackage.IsSelected
            and (ModelSelection in [msModflowNWT]) then
          begin
            frmProgressMM.StepIt;
          end;

          RipWriter := TModflowRipWriter.Create(self, etExport);
          try
            RipWriter.WriteFile(FileName);
          finally
            RipWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.RipPackage.IsSelected
            and (ModelSelection in [msModflowFmp, msModflowOwhm2]) then
          begin
            frmProgressMM.StepIt;
          end;

          LakeMf6Writer := TModflowLAKMf6Writer.Create(self, etExport);
          try
            LakeMf6Writer.MvrWriter := ModflowMvrWriter;
            LakeMf6Writer.WriteFile(FileName);
            if GwtUsed then
            begin
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                LakeMf6Writer.WriteLktFile(FileName, SpeciesIndex);
              end;
            end;
          finally
            LakeMf6Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.LakMf6Package.IsSelected
            and (ModelSelection in [msModflow2015]) then
          begin
            frmProgressMM.StepIt;
          end;

          UzfMf6Writer := TModflowUzfMf6Writer.Create(self, etExport);
          try
            UzfMf6Writer.MvrWriter := ModflowMvrWriter;
            UzfMf6Writer.WriteFile(FileName);
            if GwtUsed then
            begin
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                UzfMf6Writer.WriteUztFile(FileName, SpeciesIndex);
              end;
            end;
          finally
            UzfMf6Writer.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.UzfMf6Package.IsSelected
            and (ModelSelection in [msModflow2015]) then
          begin
            frmProgressMM.StepIt;
          end;

          CSubWriter := TCSubWriter.Create(self, etExport);
          try
            CSubWriter.WriteFile(FileName);
          finally
            CSubWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.CsubPackage.IsSelected
            and (ModelSelection in [msModflow2015]) then
          begin
            frmProgressMM.StepIt;
          end;

          FmiWriter := TModflowFmiWriter.Create(self, etExport);
          try
            FmiWriter.WriteFile(FileName);
          finally
            FmiWriter.Free;
          end;


          if Self is TPhastModel then
          begin
            LocalPhastModel := TPhastModel(Self);
            ExportLakePackage(FileName);
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;
            if ExportAllLgr then
            begin
              for ChildIndex := 0 to LocalPhastModel.ChildModels.Count - 1 do
              begin
                ChildModel := LocalPhastModel.ChildModels[ChildIndex].ChildModel;
                if ChildModel <> nil then
                begin
                  ChildNameFile := ChildModel.Child_NameFile_Name(FileName);
                  ChildModel.ExportLakePackage(ChildNameFile);
                  Application.ProcessMessages;
                  if not frmProgressMM.ShouldContinue then
                  begin
                    Exit;
                  end;
                end;
              end;
            end;
          end
          else
          begin
            if not ExportAllLgr then
            begin
              ExportLakePackage(FileName);
              Application.ProcessMessages;
              if not frmProgressMM.ShouldContinue then
              begin
                Exit;
              end;
            end;
          end;
          Assert(LocalNameWriter <> nil);
          SetCurrentNameFileWriter(LocalNameWriter);

          // SfrWriter requires that LakWriter be completed first
          // so that TScreenObject.ModflowLakBoundary.TrueLakeID
          // is set properly.
          if Self is TPhastModel then
          begin
            LocalPhastModel := TPhastModel(Self);
            EvaluateSfrPackage;
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;

            // The Farm process requires that SFR be evaluated first so
            // that the segment numbers are assigned.
            // If FMP is allowed to be used with Local Grid Refinement.
            // FMP must also be exported after SFR evaluated in the local grid.

            if LocalPhastModel.LgrUsed then
            begin
              WriterList := TSfrWriterList.Create;
              try
                WriterList.Add(SfrWriter as TModflowSFR_Writer);
                for ChildIndex := 0 to LocalPhastModel.ChildModels.Count - 1 do
                begin
                  ChildModel := LocalPhastModel.ChildModels[ChildIndex].ChildModel;
                  if ChildModel <> nil then
                  begin
                    WriterList.Add(ChildModel.SfrWriter as TModflowSFR_Writer);
                    ChildModel.EvaluateSfrPackage;
                    Application.ProcessMessages;
                    if not frmProgressMM.ShouldContinue then
                    begin
                      Exit;
                    end;
                  end;
                end;
                (SfrWriter as TModflowSFR_Writer).AssociateLgrSubSegments(WriterList);
                Application.ProcessMessages;
                if not frmProgressMM.ShouldContinue then
                begin
                  Exit;
                end;

                // if FMP is ever allowed to be used with local grid refinement.
                // FMP for the local grid will have to be exported here.
              finally
                WriterList.Free;
              end;
            end;

            ExportSfrPackage(FileName);
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;
            ExportUzfPackage(FileName);
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;
            ExportFarmProcess(FileName);
            Application.ProcessMessages;
            if not frmProgressMM.ShouldContinue then
            begin
              Exit;
            end;
            if ExportAllLgr then
            begin
              for ChildIndex := 0 to LocalPhastModel.ChildModels.Count - 1 do
              begin
                ChildModel := LocalPhastModel.ChildModels[ChildIndex].ChildModel;
                if ChildModel <> nil then
                begin
                  ChildNameFile := ChildModel.Child_NameFile_Name(FileName);
                  ChildModel.ExportSfrPackage(ChildNameFile);
                  Application.ProcessMessages;
                  if not frmProgressMM.ShouldContinue then
                  begin
                    Exit;
                  end;
                  ChildModel.ExportUzfPackage(ChildNameFile);
                  Application.ProcessMessages;
                  if not frmProgressMM.ShouldContinue then
                  begin
                    Exit;
                  end;
                  ChildModel.ExportFarmProcess(ChildNameFile);
                  Application.ProcessMessages;
                  if not frmProgressMM.ShouldContinue then
                  begin
                    Exit;
                  end;
                end;
              end;
            end;
          end
          else
          begin
            if not ExportAllLgr then
            begin
              ParentPhastModel := (self as TChildModel).ParentModel as TPhastModel;
              ParentPhastModel.EvaluateSfrPackage;
              Application.ProcessMessages;
              if not frmProgressMM.ShouldContinue then
              begin
                Exit;
              end;
              WriterList := TSfrWriterList.Create;
              try
                WriterList.Add(ParentPhastModel.SfrWriter as TModflowSFR_Writer);
                for ChildIndex := 0 to ParentPhastModel.ChildModels.Count - 1 do
                begin
                  ChildModel := ParentPhastModel.ChildModels[ChildIndex].ChildModel;
                  if ChildModel <> nil then
                  begin
                    WriterList.Add(ChildModel.SfrWriter as TModflowSFR_Writer);
                    ChildModel.EvaluateSfrPackage;
                    Application.ProcessMessages;
                    if not frmProgressMM.ShouldContinue then
                    begin
                      Exit;
                    end;
                  end;
                end;
                (ParentPhastModel.SfrWriter as TModflowSFR_Writer).AssociateLgrSubSegments(WriterList);
              finally
                WriterList.Free;
              end;
              ExportSfrPackage(FileName);
              Application.ProcessMessages;
              if not frmProgressMM.ShouldContinue then
              begin
                Exit;
              end;

              ExportUzfPackage(FileName);
              Application.ProcessMessages;
              if not frmProgressMM.ShouldContinue then
              begin
                Exit;
              end;

              Application.ProcessMessages;
              ExportFarmProcess(FileName);
              if not frmProgressMM.ShouldContinue then
              begin
                Exit;
              end;
            end;
          end;
          Assert(LocalNameWriter <> nil);
          SetCurrentNameFileWriter(LocalNameWriter);

          HydModWriter := TModflowHydmodWriter.Create(self, etExport);
          try
            HydModWriter.WriteFile(FileName, (SfrWriter as TModflowSFR_Writer));
          finally
            HydModWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.HydmodPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;


          // GagWriter requires that LakWriter and SfrWriter be completed
          // first so that the data in Gages is set.
          GagWriter := TModflowGAG_Writer.Create(self, etExport);
          try
            GagWriter.WriteFile(FileName, Gages, (SfrWriter as TModflowSFR_Writer));
          finally
            GagWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SfrPackage.IsSelected
            or ModflowPackages.LakPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          HfbWriter := TModflowHfb_Writer.Create(Self, etExport);
          try
            HfbWriter.WriteFile(FileName);
          finally
            HfbWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.HfbPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          SubWriter := TModflowSUB_Writer.Create(Self, etExport);
          try
            SubWriter.WriteFile(FileName);
          finally
            SubWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SubPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          SwtWriter := TModflowSWT_Writer.Create(Self, etExport);
          try
            SwtWriter.WriteFile(FileName);
          finally
            SwtWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.SwtPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;
          // It is important that the TModflowZoneWriter not be used
          // until after all the zones have been identified through the
          // export of TModflowLPF_Writer and any other packages that use
          // zone arrays.
          ZoneWriter := TModflowZoneWriter.Create(self, etExport);
          try
            ZUsed := ZoneWriter.WriteFile(FileName);
          finally
            ZoneWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ZUsed then
          begin
            frmProgressMM.StepIt;
          end;

          // It is important that the TModflowMultiplierWriter not be used
          // until after all the multiplier arrays have been identified through the
          // export of TModflowLPF_Writer and any other packages that use
          // multiplier arrays.
          MultiplierWriter := TModflowMultiplierWriter.Create(self, etExport);
          try
            MultipUsed := MultiplierWriter.WriteFile(FileName);
          finally
            MultiplierWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if MultipUsed then
          begin
            frmProgressMM.StepIt;
          end;

          HobWriter := TModflowHobWriter.Create(Self, etExport);
          try
            HobWriter.WriteFile(FileName, ObservationPurpose);
          finally
            HobWriter.Free;
          end;
          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
          if ModflowPackages.HobPackage.IsSelected then
          begin
            frmProgressMM.StepIt;
          end;

          if ModflowMvrWriter <> nil then
          begin
            ModflowMvrWriter.WriteFile(FileName);
            if GwtUsed then
            begin
              for SpeciesIndex := 0 to MobileComponents.Count - 1 do
              begin
                ModflowMvrWriter.WriteMvtFile(FileName, SpeciesIndex);
              end;
            end;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;

          ObsScriptWriter := TGlobalComparisonScriptWriter.Create(Self, etExport);
          try
            ObsScriptWriter.WriteFile(FileName);
          finally
            ObsScriptWriter.Free;
          end;

//          FinalizePvalAndTemplate(FileName);

//          LocalNameWriter.SaveNameFile(FileName);
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
//        finally
//          SetCurrentNameFileWriter(nil);
//        end;
        finally
          ModflowMvrWriter.Free;
          UpdateCurrentModel(SelectedModel);
        end;

      PestObsExtractorInputWriter := TPestObsExtractorInputWriter.Create(Self);
      try
        PestObsExtractorInputWriter.WriteFile(FileName)
      finally
        PestObsExtractorInputWriter.Free;
      end;

      if GwtUsed then
      begin
        AdvWriter := TModflowGwtAdvWriter.Create(Self, etExport);
        try
          AdvWriter.WriteFile(FileName);
        finally
          AdvWriter.Free;
        end;

        for SpeciesIndex := 0 to MobileComponents.Count - 1 do
        begin
          if not MobileComponents[SpeciesIndex].UsedForGWT then
          begin
            Continue;
          end;

          DspWriter := TModflowDspWriter.Create(Self, etExport);
          try
            DspWriter.WriteFile(FileName, SpeciesIndex);
          finally
            DspWriter.Free;
          end;

          GwtSsmWriter := TModflowGwtSsmWriter.Create(Self, etExport);
          try
            GwtSsmWriter.WriteFile(FileName, SpeciesIndex);
          finally
            GwtSsmWriter.Free;
          end;

          GwtIcWriter := TGwtInitialConcWriter.Create(Self, etExport);
          try
            GwtIcWriter.WriteFile(FileName, SpeciesIndex);
          finally
            GwtIcWriter.Free;
          end;

          MstWriter := TModflowGwtMstWriter.Create(Self, etExport);
          try
            MstWriter.WriteFile(FileName, SpeciesIndex);
          finally
            MstWriter.Free;
          end;

          IstWriter := TModflowGwtIstWriter.Create(Self, etExport);
          try
            IstWriter.WriteFile(FileName, SpeciesIndex);
          finally
            IstWriter.Free;
          end;

          CncWriter := TModflowCncWriter.Create(Self, etExport);
          try
            CncWriter.WriteFile(FileName, SpeciesIndex);
          finally
            CncWriter.Free;
          end;

          SrcWriter := TModflowSrcWriter.Create(Self, etExport);
          try
            SrcWriter.WriteFile(FileName, SpeciesIndex);
          finally
            SrcWriter.Free;
          end;

          ExchangeWriter := TModflowGwfGwtExchangeWriter.Create(Self, etExport);
          try
            ExchangeWriter.WriteFile(FileName, SpeciesIndex);
          finally
            ExchangeWriter.Free;
          end;

          ImsWriter := TImsWriter.Create(self, etExport, SpeciesIndex);
          try
            ImsWriter.WriteFile(FileName);
          finally
            ImsWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;


          FDataArrayManager.CacheDataArrays;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;
        end;
      end;

      if GweUsed then
      begin

        AdvWriter := TModflowGwtAdvWriter.Create(Self, etExport);
        try
          AdvWriter.ModelType := mtEnergyTransport;
          AdvWriter.WriteFile(FileName);
        finally
          AdvWriter.Free;
        end;

        for SpeciesIndex := 0 to MobileComponents.Count - 1 do
        begin
          if not (MobileComponents[SpeciesIndex].Name = strGweTemperature) then
          begin
            Continue;
          end;

          GwtIcWriter := TGwtInitialConcWriter.Create(Self, etExport);
          try
            GwtIcWriter.WriteFile(FileName, SpeciesIndex);
          finally
            GwtIcWriter.Free;
          end;

          CndWriter := TModflowCndWriter.Create(Self, etExport);
          try
            CndWriter.WriteFile(FileName, SpeciesIndex);
          finally
            CndWriter.Free;
          end;

          EstWriter := TModflowGwtMstWriter.Create(Self, etExport);
          try
            EstWriter.WriteFile(FileName, SpeciesIndex);
          finally
            EstWriter.Free;
          end;

          ImsWriter := TImsWriter.Create(self, etExport, SpeciesIndex);
          try
            ImsWriter.WriteFile(FileName);
          finally
            ImsWriter.Free;
          end;
          Application.ProcessMessages;
          if not frmProgressMM.ShouldContinue then
          begin
            Exit;
          end;

        end;

      end;

      FinalizePvalAndTemplate(FileName);
      LocalNameWriter.SaveNameFile(FileName);
      finally
        SetCurrentNameFileWriter(nil);
      end;

      for SpeciesIndex := 0 to GwtNameWriters.Count - 1 do
      begin
        if GweUsed and (MobileComponents[SpeciesIndex].Name = strGweTemperature) then
        begin
          GwtNameWriters[SpeciesIndex].WriteFile(mtEnergyTransport);
        end
        else
        begin
          GwtNameWriters[SpeciesIndex].WriteFile(mtGroundwaterTransport);
        end;
      end;

    except on E: EInvalidTime do
      begin
        Beep;
        MessageDlg(E.Message, mtError, [mbOK], 0);
      end;
    end;
  finally
    FreeAndNil(FDirectObservationLines);
    FreeAndNil(FDerivedObservationLines);
    FreeAndNil(FFileNameLines);
  end;
end;

procedure TCustomModel.ExportModpathModel(FileName: string;
      RunModel, NewBudgetFile: boolean; EmbeddedExport: boolean = False);
var
  StartLocations: TModpathStartingLocationsWriter;
  MainFileWriter: TModpathMainFileWriter;
  TimeFileWriter: TModpathTimeFileWriter;
  Responses: TModpathResponseFileWriter;
  NameFileWriter: TModpathNameFileWriter;
  BatchFileLocation: string;
  LargeBudgetFileResponse: string;
  BasicFileWriter : TModpathBasicFileWriter;
  SimFileWriter : TModpathSimFileWriter;
  LogFileName: string;
  GeoRefWriter: TGeoRefWriter;
  GridMetaDataWriter: TGridMetaDataWriter;
begin
  // Note: MODPATH can not read Unicode text files.

  if not TestModpathOK(self) then
  begin
    Exit;
  end;
  if frmProgressMM = nil then
  begin
    frmProgressMM := TfrmProgressMM.Create(nil);
  end;
  try
    frmErrorsAndWarnings.RemoveErrorGroup(self, StrInvalidDISVGridFo);
    if DisvUsed and (ModflowGrid.GridAngle <> 0) then
    begin
      frmErrorsAndWarnings.AddError(self, StrInvalidDISVGridFo,
        StrMODFPATHRequiresTh);
    end;

    try
      frmProgressMM.ShouldContinue := True;
      UpdateModflowFullStressPeriods;
      SetCurrentDir(ExtractFileDir(FileName));
      FileName := FixFileName(FileName);

      ModpathInputFiles.Clear;
      ModpathOutputFiles.Clear;

      case ModflowPackages.ModPath.MpathVersion of
        mp5:
          begin
            GeoRefWriter := TGeoRefWriter.Create(self, etExport);
            try
              GeoRefWriter.WriteFile(FileName, smtModpath5);
            finally
              GeoRefWriter.Free;
            end;

            NameFileWriter := TModpathNameFileWriter.Create;
            try
              NameFileWriter.WriteFile(FileName, self, EmbeddedExport);
            finally
              NameFileWriter.Free;
            end;

            MainFileWriter := TModpathMainFileWriter.Create(Self, etExport);
            try
              MainFileWriter.WriteFile(FileName);
            finally
              MainFileWriter.Free;
            end;
            StartLocations := TModpathStartingLocationsWriter.Create(Self, etExport);
            try
              StartLocations.WriteFileVersion5(FileName);
            finally
              StartLocations.Free;
            end;
            if ModflowPackages.ModPath.ShouldCreateTimeFile then
            begin
              TimeFileWriter := TModpathTimeFileWriter.Create(Self, etExport);
              try
                TimeFileWriter.WriteFile(FileName);
              finally
                TimeFileWriter.Free;
              end;
            end;
            Responses := TModpathResponseFileWriter.Create(Self, etExport);
            try
              Responses.WriteFile(FileName, NewBudgetFile);
              LargeBudgetFileResponse := Responses.FLargeBudgetFileResponse;
            finally
              Responses.Free;
            end;

            BatchFileLocation := WriteModpathBatchFile(ProgramLocations, FileName,
              ChangeFileExt(FileName,'.mplst'), RunModel, LargeBudgetFileResponse,
              EmbeddedExport, self);

          end;
        mp6:
          begin
            GeoRefWriter := TGeoRefWriter.Create(self, etExport);
            try
              GeoRefWriter.WriteFile(FileName, smtModpath6);
            finally
              GeoRefWriter.Free;
            end;

            NameFileWriter := TModpathNameFileWriter.Create;
            try
              NameFileWriter.WriteFileVersion6(FileName, self, EmbeddedExport);
            finally
              NameFileWriter.Free;
            end;

            BasicFileWriter := TModpathBasicFileWriter.Create(Self, etExport);
            try
              BasicFileWriter.WriteFile(FileName);
            finally
              BasicFileWriter.Free;
            end;
            StartLocations := TModpathStartingLocationsWriter.Create(Self, etExport);
            try
              StartLocations.WriteFileVersion6(FileName);
            finally
              StartLocations.Free;
            end;

            SimFileWriter := TModpathSimFileWriter.Create(Self, etExport);
            try
              SimFileWriter.WriteFile(FileName);
            finally
              SimFileWriter.Free;
            end;

            BatchFileLocation := WriteModPathBatchFileVersion6(ProgramLocations,
              FileName, ChangeFileExt(FileName,'.mplst'), RunModel,
              EmbeddedExport, self);
          end;
        mp7:
          begin
            GeoRefWriter := TGeoRefWriter.Create(self, etExport);
            try
              GeoRefWriter.WriteFile(FileName, smtModpath6);
            finally
              GeoRefWriter.Free;
            end;

            NameFileWriter := TModpathNameFileWriter.Create;
            try
              NameFileWriter.WriteFileVersion7(FileName, self, EmbeddedExport);
            finally
              NameFileWriter.Free;
            end;

            if ModelSelection <> msModflow2015 then
            begin
              GridMetaDataWriter := TGridMetaDataWriter.Create(self, etExport);
              try
                GridMetaDataWriter.WriteFile(FileName);
              finally
                GridMetaDataWriter.Free;
              end;
            end;

            BasicFileWriter := TModpathBasicFileWriter.Create(Self, etExport);
            try
              BasicFileWriter.WriteFile(FileName);
            finally
              BasicFileWriter.Free;
            end;

            SimFileWriter := TModpathSimFileWriter.Create(Self, etExport);
            try
              SimFileWriter.WriteFile(FileName);
            finally
              SimFileWriter.Free;
            end;

            BatchFileLocation := WriteModPathBatchFileVersion7(ProgramLocations,
              FileName, ChangeFileExt(FileName,'.mplst'), RunModel,
              EmbeddedExport, self);
          end;
        else
          Assert(False);
      end;

      (ParentModel as TPhastModel).SaveArchiveList(ChangeFileExt(FileName, '.axml'));

      if RunModel then
      begin
        RunAProgram('"' + BatchFileLocation + '"');
      end;
    except on E: EFCreateError do
      begin
        Beep;
        MessageDlg(E.Message, mtError, [mbOK], 0);
      end;
    end;
    if (ModflowPackages.ModPath.MpathVersion = mp6) then
    begin
      LogFileName := IncludeTrailingPathDelimiter(ExtractFileDir(FileName))
        + 'MPATH6.LOG';
      AddModpathOutputFile(LogFileName);
    end;
  finally
    if frmProgressMM.Owner = nil then
    begin
      FreeAndNil(frmProgressMM);
    end;

//    ReclaimMemory;
  end;
end;

procedure TCustomModel.ExportMt3dmsModel(const FileName: string;
  RunModel, ShowWarning: Boolean);
var
  NumberOfSteps: integer;
  Mt3dmsBtnWriter: TMt3dmsBtnWriter;
  Mt3dmsAdvWriter: TMt3dmsAdvWriter;
  Mt3dmsDspWriter: TMt3dmsDspWriter;
  Mt3dmsSsmWriter: TMt3dmsSsmWriter;
  Mt3dmsRctWriter: TMt3dmsRctWriter;
  Mt3dmsGcgWriter: TMt3dmsGcgWriter;
  Mt3dmsTobWriter: TMt3dmsTobWriter;
  LocalNameWriter: TMt3dmsNameWriter;
  ListFileNames : TStringList;
  ListFileName: string;
  BatchFileLocation: string;
  GeoRefWriter: TGeoRefWriter;
  UztWriter: TMt3dUztWriter;
  LktWriter: TMt3dLktWriter;
  SftWriter: TMt3dmsSftWriter;
  CtsWriter: TMt3dCtsWriter;
begin
  // Note: MT3DMS can not read Unicode text files.

  if frmProgressMM = nil then
  begin
    frmProgressMM := TfrmProgressMM.Create(nil);
  end;
  try
    frmFormulaErrors.DelayShowing := True;
    try
      frmProgressMM.Prefix := 'File ';
      if ModflowPackages.Mt3dBasic.Mt3dVersion = mvUSGS then
      begin
        frmProgressMM.Caption := StrExportingMT3DUSGS;
      end
      else
      begin
        frmProgressMM.Caption := StrExportingMT3DMSInp;
      end;
      frmProgressMM.btnAbort.Visible := True;
      frmProgressMM.ShouldContinue := True;
      frmProgressMM.Show;

      NumberOfSteps := CountStepsInMt3dExport;

      frmProgressMM.pbProgress.Max := NumberOfSteps;
      frmProgressMM.pbProgress.Position := 0;

      if not PrepareModflowFullStressPeriods(ShowWarning) then
      begin
        Exit;
      end;
      if not CheckMt3dTimes(ShowWarning) then
      begin
        Exit;
      end;

      Assert(Assigned(NameFileWriter));
      LocalNameWriter := NameFileWriter as TMt3dmsNameWriter;
      Assert(LocalNameWriter <> nil);
      SetCurrentNameFileWriter(LocalNameWriter);
      UpdateCurrentModel(self);
      try
        SetCurrentDir(ExtractFileDir(FileName));

        UztWriter := TMt3dUztWriter.Create(self, etExport);
        try
          UztWriter.WriteFile(FileName);
        finally
          UztWriter.Free;
        end;

        LktWriter := TMt3dLktWriter.Create(self, etExport);
        try
          LktWriter.WriteFile(FileName);
        finally
          LktWriter.Free;
        end;

        CtsWriter := TMt3dCtsWriter.Create(self, etExport);
        try
          CtsWriter.WriteFile(FileName);
        finally
          CtsWriter.Free;
        end;

        SftWriter := TMt3dmsSftWriter.Create(self, etExport);
        try
          SftWriter.WriteFile(FileName);
        finally
          SftWriter.Free;
        end;

        GeoRefWriter := TGeoRefWriter.Create(self, etExport);
        try
          GeoRefWriter.WriteFile(FileName, smtMt3dms);
        finally
          GeoRefWriter.Free;
        end;

        Mt3dmsBtnWriter := TMt3dmsBtnWriter.Create(Self, etExport);
        try
          Mt3dmsBtnWriter.WriteFile(FileName);
        finally
          Mt3dmsBtnWriter.Free;
        end;

        Mt3dmsAdvWriter := TMt3dmsAdvWriter.Create(Self, etExport);
        try
          Mt3dmsAdvWriter.WriteFile(FileName);
        finally
          Mt3dmsAdvWriter.Free;
        end;

        Mt3dmsDspWriter := TMt3dmsDspWriter.Create(Self, etExport);
        try
          Mt3dmsDspWriter.WriteFile(FileName);
        finally
          Mt3dmsDspWriter.Free;
        end;

        Mt3dmsSsmWriter := TMt3dmsSsmWriter.Create(Self, etExport);
        try
          Mt3dmsSsmWriter.WriteFile(FileName);
        finally
          Mt3dmsSsmWriter.Free;
        end;

        Mt3dmsRctWriter := TMt3dmsRctWriter.Create(Self, etExport);
        try
          Mt3dmsRctWriter.WriteFile(FileName);
        finally
          Mt3dmsRctWriter.Free;
        end;

        Mt3dmsGcgWriter := TMt3dmsGcgWriter.Create(Self, etExport);
        try
          Mt3dmsGcgWriter.WriteFile(FileName);
        finally
          Mt3dmsGcgWriter.Free;
        end;

        Mt3dmsTobWriter := TMt3dmsTobWriter.Create(Self, etExport);
        try
          Mt3dmsTobWriter.WriteFile(FileName, ObservationPurpose);
        finally
          Mt3dmsTobWriter.Free;
        end;

        LocalNameWriter.SaveNameFile(FileName);

        ListFileNames := TStringList.Create;
        try
          ListFileName := LocalNameWriter.ListFileName;
          ListFileNames.Add(ListFileName);

          BatchFileLocation := WriteMt3dmsBatchFile(
            ProgramLocations,
            ChangeFileExt(FileName, StrMtName), ListFileNames,
            ModflowOptions.OpenInTextEditor, self);
          AddMt3dmsInputFile(BatchFileLocation + ArchiveExt);

        finally
          ListFileNames.Free;
        end;

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      (ParentModel as TPhastModel).SaveArchiveList(ChangeFileExt(FileName, '.axml'));


      if RunModel then
      begin
        RunAProgram('"' + BatchFileLocation + '"');
      end;

      finally
        UpdateCurrentModel(SelectedModel);
        SetCurrentNameFileWriter(nil);
      end;

    finally
      frmProgressMM.btnAbort.Visible := False;
      frmProgressMM.Hide;
      if frmProgressMM.Owner = nil then
      begin
        FreeAndNil(frmProgressMM);
      end;
      frmFormulaErrors.DelayShowing := False;
    end;
  except on E: EFCreateError do
    begin
      Beep;
      MessageDlg(E.Message, mtError, [mbOK], 0);
    end;
  end;
end;

procedure TCustomModel.ExportSeparateLgrModel(const FileName: string;
  RunModel, ExportModpath, ExportZoneBudget, ShowWarning: boolean);
var
  IUPBHSV: Integer;
  IUPBFSV: Integer;
  NameFile: string;
  HeadFile: string;
  ANameFileWriter: TNameFileWriter;
  FlowFile: string;
  ListFileNames: TStringList;
  ListFileName: string;
  BatchFileLocation: string;
  FileDir: string;
  LgrUsed: Boolean;
begin
  PestTemplateLines.Clear;
  KrigfactorsScriptLines.Clear;
  if frmProgressMM = nil then
  begin
    frmProgressMM := TfrmProgressMM.Create(nil);
  end;
  try
    frmFormulaErrors.DelayShowing := True;
    try
      frmProgressMM.Prefix := 'File ';
      frmProgressMM.Caption := 'Exporting MODFLOW-LGR input files';
      frmProgressMM.btnAbort.Visible := True;
      frmProgressMM.ShouldContinue := True;
      frmProgressMM.Show;


      frmProgressMM.pbProgress.Max := CountStepsInExport;
      frmProgressMM.pbProgress.Position := 0;

      if not PrepareModflowFullStressPeriods(ShowWarning) then
      begin
        Exit;
      end;

      InitializeGages;
      if self is TChildModel then
      begin
        TChildModel(self).ParentModel.InitializeSfrWriter(etExport);
      end
      else
      begin
        InitializeSfrWriter(etExport);
      end;
      try
        IUPBHSV := UnitNumbers.UnitNumber(BFH_Heads);
        IUPBFSV := UnitNumbers.UnitNumber(BFH_Fluxes);
        NameFile := FixFileName(FileName);

        if self is TChildModel then
        begin
          NameFile := FixFileName(ExtractFileName(FileName));
          FileDir := ExtractFilePath(FileName);
          NameFile := FileDir + TChildModel(self).Child_NameFile_Name(NameFile);
        end;

//        LgrUsed := False;
        if self is TChildModel then
        begin
          LgrUsed := True;
        end
        else
        begin
          LgrUsed := (self as TPhastModel).LgrUsed;
        end;

        ANameFileWriter := NameFileWriter as TNameFileWriter;
        if LgrUsed then
        begin
          HeadFile := ChangeFileExt(NameFile, '.bfh_head');
          FlowFile := ChangeFileExt(NameFile, '.bfh_flux');
          Assert(ANameFileWriter <> nil);
          SetCurrentNameFileWriter(ANameFileWriter);
          if self is TChildModel then
          begin
            case ModelSelection of
              msModflowLGR:
                begin
                  ANameFileWriter.WriteToNameFile('BFH', IUPBHSV, HeadFile, foInputAlreadyExists, self);
                end;
              msModflowLGR2, msModflowFmp, msModflowOwhm2:
                begin
                  ANameFileWriter.WriteToNameFile('BFH2', IUPBHSV, HeadFile, foInputAlreadyExists, self);
                end;
              else
                Assert(False);
            end;
            ANameFileWriter.WriteToNameFile(StrDATA, IUPBFSV, FlowFile, foInputAlreadyExists, self);
          end
          else
          begin
            ANameFileWriter.WriteToNameFile(StrDATA, IUPBHSV, HeadFile, foInputAlreadyExists, self);
            case ModelSelection of
              msModflowLGR:
                begin
                  ANameFileWriter.WriteToNameFile('BFH', IUPBFSV, FlowFile, foInputAlreadyExists, self);
                end;
              msModflowLGR2, msModflowFmp, msModflowOwhm2:
                begin
                  ANameFileWriter.WriteToNameFile('BFH2', IUPBFSV, FlowFile, foInputAlreadyExists, self);
                end;
              else
                Assert(False);
            end;
          end;
        end;

//        FPValFile.Clear;
//        FPvalTemplate.Clear;
        ClearPval;
        InternalExportModflowModel(NameFile, False);
      finally
        if self is TChildModel then
        begin
          TChildModel(self).ParentModel.FreeSfrWriter;
        end
        else
        begin
          FreeSfrWriter;
        end;
      end;

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      ListFileNames := TStringList.Create;
      try

        ListFileName := (NameFileWriter as TNameFileWriter).ListFileName;
        ListFileNames.Add(ListFileName);

        NameFile := IncludeTrailingPathDelimiter(ExtractFileDir(FileName))
          + ExtractFileName(NameFile);

        BatchFileLocation := WriteModflowBatchFile(
          ProgramLocations,
          ChangeFileExt(NameFile, '.nam'), ListFileNames,
          ModflowOptions.OpenInTextEditor, BatchFileAdditionsBeforeModel,
          BatchFileAdditionsAfterModel, ExportModpath, ExportZoneBudget, self);

      finally
        ListFileNames.Free;
      end;

      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;

      if RunModel then
      begin
//        WinExec(PAnsiChar(AnsiString('"' + BatchFileLocation + '"')), SW_SHOW);
        RunAProgram('"' + BatchFileLocation + '"');
      end;

    finally
      frmProgressMM.btnAbort.Visible := False;
      frmProgressMM.Hide;
      if frmProgressMM.Owner = nil then
      begin
        FreeAndNil(frmProgressMM);
      end;
      frmFormulaErrors.DelayShowing := False;
    end;
  except on E: EFCreateError do
    begin
      Beep;
      MessageDlg(E.Message, mtError, [mbOK], 0);
    end;
  end;end;

procedure TCustomModel.ExportZoneBudgetModel(FileName: string; RunModel, EmbeddedExport: boolean);
var
  NumberOfSteps: Integer;
  ZoneFileWriter: TZoneBudgetZoneFileWriter;
  ResponseFileWriter: TZoneBudgetResponseFileWriter;
  BatchFileLocation: string;
  GeoRefWriter: TGeoRefWriter;
  ZbNameFileWriter: TZoneBudgetNameFileWriter;
  Root: string;
  Extension: string;
  GWTUsed:  Boolean;
  ChemIndex: Integer;
  TempFileName: string;
begin
  if ModelSelection = msModflowOwhm2 then
  begin
    frmErrorsAndWarnings.AddWarning(self, StrWhenUsingZonebudge,
      StrTheVersionOfZoneB)
  end;
  // Note: ZONEBUDGET can not read Unicode text files.

  SetCurrentDir(ExtractFileDir(FileName));
  FileName := FixFileName(FileName);
  Root := ChangeFileExt(FileName, '');
  Extension := ExtractFileExt(FileName);
  GWTUsed := (ModelSelection = msModflow2015) and ModflowPackages.GwtProcess.IsSelected;
  if frmProgressMM = nil then
  begin
    frmProgressMM := TfrmProgressMM.Create(nil);
  end;
  try
    try
      ZoneBudgetInputFiles.Clear;
      ZoneBudgetOutputFiles.Clear;

      frmProgressMM.Prefix := 'File ';
      frmProgressMM.Caption := 'Exporting ZONEBUDGET input files';
      frmProgressMM.btnAbort.Visible := True;
      frmProgressMM.ShouldContinue := True;
      frmProgressMM.Show;

      NumberOfSteps := 3;

      frmProgressMM.pbProgress.Max := NumberOfSteps;
      frmProgressMM.pbProgress.Position := 0;

      GeoRefWriter := TGeoRefWriter.Create(self, etExport);
      try
        GeoRefWriter.WriteFile(FileName, smtZoneBudget2);
      finally
        GeoRefWriter.Free;
      end;
      if GWTUsed then
      begin
        for ChemIndex := 0 to MobileComponents.Count - 1 do
        begin
          GeoRefWriter := TGeoRefWriter.Create(self, etExport);
          try
            GeoRefWriter.WriteFile(FileName, smtZoneBudget2, MobileComponents[ChemIndex].Name);
          finally
            GeoRefWriter.Free;
          end;
        end;
      end;

      // Export ZoneFile;
      ZoneFileWriter := TZoneBudgetZoneFileWriter.Create(self, etExport);
      try
        ZoneFileWriter.WriteFile(FileName);
      finally
        ZoneFileWriter.Free;
      end;
      if GWTUsed then
      begin
        for ChemIndex := 0 to MobileComponents.Count - 1 do
        begin
          ZoneFileWriter := TZoneBudgetZoneFileWriter.Create(self, etExport);
          try
            ZoneFileWriter.WriteFile(FileName, MobileComponents[ChemIndex].Name);
          finally
            ZoneFileWriter.Free;
          end;
        end;
      end;


      FDataArrayManager.CacheDataArrays;
      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;
      frmProgressMM.StepIt;

      // Export Response File;
      if ModelSelection = msModflow2015 then
      begin
        ZbNameFileWriter := TZoneBudgetNameFileWriter.Create(self, etExport, EmbeddedExport);
        try
          ZbNameFileWriter.WriteFile(FileName);
        finally
          ZbNameFileWriter.Free;
        end;
        if GWTUsed then
        begin
          for ChemIndex := 0 to MobileComponents.Count - 1 do
          begin
            ZbNameFileWriter := TZoneBudgetNameFileWriter.Create(self, etExport, EmbeddedExport);
            try
              ZbNameFileWriter.WriteFile(FileName, MobileComponents[ChemIndex].Name);
            finally
              ZbNameFileWriter.Free;
            end;
          end;
        end;
      end
      else
      begin
        ResponseFileWriter := TZoneBudgetResponseFileWriter.Create(self, etExport, EmbeddedExport);
        try
          ResponseFileWriter.WriteFile(FileName);
        finally
          ResponseFileWriter.Free;
        end;
      end;
      FDataArrayManager.CacheDataArrays;
      Application.ProcessMessages;
      if not frmProgressMM.ShouldContinue then
      begin
        Exit;
      end;
      frmProgressMM.StepIt;

      // Export Batch File;
      BatchFileLocation := WriteZoneBudgetBatchFile(self, FileName, RunModel,
        EmbeddedExport);
//      AddZoneBudgetInputFile(BatchFileLocation);

      if RunModel then
      begin
        RunAProgram('"' + BatchFileLocation + '"');
//        WinExec(PAnsiChar(AnsiString('"' + BatchFileLocation + '"')), SW_SHOW);
      end;
    except on E: EFCreateError do
      begin
        Beep;
        MessageDlg(E.Message, mtError, [mbOK], 0);
      end;
    end;
  finally
    frmProgressMM.btnAbort.Visible := False;
    frmProgressMM.Hide;
    if frmProgressMM.Owner = nil then
    begin
      FreeAndNil(frmProgressMM);
    end;
//    ReclaimMemory;
  end;
end;

procedure TCustomModel.FinalizeDischargeRouting(Sender: TObject);
var
  LakeIdArray: TDataArray;
  DischargeRoutingArray: TDataArray;
begin
  DischargeRoutingArray := FDataArrayManager.GetDataSetByName(StrUzfDischargeRouting);
  LakeIdArray := FDataArrayManager.GetDataSetByName(rsLakeID);
  if (LakeIdArray <> nil) and (DischargeRoutingArray <> nil) then
  begin
    DischargeRoutingArray.StopsTalkingTo(LakeIdArray);
  end;
end;

procedure TCustomModel.GetPestParameterNames(ParameterNames: TStringList);
var
  ParameterIndex: Integer;
  AParameter: TModflowSteadyParameter;
begin
  ParameterNames.Clear;
  ParameterNames.Add(strNone);
  for ParameterIndex := 0 to ModflowSteadyParameters.Count - 1 do
  begin
    AParameter := ModflowSteadyParameters[ParameterIndex];
    if AParameter.ParameterType = ptPEST then
    begin
      ParameterNames.AddObject(AParameter.ParameterName, AParameter);
    end;
  end;
end;

procedure TCustomModel.GetParameterUsedAndParameterFormulaForLPF(
      out ParameterUsed: Boolean; out ParameterFormula: string;
      ParameterType: TParameterType);
var
  Index: Integer;
  Item: TModflowSteadyParameter;
begin
  ParameterFormula := '';
  ParameterUsed := (ModelSelection in ModflowSelection)
    and (ModflowPackages.LpfPackage.IsSelected
    or ModflowPackages.UpwPackage.IsSelected);
  if ParameterUsed then
  begin
    ParameterUsed := False;
    for Index := 0 to ModflowSteadyParameters.Count - 1 do
    begin
      Item := ModflowSteadyParameters[Index];
      if Item.ParameterType = ParameterType then
      begin
        ParameterUsed := True;
        if ParameterFormula <> '' then
        begin
          ParameterFormula := ParameterFormula + ' + ';
        end;
        if Item.UseZone then
        begin
          ParameterFormula := ParameterFormula + '(If(' + Item.ZoneName + ', ';
        end;
        if Item.UseMultiplier then
        begin
          ParameterFormula := ParameterFormula +
            '(' + Item.MultiplierName + ' * ';
        end;
        ParameterFormula := ParameterFormula + FortranFloatToStr(Item.Value);
        if Item.UseMultiplier then
        begin
          ParameterFormula := ParameterFormula + ')';
        end;
        if Item.UseZone then
        begin
          ParameterFormula := ParameterFormula + ', 0))';
        end;
      end;
    end;
  end;
end;

function TCustomModel.GetParentModel: TCustomModel;
begin
  result := self;
end;

procedure TCustomModel.UpdateLpfDataArrayParameterUsed(const DataArrayName: string;
      ParameterType: TParameterType);
var
  DataArray: TDataArray;
  ParameterUsed: Boolean;
  ParameterFormula: string;
begin
  GetParameterUsedAndParameterFormulaForLPF(ParameterUsed, ParameterFormula,
    ParameterType);
  DataArray := FDataArrayManager.GetDataSetByName(DataArrayName);
  if (DataArray <> nil) then
  begin
    DataArray.ParameterUsed := ParameterUsed;
    if ParameterUsed then
    begin
      DataArray.ParameterFormula := ParameterFormula;
      DataArray.Lock := DataArray.Lock + [dcFormula];
    end
    else
    begin
      DataArray.ParameterFormula := '';
      DataArray.Lock := DataArray.Lock - [dcFormula];
    end;
  end;
end;

{ TChildModelCollection }

procedure TChildModelCollection.Assign(Source: TPersistent);
begin
  inherited;
  UpdateUnitNumbers;
end;

constructor TChildModelCollection.Create(Model: IModelForTOrderedCollection);
begin
  inherited Create(TChildModelItem, Model);
end;

procedure TChildModelCollection.UpdateUnitNumbers;
const
  // It is assumed here that  MODFLOW will never have more than 1000
  // files included in the name file.
  UnitNumberOffset = 1000;
var
  ItemIndex: Integer;
begin
  for ItemIndex := 0 to Count - 1 do
  begin
    Items[ItemIndex].ChildModel.UnitNumbers.AddedValue :=
      (ItemIndex + 1) * UnitNumberOffset;
  end;
end;

function TChildModelCollection.GetItem(Index: integer): TChildModelItem;
begin
  result := inherited Items[Index] as TChildModelItem;
end;

procedure TChildModelCollection.Loaded;
var
  ItemIndex: Integer;
begin
  for ItemIndex := 0 to Count - 1 do
  begin
    Items[ItemIndex].Loaded;
  end;
  UpdateUnitNumbers;
end;

procedure TChildModelCollection.SetItem(Index: integer;
  const Value: TChildModelItem);
begin
  inherited Items[Index] := Value;
end;

{ TChildModelItem }

procedure TChildModelItem.Assign(Source: TPersistent);
begin
  // if Assign is updated, update IsSame too.

  if Source is TChildModelItem then
  begin
    ChildModel.Assign(TChildModelItem(Source).ChildModel);
  end
  else if Source is TChildModelEdit then
  begin
    ChildModel.Assign(TChildModelEdit(Source));
  end
  else
  begin
    inherited;
  end;
end;

constructor TChildModelItem.Create(Collection: TCollection);
begin
  inherited;
  FChildModel := TChildModel.Create(Model as TCustomModel);
  if FChildModel.FParentModel <> nil then
  begin
    FChildModel.Assign(FChildModel.FParentModel);
  end;
  FChildModel.SetSubComponent(True);
end;

destructor TChildModelItem.Destroy;
begin
  FChildModel.Free;
  inherited;
end;

function TChildModelItem.IsSame(AnotherItem: TOrderedItem): boolean;
var
  AnotherChildItem: TChildModelItem;
  ChildEdit: TChildModelEdit;
begin
    // When editing this section, be sure to edit TChildModelEdit
    // and TChildModel too

  result := AnotherItem is TChildModelItem;
  if result then
  begin
    AnotherChildItem := TChildModelItem(AnotherItem);
    result := ChildModel = AnotherChildItem.ChildModel;
    if not result and (ChildModel <> nil)
      and (AnotherChildItem.ChildModel <> nil) then
    begin
      result :=
        (ChildModel.ModelName = AnotherChildItem.ChildModel.ModelName)
        and (ChildModel.ChildCellsPerParentCell = AnotherChildItem.ChildModel.ChildCellsPerParentCell)
        and (ChildModel.StartingHeadSource = AnotherChildItem.ChildModel.StartingHeadSource)
//        and (ChildModel.OneWayCoupling = AnotherChildItem.ChildModel.OneWayCoupling)
        and (ChildModel.CouplingMethod = AnotherChildItem.ChildModel.CouplingMethod)
        and (ChildModel.MaxIterations = AnotherChildItem.ChildModel.MaxIterations)
        and (ChildModel.LgrPrintChoice = AnotherChildItem.ChildModel.LgrPrintChoice)
        and (ChildModel.HeadRelaxationFactor = AnotherChildItem.ChildModel.HeadRelaxationFactor)
        and (ChildModel.FluxRelaxationFactor = AnotherChildItem.ChildModel.FluxRelaxationFactor)
        and (ChildModel.HeadClosureCriterion = AnotherChildItem.ChildModel.HeadClosureCriterion)
        and (ChildModel.FluxClosureCriterion = AnotherChildItem.ChildModel.FluxClosureCriterion)
        and ChildModel.Discretization.IsSame(AnotherChildItem.ChildModel.Discretization);
    end;
  end
  else if AnotherItem is TChildModelEdit then
  begin
    ChildEdit := TChildModelEdit(AnotherItem);
    result := ChildModel = ChildEdit.FChildModel;
    if result then
    begin
      result :=
        (ChildModel.ModelName = ChildEdit.ModelName)
        and (ChildModel.ChildCellsPerParentCell = ChildEdit.ChildCellsPerParentCell)
        and (ChildModel.StartingHeadSource = ChildEdit.StartingHeadSource)
//        and (ChildModel.OneWayCoupling = ChildEdit.OneWayCoupling)
        and (ChildModel.CouplingMethod = ChildEdit.CouplingMethod)
        and (ChildModel.MaxIterations = ChildEdit.MaxIterations)
        and (ChildModel.LgrPrintChoice = ChildEdit.LgrPrintChoice)
        and (ChildModel.HeadRelaxationFactor = ChildEdit.HeadRelaxationFactor)
        and (ChildModel.FluxRelaxationFactor = ChildEdit.FluxRelaxationFactor)
        and (ChildModel.HeadClosureCriterion = ChildEdit.HeadClosureCriterion)
        and (ChildModel.FluxClosureCriterion = ChildEdit.FluxClosureCriterion)
        and ChildModel.Discretization.IsSame(ChildEdit.Discretization)
    end;
  end;

end;

procedure TChildModelItem.Loaded;
begin
  ChildModel.Loaded;
end;

procedure TChildModelItem.SetChildModel(const Value: TChildModel);
begin
  FChildModel.Assign(Value);
end;

{ TChildModel }

procedure TChildModel.AdjustCellPosition(AValueCell: TValueCell);
var
  Column: Integer;
  Row: Integer;
  Layer: Integer;
begin
  if ModelSelection in [msModflowLgr2, msModflowFmp, msModflowOwhm2] then
  begin
    Exit;
  end;
  Column := AValueCell.Column;
  Row := AValueCell.Row;
  Layer := AValueCell.Layer;
  AdjustCellPosition(Column, Row, Layer);
  AValueCell.Column := Column;
  AValueCell.Row := Row;
  AValueCell.Layer := Layer;
//
//  if AValueCell.Column = 0 then
//  begin
//    AValueCell.Column := 1;
//  end;
//  if AValueCell.Column = ModflowGrid.ColumnCount-1 then
//  begin
//    AValueCell.Column := ModflowGrid.ColumnCount-2;
//  end;
//  if AValueCell.Row = 0 then
//  begin
//    AValueCell.Row := 1;
//  end;
//  if AValueCell.Row = ModflowGrid.RowCount-1 then
//  begin
//    AValueCell.Row := ModflowGrid.RowCount-2;
//  end;
//  if AValueCell.Layer = ModflowGrid.LayerCount-1 then
//  begin
//    if (Discretization.BottomLayerGroup <> LayerStructure.Last)
//      or (Discretization.BottomLayerInUnit <> Discretization.BottomLayerGroup.LayerCount-1) then
//    begin
//      AValueCell.Layer := ModflowGrid.LayerCount-2
//    end;
//  end;
end;

procedure TChildModel.AdjustCellPosition(ACellAssignment: TCellAssignment);
var
  Column: Integer;
  Row: Integer;
  Layer: Integer;
begin
  Column := ACellAssignment.Column;
  Row := ACellAssignment.Row;
  Layer := ACellAssignment.Layer;
  AdjustCellPosition(Column, Row, Layer);
  ACellAssignment.Column := Column;
  ACellAssignment.Row := Row;
  ACellAssignment.Layer := Layer;
end;

procedure TChildModel.AdjustCellPosition(var Column, Row, Layer: integer);
begin
  if ModelSelection in [msModflowLgr2, msModflowFmp, msModflowOwhm2] then
  begin
    Exit;
  end;
  if Column = 0 then
  begin
    Column := 1;
  end;
  if Column = ModflowGrid.ColumnCount-1 then
  begin
    Column := ModflowGrid.ColumnCount-2;
  end;
  if Row = 0 then
  begin
    Row := 1;
  end;
  if Row = ModflowGrid.RowCount-1 then
  begin
    Row := ModflowGrid.RowCount-2;
  end;
  if Layer = ModflowGrid.LayerCount-1 then
  begin
    if (Discretization.BottomLayerGroup <> LayerStructure.Last)
      or (Discretization.BottomLayerInUnit <> Discretization.BottomLayerGroup.LayerCount-1) then
    begin
      Layer := ModflowGrid.LayerCount-2;
      if  Layer < 0 then
      begin
        Layer := 0;
      end;
    end;
  end;
end;

procedure TChildModel.AdjustDataArray(ADataArray: TDataArray);
var
  AnnotationList: TStringList;
  ColIndex: Integer;
  LayerIndex: Integer;
  NewAnnotation: string;
  AnnotationPosition: Integer;
  OuterCellArea: Real;
  InnerCellArea: Real;
  OuterGridIndex: Integer;
  InnerGridIndex: Integer;
  RowIndex: Integer;
begin
  if (ParentModel as TPhastModel).LgrV1Used then
  begin
    Assert(ADataArray.DataType in [rdtDouble, rdtBoolean]);
    Assert(ADataArray.ColumnCount >= 3);
    Assert(ADataArray.RowCount >= 3);
    AnnotationList := TStringList.Create;
    try
      AnnotationList.Sorted := True;
      for LayerIndex := 0 to ADataArray.LayerCount - 1 do
      begin
        for ColIndex := 0 to ADataArray.ColumnCount - 1 do
        begin
          OuterGridIndex := 0;
          InnerGridIndex := 1;
          if ADataArray.IsValue[LayerIndex, OuterGridIndex, ColIndex] then
          begin
            OuterCellArea := ModflowGrid.ColumnWidth[ColIndex]
              * ModflowGrid.RowWidth[OuterGridIndex];
            InnerCellArea := ModflowGrid.ColumnWidth[ColIndex]
              * ModflowGrid.RowWidth[InnerGridIndex];
            if ADataArray.IsValue[LayerIndex, InnerGridIndex, ColIndex] then
            begin
              NewAnnotation := 'Combined values for LGR: '
                + ADataArray.Annotation[LayerIndex, OuterGridIndex, ColIndex]
                + ', ' + ADataArray.Annotation[LayerIndex, InnerGridIndex, ColIndex];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation)
              end;
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.RealData[LayerIndex, InnerGridIndex, ColIndex]
                    + ADataArray.RealData[LayerIndex, OuterGridIndex, ColIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, InnerGridIndex, ColIndex] :=
                    ADataArray.BooleanData[LayerIndex, InnerGridIndex, ColIndex]
                    or ADataArray.BooleanData[LayerIndex, OuterGridIndex, ColIndex];
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, InnerGridIndex, ColIndex]
                := NewAnnotation;
            end
            else
            begin
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.RealData[LayerIndex, OuterGridIndex, ColIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.BooleanData[LayerIndex, OuterGridIndex, ColIndex];
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, InnerGridIndex, ColIndex] :=
                ADataArray.Annotation[LayerIndex, OuterGridIndex, ColIndex];
            end;
            case ADataArray.DataType of
              rdtDouble:
                ADataArray.RealData[LayerIndex, OuterGridIndex, ColIndex] := 0;
              rdtBoolean:
                ADataArray.BooleanData[LayerIndex, OuterGridIndex, ColIndex] := False;
              else Assert(False);
            end;
          end;

          OuterGridIndex := ADataArray.RowCount-1;
          InnerGridIndex := ADataArray.RowCount-2;
          if ADataArray.IsValue[LayerIndex, OuterGridIndex, ColIndex] then
          begin
            OuterCellArea := ModflowGrid.ColumnWidth[ColIndex]
              * ModflowGrid.RowWidth[OuterGridIndex];
            InnerCellArea := ModflowGrid.ColumnWidth[ColIndex]
              * ModflowGrid.RowWidth[InnerGridIndex];
            if ADataArray.IsValue[LayerIndex, InnerGridIndex, ColIndex] then
            begin
              NewAnnotation := 'Combined values for LGR: '
                + ADataArray.Annotation[LayerIndex, OuterGridIndex, ColIndex]
                + ', ' + ADataArray.Annotation[LayerIndex, InnerGridIndex, ColIndex];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation)
              end;
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.RealData[LayerIndex, InnerGridIndex, ColIndex]
                    + ADataArray.RealData[LayerIndex, OuterGridIndex, ColIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.BooleanData[LayerIndex, InnerGridIndex, ColIndex]
                    or ADataArray.BooleanData[LayerIndex, OuterGridIndex, ColIndex]
                else Assert(False);

              end;
              ADataArray.Annotation[LayerIndex, InnerGridIndex, ColIndex]
                := NewAnnotation;
            end
            else
            begin
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.RealData[LayerIndex, OuterGridIndex, ColIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, InnerGridIndex, ColIndex]
                    := ADataArray.BooleanData[LayerIndex, OuterGridIndex, ColIndex]
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, InnerGridIndex, ColIndex] :=
                ADataArray.Annotation[LayerIndex, OuterGridIndex, ColIndex];
            end;
            case ADataArray.DataType of
              rdtDouble:
                ADataArray.RealData[LayerIndex, OuterGridIndex, ColIndex] := 0;
              rdtBoolean:
                ADataArray.BooleanData[LayerIndex, OuterGridIndex, ColIndex] := False;
              else Assert(False);
            end;
          end;
        end;


        for RowIndex := 0 to ADataArray.RowCount - 1 do
        begin
          OuterGridIndex := 0;
          InnerGridIndex := 1;
          if ADataArray.IsValue[LayerIndex, RowIndex, OuterGridIndex] then
          begin
            OuterCellArea := ModflowGrid.ColumnWidth[OuterGridIndex]
              * ModflowGrid.RowWidth[RowIndex];
            InnerCellArea := ModflowGrid.ColumnWidth[InnerGridIndex]
              * ModflowGrid.RowWidth[RowIndex];
            if ADataArray.IsValue[LayerIndex, RowIndex, InnerGridIndex] then
            begin
              NewAnnotation := 'Combined values for LGR: '
                + ADataArray.Annotation[LayerIndex, RowIndex, OuterGridIndex]
                + ', ' + ADataArray.Annotation[LayerIndex, RowIndex, InnerGridIndex];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation)
              end;
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.RealData[LayerIndex, RowIndex, InnerGridIndex]
                    + ADataArray.RealData[LayerIndex, RowIndex, OuterGridIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.BooleanData[LayerIndex, RowIndex, InnerGridIndex]
                    or ADataArray.BooleanData[LayerIndex, RowIndex, OuterGridIndex]
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, RowIndex, InnerGridIndex]
                := NewAnnotation;
            end
            else
            begin
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.RealData[LayerIndex, RowIndex, OuterGridIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.BooleanData[LayerIndex, RowIndex, OuterGridIndex]
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, RowIndex, InnerGridIndex] :=
                ADataArray.Annotation[LayerIndex, RowIndex, OuterGridIndex];
            end;
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, RowIndex, OuterGridIndex] := 0;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, RowIndex, OuterGridIndex] := False;
                else Assert(False);
              end;
          end;

          OuterGridIndex := ADataArray.ColumnCount-1;
          InnerGridIndex := ADataArray.ColumnCount-2;
          if ADataArray.IsValue[LayerIndex, RowIndex, OuterGridIndex] then
          begin
            OuterCellArea := ModflowGrid.ColumnWidth[OuterGridIndex]
              * ModflowGrid.RowWidth[RowIndex];
            InnerCellArea := ModflowGrid.ColumnWidth[InnerGridIndex]
              * ModflowGrid.RowWidth[RowIndex];
            if ADataArray.IsValue[LayerIndex, RowIndex, InnerGridIndex] then
            begin
              NewAnnotation := 'Combined values for LGR: '
                + ADataArray.Annotation[LayerIndex, RowIndex, OuterGridIndex]
                + ', ' + ADataArray.Annotation[LayerIndex, RowIndex, InnerGridIndex];
              AnnotationPosition := AnnotationList.IndexOf(NewAnnotation);
              if AnnotationPosition >= 0 then
              begin
                NewAnnotation := AnnotationList[AnnotationPosition];
              end
              else
              begin
                AnnotationList.Add(NewAnnotation)
              end;
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.RealData[LayerIndex, RowIndex, InnerGridIndex]
                    + ADataArray.RealData[LayerIndex, RowIndex, OuterGridIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.BooleanData[LayerIndex, RowIndex, InnerGridIndex]
                    or ADataArray.BooleanData[LayerIndex, RowIndex, OuterGridIndex];
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, RowIndex, InnerGridIndex]
                := NewAnnotation;
            end
            else
            begin
              case ADataArray.DataType of
                rdtDouble:
                  ADataArray.RealData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.RealData[LayerIndex, RowIndex, OuterGridIndex]
                    * OuterCellArea / InnerCellArea;
                rdtBoolean:
                  ADataArray.BooleanData[LayerIndex, RowIndex, InnerGridIndex]
                    := ADataArray.BooleanData[LayerIndex, RowIndex, OuterGridIndex]
                else Assert(False);
              end;
              ADataArray.Annotation[LayerIndex, RowIndex, InnerGridIndex] :=
                ADataArray.Annotation[LayerIndex, RowIndex, OuterGridIndex];
            end;
            case ADataArray.DataType of
              rdtDouble:
                ADataArray.RealData[LayerIndex, RowIndex, OuterGridIndex] := 0;
              rdtBoolean:
                ADataArray.BooleanData[LayerIndex, RowIndex, OuterGridIndex] := False;
              else Assert(False);
            end;
          end;
        end
      end;
    finally
      AnnotationList.Free;
    end;
  end;
end;

procedure TChildModel.Assign(Source: TPersistent);
var
  SourceModel: TChildModel;
begin
  if Source is TChildModel then
  begin
    // When editing this section, be sure to edit TChildModelEdit
    // and TChildModelItem too
    SourceModel := TChildModel(Source);
    ModelName := SourceModel.ModelName;
    ChildCellsPerParentCell := SourceModel.ChildCellsPerParentCell;
    Discretization := SourceModel.Discretization;
    UpdateLayerCount;
    StartingHeadSource := SourceModel.StartingHeadSource;
//    OneWayCoupling := SourceModel.OneWayCoupling;
    CouplingMethod := SourceModel.CouplingMethod;
    MaxIterations := SourceModel.MaxIterations;
    LgrPrintChoice := SourceModel.LgrPrintChoice;
    HeadRelaxationFactor := SourceModel.HeadRelaxationFactor;
    FluxRelaxationFactor := SourceModel.FluxRelaxationFactor;
    HeadClosureCriterion := SourceModel.HeadClosureCriterion;
    FluxClosureCriterion := SourceModel.FluxClosureCriterion;
  end;
  inherited;
end;

function TChildDiscretizationCollection.GetAnItemByGroupAndLayer(
  LayerGroup: TLayerGroup; SubLayer: integer): TChildDiscretization;
var
  Index: Integer;
  Item: TChildDiscretization;
  PriorItem: TChildDiscretization;
begin
  Assert(LayerGroup.Index <> 0);
  result := nil;
  for Index := 0 to Count - 1 do
  begin
    Item := Items[Index] as TChildDiscretization;
    if (Item.LayerGroup = LayerGroup)
      and (Item.ParentLayerNumber = SubLayer) then
    begin
      result := Item;
      Exit;
    end;
  end;
  if result = nil then
  begin
    result := Add as TChildDiscretization;
    result.LayerGroup := LayerGroup;
    result.ParentLayerNumber := SubLayer;
    if SubLayer > 0 then
    begin
      PriorItem := GetAnItemByGroupAndLayer(LayerGroup, SubLayer-1);
      result.Discretization := PriorItem.Discretization;
    end;
  end;
end;

function TChildDiscretizationCollection.GetAnItemByLayer(
  Layer: integer): TChildDiscretization;
var
  Index: Integer;
  Item: TChildDiscretization;
  CumulativeLayers: integer;
begin
  result := nil;
  CumulativeLayers := 0;
  for Index := 0 to Count - 1 do
  begin
    Item := Items[Index] as TChildDiscretization;
    CumulativeLayers := CumulativeLayers + Item.Discretization;
    if CumulativeLayers > Layer then
    begin
      result := Item;
      Exit;
    end;
  end;
end;

procedure TChildDiscretizationCollection.SortAndDeleteExtraItems;
var
  Index: Integer;
  Item: TChildDiscretization;
  InnerIndex: Integer;
begin
  Sort;
  for Index := Count - 1 downto 0 do
  begin
    Item := Items[Index];
    if Item.LayerGroup = BottomLayerGroup then
    begin
      for InnerIndex := Index downto 0 do
      begin
        Item := Items[InnerIndex];
        if Item.ParentLayerNumber > BottomLayerInUnit then
        begin
          Delete(InnerIndex);
        end
        else
        begin
          break;
        end;
      end;
      break;
    end
    else
    begin
      Delete(Index);
    end;
  end;
end;

procedure TChildDiscretizationCollection.Update(Item: TCollectionItem);
begin
  inherited;
  if Item <> nil then
  begin
    FChanged := True;
  end;
  if (UpdateCount = 0) and FChanged then
  begin
    if Model <> nil then
    begin
      (Model as TChildModel).ModflowGrid.NotifyGridChanged(self);
    end;
  end;
end;

procedure TChildDiscretizationCollection.WriteLAYCB(
  const DiscretizationWriter: TObject);
var
  DisWriter: TModflowDiscretizationWriter;
  LocalModel: TChildModel;
  GroupIndex: Integer;
  LAYCB: array of integer;
  AGroup: TLayerGroup;
  DisIndex: Integer;
  LayerIndex: integer;
  DisItem: TChildDiscretization;
  SubIndex: Integer;
  Index: Integer;
begin
  LocalModel := Model as TChildModel;
  SetLength(LAYCB, ModflowLayerCount);
  LayerIndex := 0;
  for GroupIndex := 1 to LocalModel.LayerStructure.Count - 1 do
  begin
    AGroup := LocalModel.LayerStructure[GroupIndex];
    if AGroup.RunTimeSimulated then
    begin
      for DisIndex := 0 to AGroup.LayerCount - 1 do
      begin
        DisItem := GetAnItemByGroupAndLayer(AGroup,DisIndex);
        for SubIndex := 0 to DisItem.Discretization - 1 do
        begin
          if LayerIndex < Length(LAYCB) then
          begin
            LAYCB[LayerIndex] := 0;
          end;
          Inc(LayerIndex);
        end;
        if (AGroup = BottomLayerGroup)
          and (DisIndex = BottomLayerInUnit) then
        begin
          break;
        end;
      end;
    end
    else
    begin
      if LayerIndex-1 < Length(LAYCB) then
      begin
        LAYCB[LayerIndex-1] := 1;
      end;
    end;
    if (AGroup = BottomLayerGroup) then
    begin
      break;
    end;
  end;
  DisWriter := DiscretizationWriter as TModflowDiscretizationWriter;
  for Index := 0 to Length(LAYCB) - 1 do
  begin
    DisWriter.WriteInteger(LAYCB[Index]);
  end;
  DisWriter.WriteString(' # LAYCB');
  DisWriter.NewLine;
end;

function CompareChildDisItems(Item1, Item2: Pointer): Integer;
var
  Child1: TChildDiscretization;
  Child2: TChildDiscretization;
begin
  Child1 := Item1;
  Child2 := Item2;
  Assert(Child1.LayerGroup <> nil);
  Assert(Child2.LayerGroup <> nil);
  result := Child1.LayerGroup.Index - Child2.LayerGroup.Index;
  if result = 0 then
  begin
    result := Child1.ParentLayerNumber - Child2.ParentLayerNumber;
  end;
end;

procedure TChildDiscretizationCollection.Sort;
var
  ItemList: TList;
  Item: TChildDiscretization;
  Index: Integer;
begin
  ItemList := TList.Create;
  try
    ItemList.Capacity := Count;
    for Index := 0 to Count - 1 do
    begin
      ItemList.Add(Items[Index]);
    end;
    ItemList.Sort(CompareChildDisItems);
    for Index := 0 to ItemList.Count - 1 do
    begin
      Item := ItemList[Index];
      Item.Index := Index;
    end;
  finally
    ItemList.Free;
  end;
end;

function TChildDiscretizationCollection.GetBottomLayerGroup: TLayerGroup;
var
  Index: Integer;
  Group: TLayerGroup;
begin
  if (FBottomLayerGroup = nil) and (FBottomUnitName <> '') then
  begin
    for Index := 1 to frmGoPhast.PhastModel.LayerStructure.Count - 1 do
    begin
      Group := frmGoPhast.PhastModel.LayerStructure[Index];
      if Group.AquiferName = FBottomUnitName then
      begin
        FBottomLayerGroup := Group;
        break;
      end;
    end;
  end;
  result := FBottomLayerGroup;
end;

function TChildDiscretizationCollection.GetBottomUnitName: string;
begin
  if BottomLayerGroup <> nil then
  begin
    result := BottomLayerGroup.AquiferName;
  end
  else
  begin
    result := FBottomUnitName
  end;
end;

function TChildDiscretizationCollection.GetItem(
  Index: integer): TChildDiscretization;
begin
  result := inherited Items[Index] as TChildDiscretization;
end;

function TChildDiscretizationCollection.IsSame(
  AnOrderedCollection: TOrderedCollection): boolean;
var
  AnotherDis: TChildDiscretizationCollection;
begin
  result := AnOrderedCollection is TChildDiscretizationCollection;
  if result then
  begin
    AnotherDis := TChildDiscretizationCollection(AnOrderedCollection);
    result := inherited IsSame(AnOrderedCollection)
      and (BottomUnitName = AnotherDis.BottomUnitName)
      and (BottomLayerInUnit = AnotherDis.BottomLayerInUnit)
  end;
end;

procedure TChildDiscretizationCollection.Loaded;
var
  ItemIndex: Integer;
begin
  for ItemIndex := 0 to Count - 1 do
  begin
    Items[ItemIndex].Loaded;
  end;
  GetBottomLayerGroup;
end;

function TChildDiscretizationCollection.ModflowConfiningBedCount: integer;
var
  GroupIndex: Integer;
  LocalModel: TCustomModel;
  AGroup: TLayerGroup;
begin
  result := 0;
  LocalModel := Model as TCustomModel;
  for GroupIndex := 1 to LocalModel.LayerStructure.Count - 1 do
  begin
    AGroup := LocalModel.LayerStructure[GroupIndex];
    if AGroup = BottomLayerGroup then
    begin
      Exit;
    end;
    if not AGroup.RunTimeSimulated then
    begin
      Inc(result);
    end;
  end;
end;

function TChildDiscretizationCollection.ModflowLayerCount: integer;
var
  GroupIndex: Integer;
  LocalModel: TCustomModel;
  AGroup: TLayerGroup;
  DisItem: TChildDiscretization;
  DisIndex: Integer;
begin
  result := 0;
  LocalModel := Model as TCustomModel;
  for GroupIndex := 1 to LocalModel.LayerStructure.Count - 1 do
  begin
    AGroup := LocalModel.LayerStructure[GroupIndex];
    if AGroup.RunTimeSimulated then
    begin
      for DisIndex := 0 to AGroup.LayerCount - 1 do
      begin
        DisItem := GetAnItemByGroupAndLayer(AGroup, DisIndex);
        result := result + DisItem.Discretization;
        if (AGroup = BottomLayerGroup) and (DisIndex = BottomLayerInUnit) then
        begin
          if (GroupIndex <> LocalModel.LayerStructure.Count - 1)
            or (DisIndex <> AGroup.LayerCount - 1) then
          begin
            if LocalModel.ModelSelection in [msModflowLGR] then
            begin
              result := result - DisItem.Discretization div 2;
            end;
          end;
          Exit;
        end;
      end;
    end;
  end;
end;

function TChildModel.CfpIsSelected: Boolean;
begin
  result := False;
end;

function TChildModel.Chani: TOneDIntegerArray;
begin
  Result := ConvertIntegerParentArray(inherited Chani);
end;

function TChildModel.ChildColToParentCol(ACol: integer): integer;
begin
  result := -1;
  if (ACol < 0) or (ACol >= Grid.ColumnCount) then
  begin
    Exit;
  end
  else
  begin
    case ModelSelection of
      msModflowLGR:
        result := ((ACol + (ChildCellsPerParentCell div 2))
           div ChildCellsPerParentCell) + FFirstCol;
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result := (ACol div ChildCellsPerParentCell) + FFirstCol;
      else
        Assert(False);
    end;
  end;
end;

function TChildModel.ChildLayerToParentLayer(ALayer: integer): integer;
var
  CumulativeLayers: Integer;
  LayerGroupIndex: Integer;
  LayerGroup: TLayerGroup;
  DisIndex: Integer;
  DisItem: TChildDiscretization;
begin
  if (ALayer < 0) or (ALayer >= Grid.LayerCount) then
  begin
    result := -1;
  end
  else
  begin
    result := -1;
    CumulativeLayers := -1;

    for LayerGroupIndex := 1 to LayerStructure.Count - 1 do
    begin
      LayerGroup := LayerStructure[LayerGroupIndex];
      for DisIndex := 0 to LayerGroup.LayerCount - 1 do
      begin
        DisItem := Discretization.GetAnItemByGroupAndLayer(LayerGroup,DisIndex);
        CumulativeLayers := CumulativeLayers + DisItem.Discretization;
        Inc(result);
        if CumulativeLayers >= ALayer then
        begin
          Exit;
        end;
        if (Discretization.BottomLayerGroup = LayerGroup)
          and (Discretization.BottomLayerInUnit = DisIndex) then
        begin
          break;
        end;
      end;
      if (Discretization.BottomLayerGroup = LayerGroup) then
      begin
        Break;
      end;
    end;
    Assert(False);

    // The bottom bottom parent layer may have fewer layers
    // than indicated by Discretization[LayerIndex].Discretization.
    // That doesn't matter because cases where it might matter
    // are caught by ALayer >= Grid.LayerCount.
//    for LayerIndex := 0 to Discretization.Count - 1 do
//    begin
//      CumulativeLayers := CumulativeLayers
//        + Discretization[LayerIndex].Discretization;
//      if ALayer < CumulativeLayers  then
//      begin
//        result := LayerIndex;
//        Exit;
//      end;
//    end;
//    Assert(False);
  end;
end;

function TChildModel.ChildRowToParentRow(ARow: integer): integer;
begin
  result := -1;
  if (ARow < 0) or (ARow >= Grid.RowCount) then
  begin
    Exit;
  end
  else
  begin
    case ModelSelection of
      msModflowLGR:
        result := ((ARow + (ChildCellsPerParentCell div 2))
           div ChildCellsPerParentCell) + FFirstRow;
      msModflowLGR2, msModflowFmp , msModflowOwhm2:
        result := (ARow div ChildCellsPerParentCell) + FFirstRow;
      else
        Assert(False);
    end;
  end;
end;

function TChildModel.Child_NameFile_Name(const Parent_NameFile_Name: string): string;
var
  Directory: string;
begin
  Directory := ExtractFileDir(Parent_NameFile_Name);
  result := ExtractFileName(Parent_NameFile_Name);
  result := ChangeFileExt(result, '');
  result := result + '_' + ModelName;
  result := FixFileName(result);
  result := ChangeFileExt(result, '.nam');
  result := IncludeTrailingPathDelimiter(Directory) + result;
end;

constructor TChildModel.Create(AnOwner: TComponent);
var
  DataArrayIndex: Integer;
  ParentDataArray: TDataArray;
  ChildDataArray: TDataArray;
  ChildArrays: TList;
  ParentArrays: TList;
  ParamIndex: Integer;
  AParam: TModflowTransientListParameter;
begin
  FCreating := True;
  inherited Create(nil);
  FStartingHeadSource := shsSelf;
  FMaxIterations := 20;
  FLgrPrintChoice := lpcListing;
  FFluxRelaxationFactor := 0.5;
  FHeadRelaxationFactor := 0.5;
  FHeadClosureCriterion := 5E-3;
  FFluxClosureCriterion := 5E-2;
  FFirstCol := -1;
  FLastCol := -1;
  FFirstRow := -1;
  FLastRow := -1;
  FParentModel := AnOwner as TCustomModel;
  FChildCellsPerParentCell := 3;
  FDiscretization := TChildDiscretizationCollection.Create(self);

  if (ParentModel  <> nil) then
  begin
    ChildArrays := TList.Create;
    ParentArrays := TList.Create;
    try
      for DataArrayIndex := 0 to ParentModel.DataArrayManager.DataSetCount - 1 do
      begin
        ParentDataArray := ParentModel.DataArrayManager.DataSets[DataArrayIndex];
        ChildDataArray := TDataArrayType(ParentDataArray.ClassType).Create(self);
        ChildDataArray.AssignProperties(ParentDataArray);
        DataArrayManager.AddDataSet(ChildDataArray);
        CreateVariables(ChildDataArray);
        ParentArrays.Add(ParentDataArray);
        ChildArrays.Add(ChildDataArray);
        ParentDataArray.TalksTo(ChildDataArray);
      end;
      ModelSelection := ParentModel.ModelSelection;
      for DataArrayIndex := 0 to ChildArrays.Count - 1 do
      begin
        ChildDataArray := ChildArrays[DataArrayIndex];
        ParentDataArray := ParentArrays[DataArrayIndex];
        ChildDataArray.Formula := ParentDataArray.Formula;
      end;

      for ParamIndex := 0 to ParentModel.ModflowTransientParameters.Count - 1 do
      begin
        AParam := ParentModel.ModflowTransientParameters[ParamIndex];
        AParam.NewChildModelCreated(self);
      end;

      ModflowGrid.OnSelectedColumnChange :=
        ParentModel.ModflowGrid.OnSelectedColumnChange;
      ModflowGrid.OnSelectedRowChange :=
        ParentModel.ModflowGrid.OnSelectedRowChange;
      ModflowGrid.OnSelectedLayerChange :=
        ParentModel.ModflowGrid.OnSelectedLayerChange;
    finally
      ParentArrays.Free;
      ChildArrays.Free;
    end;
  end;
  FCanUpdateGrid := True;
  FCreating := False;
end;

function TChildModel.DataSetLayerToModflowLayer(DataSetLayer: integer): integer;
var
  Index: Integer;
begin
  result := 0;
  for Index := 0 to DataSetLayer do
  begin
    if IsLayerSimulated(Index) then
    begin
      Inc(result);
    end;
  end;
end;

function TChildModel.DefaultModflowOutputFileName: string;
var
  Extension: string;
begin
  GetDefaultOutputFileExtension(Extension);
  if Extension = '' then
  begin
    result := '';
    Exit;
  end;
  result := ChangeFileExt(Child_NameFile_Name(ModelFileName), Extension);
  result := FixFileName(result);
end;

procedure TChildModel.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('HeadRelaxationFactor', ReadHeadRelaxationFactor,
    WriteHeadRelaxationFactor, FHeadRelaxationFactor = 0);
  Filer.DefineProperty('FluxRelaxationFactor', ReadFluxRelaxationFactor,
    WriteFluxRelaxationFactor, FFluxRelaxationFactor = 0);
  Filer.DefineProperty('HeadClosureCriterion', ReadHeadClosureCriterion,
    WriteHeadClosureCriterion, FHeadClosureCriterion = 0);
  Filer.DefineProperty('FluxClosureCriterion', ReadFluxClosureCriterion,
    WriteFluxClosureCriterion, FFluxClosureCriterion = 0);
end;

destructor TChildModel.Destroy;
var
  ParamIndex: Integer;
  AParam: TModflowTransientListParameter;
  ScreenObjectIndex: integer;
begin

  AllObserversStopTalking;
  DataArrayManager.UnlinkDeletedDataSets;
  if FParentModel <> nil then
  begin
    for ParamIndex := 0 to ParentModel.ModflowTransientParameters.Count - 1 do
    begin
      AParam := ParentModel.ModflowTransientParameters[ParamIndex];
      AParam.ChildModelBeingDestroyed(self);
    end;
    FParentModel.TopGridObserver.StopsTalkingTo(TopGridObserver);
    FParentModel.ThreeDGridObserver.StopsTalkingTo(ThreeDGridObserver);
    FParentModel.HufKxNotifier.StopsTalkingTo(HufKxNotifier);
    FParentModel.HufKyNotifier.StopsTalkingTo(HufKyNotifier);
    FParentModel.HufKzNotifier.StopsTalkingTo(HufKzNotifier);
    FParentModel.HufSsNotifier.StopsTalkingTo(HufSsNotifier);
    FParentModel.HufSyNotifier.StopsTalkingTo(HufSyNotifier);
    for ScreenObjectIndex := 0 to ScreenObjectCount - 1 do
    begin
      ScreenObjects[ScreenObjectIndex].RemoveModelLink(self);
    end;
  end;
  FClearing := True;
  try
    InternalClear;
  finally
    FClearing := False;
  end;
  HorizontalPositionScreenObject := nil;
  FreeHufNotifiers;
  FreeGridNotifiers;
  FModelName := '';
  FDiscretization.Free;

  inherited;
end;

function TChildModel.DMCOEF: TOneDRealArray;
begin
  Result := ConvertRealParentArray(inherited DMCOEF);
end;

function TChildModel.EdgeIndex: integer;
var
  PhastModel: TPhastModel;
  ChildIndex: Integer;
  ChildModel: TChildModel;
begin
  PhastModel := ParentModel as TPhastModel;
  result := 0;
  for ChildIndex := 0 to PhastModel.ChildModels.Count - 1 do
  begin
    ChildModel := PhastModel.ChildModels[ChildIndex].ChildModel;
    if ChildModel = self then
    begin
      result := ChildIndex +2;
      if ModelSelection in [msModflowLGR] then
      begin
        result := -result;
      end;
      Exit;
    end;
  end;
  Assert(False);
end;

function TChildModel.FirstOverlappedLayer: integer;
var
  DisIndex: Integer;
  EndLayer: Integer;
  Group: TLayerGroup;
  GroupIndex: Integer;
  PriorItem: TChildDiscretization;
  Item: TChildDiscretization;
  NewItems: boolean;
begin
  result := 0;
  NewItems := False;
  for GroupIndex := 1 to LayerStructure.Count - 1 do
  begin
    Group := LayerStructure[GroupIndex];
    if Group.RunTimeSimulated then
    begin
      if Group = Discretization.BottomLayerGroup then
      begin
        EndLayer := Discretization.BottomLayerInUnit;
      end
      else
      begin
        EndLayer := Group.LayerCount - 1;
      end;
      for DisIndex := 0 to EndLayer do
      begin
        Item := Discretization.GetAnItemByGroupAndLayer(Group, DisIndex);
        if Item = nil then
        begin
          Item := Discretization.Add as TChildDiscretization;
          Item.LayerGroup := Group;
          Item.ParentLayerNumber := DisIndex;
          if DisIndex > 0 then
          begin
            PriorItem := Discretization.GetAnItemByGroupAndLayer(Group, DisIndex - 1);
            Item.Discretization := PriorItem.Discretization;
          end;
          NewItems := True;
        end;
        if (Group = Discretization.BottomLayerGroup)
          and (DisIndex = EndLayer)
          and ((GroupIndex <> LayerStructure.Count - 1)
          or (EndLayer <> Group.LayerCount - 1)) then
        begin
//          Inc(result, (Item.Discretization div 2)+1);
        end
        else
        begin
          Inc(result, Item.Discretization);
        end;
      end;
      if Group = Discretization.BottomLayerGroup then
      begin
        break;
      end
    end
    else
    begin
      Inc(result);
    end;
  end;
  if NewItems then
  begin
    Discretization.SortAndDeleteExtraItems;
  end;
end;

function TChildModel.GetAppsMoved: TStringList;
begin
  result := ParentModel.GetAppsMoved;
end;

function TChildModel.GetChemistryOptions: TChemistryOptions;
begin
  result := ParentModel.GetChemistryOptions;
end;

function TChildModel.GetContourFont: TFont;
begin
  result := ParentModel.GetContourFont;
end;

function TChildModel.GetContourLabelSpacing: Integer;
begin
  result := ParentModel.GetContourLabelSpacing;
end;

function TChildModel.GetContourLegend: TLegend;
begin
  result := ParentModel.GetContourLegend;
end;

function TChildModel.GetCtsSystems: TCtsSystemCollection;
begin
  if ParentModel <> nil then
  begin
    result := ParentModel.CtsSystems;
  end
  else
  begin
    result := nil;
  end;
end;

function TChildModel.GetDisplayName: string;
begin
  result := ModelName;
end;

function TChildModel.GetFarms: TFarmCollection;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetFarms;
  end;
end;

function TChildModel.GetFilesToDelete: TStrings;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.FilesToDelete;
  end;
end;

function TChildModel.GetFmpAllotment: TAllotmentCollection;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetFmpAllotment;
  end;
end;

function TChildModel.GetFmpClimate: TClimateCollection;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetFmpClimate;
  end;
end;

function TChildModel.GetFmpCrops: TCropCollection;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetFmpCrops;
  end;
end;

function TChildModel.GetFmpSoils: TSoilCollection;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetFmpSoils;
  end;
end;

function TChildModel.GetFootprintProperties: TFootprintProperties;
begin
  if ParentModel <> nil then
  begin
    result := ParentModel.FootprintProperties
  end
  else
  begin
    result := nil;
  end;
end;

function TChildModel.GetFormulaManager: TFormulaManager;
begin
  result := ParentModel.GetFormulaManager;
end;

function TChildModel.GetFreeSurface: boolean;
begin
  result := ParentModel.GetFreeSurface;
end;

function TChildModel.GetGeoRef: TGeoRef;
begin
  result := ParentModel.GeoRef;
end;

function TChildModel.GetGlobalVariables: TGlobalVariables;
begin
  if ParentModel = nil then
  begin
    result := nil;
  end
  else
  begin
    result := ParentModel.GetGlobalVariables;
  end;
end;

function TChildModel.GetGlobalVariablesI: IGlobalVariables;
begin
  if ParentModel = nil then
  begin
    result := nil;
  end
  else
  begin
    result := ParentModel.GetGlobalVariablesI;
  end;
end;

function TChildModel.GetHufParameters: THufModflowParameters;
begin
  result := ParentModel.GetHufParameters;
end;

function TChildModel.GetImmobileComponents: TChemSpeciesCollection;
begin
  if ParentModel = nil then
  begin
    result := nil;
  end
  else
  begin
    result := ParentModel.GetImmobileComponents;
  end;
end;

function TChildModel.GetIrrigationTypes: TIrrigationCollection;
begin
  result := ParentModel.GetIrrigationTypes;
end;

function TChildModel.GetLayerGroupByLayer(const Layer: integer): TLayerGroup;
begin
  result := inherited GetLayerGroupByLayer(ChildLayerToParentLayer(Layer));
end;

function TChildModel.GetLayerStructure: TLayerStructure;
begin
  if ParentModel = nil then
  begin
    result := nil;
  end
  else
  begin
    result := ParentModel.GetLayerStructure;
  end;
end;

function TChildModel.GetLinkedRasters: TLinkedRasterCollection;
begin
  result := ParentModel.LinkedRasters;
end;

function TChildModel.GetMobileComponents: TMobileChemSpeciesCollection;
begin
  if ParentModel = nil then
  begin
    result := nil;
  end
  else
  begin
    result := ParentModel.GetMobileComponents;
  end;
end;

function TChildModel.GetModelSelection: TModelSelection;
begin
  if ParentModel = nil then
  begin
    result := msUndefined;
  end
  else
  begin
    result := ParentModel.GetModelSelection;
  end;
end;

function TChildModel.GetModflowFullStressPeriods: TModflowStressPeriods;
begin
  result := ParentModel.GetModflowFullStressPeriods;
end;

function TChildModel.GetModflowOutputControl: TModflowOutputControl;
begin
  result := ParentModel.GetModflowOutputControl;
end;

function TChildModel.GetModflowSteadyParameters: TModflowSteadyParameters;
begin
  result := ParentModel.GetModflowSteadyParameters;
end;

function TChildModel.GetModflowStressPeriods: TModflowStressPeriods;
begin
  result := ParentModel.GetModflowStressPeriods;
end;

function TChildModel.GetModflowTransientParameters: TModflowTransientListParameters;
begin
  result := ParentModel.GetModflowTransientParameters;
end;

function TChildModel.GetMt3dmsOutputControl: TMt3dmsOutputControl;
begin
  result := ParentModel.GetMt3dmsOutputControl;
end;

function TChildModel.GetMt3dmsTimes: TMt3dmsTimeCollection;
begin
  result := ParentModel.GetMt3dmsTimes
end;

function TChildModel.GetObservationPurpose: TObservationPurpose;
begin
  result := ParentModel.GetObservationPurpose;
end;

function TChildModel.GetParamGroups: TPestParamGroups;
begin
  if ParentModel <> nil then
  begin
    result := ParentModel.ParamGroups;
  end
  else
  begin
    result := nil;
  end;
end;

function TChildModel.GetParentModel: TCustomModel;
begin
  result := FParentModel
end;

function TChildModel.GetPestProperties: TPestProperties;
begin
  result := ParentModel.PestProperties;
end;

function TChildModel.GetProgramLocations: TProgramLocations;
begin
  result := ParentModel.GetProgramLocations;
end;

procedure TChildModel.GetRowColPositions(const StartPosition,
  EndPosition: integer; const ParentPositions: TOneDRealArray;
  out ChildPostions: TOneDRealArray);
var
  NewLength: Integer;
  ParentIndex: Integer;
  PositionIndex: Integer;
  ChildIndex: Integer;
  Start: Double;
  Delta: Double;
  StartParentIndex: Integer;
  EndParentIndex: Integer;
begin
  if (Length(ParentPositions) = 0) then
  begin
    SetLength(ChildPostions, 0);
    Exit;
  end;
  Assert(0 <= StartPosition);
  Assert(StartPosition < EndPosition);
  Assert(EndPosition+1 < Length(ParentPositions));
  case ModelSelection of
    msModflowLGR:
      NewLength := (EndPosition - StartPosition)*ChildCellsPerParentCell + 2;
    msModflowLGR2, msModflowFmp, msModflowOwhm2:
      NewLength := (EndPosition - StartPosition + 1)*ChildCellsPerParentCell+1;
    else
      begin
        NewLength := 0
      end;
  end;
  SetLength(ChildPostions, NewLength);
  PositionIndex := 0;

  Start := ParentPositions[StartPosition];
  Delta := ParentPositions[StartPosition+1] - Start;

//  case ModelSelection of
//    msModflowLGR:
//    msModflowLGR2:
//      ChildPostions[PositionIndex] := Start;
//    else
//      Assert(False);
//  end;

  if ModelSelection in [msModflowLGR] then
  begin
    ChildPostions[PositionIndex] := (Start + ParentPositions[StartPosition+1])/2;
    Inc(PositionIndex);
    for ChildIndex := (ChildCellsPerParentCell div 2) + 1 to ChildCellsPerParentCell - 1 do
    begin
      ChildPostions[PositionIndex] := Start + ChildIndex*Delta/ChildCellsPerParentCell;
      Inc(PositionIndex);
    end;
  end;

  StartParentIndex := 0;
  EndParentIndex := -1;
  case ModelSelection of
    msModflowLGR:
      begin
        StartParentIndex := StartPosition+1;
        EndParentIndex := EndPosition-1;
      end;
    msModflowLGR2, msModflowFmp, msModflowOwhm2:
      begin
        StartParentIndex := StartPosition;
        EndParentIndex := EndPosition;
      end;
    else
      Assert(False);
  end;

  for ParentIndex := StartParentIndex to EndParentIndex do
  begin
    Start := ParentPositions[ParentIndex];
    Delta := ParentPositions[ParentIndex+1] - Start;
    for ChildIndex := 0 to ChildCellsPerParentCell - 1 do
    begin
      ChildPostions[PositionIndex] := Start + ChildIndex*Delta/ChildCellsPerParentCell;
      Inc(PositionIndex);
    end;
  end;

  case ModelSelection of
    msModflowLGR:
      begin
        Start := ParentPositions[EndPosition];
        Delta := ParentPositions[EndPosition+1] - Start;

        for ChildIndex := 0 to (ChildCellsPerParentCell div 2) do
        begin
          ChildPostions[PositionIndex] := Start
            + ChildIndex*Delta/ChildCellsPerParentCell;
          Inc(PositionIndex);
        end;

        ChildPostions[PositionIndex] :=
          (Start + ParentPositions[EndPosition+1])/2;
        Inc(PositionIndex);
      end;
    msModflowLGR2, msModflowFmp, msModflowOwhm2:
      begin
        ChildPostions[PositionIndex] := ParentPositions[EndPosition+1];
        Inc(PositionIndex);
      end;
    else
      Assert(False);
  end;

  Assert(PositionIndex = NewLength);
end;

function TChildModel.GetSaveBfhBoundaryConditions: boolean;
begin
  result := ParentModel.SaveBfhBoundaryConditions;
end;

function TChildModel.GetScreenObjectByName(AName: string): TScreenObject;
begin
  result := ParentModel.GetScreenObjectByName(AName);
end;

function TChildModel.GetScreenObjectCount: integer;
begin
  if ParentModel = nil then
  begin
    result := 0;
  end
  else
  begin
    result := ParentModel.GetScreenObjectCount;
  end;
end;

function TChildModel.GetScreenObjects(const Index: integer): TScreenObject;
begin
  result := ParentModel.GetScreenObjects(Index);
end;

function TChildModel.GetSelectedModel: TCustomModel;
begin
  result := ParentModel.SelectedModel;
end;

function TChildModel.GetSfrMf6StreamLinkPlot: TSfrStreamLinkPlot;
begin
  result := ParentModel.GetSfrMf6StreamLinkPlot
end;

function TChildModel.GetSfrStreamLinkPlot: TSfrStreamLinkPlot;
begin
  result := ParentModel.GetSfrStreamLinkPlot
end;

function TChildModel.GetShowContourLabels: boolean;
begin
  result := ParentModel.GetShowContourLabels;
end;

function TChildModel.GetSoluteTransport: boolean;
begin
  result := ParentModel.GetSoluteTransport
end;

function TChildModel.GetSomeSegmentsUpToDate: boolean;
begin
  result := FParentModel.SomeSegmentsUpToDate;
end;

function TChildModel.GetStrStreamLinkPlot: TSfrStreamLinkPlot;
begin
  result := ParentModel.GetStrStreamLinkPlot
end;

function TChildModel.GetSwrReachConnectionsPlot: TSwrReachConnectionsPlot;
begin
  result := ParentModel.GetSwrReachConnectionsPlot
end;

function TChildModel.GetMf6TimesSeries: TTimesSeriesCollections;
begin
  result := nil;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetMf6TimesSeries
  end
end;

function TChildModel.GetUseGsflowFormat: boolean;
begin
  result := False;
  if ParentModel <> nil then
  begin
    result := ParentModel.GetUseGsflowFormat
  end
end;

function TChildModel.GetUseWaterTable: boolean;
begin
  result := ParentModel.GetUseWaterTable
end;

procedure TChildModel.DoInvalidate(Sender: TObject);
begin
  inherited;
  if ParentModel <> nil then
  begin
  { TODO -cRefactor : Consider replacing ParentModel with a TNotifyEvent. }
    ParentModel.DoInvalidate(Sender);
  end;
end;

function TChildModel.IsLayerConfined(const LayerID: integer): boolean;
begin
  result := inherited IsLayerConfined(ChildLayerToParentLayer(LayerID));
end;

function TChildModel.IsLayerSimulated(const LayerID: integer): boolean;
begin
  result := inherited IsLayerSimulated(ChildLayerToParentLayer(LayerID));
end;

procedure TChildDiscretizationCollection.SetBottomLayerGroup(const Value: TLayerGroup);
begin
  BeginUpdate;
  try
    if FBottomLayerGroup <> Value then
    begin
      FBottomLayerGroup := Value;
      FChanged := True;
      InvalidateModel;
    end;
    if BottomLayerGroup <> nil then
    begin
      FBottomUnitName := BottomLayerGroup.AquiferName;
    end;
  finally
    EndUpdate;
  end;
end;

procedure TChildDiscretizationCollection.SetBottomLayerInUnit(const Value: integer);
begin
  if FBottomLayerInUnit <> Value then
  begin
    BeginUpdate;
    try
      FBottomLayerInUnit := Value;
      FChanged := True;
      InvalidateModel;
    finally
      EndUpdate;
    end;
  end;
end;

procedure TChildDiscretizationCollection.SetBottomUnitName(const Value: string);
begin
  if FBottomUnitName <> Value then
  begin
    BeginUpdate;
    try
      FBottomUnitName := Value;
      FChanged := True;
      InvalidateModel;
      // upate FBottomLayerGroup;
      GetBottomLayerGroup;
    finally
      EndUpdate
    end;
  end;
end;

procedure TChildDiscretizationCollection.SetItem(Index: integer;
  const Value: TChildDiscretization);
begin
  inherited Items[Index] := Value;
end;

procedure TChildModel.SetCanUpdateGrid(const Value: Boolean);
begin
  FCanUpdateGrid := Value;
  if FCanUpdateGrid and FShouldUpdateGrid then
  begin
    UpdateGrid;
  end;
end;

procedure TChildModel.SetChemistryOptions(const Value: TChemistryOptions);
begin
  ParentModel.SetChemistryOptions(Value);
end;

procedure TChildModel.SetChildCellsPerParentCell(const Value: integer);
begin
  if ModelSelection in [msModflowLGR] then
  begin
    Assert(Odd(Value));
  end;
  if FChildCellsPerParentCell <> Value then
  begin
    FChildCellsPerParentCell := Value;
    UpdateGrid;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetContourFont(const Value: TFont);
begin
  ParentModel.ContourFont := Value;
end;

procedure TChildModel.SetContourLabelSpacing(const Value: Integer);
begin
  ParentModel.SetContourLabelSpacing(Value);
end;

procedure TChildModel.SetCouplingMethod(const Value: TCouplingMethod);
begin
  if FCouplingMethod <> Value then
  begin
    FCouplingMethod := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetCtsSystems(const Value: TCtsSystemCollection);
begin
  ParentModel.CtsSystems := Value;
end;

procedure TChildModel.SetDiscretization(
  const Value: TChildDiscretizationCollection);
begin
  FDiscretization.Assign(Value);
end;

procedure TChildModel.SetFarms(const Value: TFarmCollection);
begin
  ParentModel.SetFarms(Value);
end;

procedure TChildModel.SetFluxClosureCriterion(const Value: double);
begin
  if FFluxClosureCriterion <> Value then
  begin
    FFluxClosureCriterion := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetFluxRelaxationFactor(const Value: double);
begin
  if FFluxRelaxationFactor <> Value then
  begin
    FFluxRelaxationFactor := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetFmpAllotment(const Value: TAllotmentCollection);
begin
  ParentModel.SetFmpAllotment(Value);
end;

procedure TChildModel.SetFmpClimate(const Value: TClimateCollection);
begin
  ParentModel.SetFmpClimate(Value);
end;

procedure TChildModel.SetFmpCrops(const Value: TCropCollection);
begin
  ParentModel.SetFmpCrops(Value);
end;

procedure TChildModel.SetFmpSoils(const Value: TSoilCollection);
begin
  ParentModel.SetFmpSoils(Value);
end;

procedure TChildModel.SetFootprintProperties(const Value: TFootprintProperties);
begin
  ParentModel.FootprintProperties := Value;
end;

procedure TChildModel.SetFreeSurface(const Value: boolean);
begin
  ParentModel.SetFreeSurface(Value);
end;

procedure TChildModel.SetGeoRef(const Value: TGeoRef);
begin
  ParentModel.GeoRef := Value;
end;

procedure TChildModel.SetGlobalVariables(const Value: TGlobalVariables);
begin
  // do nothing
end;

procedure TChildModel.SetGlobalVariablesI(const Value: IGlobalVariables);
begin
  // do nothing
end;

procedure TChildModel.SetHeadClosureCriterion(const Value: double);
begin
  if FHeadClosureCriterion <> Value then
  begin
    FHeadClosureCriterion := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetHeadRelaxationFactor(const Value: double);
begin
  if FHeadRelaxationFactor <> Value then
  begin
    FHeadRelaxationFactor := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetHorizontalPositionScreenObject(
  const Value: TScreenObject);
begin
  if FHorizontalPositionScreenObject <> Value then
  begin
    if FHorizontalPositionScreenObject <> nil then
    begin
      FHorizontalPositionScreenObject.ChildModel := nil;
    end;
    FHorizontalPositionScreenObject := Value;
    if (FHorizontalPositionScreenObject <> nil)
      and (FHorizontalPositionScreenObject.ChildModel <> self) then
    begin
      FHorizontalPositionScreenObject.ChildModel := self;
    end;
    UpdateGrid;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetHufParameters(const Value: THufModflowParameters);
begin
  ParentModel.SetHufParameters(Value);
end;

procedure TChildModel.SetImmobileComponents(
  const Value: TChemSpeciesCollection);
begin
  ParentModel.SetImmobileComponents(Value);
end;

procedure TChildModel.SetIrrigationTypes(const Value: TIrrigationCollection);
begin
  ParentModel.SetIrrigationTypes(Value);
end;

procedure TChildModel.SetLayerStructure(const Value: TLayerStructure);
begin
  ParentModel.SetLayerStructure(Value);
end;

procedure TChildModel.SetLgrPrintChoice(const Value: TLgrPrintChoice);
begin
  if FLgrPrintChoice <> Value then
  begin
    FLgrPrintChoice := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetLinkedRasters(const Value: TLinkedRasterCollection);
begin
  ParentModel.LinkedRasters := Value;
end;

procedure TChildModel.SetMaxIterations(const Value: integer);
begin
  if FMaxIterations <> Value then
  begin
    FMaxIterations := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetMobileComponents(
  const Value: TMobileChemSpeciesCollection);
begin
  ParentModel.SetMobileComponents(Value);
end;

procedure TChildModel.SetModelName(const Value: string);
begin
  if FModelName <> Value then
  begin
    FModelName := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetModflowOutputControl(
  const Value: TModflowOutputControl);
begin
  ParentModel.SetModflowOutputControl(Value);
end;

procedure TChildModel.SetModflowSteadyParameters(
  const Value: TModflowSteadyParameters);
begin
  ParentModel.SetModflowSteadyParameters(Value);
end;

procedure TChildModel.SetModflowStressPeriods(
  const Value: TModflowStressPeriods);
begin
  ParentModel.SetModflowStressPeriods(Value);
end;

procedure TChildModel.SetModflowTransientParameters(
  const Value: TModflowTransientListParameters);
begin
  ParentModel.SetModflowTransientParameters(Value);
end;

procedure TChildModel.SetMt3dmsOutputControl(const Value: TMt3dmsOutputControl);
begin
  ParentModel.SetMt3dmsOutputControl(Value);
end;

procedure TChildModel.SetMt3dmsTimes(const Value: TMt3dmsTimeCollection);
begin
  ParentModel.SetMt3dmsTimes(Value);
end;

procedure TChildModel.SetObservationPurpose(const Value: TObservationPurpose);
begin
  ParentModel.SetObservationPurpose(Value);
end;

procedure TChildModel.SetParamGroups(const Value: TPestParamGroups);
begin

end;

procedure TChildModel.SetPestProperties(const Value: TPestProperties);
begin
  ParentModel.PestProperties := Value;
end;

procedure TChildModel.SetProgramLocations(const Value: TProgramLocations);
begin
  ParentModel.SetProgramLocations(Value);
end;

procedure TChildModel.SetSaveBfhBoundaryConditions(const Value: boolean);
begin
  ParentModel.SaveBfhBoundaryConditions := Value;
end;

procedure TChildModel.SetSelectedModel(const Value: TCustomModel);
begin
  ParentModel.SelectedModel := Value;
end;

procedure TChildModel.SetSfrMf6StreamLinkPlot(const Value: TSfrStreamLinkPlot);
begin
  ParentModel.SetSfrMf6StreamLinkPlot(Value);
end;

procedure TChildModel.SetSfrStreamLinkPlot(const Value: TSfrStreamLinkPlot);
begin
  ParentModel.SetSfrStreamLinkPlot(Value);
end;

procedure TChildModel.SetShowContourLabels(const Value: boolean);
begin
  ParentModel.ShowContourLabels := Value;
end;

procedure TChildModel.SetSoluteTransport(const Value: boolean);
begin
  ParentModel.SetSoluteTransport(Value);
end;

procedure TChildModel.SetSomeSegmentsUpToDate(const Value: boolean);
begin
  FParentModel.SomeSegmentsUpToDate := Value;
end;

procedure TChildModel.SetStartingHeadSource(const Value: TStartingHeadSource);
begin
  if FStartingHeadSource <> Value then
  begin
    FStartingHeadSource := Value;
    DoInvalidate(self);
  end;
end;

procedure TChildModel.SetStrStreamLinkPlot(const Value: TSfrStreamLinkPlot);
begin
  ParentModel.SetStrStreamLinkPlot(Value);
end;

procedure TChildModel.SetSwrReachConnectionsPlot(
  const Value: TSwrReachConnectionsPlot);
begin
  ParentModel.SetSwrReachConnectionsPlot(Value);
end;

procedure TChildModel.SetMf6TimesSeries(const Value: TTimesSeriesCollections);
begin
  if ParentModel <> nil then
  begin
    ParentModel.SetMf6TimesSeries(Value);
  end;
end;

procedure TChildModel.SetUseGsflowFormat(const Value: boolean);
begin
  if (ParentModel <> nil) then
  begin
    ParentModel.SetUseGsflowFormat(Value);
  end;
end;

procedure TChildModel.SetUseWaterTable(const Value: boolean);
begin
  ParentModel.SetUseWaterTable(Value);
end;

function TChildModel.StoreHydrogeologicUnits: Boolean;
begin
  result := False;
end;

function TChildModel.TRPT: TOneDRealArray;
begin
  Result := ConvertRealParentArray(inherited TRPT);
end;

function TChildModel.TRPV: TOneDRealArray;
begin
  Result := ConvertRealParentArray(inherited TRPV);
end;

function TChildModel.Trpy: TOneDRealArray;
begin
  Result := ConvertRealParentArray(inherited Trpy);
end;

function TChildModel.ConvertRealParentArray(ParentArray: TOneDRealArray): TOneDRealArray;
var
  GroupIndex: Integer;
  ChildIndex: Integer;
  ParentIndex: Integer;
  ChildDisIndex: Integer;
  DisItem: TChildDiscretization;
  DiscIndex: Integer;
  AGroup: TLayerGroup;
begin
  SetLength(result, ModflowLayerCount);
  ParentIndex := 0;
  ChildIndex := 0;
  for GroupIndex := 1 to LayerStructure.Count - 1 do
  begin
    AGroup := LayerStructure[GroupIndex];
    if AGroup.RunTimeSimulated then
    begin
      for DiscIndex := 0 to AGroup.LayerCount - 1 do
      begin
        DisItem := Discretization.GetAnItemByGroupAndLayer(AGroup, DiscIndex);
        for ChildDisIndex := 0 to DisItem.Discretization - 1 do
        begin
          if ChildIndex < length(result) then
          begin
            result[ChildIndex] := ParentArray[ParentIndex];
            Inc(ChildIndex);
          end;
        end;
        Inc(ParentIndex);
        if (AGroup = Discretization.BottomLayerGroup) and (DiscIndex = Discretization.BottomLayerInUnit) then
        begin
          break;
        end;
      end;
    end;
    if (AGroup = Discretization.BottomLayerGroup) then
    begin
      break;
    end;
  end;
end;

function TChildModel.ConvertIntegerParentArray( ParentArray: TOneDIntegerArray): TOneDIntegerArray;
var
  ChildDisIndex: Integer;
  DisItem: TChildDiscretization;
  DiscIndex: Integer;
  AGroup: TLayerGroup;
  GroupIndex: Integer;
  ChildIndex: Integer;
  ParentIndex: Integer;
begin
  SetLength(result, ModflowLayerCount);
  ParentIndex := 0;
  ChildIndex := 0;
  for GroupIndex := 1 to LayerStructure.Count - 1 do
  begin
    AGroup := LayerStructure[GroupIndex];
    if AGroup.RunTimeSimulated then
    begin
      for DiscIndex := 0 to AGroup.LayerCount - 1 do
      begin
        DisItem := Discretization.GetAnItemByGroupAndLayer(AGroup, DiscIndex);
        for ChildDisIndex := 0 to DisItem.Discretization - 1 do
        begin
          if ChildIndex < length(result) then
          begin
            result[ChildIndex] := ParentArray[ParentIndex];
            Inc(ChildIndex);
          end;
        end;
        Inc(ParentIndex);
        if (AGroup = Discretization.BottomLayerGroup)
          and (DiscIndex = Discretization.BottomLayerInUnit) then
        begin
          break;
        end;
      end;
    end;
    if (AGroup = Discretization.BottomLayerGroup) then
    begin
      break;
    end;
  end;
end;

procedure TChildModel.UpdateDataSetConnections;
var
  Index: Integer;
  ParentDataArray: TDataArray;
  ChildDataArray: TDataArray;
begin
  for Index := 0 to ParentModel.DataArrayManager.DataSetCount - 1 do
  begin
    ParentDataArray := ParentModel.DataArrayManager[Index];
    ChildDataArray := DataArrayManager.GetDataSetByName(ParentDataArray.Name);
    ParentDataArray.TalksTo(ChildDataArray);
  end;
end;

procedure TChildModel.UpdateDisplayUseList(NewUseList: TStringList;
  ParamType: TParameterType; DataIndex: integer; const DisplayName: string);
begin
  FParentModel.UpdateDisplayUseList(NewUseList, ParamType, DataIndex, DisplayName);
end;

procedure TChildModel.UpdateLayerCount;
var
  LocalParent: TPhastModel;
begin
  if ParentModel <> nil then
  begin
    ModflowGrid.LayerCount := LayerCount;
    LocalParent := ParentModel as TPhastModel;
    LocalParent.InvalidateMapping;
    LocalParent.InvalidateSegments;
  end;
end;

procedure TChildModel.UpdateMt3dmsChemDataSets;
begin
  if ParentModel <> nil then
  begin
    ParentModel.UpdateMt3dmsChemDataSets
  end;
end;

procedure TChildModel.WriteFluxClosureCriterion(Writer: TWriter);
begin
  Writer.WriteFloat(FFluxClosureCriterion);
end;

procedure TChildModel.WriteFluxRelaxationFactor(Writer: TWriter);
begin
  Writer.WriteFloat(FFluxRelaxationFactor);
end;

procedure TChildModel.WriteHeadClosureCriterion(Writer: TWriter);
begin
  Writer.WriteFloat(FHeadClosureCriterion);
end;

procedure TChildModel.WriteHeadRelaxationFactor(Writer: TWriter);
begin
  Writer.WriteFloat(FHeadRelaxationFactor);
end;

procedure TChildModel.WriteLAYCB(const DiscretizationWriter: TObject);
begin
  Discretization.WriteLAYCB(DiscretizationWriter);
end;

procedure TChildModel.UpdateGrid;
const
  Zero: NativeInt = 0;
var
  SegIndex: NativeInt;
  SegmentList: TCellElementSegmentList;
  Segment: TCellElementSegment;
  NewColumnPositions: TOneDRealArray;
  NewRowPositions: TOneDRealArray;
  LocalFirstCol: Integer;
  LocalLastCol: Integer;
  LocalFirstRow: Integer;
  LocalLastRow: Integer;
begin
  if FParentModel = nil then
  begin
    Exit;
  end;
  if FParentModel.Clearing then
  begin
    Exit;
  end;
  if not FCanUpdateGrid then
  begin
    FShouldUpdateGrid := True;
    Exit;
  end;
  if not (FParentModel.ModelSelection in
    [msModflowLGR, msModflowLGR2, msModflowFMP, msModflowOwhm2]) then
  begin
    Exit;
  end;
  LocalFirstCol := FirstCol;
  LocalLastCol := LastCol;
  LocalFirstRow := FirstRow;
  LocalLastRow := LastRow;
  try
    ModflowGrid.GridAngle := (FParentModel as TCustomModel).ModflowGrid.GridAngle;
    FShouldUpdateGrid := False;
    FFirstCol := -1;
    FLastCol := -1;
    FFirstRow := -1;
    FLastRow := -1;
    if (HorizontalPositionScreenObject = nil)
      or (ParentModel.ModflowGrid.RowCount < 3)
      or (ParentModel.ModflowGrid.ColumnCount < 3)then
    begin
      ModflowGrid.RowCount := -1;
      ModflowGrid.ColumnCount := -1;
    end
    else
    begin
      SegmentList := HorizontalPositionScreenObject.Segments[ParentModel];
      if (SegmentList.Count >= 1) then
      begin
        Segment := SegmentList[Zero];
        FFirstCol :=  Segment.Col;
        FLastCol := FFirstCol;
        FFirstRow :=  Segment.Row;
        FLastRow := FFirstRow;
        for SegIndex := 1 to SegmentList.Count - 1 do
        begin
          Segment := SegmentList[SegIndex];
          if FFirstCol > Segment.Col then
          begin
            FFirstCol := Segment.Col;
          end
          else if FLastCol < Segment.Col then
          begin
            FLastCol := Segment.Col;
          end;
          if FFirstRow > Segment.Row then
          begin
            FFirstRow := Segment.Row;
          end
          else if FLastRow < Segment.Row then
          begin
            FLastRow := Segment.Row;
          end;
        end;

        if FParentModel.ModelSelection in [msModflowLGR] then
        begin
          if FFirstCol = 0 then
          begin
            FFirstCol := 1;
          end;
          if FFirstRow = 0 then
          begin
            FFirstRow := 1;
          end;
          if FLastRow = ParentModel.ModflowGrid.RowCount-1 then
          begin
            FLastRow := ParentModel.ModflowGrid.RowCount-2;
          end;
          if FLastCol = ParentModel.ModflowGrid.ColumnCount-1 then
          begin
            FLastCol := ParentModel.ModflowGrid.ColumnCount-2;
          end;
        end;

        GetRowColPositions(FFirstCol, FLastCol,
          ParentModel.ModflowGrid.ColumnPositions, NewColumnPositions);
        ModflowGrid.ColumnPositions := NewColumnPositions;
        GetRowColPositions(FFirstRow, FLastRow,
          ParentModel.ModflowGrid.RowPositions, NewRowPositions);
        ModflowGrid.RowPositions := NewRowPositions;
      end
      else
      begin
        ModflowGrid.RowCount := -1;
        ModflowGrid.ColumnCount := -1;
      end;
    end;
    UpdateLayerCount;
  finally
    if (LocalFirstCol <> FirstCol) or (LocalLastCol <> LastCol)
      or (LocalFirstRow <> FirstRow) or (LocalLastRow <> LastRow) then
    begin
      InvalidateScreenObjects;
    end;
  end;
end;

function TChildModel.Layavg: TOneDIntegerArray;
begin
  Result := ConvertIntegerParentArray(inherited Layavg);
end;

function TChildModel.LayerCount: integer;
var
  DisIndex: Integer;
  EndLayer: Integer;
  Group: TLayerGroup;
  GroupIndex: Integer;
  PriorItem: TChildDiscretization;
  Item: TChildDiscretization;
  NewItems: boolean;
begin
  result := 0;
  NewItems := False;
  for GroupIndex := 1 to LayerStructure.Count - 1 do
  begin
    Group := LayerStructure[GroupIndex];
    if Group.RunTimeSimulated then
    begin
      if (Group = Discretization.BottomLayerGroup) then
      begin
        EndLayer := Discretization.BottomLayerInUnit;
      end
      else
      begin
        EndLayer := Group.LayerCount - 1;
      end;
      for DisIndex := 0 to EndLayer do
      begin
        Item := Discretization.GetAnItemByGroupAndLayer(Group, DisIndex);
        if Item = nil then
        begin
          Item := Discretization.Add as TChildDiscretization;
          Item.LayerGroup := Group;
          Item.ParentLayerNumber := DisIndex;
          if DisIndex > 0 then
          begin
            PriorItem := Discretization.GetAnItemByGroupAndLayer(Group, DisIndex - 1);
            Item.Discretization := PriorItem.Discretization;
          end;
          NewItems := True;
        end;
        if (Group = Discretization.BottomLayerGroup)
          and (ModelSelection  in [msModflowLGR])
          and (DisIndex = EndLayer)
          and ((GroupIndex <> LayerStructure.Count - 1)
          or (EndLayer <> Group.LayerCount - 1)) then
        begin
          Inc(result, (Item.Discretization div 2)+1);
        end
        else
        begin
          Inc(result, Item.Discretization);
        end;
      end;
      if Group = Discretization.BottomLayerGroup then
      begin
        break;
      end
    end
    else
    begin
      Inc(result);
    end;
  end;
  if NewItems then
  begin
    Discretization.SortAndDeleteExtraItems;
  end;
end;

function TChildModel.LayerFractions(LayerGroup: TCustomLayerGroup): TDoubleDynArray;
var
  ParentLayerIndex: Integer;
  ArrayLength: Integer;
  Item: TChildDiscretization;
  LayerIndex: Integer;
  FracItem, HigherFracItem: TLayerFraction;
  Fraction: Real;
  ChildLayerIndex: Integer;
  HigherFraction: Real;
  Delta: Real;
begin
  Assert(Discretization.BottomLayerGroup.Index >= LayerGroup.Index);
  if (LayerGroup.Index = 0) then
  begin
    // The uppermost layer group represents the top of the model and never
    // has additional layers above it.
    //
    result := nil;
    Exit;
  end
  else
  begin
    ArrayLength := 0;
    if LayerGroup.RunTimeSimulated then
    begin
//      if Discretization.BottomLayerGroup = LayerGroup then
//      begin
//        for ParentLayerIndex := 0 to Discretization.BottomLayerInUnit do
//        begin
//          Item := Discretization.GetAnItemByGroupAndLayer(LayerGroup as TLayerGroup, ParentLayerIndex);
//          Inc(ArrayLength, Item.Discretization);
//        end;
//      end
//      else
//      begin
        for ParentLayerIndex := 0 to LayerGroup.LayerCount - 1 do
        begin
          Item := Discretization.GetAnItemByGroupAndLayer(LayerGroup as TLayerGroup, ParentLayerIndex);
          Inc(ArrayLength, Item.Discretization);
        end;
//      end;
    end
    else
    begin
      ArrayLength := 1;
    end;
    Dec(ArrayLength);
    SetLength(result, ArrayLength);
    LayerIndex := 0;
    HigherFracItem := nil;
    for ParentLayerIndex := 0 to LayerGroup.LayerCollection.Count do
    begin
      if Discretization.BottomLayerGroup = LayerGroup then
      begin
        if (ParentLayerIndex < LayerGroup.LayerCollection.Count)
          and (ParentLayerIndex <= Discretization.BottomLayerInUnit) then
        begin
          FracItem := LayerGroup.LayerCollection.Items[ParentLayerIndex] as TLayerFraction;
          Fraction := FracItem.Fraction;
        end
        else
        begin
          FracItem := nil;
          Fraction := 0;
        end;
      end
      else if ParentLayerIndex < LayerGroup.LayerCollection.Count then
      begin
        FracItem := LayerGroup.LayerCollection.Items[ParentLayerIndex] as TLayerFraction;
        Fraction := FracItem.Fraction;
      end
      else
      begin
        FracItem := nil;
        Fraction := 0;
      end;
      if HigherFracItem <> nil then
      begin
        HigherFraction := HigherFracItem.Fraction;
      end
      else
      begin
        HigherFraction := 1.;
      end;

      Delta := HigherFraction - Fraction;
      Item := Discretization.GetAnItemByGroupAndLayer(LayerGroup as TLayerGroup, ParentLayerIndex);
      for ChildLayerIndex := Item.Discretization - 1 downto 1 do
      begin
//        if LayerIndex >= Length(result) then
//        begin
//          break;
//        end;
        result[LayerIndex] := Fraction
          + ChildLayerIndex/Item.Discretization * Delta;
        Inc(LayerIndex);
      end;
      if FracItem <> nil then
      begin
        result[LayerIndex] := Fraction;
        Inc(LayerIndex);
      end;
      HigherFracItem := FracItem;
    end;
  end;
  if
    not ((Discretization.BottomLayerGroup.Index > LayerGroup.Index)
    or ((LayerStructure[LayerStructure.Count-1] = Discretization.BottomLayerGroup)
    and (Discretization.BottomLayerInUnit = Discretization.BottomLayerGroup.LayerCount-1)))
//    and (Discretization.BottomLayerInUnit < Discretization.BottomLayerGroup.LayerCount-1)))
    then
  begin
    // The bottom of the child grid occurs in a layer in the parent grid
    // that is not the bottom most layer.  The child grid ends in the middle
    // of the layer of the parent grid.
    if ArrayLength > 0 then
    begin
      ArrayLength := 0;
      for ParentLayerIndex := 0 to LayerGroup.LayerCount - 1 do
      begin
        Item := Discretization.GetAnItemByGroupAndLayer(LayerGroup as TLayerGroup, ParentLayerIndex);
        if Discretization.BottomLayerInUnit = ParentLayerIndex then
        begin
          if (ModelSelection = msModflowLGR) then
          begin
            Inc(ArrayLength, Item.Discretization div 2);
          end
          else
          begin
            Inc(ArrayLength, Item.Discretization-1);
          end;
          break;
        end
        else
        begin
          Inc(ArrayLength, Item.Discretization);
        end;
      end;
//      Item := Discretization.GetAnItemByGroupAndLayer(
//        Discretization.BottomLayerGroup, Discretization.BottomLayerInUnit);
//      ArrayLength := ArrayLength - Item.Discretization div 2;
      SetLength(result, ArrayLength);
    end;
  end

end;

function TChildModel.LayerGroupUsed(LayerGroup: TLayerGroup): boolean;
begin
  result := LayerGroup.Index <= Discretization.FBottomLayerGroup.Index;
end;

function TChildModel.Laytyp: TOneDIntegerArray;
var
  LayerIndex: Integer;
begin
  Result := ConvertIntegerParentArray(inherited Laytyp);
  if ModflowPackages.BcfPackage.IsSelected then
  begin
    // unconfined is only valid for the top layer.
    // convert unconfined to convertible.
    for LayerIndex := 1 to Length(result) - 1 do
    begin
      if (result[LayerIndex] mod 10) = 1 then
      begin
        result[LayerIndex] := result[LayerIndex] + 2;
      end;
    end;
  end;
end;

function TChildModel.Layvka: TOneDIntegerArray;
begin
  Result := ConvertIntegerParentArray(inherited Layvka);
end;

procedure TChildModel.Loaded;
begin
  inherited;
  Discretization.Loaded;
  ModelSelection := ParentModel.ModelSelection;
  SwrObservations.Loaded;
  UpdateGrid;
end;

function TChildModel.MaxPosition(
  ViewDirection: TViewDirection): integer;
begin
  result := 0;
  case ViewDirection of
    vdTop: result := ModflowGrid.LayerCount;
    vdFront: result := ModflowGrid.RowCount;
    vdSide: result := ModflowGrid.ColumnCount;
    else Assert(False);
  end;
end;

function TChildModel.ModelNameForDos: string;
begin
  result := StringReplace(ModelName, ' ', '_', [rfReplaceAll]);
end;

function TChildModel.ModflowConfiningBedCount: integer;
begin
  result := Discretization.ModflowConfiningBedCount;
end;

function TChildModel.ModflowLayerBottomDescription(
  const LayerID: integer): string;
begin
  result := inherited ModflowLayerBottomDescription(
    ChildLayerToParentLayer(LayerID))
    + ' Child layer ' + IntToStr(LayerId+1);
end;

function TChildModel.ModflowLayerCount: integer;
begin
  result := Discretization.ModflowLayerCount;
end;

function TChildModel.ModflowLayerToDataSetLayer(ModflowLayer: integer): integer;
var
  GroupIndex: Integer;
  LayerGroup: TLayerGroup;
  ParentLayerIndex: Integer;
  DisItem: TChildDiscretization;
  MFLayer: Integer;
  ChildDisIndex: Integer;
begin
  result := 0;
  MFLayer := 0;
  for GroupIndex := 1 to LayerStructure.Count - 1 do
  begin
    LayerGroup := LayerStructure[GroupIndex];
    if LayerGroup.RunTimeSimulated then
    begin
      for ParentLayerIndex := 0 to LayerGroup.LayerCount - 1 do
      begin
        DisItem := Discretization.
          GetAnItemByGroupAndLayer(LayerGroup, ParentLayerIndex);
        for ChildDisIndex := 0 to DisItem.Discretization - 1 do
        begin
          Inc(MFLayer);
          if MFLayer = ModflowLayer then
          begin
            Exit;
          end;
          Inc(result);
        end;
      end;
    end
    else
    begin
      Inc(result);
    end;
  end;
end;

function TChildModel.ParentPositionToChildPositions(
  ViewDirection: TViewDirection; APosition: integer): TGridRange;
begin
  case ViewDirection of
    vdTop: result := ParentLayerToChildLayers(APosition);
    vdFront: result := ParentRowToChildRows(APosition);
    vdSide: result := ParentColToChildCols(APosition);
  end;
end;

function TChildModel.ParentColToChildCols(ACol: integer): TGridRange;
begin
  if (FFirstCol < 0) or (FLastCol < 0)
    or (ACol < FFirstCol) then
  begin
    result.First := -1;
    result.Last := -1;
  end
  else if (ACol > FLastCol) then
  begin
    result.First := ModflowGrid.ColumnCount;
    result.Last := result.First;
  end
  else if ACol = FFirstCol then
  begin
    result.First := 0;
    case ModelSelection of
      msModflowLGR:
        result.Last := (ChildCellsPerParentCell div 2);
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result.Last := (ChildCellsPerParentCell - 1);
      else
        result.Last := (ChildCellsPerParentCell div 2);
    end;
  end
  else if ACol = FLastCol then
  begin
    result.Last := Grid.ColumnCount-1;
    case ModelSelection of
      msModflowLGR:
        result.First := result.Last - (ChildCellsPerParentCell div 2);
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result.First := result.Last - (ChildCellsPerParentCell - 1);
      else
        result.First := result.Last - (ChildCellsPerParentCell div 2);
    end;
  end
  else
  begin
    case ModelSelection of
      msModflowLGR:
        result.Last := (ACol-FFirstCol+1)*ChildCellsPerParentCell
          - (ChildCellsPerParentCell div 2) - 1;
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result.Last := (ACol-FFirstCol+1)*ChildCellsPerParentCell - 1;
      else
        result.Last := (ACol-FFirstCol+1)*ChildCellsPerParentCell
          - (ChildCellsPerParentCell div 2) - 1;
    end;
    result.First  := result.Last - ChildCellsPerParentCell + 1;
  end;

end;

function TChildModel.ParentLayerToChildLayers(ALayer: integer): TGridRange;
var
  LayerGroupIndex: Integer;
  LayerGroup: TLayerGroup;
  ParentLayerIndex: Integer;
  DisItem: TChildDiscretization;
  CumulativeParentLayers: Integer;
  LastLayer: Integer;
begin
  result.First := -1;
  result.Last := -1;
  if (ALayer >= ModflowGrid.LayerCount) and (ModflowGrid.LayerCount > 0) then
  begin
    result.First := ModflowGrid.LayerCount;
    result.Last := result.First;
    Exit;
  end;
  if ALayer < 0 then
  begin
    Exit;
  end;
  CumulativeParentLayers := 0;
  LastLayer := -1;
  for LayerGroupIndex := 1 to FParentModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := FParentModel.LayerStructure[LayerGroupIndex];
    for ParentLayerIndex := 0 to LayerGroup.LayerCount - 1 do
    begin
      if LayerGroup.RunTimeSimulated then
      begin
        DisItem := Discretization.
          GetAnItemByGroupAndLayer(LayerGroup,ParentLayerIndex);
        LastLayer := LastLayer + DisItem.Discretization;
      end
      else
      begin
        DisItem := nil;
        LastLayer := LastLayer + 1;
      end;
      if CumulativeParentLayers = ALayer then
      begin
        result.Last := Min(LastLayer, ModflowGrid.LayerCount-1);
        if LayerGroup.RunTimeSimulated then
        begin
          result.First := LastLayer - DisItem.Discretization + 1;
        end
        else
        begin
          result.First := LastLayer;
        end;
        Exit;
      end;
      Inc(CumulativeParentLayers);
    end;
  end;
end;

function TChildModel.ParentRowToChildRows(ARow: integer): TGridRange;
begin
  if (FFirstRow < 0) or (FLastRow < 0)
    or (ARow < FFirstRow) then
  begin
    result.First := -1;
    result.Last := -1;
  end
  else if (ARow > FLastRow) then
  begin
    result.First := ModflowGrid.RowCount;
    result.Last := result.First;
  end
  else if ARow = FFirstRow then
  begin
    result.First := 0;
    case ModelSelection of
      msModflowLGR:
        result.Last := (ChildCellsPerParentCell div 2);
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result.Last := (ChildCellsPerParentCell -1);
      else
        result.Last := (ChildCellsPerParentCell div 2);
    end;
  end
  else if ARow = FLastRow then
  begin
    result.Last := Grid.RowCount-1;
    case ModelSelection of
      msModflowLGR:
        result.First := result.Last - (ChildCellsPerParentCell div 2);
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result.First := result.Last - (ChildCellsPerParentCell - 1);
      else
        result.First := result.Last - (ChildCellsPerParentCell div 2);
    end;
  end
  else
  begin
    case ModelSelection of
      msModflowLGR:
        result.Last := (ARow-FFirstRow+1)*ChildCellsPerParentCell
          - (ChildCellsPerParentCell div 2) - 1;
      msModflowLGR2, msModflowFmp, msModflowOwhm2:
        result.Last := (ARow-FFirstRow+1)*ChildCellsPerParentCell - 1;
      else
        result.Last := (ARow-FFirstRow+1)*ChildCellsPerParentCell
          - (ChildCellsPerParentCell div 2) - 1;
    end;
    result.First  := result.Last - ChildCellsPerParentCell + 1;
  end;
end;

procedure TChildModel.ReadFluxClosureCriterion(Reader: TReader);
begin
  FFluxClosureCriterion := Reader.ReadFloat;
end;

procedure TChildModel.ReadFluxRelaxationFactor(Reader: TReader);
begin
  FFluxRelaxationFactor := Reader.ReadFloat;
end;

procedure TChildModel.ReadHeadClosureCriterion(Reader: TReader);
begin
  FFluxRelaxationFactor := Reader.ReadFloat;
end;

procedure TChildModel.ReadHeadRelaxationFactor(Reader: TReader);
begin
  FHeadRelaxationFactor := Reader.ReadFloat;
end;

{ TChildDiscretization }

procedure TChildDiscretization.Assign(Source: TPersistent);
var
  SourceChildDiscretization: TChildDiscretization;
begin
  // if Assign is updated, update IsSame too.
  if Source is TChildDiscretization then
  begin
    SourceChildDiscretization := TChildDiscretization(Source);
    LayerGroup := SourceChildDiscretization.LayerGroup;
    LayerGroupName := SourceChildDiscretization.LayerGroupName;
    ParentLayerNumber := SourceChildDiscretization.ParentLayerNumber;
    Discretization := SourceChildDiscretization.Discretization;
  end
  else
  begin
    inherited;
  end;
end;

constructor TChildDiscretization.Create(Collection: TCollection);
begin
  inherited;
  FDiscretization := 1;
end;

function TChildDiscretization.GetDiscretization: integer;
begin
  if LayerGroup.RunTimeSimulated then
  begin
    result := FDiscretization
  end
  else
  begin
    result := 1
  end;
end;

function TChildDiscretization.GetLayerGroup: TLayerGroup;
var
  Group: TLayerGroup;
  Index: integer;
begin
  if (FLayerGroup = nil) and (FLayerGroupName <> '') then
  begin
    for Index := 0 to frmGoPhast.PhastModel.LayerStructure.Count - 1 do
    begin
      Group := frmGoPhast.PhastModel.LayerStructure[Index];
      if Group.AquiferName = FLayerGroupName then
      begin
        FLayerGroup := Group;
        break;
      end;
    end;
  end;
  result := FLayerGroup;
end;

function TChildDiscretization.GetLayerGroupName: string;
begin
  if FLayerGroup <> nil then
  begin
    result := FLayerGroup.AquiferName;
  end
  else
  begin
    result := FLayerGroupName;
  end;
end;

function TChildDiscretization.IsSame(AnotherItem: TOrderedItem): boolean;
var
  AnotherChildDis: TChildDiscretization;
begin
  result := AnotherItem is TChildDiscretization;
  if result then
  begin
    AnotherChildDis := TChildDiscretization(AnotherItem);
    result := (LayerGroupName = AnotherChildDis.LayerGroupName)
      and (ParentLayerNumber = AnotherChildDis.ParentLayerNumber)
      and (Discretization = AnotherChildDis.Discretization);
  end;
end;

procedure TChildDiscretization.Loaded;
begin
  GetLayerGroup;
end;

procedure TChildDiscretization.SetDiscretization(const Value: integer);
begin
  SetIntegerProperty(FDiscretization, Value);
end;

procedure TChildDiscretization.SetLayerGroup(const Value: TLayerGroup);
begin
  if FLayerGroup <> Value then
  begin
    FLayerGroup := Value;
    InvalidateModel;
  end;
  if FLayerGroup <> nil then
  begin
    FLayerGroupName := FLayerGroup.AquiferName;
  end;
end;

procedure TChildDiscretization.SetLayerGroupName(const Value: string);
begin
  SetCaseInsensitiveStringProperty(FLayerGroupName, Value);
  // update FLayerGroup.
  GetLayerGroup;
end;

procedure TChildDiscretization.SetParentLayerNumber(const Value: integer);
begin
  SetIntegerProperty(FParentLayerNumber, Value);
end;

{ TChildDiscretizationCollection }

procedure TChildDiscretizationCollection.Assign(Source: TPersistent);
var
  SourceCollection: TChildDiscretizationCollection;
begin
  inherited;
  // if Assign is updated, update IsSame too.
  if Source is TChildDiscretizationCollection then
  begin
    BeginUpdate;
    try
      SourceCollection := TChildDiscretizationCollection(Source);
      BottomUnitName := SourceCollection.BottomUnitName;
      BottomLayerInUnit := SourceCollection.BottomLayerInUnit;
      BottomLayerGroup := SourceCollection.BottomLayerGroup;
      SortAndDeleteExtraItems;
    finally
      EndUpdate;
    end;
  end;
end;

function TChildDiscretizationCollection.BottomLayerIndex: integer;
var
  ChildModel: TChildModel;
  PhastModel: TPhastModel;
  GroupIndex: Integer;
  LayerGroup: TLayerGroup;
begin
  Assert(Model <> nil);
  ChildModel := Model as TChildModel;
  PhastModel := ChildModel.ParentModel as TPhastModel;
  result := -1;
  for GroupIndex := 1 to PhastModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := PhastModel.LayerStructure[GroupIndex];
    if LayerGroup = ChildModel.Discretization.BottomLayerGroup then
    begin
      Inc(result, ChildModel.Discretization.BottomLayerInUnit+1);
      Exit;
    end
    else
    begin
      Inc(result, LayerGroup.LayerCount);
    end;
  end;
end;

function TChildDiscretizationCollection.BottomModflowParentLayerNumber: integer;
var
  ChildModel: TChildModel;
  PhastModel: TPhastModel;
  GroupIndex: Integer;
  LayerGroup: TLayerGroup;
begin
  Assert(Model <> nil);
  ChildModel := Model as TChildModel;
  PhastModel := ChildModel.ParentModel as TPhastModel;
  result := 0;
  for GroupIndex := 1 to PhastModel.LayerStructure.Count - 1 do
  begin
    LayerGroup := PhastModel.LayerStructure[GroupIndex];
    if LayerGroup.RunTimeSimulated then
    begin
      if LayerGroup = ChildModel.Discretization.BottomLayerGroup then
      begin
        Inc(result, ChildModel.Discretization.BottomLayerInUnit + 1);
        Exit;
      end
      else
      begin
        Inc(result, LayerGroup.LayerCount);
      end;
    end;
  end;
end;

constructor TChildDiscretizationCollection.Create(Model: IModelForTOrderedCollection);
begin
  inherited Create(TChildDiscretization, Model);
  FBottomLayerInUnit := 0;
end;

{ TChildModelEdit }

procedure TChildModelEdit.Assign(Source: TPersistent);
  procedure AssignSourceModel(SourceModel: TChildModel);
  begin
    ModelName := SourceModel.ModelName;
    Discretization := SourceModel.Discretization;
    ChildCellsPerParentCell := SourceModel.ChildCellsPerParentCell;
    StartingHeadSource := SourceModel.StartingHeadSource;
//    OneWayCoupling := SourceModel.OneWayCoupling;
    CouplingMethod := SourceModel.CouplingMethod;
    MaxIterations := SourceModel.MaxIterations;
    LgrPrintChoice := SourceModel.LgrPrintChoice;
    HeadRelaxationFactor := SourceModel.HeadRelaxationFactor;
    FluxRelaxationFactor := SourceModel.FluxRelaxationFactor;
    HeadClosureCriterion := SourceModel.HeadClosureCriterion;
    FluxClosureCriterion := SourceModel.FluxClosureCriterion;
    FChildModel := SourceModel;
  end;
var
  SourceItem: TChildModelEdit;
begin
  // if Assign is updated, update IsSame too.

    // When editing this section, be sure to edit TChildModel
    // and TChildModelItem too
  if Source is TChildModelEdit then
  begin
    SourceItem := TChildModelEdit(Source);
    ModelName := SourceItem.ModelName;
    Discretization := SourceItem.Discretization;
    ChildCellsPerParentCell := SourceItem.ChildCellsPerParentCell;
    StartingHeadSource := SourceItem.StartingHeadSource;
//    OneWayCoupling := SourceItem.OneWayCoupling;
    CouplingMethod := SourceItem.CouplingMethod;
    MaxIterations := SourceItem.MaxIterations;
    LgrPrintChoice := SourceItem.LgrPrintChoice;
    HeadRelaxationFactor := SourceItem.HeadRelaxationFactor;
    FluxRelaxationFactor := SourceItem.FluxRelaxationFactor;
    HeadClosureCriterion := SourceItem.HeadClosureCriterion;
    FluxClosureCriterion := SourceItem.FluxClosureCriterion;
    FChildModel := SourceItem.FChildModel;
  end
  else if Source is TChildModel then
  begin
    AssignSourceModel(TChildModel(Source));
  end
  else if Source is TChildModelItem then
  begin
    AssignSourceModel(TChildModelItem(Source).ChildModel);
  end
  else
  begin
    inherited;
  end;
end;

procedure TChildModelEdit.AssignTo(Dest: TPersistent);
var
  DestModel: TChildModel;
  Mnw1Parent: TMnw1Package;
  Mnw1Child: TMnw1Package;
  Root: string;
begin
    // When editing this section, be sure to edit TChildModel
    // and TChildModelItem too
  if Dest is TChildModel then
  begin
    DestModel := TChildModel(Dest);
    DestModel.ModelName := ModelName;
    DestModel.Discretization := Discretization;
    DestModel.ChildCellsPerParentCell := ChildCellsPerParentCell;
    DestModel.StartingHeadSource := StartingHeadSource;
//    DestModel.OneWayCoupling := OneWayCoupling;
    DestModel.CouplingMethod := CouplingMethod;
    DestModel.MaxIterations := MaxIterations;
    DestModel.LgrPrintChoice := LgrPrintChoice;
    DestModel.HeadRelaxationFactor := HeadRelaxationFactor;
    DestModel.FluxRelaxationFactor := FluxRelaxationFactor;
    DestModel.HeadClosureCriterion := HeadClosureCriterion;
    DestModel.FluxClosureCriterion := FluxClosureCriterion;
    DestModel.UpdateGrid;

    Mnw1Parent := frmGoPhast.PhastModel.ModflowPackages.Mnw1Package;
    if Mnw1Parent.IsSelected then
    begin
      Mnw1Child := DestModel.ModflowPackages.Mnw1Package;
      if (Mnw1Parent.WellFileName <> '')
        and (Mnw1Parent.WellFileName = Mnw1Child.WellFileName) then
      begin
        Root := ChangeFileExt(Mnw1Parent.WellFileName, '');
        Mnw1Child.WellFileName := DestModel.FixFileName(Root + '_'
          + DestModel.ModelName
          + ExtractFileExt(Mnw1Parent.WellFileName))
      end;
      if (Mnw1Parent.ByNodeFileName <> '')
        and (Mnw1Parent.ByNodeFileName = Mnw1Child.ByNodeFileName) then
      begin
        Root := ChangeFileExt(Mnw1Parent.ByNodeFileName, '');
        Mnw1Child.ByNodeFileName := DestModel.FixFileName(Root + '_'
          + DestModel.ModelName
          + ExtractFileExt(Mnw1Parent.ByNodeFileName));
      end;
      if (Mnw1Parent.QSumFileName <> '')
        and (Mnw1Parent.QSumFileName = Mnw1Child.QSumFileName) then
      begin
        Root := ChangeFileExt(Mnw1Parent.QSumFileName, '');
        Mnw1Child.QSumFileName := DestModel.FixFileName(Root + '_'
          + DestModel.ModelName
          + ExtractFileExt(Mnw1Parent.QSumFileName));
      end;
    end;
  end
  else
  begin
    inherited;
  end;
end;

constructor TChildModelEdit.Create(Collection: TCollection);
begin
  inherited;
  FChildCellsPerParentCell := 3;
  FStartingHeadSource := shsSelf;
  FMaxIterations := 20;
  FLgrPrintChoice := lpcListing;
  FFluxRelaxationFactor := 0.5;
  FHeadRelaxationFactor := 0.5;
  FHeadClosureCriterion := 5E-3;
  FFluxClosureCriterion := 5E-2;
  FDiscretization := TChildDiscretizationCollection.Create(nil);
end;

destructor TChildModelEdit.Destroy;
begin
  FDiscretization.Free;
  inherited;
end;

function TChildModelEdit.IsSame(AnotherItem: TOrderedItem): boolean;
var
  AnotherEdit: TChildModelEdit;
  ChildModel: TChildModel;
begin
    // When editing this section, be sure to edit TChildModel
    // and TChildModelItem too

  result := AnotherItem is TChildModelEdit;
  if result then
  begin
    AnotherEdit := TChildModelEdit(AnotherItem);
    result := (ModelName = AnotherEdit.ModelName)
      and (ChildCellsPerParentCell = AnotherEdit.ChildCellsPerParentCell)
      and Discretization.IsSame(AnotherEdit.Discretization)
      and (StartingHeadSource = AnotherEdit.StartingHeadSource)
//      and (OneWayCoupling = AnotherEdit.OneWayCoupling)
      and (CouplingMethod = AnotherEdit.CouplingMethod)
      and (MaxIterations = AnotherEdit.MaxIterations)
      and (LgrPrintChoice = AnotherEdit.LgrPrintChoice)
      and (HeadRelaxationFactor = AnotherEdit.HeadRelaxationFactor)
      and (FluxRelaxationFactor = AnotherEdit.FluxRelaxationFactor)
      and (HeadClosureCriterion = AnotherEdit.HeadClosureCriterion)
      and (FluxClosureCriterion = AnotherEdit.FluxClosureCriterion)
  end
  else
  begin
    result := AnotherItem is TChildModelItem;
    if result then
    begin
      ChildModel := TChildModelItem(AnotherItem).ChildModel;
      result := (ModelName = ChildModel.ModelName)
        and (ChildCellsPerParentCell = ChildModel.ChildCellsPerParentCell)
        and Discretization.IsSame(ChildModel.Discretization)
        and (StartingHeadSource = ChildModel.StartingHeadSource)
//        and (OneWayCoupling = ChildModel.OneWayCoupling)
        and (CouplingMethod = ChildModel.CouplingMethod)
        and (MaxIterations = ChildModel.MaxIterations)
        and (LgrPrintChoice = ChildModel.LgrPrintChoice)
        and (HeadRelaxationFactor = ChildModel.HeadRelaxationFactor)
        and (FluxRelaxationFactor = ChildModel.FluxRelaxationFactor)
        and (HeadClosureCriterion = ChildModel.HeadClosureCriterion)
        and (FluxClosureCriterion = ChildModel.FluxClosureCriterion)
    end;
  end;
end;

procedure TChildModelEdit.SetChildCellsPerParentCell(const Value: integer);
begin
  FChildCellsPerParentCell := Value;
end;

procedure TChildModelEdit.SetCouplingMethod(const Value: TCouplingMethod);
begin
  FCouplingMethod := Value;
end;

procedure TChildModelEdit.SetDiscretization(
  const Value: TChildDiscretizationCollection);
begin
  FDiscretization.Assign(Value);
end;

procedure TChildModelEdit.SetFluxClosureCriterion(const Value: double);
begin
  FFluxClosureCriterion := Value;
end;

procedure TChildModelEdit.SetFluxRelaxationFactor(const Value: double);
begin
  FFluxRelaxationFactor := Value;
end;

procedure TChildModelEdit.SetHeadClosureCriterion(const Value: double);
begin
  FHeadClosureCriterion := Value;
end;

procedure TChildModelEdit.SetHeadRelaxationFactor(const Value: double);
begin
  FHeadRelaxationFactor := Value;
end;

procedure TChildModelEdit.SetLgrPrintChoice(const Value: TLgrPrintChoice);
begin
  FLgrPrintChoice := Value;
end;

procedure TChildModelEdit.SetMaxIterations(const Value: integer);
begin
  FMaxIterations := Value;
end;

procedure TChildModelEdit.SetModelName(const Value: string);
begin
  FModelName := Value;
end;

procedure TChildModelEdit.SetStartingHeadSource(
  const Value: TStartingHeadSource);
begin
  FStartingHeadSource := Value;
end;

{ TChildModelEditCollection }

constructor TChildModelEditCollection.Create;
begin
  inherited Create(TChildModelEdit, nil);
end;

function TChildModelEditCollection.GetItems(Index: integer): TChildModelEdit;
begin
  result := inherited Items[Index] as TChildModelEdit;
end;

procedure TChildModelEditCollection.SetItems(Index: integer;
  const Value: TChildModelEdit);
begin
  inherited Items[Index] := Value;
end;

{ TFontChangeNotifier }

procedure TFontChangeNotifier.Changed;
begin
  FInvalidateModelEvent(self);
end;

constructor TFontChangeNotifier.Create(InvalidateModelEvent: TNotifyEvent; AFont: TFont);
begin
  inherited Create(AFont);
  FInvalidateModelEvent := InvalidateModelEvent;
end;

procedure TCustomModel.SetPathLine(const Value: TPathLineReader);
begin
  if FPathLine = nil then
  begin
    FPathLine := TPathLineReader.Create(self);
  end;
  FPathLine.Assign(Value);
end;

procedure TCustomModel.SetPestObsCollection(const Value: TPestObsCollection);
begin
  FPestObsCollection.Assign(Value);
end;

function TCustomModel.GetPathLine: TPathLineReader;
begin
  if (FPathLine = nil) then
  begin
    FPathLine := TPathLineReader.Create(self);
  end;
  result := FPathLine;
end;

function TCustomModel.GetPestParameterByName(
  PestParamName: string): TModflowSteadyParameter;
var
  ParameterIndex: Integer;
  AParam: TModflowSteadyParameter;
begin
  if FPestParamDictionay = nil then
  begin
    FPestParamDictionay := TDictionary<string, TModflowSteadyParameter>.Create;

    for ParameterIndex := 0 to ModflowSteadyParameters.Count - 1 do
    begin
      AParam := ModflowSteadyParameters[ParameterIndex];
      if AParam.ParameterType = ptPEST then
      begin
        FPestParamDictionay.Add(UpperCase(AParam.ParameterName), AParam);
      end;
    end;
  end;

  if not FPestParamDictionay.TryGetValue(UpperCase(PestParamName), result) then
  begin
    result := nil;
  end;
end;

function TCustomModel.GetPestParameterByNameI(
  PestParamName: string): IModflowParameter;
begin
  result := GetPestParameterByName(PestParamName);
end;

function TCustomModel.GetPestParameterValueByName(PestParamName: string;
  out Value: double): Boolean;
var
  Param: TModflowSteadyParameter;
begin
  Param := GetPestParameterByName(PestParamName);
  result := (Param <> nil);
  if result then
  begin
    Value := Param.Value;
  end;
end;

function TCustomModel.GetPestStatus: TPestStatus;
begin
  result := PestProperties.PestStatus;
end;

function TCustomModel.GetPestUsed: Boolean;
begin
  result := PestProperties.PestUsed;
end;

function TCustomModel.StorePathLine: boolean;
begin
  result := (FPathLine <> nil) and (FPathLine.FileName <> '');
end;

function TCustomModel.StoreTimeSeries: boolean;
begin
  result := (FTimeSeries <> nil) and (FTimeSeries.FileName <> '');
end;

procedure TCustomModel.SetTimeSeries(const Value: TTimeSeriesReader);
begin
  if FTimeSeries = nil then
  begin
    FTimeSeries := TTimeSeriesReader.Create(self);
  end;
  FTimeSeries.Assign(Value);
end;

function TCustomModel.GetTimeSeries: TTimeSeriesReader;
begin
  if (FTimeSeries = nil) then
  begin
    FTimeSeries := TTimeSeriesReader.Create(self);
  end;
  result := FTimeSeries;
end;

function TCustomModel.GetTopContourDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        if Grid <> nil then
        begin
          result := Grid.TopContourDataSet;
        end
      end;
    msModflow2015:
      begin
        if Grid <> nil then
        begin
          result := Grid.TopContourDataSet;
        end
        else if DisvGrid <> nil then
        begin
          result := DisvGrid.TopContourDataSet;
        end
        else
        begin
        result := nil;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          result := SutraMesh.TopContourDataSet;
        end;
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetTopDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msFootPrint, msModflowOwhm2:
      begin
        if Grid <> nil then
        begin
          result := Grid.TopDataSet;
        end
      end;
    msModflow2015:
      begin
        if Grid <> nil then
        begin
          result := Grid.TopDataSet;
        end
        else
        begin
          result := DisvGrid.TopDataSet;
        end;
      end;
    msSutra22, msSutra30, msSutra40:
      begin
        if (Mesh <> nil) then
        begin
          result := SutraMesh.TopDataSet;
        end;
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetTranspirationFractionUsed: TObjectUsedEvent;
begin
  result := DoTranspirationFractionUsed;
end;

function TCustomModel.GetUnitNumbers: TUnitNumbers;
begin
  result := FUnitNumbers;
end;

function TCustomModel.GetUseFootprintWells: TCheckUsageEvent;
begin
  Result := DoUseFootprintWells;
end;

function TCustomModel.GetUzfInitialInfiltrationUsed: TObjectUsedEvent;
begin
  result := DoUzfInitialInfiltrationUsed;
end;

function TCustomModel.GetUzfMf6PackageUsed: TObjectUsedEvent;
begin
  result := DoUzfMf6PackageUsed;
end;

function TCustomModel.GetUzfPackageUsed: TObjectUsedEvent;
begin
  result := DoUzfPackageUsed;
end;

function TCustomModel.GetUzfResidualWaterContentUsed: TObjectUsedEvent;
begin
  result := DoUzfResidualWaterContentUsed;
end;

function TCustomModel.GetUzfSurfKUsed: TObjectUsedEvent;
begin
  result := DoUzfSurfKUsed;
end;

function TCustomModel.GetUzfUnsatVertKUsed: TObjectUsedEvent;
begin
  result := DoUzfUnsatVertKUsed;
end;

function TCustomModel.GetVertAnisotropyMf6Used: TObjectUsedEvent;
begin
  Result := DoVertAnisotropyMf6Used;
end;

function TCustomModel.GetVerticalAnisotropyUsed: TObjectUsedEvent;
begin
  result := DoVerticalAnisotropyUsed;
end;

function TCustomModel.GetVerticalTransverseDispersionUsed: TObjectUsedEvent;
begin
  result := DoVerticalTransverseDispersionUsed;
end;

function TCustomModel.GetVerticalTransverseDispersionUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoVerticalTransverseDispersionUsedPerSpecies;
end;

function TCustomModel.GetViscosityPkgUsedUsed: Boolean;
begin
  Result := ModflowPackages.ViscosityPackage.IsSelected
end;

function TCustomModel.GetViscosityPkgViscUsed: Boolean;
var
  Viscosity: TViscosityPackage;
begin
  Viscosity := ModflowPackages.ViscosityPackage;
  Result := Viscosity.IsSelected and Viscosity.ViscositySpecified;
end;

function TCustomModel.GetWetDryUsed: TObjectUsedEvent;
begin
  result := DoWetDryUsed;
end;

function TCustomModel.GetZetaUsed: TObjectUsedEvent;
begin
  result := DoZetaUsed;
end;

function TCustomModel.GetZoneBudgetSelected: TObjectUsedEvent;
begin
  result := DoZoneBudgetSelected;
end;

function TCustomModel.DoGroundSurfaceUsed(Sender: TObject): boolean;
begin
  result := DoUzfPackageUsed(Sender) or FarmProcessUsed(Sender) or Farm4ProcessUsed(Sender);
end;

function TCustomModel.DoGweCndUsed(Sender: TObject): boolean;
begin
  result := Mf6GweUsed(Sender) and ModflowPackages.GweConductionAndDispersionPackage.IsSelected
end;

function TCustomModel.DoGwRootInteractionUsed(Sender: TObject): Boolean;
begin
  result := (ModelSelection = msModflowOwhm2)
    and ModflowPackages.FarmProcess4.IsSelected
    and ModflowPackages.FarmLandUse.StaticGwRootInteractionArrayUsed(nil);
end;

function TCustomModel.DoGwtDispUsed(Sender: TObject): boolean;
begin
  result := Mf6GwtUsed(Sender) and ModflowPackages.GwtDispersionPackage.IsSelected
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtCombined)
end;

function TCustomModel.DoGwtDispUsedPerSpecies(Sender: TObject): boolean;
begin
  result := Mf6GwtUsed(Sender) and ModflowPackages.GwtDispersionPackage.IsSelected
    and (ModflowPackages.GwtDispersionPackage.SeparateDataSetsForEachSpecies = dtSeparate)
end;

function TCustomModel.DoGwtUztUsed(Sender: TObject): boolean;
begin
  result := GwtUsed and ModflowPackages.UzfMf6Package.IsSelected
end;

function TCustomModel.StoreEndPoints: boolean;
begin
  result := (FEndPoints <> nil) and (FEndPoints.FileName <> '');
end;

function TCustomModel.GetEndPoints: TEndPointReader;
begin
  if (FEndPoints = nil) then
  begin
    FEndPoints := TEndPointReader.Create(self);
  end;
  result := FEndPoints;
end;

function TCustomModel.GetEquilibriumPhasesUsed: TObjectUsedEvent;
begin
  result := DoEquilibriumPhasesUsed;
end;

function TCustomModel.GetEvaporationIrrigationFractionUsed: TObjectUsedEvent;
begin
  result := DoEvaporationIrrigationFractionUsed;
end;

function TCustomModel.GetFarmProcess4SteadArrayAddedDemandRunoffSplitUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadArrayAddedDemandRunoffSplitUsed;
end;

function TCustomModel.GetFarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadArrayBarePrecipitationConsumptionFractionUsed;
end;

function TCustomModel.GetFarmProcess4SteadArrayBareRunoffFractionUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadArrayBareRunoffFractionUsed;
end;

function TCustomModel.GetFarmProcess4SteadArrayEfficiencyImprovementUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadArrayEfficiencyImprovementUsed;
end;

function TCustomModel.GetFarmProcess4SteadArrayEfficiencyUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadArrayEfficiencyUsed;
end;

function TCustomModel.GetFarmProcess4SteadyCropsUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadyCropsUsed;
end;

function TCustomModel.GetFarmProcess4SteadyFarmsUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadyFarmsUsed;
end;

function TCustomModel.GetFarmProcess4SteadyPrecipUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadyPrecipUsed;
end;

function TCustomModel.GetFarmProcess4SteadyRefETUsed: TObjectUsedEvent;
begin
  result := DoFarmProcess4SteadyRefETUsed;
end;

function TCustomModel.GetFilesToArchive: TStrings;
var
  index: Integer;
begin
  for index := FFilesToArchive.Count - 1 downto 0 do
  begin
    if Trim(FFilesToArchive[Index]) = '' then
    begin
      FFilesToArchive.Delete(Index);
    end;
  end;
  result := FFilesToArchive
end;

function TCustomModel.GetFootprintSelected: TObjectUsedEvent;
begin
  result := DoFootprintSelected;
end;

function TCustomModel.GetFractionOfIrrigToSurfaceWaterUsed: TObjectUsedEvent;
begin
  result := DoFractionOfIrrigToSurfaceWaterUsed
end;

function TCustomModel.GetFractionOfPrecipToSurfaceWaterUsed: TObjectUsedEvent;
begin
  result := DoFractionOfPrecipToSurfaceWaterUsed;
end;

function TCustomModel.GetFrontContourDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        if Grid <> nil then
        begin
          result := Grid.FrontContourDataSet;
        end
        else
        begin
          result := nil;
        end;
      end;
    msModflow2015:
      begin
        if Grid <> nil then
        begin
          result := Grid.FrontContourDataSet;
        end
        else if DisvGrid <> nil then
        begin
          result := DisvGrid.FrontContourDataSet;
        end
        else
        begin
          result := nil;
        end;
      end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetFrontDataSet: TDataArray;
begin
  result := nil;
  case ModelSelection of
    msUndefined:
      begin
        result := nil;
      end;
    msPhast, msModflow, msModflowLGR, msModflowLGR2, msModflowNWT,
      msModflowFmp, msModflowCfp, msModflowOwhm2:
      begin
        result := Grid.FrontDataSet;
      end;
    msModflow2015:
      begin
        if Grid <> nil then
        begin
          result := Grid.FrontDataSet;
        end
        else
        begin
          result := DisvGrid.FrontDataSet;
        end;
      end;
    msSutra22, msSutra30, msSutra40, msFootPrint:
      begin
        // do nothing
      end;
    else
       Assert(False);
  end;
end;

function TCustomModel.GetGasPhaseUsed: TObjectUsedEvent;
begin
  result := DoGasPhaseUsed;
end;

function TCustomModel.GetGrid: TCustomModelGrid;
begin
  if ModelSelection in SutraSelection then
  begin
    result := nil;
  end
  else
  begin
    result := FGrid;
    if (result = nil) and (DisvGrid <> nil)
      and (DisvGrid.AssigningQuadRefinement or not DisvUsed)
      and (ModelSelection in ModflowSelection) then
    begin
      result := ModflowGrid;
    end;
  end;
end;

function TCustomModel.GetGridI: ICustomModelGrid;
begin
  result := Grid;
end;

function TCustomModel.GetGroundSurfaceUsed: TObjectUsedEvent;
begin
  result := DoGroundSurfaceUsed;
end;

function TCustomModel.GetGweUsed: Boolean;
begin
  if ModelSelection = msModflow2015 then
  begin
    result := ModflowPackages.GweProcess.IsSelected;
  end
  else
  begin
    result := False;
  end;
end;

function TCustomModel.GetGwRootInteractionUsed: TObjectUsedEvent;
begin
  result := DoGwRootInteractionUsed;
end;

function TCustomModel.GetGwtDispUsed: TObjectUsedEvent;
begin
  result := DoGwtDispUsed;
end;

function TCustomModel.GetGwtDispUsedPerSpecies: TObjectUsedEvent;
begin
  result := DoGwtDispUsedPerSpecies;
end;

function TCustomModel.GetGwtUsed: Boolean;
begin
  if ModelSelection = msModflow2015 then
  begin
    result := ModflowPackages.GwtProcess.IsSelected;
  end
  else
  begin
    result := False;
  end;
end;

function TCustomModel.GetGwtUztUsed: TObjectUsedEvent;
begin
  result := DoGwtUztUsed;
end;

procedure TCustomModel.SetEndPoints(const Value: TEndPointReader);
begin
  if FEndPoints = nil then
  begin
    FEndPoints := TEndPointReader.Create(self);
  end;
  FEndPoints.Assign(Value);
end;

procedure TCustomModel.SetExternalFiles(const Value: TStrings);
begin
  FExternalFiles.Assign(Value);
end;

procedure TCustomModel.SetVelocityVectors(const Value: TVectorCollection);
begin
  FVelocityVectors.Assign(Value);
end;

function TCustomModel.GetExaggeration: double;
begin
  result := 1;
  if (ModelSelection in SutraSelection) and (SutraMesh <> nil) and
    (SutraMesh.MeshType = mtProfile) then
  begin
    if frmGoPhast.frameTopView <> nil then
    begin
      result := frmGoPhast.frameTopView.ZoomBox.Exaggeration;
    end
  end
  else
  begin
    if frmGoPhast.frameFrontView <> nil then
    begin
      result := frmGoPhast.frameFrontView.ZoomBox.Exaggeration;
    end
    else if frmGoPhast.frameSideView <> nil then
    begin
      result := frmGoPhast.frameSideView.ZoomBox.Exaggeration;
    end;
  end;
end;

function TCustomModel.GetExchangeUsed: TObjectUsedEvent;
begin
  result := DoExchangeUsed;
end;

procedure TCustomModel.SetExaggeration(Value: double);
begin
  if Value <= 0 then
  begin
    Value := 1;
  end;
  if Exaggeration <> Value then
  begin
    if (ModelSelection in SutraSelection) and (SutraMesh <> nil) and
      (SutraMesh.MeshType = mtProfile) then
    begin
      if frmGoPhast.frameTopView <> nil then
      begin
        frmGoPhast.frameTopView.ZoomBox.Exaggeration := Value;
      end;
    end
    else
    begin
      if frmGoPhast.frameFrontView <> nil then
      begin
        frmGoPhast.frameFrontView.ZoomBox.Exaggeration := Value;
      end;
      if frmGoPhast.frameSideView <> nil then
      begin
        frmGoPhast.frameSideView.ZoomBox.Exaggeration := Value;
      end;
      frmGoPhast.PhastGrid.GridChanged;
      frmGoPhast.ModflowGrid.GridChanged;
    end;
  end;
end;

function TCustomModel.GetPilotPointCount: integer;
begin
  result := PestProperties.PilotPointCount;
end;

function TCustomModel.GetPorosityUsed: TObjectUsedEvent;
begin
  result := DoPorosityUsed;
end;

function TCustomModel.GetPotentialEvapBareUsed: TObjectUsedEvent;
begin
  result := DoPotentialEvapBareUsed;
end;

function TCustomModel.GetPrecipPotConsumptionUsed: TObjectUsedEvent;
begin
  result := DoPrecipPotConsumptionUsed
end;

function TCustomModel.GetReservoirLayerUsed: TObjectUsedEvent;
begin
  result := DoReservoirLayerUsed;
end;

function TCustomModel.GetReservoirPackageUsed: TObjectUsedEvent;
begin
  result := DoReservoirPackageUsed;
end;

function TCustomModel.GetRootDepthUsed: TObjectUsedEvent;
begin
  result := DoRootDepthUsed;
end;

function TCustomModel.GetRouteUzfDischarge: TObjectUsedEvent;
begin
  result := DoRouteUzfDischarge;
end;

procedure TCustomModel.InvalidateMfSfrReachLength(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrReachLength.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrUpstreamDepth(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrUpstreamDepth.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrDownstreamDepth(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrDownstreamDepth.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrRunoff(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrRunoff.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrPrecipitation(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrPrecipitation.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrFlow(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrFlow.Invalidate;
end;

procedure TCustomModel.InvalidateMfSfrEvapotranspiration(Sender: TObject);
begin
  ModflowPackages.SfrPackage.MfSfrEvapotranspiration.Invalidate;
end;

initialization

  RegisterClass(TPhastModel);
  RegisterClass(TChildModel);

end.
