unit TestRbwParser;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

{$ifdef CONDITIONALEXPRESSIONS}
  {$if CompilerVersion>=20}
    {$DEFINE Delphi_2009_UP}
  {$ifend}
  {$if CompilerVersion>=21}
    {$DEFINE Delphi_XE_UP}
  {$ifend}
{$endif}


interface

uses
  TestFramework, RbwParser, SysUtils, Contnrs, Classes, Types;
type
  // Test methods for class TRbwParser
  TestTRbwParser = class(TTestCase)
  strict private
    FRbwParser: TRbwParser;
  private
    procedure CheckInvalidNumberOfArguments;
    procedure CheckInvalidSquareBrackets;
    procedure CompileTestFormula;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestClearExpressions;
    procedure TestClearVariables;
    procedure TestCreateVariable;
    procedure TestCreateVariable1;
    procedure TestCreateVariable2;
    procedure TestCreateVariable3;
    {$IFDEF Delphi_XE_UP}
    procedure TestCreateVariable4;
    procedure Test_InternationalChar;
    {$ENDIF}
    procedure TestCompile;
    procedure TestDeleteExpression;
    procedure TestExpressionCount;
    procedure TestIndexOfVariable;
    procedure TestRemoveExpression;
    procedure TestRemoveVariable;
    procedure TestRenameVariable;
    procedure TestVariableCount;
    procedure Test_AbsI;
    procedure Test_AbsR;
    procedure Test_Arccos;
    procedure Test_Arccosh;
    procedure Test_Arcsin;
    procedure Test_Arcsinh;
    procedure Test_Arctan2;
    procedure Test_Arctanh;
    procedure Test_Cos;
    procedure Test_Cosh;
    procedure Test_Copy;
    procedure Test_DegToRad;
    procedure Text_Exp;
    procedure Test_FactorialI;
    procedure Test_FactorialR;
    procedure Test_Frac;
    procedure Test_FloatToStr;
    procedure Test_CaseB;
    procedure Test_CaseI;
    procedure Test_CaseR;
    procedure Test_CaseS;
    procedure Test_Case1;
    procedure Test_Case2;
    procedure Test_Case3;
    procedure Test_Case4;
    procedure Test_IfBoolean;
    procedure Test_IfInteger;
    procedure Test_IfDouble;
    procedure Test_IfString;
    procedure Test_If1;
    procedure Test_If2;
    procedure Test_If3;
    procedure Test_If4;
    procedure Test_IntPower;
    procedure Test_IntToStr;
    procedure Test_Length;
    procedure Test_ln;
    procedure Test_log10;
    procedure Test_logN;
    procedure Test_LowerCase;
    procedure Test_MaxI;
    procedure Test_MaxR;
    procedure Test_Max1;
    procedure Test_Max2;
    procedure Test_MinI;
    procedure Test_MinR;
    procedure Test_Min1;
    procedure Test_Min2;
    procedure Test_MultiInterpolate;
    procedure Test_Odd;
    procedure Test_Pos;
    procedure Test_PosEx;
    procedure Test_Power;
    procedure Test_Pi;
    procedure Test_RadToDeg;
    procedure Test_Round;
    procedure Test_Sin;
    procedure Test_Sinh;
    procedure Test_SqrR;
    procedure Test_SqrI;
    procedure Test_Sqr1;
    procedure Test_Sqr2;
    procedure Test_Sqrt;
    procedure Test_StrToInt;
    procedure Test_StrToIntDef;
    procedure Test_StrToFloat;
    procedure Test_StrToFloatDef;
    procedure Test_Tan;
    procedure Test_Tanh;
    procedure Test_Trim;
    procedure Test_Trunc;
    procedure Test_UpperCase;
    procedure Test_Interpolate;
    procedure Test_Distance;
    procedure Test_AndOperator;
    procedure Test_OrOperator;
    procedure Test_XorOperator;
    procedure Test_NotOperator;
    procedure Test_GreaterThanOperator;
    procedure Test_GreaterThanOrEqualOperator;
    procedure Test_LessThanOperator;
    procedure Test_LessThanOrEqualOperator;
    procedure Test_EqualOperator;
    procedure Test_NotEqualOperator;
    procedure Test_PlusIntegerOperator;
    procedure Test_MinusIntegerOperator;
    procedure Test_MultiplyIntegerOperator;
    procedure Test_DivIntegerOperator;
    procedure Test_ModIntegerOperator;
    procedure Test_PlusRealOperator;
    procedure Test_MinusRealOperator;
    procedure Test_MultiplyRealOperator;
    procedure Test_DivideRealOperator;
    procedure Test_PlusStringOperators;
    procedure Test_ArithmeticOperatorPrecedence;
    procedure Test_BooleanOperatorPrecedence;
    procedure Test_CommaConversion;
    procedure Test_CommaConversion2;
    procedure Test_SimpleDecompile;
    procedure Test_NoNumeralBeforeDecimal;
    procedure Test_InvalidExpression;
    procedure Test_Diagram;
    procedure TestAddAndRemoveOperator;
    procedure TestDelete;
    procedure Test_UsesFunction;
    procedure Test_SpecialImplementor;
    procedure TestDisplayNames;
    procedure TestSquareBracketsUsed;
    procedure TestChangedPriority;
    procedure TestOperatorParenthesisSkipped;
    procedure FarmProcessTest;
  end;

implementation

Uses Math, StrUtils;

procedure TestTRbwParser.SetUp;
begin
  FRbwParser := TRbwParser.Create(nil);
  FRbwParser.SquareBracketsAllowed := False;
end;

procedure TestTRbwParser.TearDown;
begin
  FRbwParser.Free;
  FRbwParser := nil;
end;

var
  PowerOperator: TFunctionClass;

procedure TestTRbwParser.TestAddAndRemoveOperator;
const
  NewOperator = '*^*';
  NewOperator2 = '&&';
var
  OperatorDefinition: TOperatorDefinition;
  ArgumentDef: TOperatorArgumentDefinition;
  rR1, rR2: TRealVariable;
//  Index: integer;
  Expression: string;
//  Value: integer;
//  I1, I2: integer;
//  MaxRange: integer;
begin
  try
    OperatorDefinition := TOperatorDefinition.Create;
    OperatorDefinition.OperatorName := NewOperator;
    OperatorDefinition.ArgumentCount := acTwo;
    OperatorDefinition.Precedence := p1;
    OperatorDefinition.SignOperator := False;

    ArgumentDef := TOperatorArgumentDefinition.Create;
    OperatorDefinition.ArgumentDefinitions.Add(ArgumentDef);
    ArgumentDef.FirstArgumentType := rdtDouble;
    ArgumentDef.SecondArgumentType := rdtDouble;
    ArgumentDef.CreationMethod := cmCreate;
    ArgumentDef.FunctionClass := PowerOperator;
    ArgumentDef.OperatorClass := TOperator;

    FRbwParser.AddOperator(OperatorDefinition);
  except
    Check(False, 'Exception adding power operator');
    Exit;
  end;

  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  rR1.Value := 2;
  rR2.Value := 3;

  Expression := 'R1' + NewOperator + 'R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Incorrect result type');
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = Power(2.0,3.0), 'Incorrect result');

  FRbwParser.RemoveOperator(NewOperator);
  Expression := 'R1' + NewOperator + 'R2';
  try
    FRbwParser.Compile(Expression);
    Check(False, 'Failed to remove operator');
  except on ERbwParserError do
    begin
      Check(True);
    end;
  end;

  try
    OperatorDefinition := TOperatorDefinition.Create;
    OperatorDefinition.OperatorName := NewOperator2;
    OperatorDefinition.ArgumentCount := acTwo;
    OperatorDefinition.Precedence := p1;
    OperatorDefinition.SignOperator := False;

    ArgumentDef := TOperatorArgumentDefinition.Create;
    OperatorDefinition.ArgumentDefinitions.Add(ArgumentDef);
    ArgumentDef.FirstArgumentType := rdtDouble;
    ArgumentDef.SecondArgumentType := rdtDouble;
    ArgumentDef.CreationMethod := cmCreate;
    ArgumentDef.FunctionClass := PowerOperator;
    ArgumentDef.OperatorClass := TOperator;

    FRbwParser.AddOperator(OperatorDefinition);
  except
    Check(False, 'Exception adding power operator');
    Exit;
  end;

  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  rR1.Value := 2;
  rR2.Value := 3;

  Expression := 'R1' + NewOperator2 + 'R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Incorrect result type');
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = Power(2.0,3.0), 'Incorrect result');

  FRbwParser.RemoveOperator(NewOperator2);
  Expression := 'R1' + NewOperator2 + 'R2';
  try
    FRbwParser.Compile(Expression);
    Check(False, 'Failed to remove operator');
  except on ERbwParserError do
    begin
      Check(True);
    end;
  end;
end;

var
  AndOperator: TFunctionClass;
  OrOperator: TFunctionClass;

procedure TestTRbwParser.CompileTestFormula;
const
  TestFormula = 'A and B or C and D';
var
  Formula: string;
begin
  Formula := TestFormula;
  FRbwParser.Compile(Formula);
end;

var
  OtherNotEqualsOperator: TFunctionClass;

procedure TestTRbwParser.FarmProcessTest;
const
  TestFormula = 'If(A!=B, C, D)';
  procedure DefineNotEqualsOperator;
  var
    ArgumentDef: TOperatorArgumentDefinition;
    OperatorDefinition: TOperatorDefinition;
  begin
    OperatorDefinition := TOperatorDefinition.Create;
    OperatorDefinition.OperatorName := '!=';
    OperatorDefinition.ArgumentCount := acTwo;
    OperatorDefinition.Precedence := p1;
    OperatorDefinition.SignOperator := False;
    OperatorDefinition.ParenthesesAllowed := False;
    //
    ArgumentDef := TOperatorArgumentDefinition.Create;
    OperatorDefinition.ArgumentDefinitions.Add(ArgumentDef);
    ArgumentDef.FirstArgumentType := rdtBoolean;
    ArgumentDef.SecondArgumentType := rdtBoolean;
    ArgumentDef.CreationMethod := cmCreate;
    ArgumentDef.FunctionClass := OtherNotEqualsOperator;
    ArgumentDef.OperatorClass := TOperator;

    FRbwParser.AddOperator(OperatorDefinition);
  end;
var
  Formula: string;
begin
  FRbwParser.SquareBracketsAllowed := True;
  DefineNotEqualsOperator;

  FRbwParser.CreateVariable('A', '', True, '');
  FRbwParser.CreateVariable('B', '', True, '');
  FRbwParser.CreateVariable('C', '', 1.0, '');
  FRbwParser.CreateVariable('D', '', 2.0, '');

  Formula := TestFormula;
  FRbwParser.Compile(Formula);
  CheckEquals(FRbwParser.CurrentExpression.Decompile, 'If[A != B, C, D]')

end;

procedure TestTRbwParser.TestChangedPriority;
const
  TestFormula = 'A and B or C and D';
var
  DecompiledFormula: string;
  procedure DefineAndOperator;
  var
    OperatorDefinition: TOperatorDefinition;
    ArgumentDef: TOperatorArgumentDefinition;
  begin
    OperatorDefinition := TOperatorDefinition.Create;
    OperatorDefinition.OperatorName := 'AND';
    OperatorDefinition.ArgumentCount := acTwo;
    OperatorDefinition.Precedence := p4;
    OperatorDefinition.SignOperator := False;

    ArgumentDef := TOperatorArgumentDefinition.Create;
    OperatorDefinition.ArgumentDefinitions.Add(ArgumentDef);
    ArgumentDef.FirstArgumentType := rdtBoolean;
    ArgumentDef.SecondArgumentType := rdtBoolean;
    ArgumentDef.CreationMethod := cmCreate;
    ArgumentDef.FunctionClass := AndOperator;
    ArgumentDef.OperatorClass := TOperator;

    FRbwParser.AddOperator(OperatorDefinition);
  end;
  procedure DefineOrOperator;
  var
    ArgumentDef: TOperatorArgumentDefinition;
    OperatorDefinition: TOperatorDefinition;
  begin
    OperatorDefinition := TOperatorDefinition.Create;
    OperatorDefinition.OperatorName := 'OR';
    OperatorDefinition.ArgumentCount := acTwo;
    OperatorDefinition.Precedence := p3;
    OperatorDefinition.SignOperator := False;
    //
    ArgumentDef := TOperatorArgumentDefinition.Create;
    OperatorDefinition.ArgumentDefinitions.Add(ArgumentDef);
    ArgumentDef.FirstArgumentType := rdtBoolean;
    ArgumentDef.SecondArgumentType := rdtBoolean;
    ArgumentDef.CreationMethod := cmCreate;
    ArgumentDef.FunctionClass := OrOperator;
    ArgumentDef.OperatorClass := TOperator;

    FRbwParser.AddOperator(OperatorDefinition);
  end;
begin
  FRbwParser.CreateVariable('A', '', True, '');
  FRbwParser.CreateVariable('B', '', True, '');
  FRbwParser.CreateVariable('C', '', True, '');
  FRbwParser.CreateVariable('D', '', True, '');

  CompileTestFormula;

  DecompiledFormula := FRbwParser.CurrentExpression.Decompile;
  CheckEquals(DecompiledFormula, '(A and B) or (C and D)');

  FRbwParser.ClearExpressions;
  FRbwParser.RemoveOperator('and');
  FRbwParser.RemoveOperator('or');

  CheckException(CompileTestFormula, ERbwParserError);

  DefineAndOperator;
  DefineOrOperator;

  CompileTestFormula;
  DecompiledFormula := FRbwParser.CurrentExpression.Decompile;
  CheckEquals(DecompiledFormula, '(A AND (B OR C)) AND D');

//  CheckNotEquals(DecompiledFormula, FRbwParser.CurrentExpression.Decompile)
end;

procedure TestTRbwParser.TestClearExpressions;
var
  Expression: string;
begin
  if FRbwParser.ExpressionCount = 0 then
  begin
    Expression := '1+2';
    FRbwParser.Compile(Expression);
  end;
  Check(FRbwParser.ExpressionCount > 0, 'Error in counting expressions');

  FRbwParser.ClearExpressions;
  Check(FRbwParser.ExpressionCount = 0, 'Error in clearing expressions');
end;

procedure TestTRbwParser.TestClearVariables;
begin
  if FRbwParser.VariableCount = 0 then
  begin
    FRbwParser.CreateVariable('X', '', True, '');
  end;
  Check(FRbwParser.VariableCount > 0, 'Error counting variables');

  FRbwParser.ClearVariables;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');
end;

procedure TestTRbwParser.TestCreateVariable;
var
  ReturnValue: TCustomVariable;
  TestValue: boolean;
begin
  if FRbwParser.VariableCount > 0 then
  begin
    FRbwParser.ClearVariables;
  end;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');

  ReturnValue := FRbwParser.CreateVariable('X_bool', '', True, '');
  Check(ReturnValue.ResultType = rdtBoolean, 'Error creating boolean variable');
  Check(ReturnValue.BooleanResult = True, 'Error setting boolean variable value');
  Check(ReturnValue.Decompile = 'X_bool', 'Error decompiling variable');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  TestValue := False;
  try
    FRbwParser.CreateVariable('X_bool', '', True, '');
  except on ERbwParserError do
    begin
      TestValue := True;
    end;
  end;
  Check(TestValue, 'Error attempting to create a duplicating variable');
end;

procedure TestTRbwParser.TestCreateVariable1;
var
  ReturnValue: TCustomVariable;
  TestValue: boolean;
begin
  if FRbwParser.VariableCount > 0 then
  begin
    FRbwParser.ClearVariables;
  end;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');

  ReturnValue := FRbwParser.CreateVariable('X_integer', '', 1, '');
  Check(ReturnValue.ResultType = rdtInteger, 'Error creating integer variable');
  Check(ReturnValue.IntegerResult = 1, 'Error setting integer variable value');
  Check(ReturnValue.Decompile = 'X_integer', 'Error decompiling variable');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  TestValue := False;
  try
    FRbwParser.CreateVariable('X_integer', '', 1, '');

  except on ERbwParserError do
    begin
      TestValue := True;
    end;
  end;
  Check(TestValue, 'Error attempting to create a duplicating variable');

end;

procedure TestTRbwParser.TestCreateVariable2;
var
  ReturnValue: TCustomVariable;
  TestValue: boolean;
  Variable: double;
begin
  if FRbwParser.VariableCount > 0 then
  begin
    FRbwParser.ClearVariables;
  end;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');

  Variable := 0.1;
  ReturnValue := FRbwParser.CreateVariable('X_real', '', Variable, '');
  Check(ReturnValue.ResultType = rdtDouble, 'Error creating real variable');
  Variable := 0.1;
  Check(ReturnValue.DoubleResult = Variable, 'Error setting real variable value');
  Check(ReturnValue.Decompile = 'X_real', 'Error decompiling variable');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  TestValue := False;
  try
    FRbwParser.CreateVariable('X_real', '', 0.1, '');

  except on ERbwParserError do
    begin
      TestValue := True;
    end;
  end;
  Check(TestValue, 'Error attempting to create a duplicating variable');
end;

procedure TestTRbwParser.TestCreateVariable3;
var
  ReturnValue: TCustomVariable;
  TestValue: boolean;
begin
  if FRbwParser.VariableCount > 0 then
  begin
    FRbwParser.ClearVariables;
  end;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');

  ReturnValue := FRbwParser.CreateVariable('X_string', '', '1', '');
  Check(ReturnValue.ResultType = rdtString, 'Error creating string variable');
  Check(ReturnValue.StringResult = '1', 'Error setting string variable value');
  Check(ReturnValue.Decompile = 'X_string', 'Error decompiling variable');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  TestValue := False;
  try
    FRbwParser.CreateVariable('X_string', '', '1', '');

  except on ERbwParserError do
    begin
      TestValue := True;
    end;
  end;
  Check(TestValue, 'Error attempting to create a duplicating variable');
end;

{$IFDEF Delphi_XE_UP}
procedure TestTRbwParser.TestCreateVariable4;
var
  ReturnValue: TCustomVariable;
  TestValue: boolean;
begin
  if FRbwParser.VariableCount > 0 then
  begin
    FRbwParser.ClearVariables;
  end;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');

  ReturnValue := FRbwParser.CreateVariable('变量', '', '1', '');
  Check(ReturnValue.ResultType = rdtString, 'Error creating string variable');
  Check(ReturnValue.StringResult = '1', 'Error setting string variable value');
  Check(ReturnValue.Decompile = '变量', 'Error decompiling variable');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  TestValue := False;
  try
    FRbwParser.CreateVariable('变量', '', '1', '');

  except on ERbwParserError do
    begin
      TestValue := True;
    end;
  end;
  Check(TestValue, 'Error attempting to create a duplicating variable');
end;
{$ENDIF}

procedure TestTRbwParser.TestCompile;
var
  RealVariable1: TRealVariable;
  RealVariable2: TRealVariable;
  Expression: string;
  Exp : TExpression;
  Position: integer;
begin
  if FRbwParser.VariableCount > 0 then
  begin
    FRbwParser.ClearVariables;
  end;
  Check(FRbwParser.VariableCount = 0, 'Error counting variables');

  RealVariable1 := FRbwParser.CreateVariable('RealVariable1', '', 1.0, '');
  Check(RealVariable1.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable1.DoubleResult = 1.0, 'Error setting real variable value');
  Check(RealVariable1.Decompile = 'RealVariable1');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  RealVariable2 := FRbwParser.CreateVariable('RealVariable2', '', 2.0, '');
  Check(RealVariable2.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable2.DoubleResult = 2.0, 'Error setting real variable value');
  Check(RealVariable2.Decompile = 'RealVariable2');
  Check(FRbwParser.VariableCount = 2, 'Error counting variables');

  Expression := 'RealVariable1 + RealVariable2';
  Position := FRbwParser.Compile(Expression);
  Check(Position >= 0, 'Error compiling');
  Exp := FRbwParser.CurrentExpression;
  Check(Exp = FRbwParser.Expressions[Position], 'Error accessing expression');
  Check(Exp.ResultType = rdtDouble, 'Error compiling: wrong result type');
  Exp.Evaluate;
  Check(Exp.DoubleResult = 3.0, 'Error evaluating expression');
end;

procedure TestTRbwParser.TestDelete;
var
  Parser: TRbwParser;
begin
  Parser := TRbwParser.Create(nil);
  try
    try
      while Parser.Functions.Count > 0 do
      begin
        Parser.Functions.Delete(0);
      end;
      
    except on E: Exception do
      Check(False, 'Error deleting item');
    end;
  finally
    try
      Parser.Free;
      Check(True);
    except on E: Exception do
      Check(False, 'Error deleting item');
    end;
  end;
end;

procedure TestTRbwParser.TestDeleteExpression;
var
  Index: Integer;
  Expr: string;
begin
  if FRbwParser.ExpressionCount = 0 then
  begin
    Expr := '1/3';
    FRbwParser.Compile(Expr);
  end;

  for Index := FRbwParser.ExpressionCount -1 downto 0  do
  begin
    Check(FRbwParser.ExpressionCount = Index+1, 'Error deleting expressions');
    FRbwParser.DeleteExpression(Index);
    Check(FRbwParser.ExpressionCount = Index, 'Error deleting expressions');
  end;
end;

procedure TestTRbwParser.TestExpressionCount;
var
  ReturnValue: Integer;
  Expr: string;
begin
  ReturnValue := FRbwParser.ExpressionCount;
  Expr := '1/4';
  FRbwParser.Compile(Expr);
  Check(ReturnValue+1 = FRbwParser.ExpressionCount, 'Error counting expressions');
end;

procedure TestTRbwParser.TestIndexOfVariable;
var
  ReturnValue: Integer;
  RealVariable1, RealVariable2: TRealVariable;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');

  RealVariable1 := FRbwParser.CreateVariable('RealVariable1', '', 1.0, '');
  Check(RealVariable1.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable1.DoubleResult = 1.0, 'Error setting real variable value');
  Check(RealVariable1.Decompile = 'RealVariable1');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  RealVariable2 := FRbwParser.CreateVariable('RealVariable2', '', 2.0, '');
  Check(RealVariable2.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable2.DoubleResult = 2.0, 'Error setting real variable value');
  Check(RealVariable2.Decompile = 'RealVariable2');
  Check(FRbwParser.VariableCount = 2, 'Error counting variables');

  ReturnValue := FRbwParser.IndexOfVariable('RealVariable1');
  Check(FRbwParser.Variables[ReturnValue] = RealVariable1, 'Error finding variable');
end;

procedure TestTRbwParser.TestOperatorParenthesisSkipped;
const
  NotEqualsFormaula = 'A != B or C != D';
  procedure DefineNotEqualsOperator;
  var
    ArgumentDef: TOperatorArgumentDefinition;
    OperatorDefinition: TOperatorDefinition;
  begin
    OperatorDefinition := TOperatorDefinition.Create;
    OperatorDefinition.OperatorName := '!=';
    OperatorDefinition.ArgumentCount := acTwo;
    OperatorDefinition.Precedence := p1;
    OperatorDefinition.SignOperator := False;
    OperatorDefinition.ParenthesesAllowed := False;
    //
    ArgumentDef := TOperatorArgumentDefinition.Create;
    OperatorDefinition.ArgumentDefinitions.Add(ArgumentDef);
    ArgumentDef.FirstArgumentType := rdtBoolean;
    ArgumentDef.SecondArgumentType := rdtBoolean;
    ArgumentDef.CreationMethod := cmCreate;
    ArgumentDef.FunctionClass := OtherNotEqualsOperator;
    ArgumentDef.OperatorClass := TOperator;

    FRbwParser.AddOperator(OperatorDefinition);
  end;
var
  TestFormula: string;
begin
  FRbwParser.CreateVariable('A', '', True, '');
  FRbwParser.CreateVariable('B', '', True, '');
  FRbwParser.CreateVariable('C', '', True, '');
  FRbwParser.CreateVariable('D', '', True, '');

  DefineNotEqualsOperator;

  TestFormula := NotEqualsFormaula;
  FRbwParser.Compile(TestFormula);
  CheckEquals(NotEqualsFormaula, FRbwParser.CurrentExpression.Decompile);

end;

procedure TestTRbwParser.TestRemoveExpression;
var
  Expression1: TExpression;
  Exp: string;
begin

  FRbwParser.ClearVariables;
  FRbwParser.ClearExpressions;
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  Exp := '1+2';
  FRbwParser.Compile(Exp);
  Expression1 := FRbwParser.CurrentExpression;
  Check(Expression1.ResultType = rdtInteger, 'Error creating compiling');
  Check(Expression1.DoubleResult = 3, 'Error setting integer expression value');
  Check(FRbwParser.ExpressionCount = 1, 'Error counting expressions');
  FRbwParser.RemoveExpression(Expression1);
  Check(FRbwParser.ExpressionCount = 0, 'Error removing expressions');
end;

procedure TestTRbwParser.TestRemoveVariable;
var
  RealVariable1, RealVariable2: TRealVariable;
  Formula: string;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');

  RealVariable1 := FRbwParser.CreateVariable('RealVariable1', '', 1.0, '');
  Check(RealVariable1.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable1.DoubleResult = 1.0, 'Error setting real variable value');
  Check(RealVariable1.Decompile = 'RealVariable1');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  RealVariable2 := FRbwParser.CreateVariable('RealVariable2', '', 2.0, '');
  Check(RealVariable2.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable2.DoubleResult = 2.0, 'Error setting real variable value');
  Check(RealVariable2.Decompile = 'RealVariable2');
  Check(FRbwParser.VariableCount = 2, 'Error counting variables');

  Formula := 'if(RealVariable2 = 1, RealVariable2, RealVariable1+3)';
  FRbwParser.Compile(Formula);
  Check(FRbwParser.ExpressionCount = 1, 'Error compiling expression');

  FRbwParser.RemoveVariable(RealVariable1);
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');
  Check(FRbwParser.ExpressionCount = 0, 'Error removing variable');
  Check(FRbwParser.Variables[0] = RealVariable2, 'error removing variables');
end;

procedure TestTRbwParser.TestDisplayNames;
var
  RealVariable1, RealVariable2: TRealVariable;
  Position: integer;
  Expression: string;
  Index: Integer;
  b1: double;
  b2: double;
  Value: Double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');

  RealVariable1 := FRbwParser.CreateVariable('RealVariable1', '', 1.0, 'RealVariable5');
  Check(RealVariable1.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable1.DoubleResult = 1.0, 'Error setting real variable value');
  Check(RealVariable1.Decompile = 'RealVariable1', 'Error creating variable');
  Check(RealVariable1.DecompileDisplay = 'RealVariable5', 'Error Setting Display Name');
  Check(FRbwParser.VariableCount = 2, 'Error counting variables');

  RealVariable2 := FRbwParser.CreateVariable('RealVariable2', '', 2.0, '');
  Check(RealVariable2.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable2.DoubleResult = 2.0, 'Error setting real variable value');
  Check(RealVariable2.Decompile = 'RealVariable2');
  Check(FRbwParser.VariableCount = 3, 'Error counting variables');

  Expression := 'RealVariable1 + RealVariable2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');

  for Index := 0 to 100 do
  begin
    b1 := Random(1000);
    b2 := Random(1000);
    RealVariable1.Value := b1;
    RealVariable2.Value := b2;
    Value := b1 + b2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating addition.');
  end;

  Position := FRbwParser.IndexOfVariable('RealVariable1');
  FRbwParser.RenameVariable(Position, 'RealVariable6', 'RealVariable7');
  Check(RealVariable1.Decompile = 'RealVariable6', 'Error renaming variable');
  Check(RealVariable1.DecompileDisplay = 'RealVariable7', 'Error setting DisplayName');

  Expression := 'RealVariable7 + RealVariable2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');

  for Index := 0 to 100 do
  begin
    b1 := Random(1000);
    b2 := Random(1000);
    RealVariable1.Value := b1;
    RealVariable2.Value := b2;
    Value := b1 + b2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating addition.');
  end;

end;

procedure TestTRbwParser.TestRenameVariable;
var
  RealVariable1, RealVariable2: TRealVariable;
  Position: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');

  RealVariable1 := FRbwParser.CreateVariable('RealVariable1', '', 1.0, '');
  Check(RealVariable1.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable1.DoubleResult = 1.0, 'Error setting real variable value');
  Check(RealVariable1.Decompile = 'RealVariable1');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  RealVariable2 := FRbwParser.CreateVariable('RealVariable2', '', 2.0, '');
  Check(RealVariable2.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable2.DoubleResult = 2.0, 'Error setting real variable value');
  Check(RealVariable2.Decompile = 'RealVariable2');
  Check(FRbwParser.VariableCount = 2, 'Error counting variables');

  Position := FRbwParser.IndexOfVariable('RealVariable1');
  FRbwParser.RenameVariable(Position, 'RealVariable3', '');
  Check(RealVariable1.Decompile = 'RealVariable3', 'Error renaming variable');
end;

procedure TestTRbwParser.CheckInvalidSquareBrackets;
const
  IfFormula = 'If[ABoolean, One, Two]';
var
  Formula: string;
begin
  Formula:= IfFormula;
  FRbwParser.Compile(Formula);
end;

procedure TestTRbwParser.TestSquareBracketsUsed;
const
  IfFormula = 'If[ABoolean, One, Two]';
  IfFormula2 = 'If(ABoolean, One, Two)';
  MaxFormula = 'Max[One, Two, Three]';
  MinFormula = 'Min[One, Two, Three]';
var
  Formula: string;
begin
  FRbwParser.SquareBracketsAllowed := True;
  FRbwParser.CreateVariable('ABoolean', '', True, '');
  FRbwParser.CreateVariable('One', '', 1.0, '');
  FRbwParser.CreateVariable('Two', '', 2.0, '');
  FRbwParser.CreateVariable('Three', '', 3.0, '');

  Formula:= IfFormula;
  FRbwParser.Compile(Formula);
  CheckEquals(FRbwParser.CurrentExpression.Decompile, IfFormula);

  Formula:= MaxFormula;
  FRbwParser.Compile(Formula);
  CheckEquals(FRbwParser.CurrentExpression.Decompile, MaxFormula);

  Formula:= MinFormula;
  FRbwParser.Compile(Formula);
  CheckEquals(FRbwParser.CurrentExpression.Decompile, MinFormula);

  Formula:= IfFormula2;
  FRbwParser.Compile(Formula);
  CheckEquals(FRbwParser.CurrentExpression.Decompile, IfFormula);

  FRbwParser.SquareBracketsAllowed := False;

  Formula:= IfFormula2;
  FRbwParser.Compile(Formula);
  CheckEquals(FRbwParser.CurrentExpression.Decompile, IfFormula2);

  CheckException(CheckInvalidSquareBrackets, ERbwParserError);
end;

procedure TestTRbwParser.TestVariableCount;
var
  RealVariable1, RealVariable2: TRealVariable;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');

  RealVariable1 := FRbwParser.CreateVariable('RealVariable1', '', 1.0, '');
  Check(RealVariable1.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable1.DoubleResult = 1.0, 'Error setting real variable value');
  Check(RealVariable1.Decompile = 'RealVariable1');
  Check(FRbwParser.VariableCount = 1, 'Error counting variables');

  RealVariable2 := FRbwParser.CreateVariable('RealVariable2', '', 2.0, '');
  Check(RealVariable2.ResultType = rdtDouble, 'Error creating real variable');
  Check(RealVariable2.DoubleResult = 2.0, 'Error setting real variable value');
  Check(RealVariable2.Decompile = 'RealVariable2');
  Check(FRbwParser.VariableCount = 2, 'Error counting variables');
end;



procedure TestTRbwParser.Test_UpperCase;
const
  LowerCaseLetters = 'abcdefghijklmnopqrstuvwxyz';
var
  sS: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS :=FRbwParser.CreateVariable('S', '', '', '');
  Expression := 'UpperCase(S)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S := '';
    for CharIndex := 1 to 30 do
    begin
      S := S + LowerCaseLetters[Random(26)+1];
    end;
    sS.Value := S;
    Value := UpperCase(S);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating UpperCase.');
  end;
end;

procedure TestTRbwParser.Test_UsesFunction;
var
  Formula: string;
  Expression: TExpression;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  FRbwParser.CreateVariable('RVar', '', 1.0, '');
  Formula := 'Cos(Sin(RVar))';
  FRbwParser.Compile(Formula);
  Expression := FRbwParser.CurrentExpression;
  Check(Expression.ResultType = rdtDouble, 'Error compiling');
  Check(Expression.UsesFunction('COS'), 'Error checking UsesFunction');
  Check(Expression.UsesFunction('sin'), 'Error checking UsesFunction');
  Check(not Expression.UsesFunction('Tan'), 'Error checking UsesFunction');
end;

procedure TestTRbwParser.Test_MinI;
var
  iI1, iI2, iI3: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2, I3: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  iI3 :=FRbwParser.CreateVariable('I3', '', 0, '');
  Expression := 'MinI(I1, I2, I3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    I3 := Random(MAXINT);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    if Random > 0.5 then
    begin
      I3 := -I3;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    iI3.Value := I3;
    value := Min(Min(I1,I2),I3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating MinI.');
  end;
end;

procedure TestTRbwParser.Test_Arccos;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'ArcCos(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*2-1;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := ArcCos(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating ArcCos for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_StrToFloatDef;
const
  Digits = '0123456789';
  Letters = 'abcdefghi0123456789';
var
  sS1: TStringVariable;
  Index: integer;
  Expression: string;
  Value: double;
  S1: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  Expression := 'StrTofloatDef(S1, 0)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 9 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    S1 := S1 + 'e';
    if Random > 0.5 then
    begin
      S1 := S1 + '-';
    end;
    S1 := S1 + Digits[Random(10)+1];
    S1 := Letters[Random(Length(Letters)) + 1] + S1;

    sS1.Value := S1;
    Value := StrToFloatDef(S1, 0);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating StrToFloatDef.');
  end;
  Expression := 'TextTofloatDef(S1, 0)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 9 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    S1 := S1 + 'e';
    if Random > 0.5 then
    begin
      S1 := S1 + '-';
    end;
    S1 := S1 + Digits[Random(10)+1];
    S1 := Letters[Random(Length(Letters)) + 1] + S1;

    sS1.Value := S1;
    Value := StrToFloatDef(S1, 0);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating TextTofloatDef.');
  end;

  sS1.Value := '.5';
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 0.5,
    'Error converting value with initial decimal.');
end;

procedure TestTRbwParser.Test_IfInteger;
var
  bB: TBooleanVariable;
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
  B: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'IfI(B, I1, I2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    bB.Value := B;
    iI1.Value := I1;
    iI2.Value := I2;
    if B then
    begin
      Value := I1;
    end
    else
    begin
      Value := I2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating IfI.');
  end;
end;

procedure TestTRbwParser.Test_Arccosh;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'ArcCosh(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random;
    if Value <> 0 then
    begin
      Value := 1/Value;
      rX.Value := Value;
      FRbwParser.CurrentExpression.Evaluate;
      Value := ArcCosh(Value);
      Check(FRbwParser.CurrentExpression.DoubleResult = Value,
        'Error calculating ArcCos for the real number ' + FloatToStr(Value));
    end;
  end;
end;

procedure TestTRbwParser.Test_StrToInt;
const
  Digits = '0123456789';
var
  sS1: TStringVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  S1: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  Expression := 'StrToInt(S1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 9 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    sS1.Value := S1;
    Value := StrToInt(S1);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating StrToInt.');
  end;
  Expression := 'TextToInt(S1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 9 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    sS1.Value := S1;
    Value := StrToInt(S1);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating TextToInt.');
  end;
end;

procedure TestTRbwParser.Test_IntToStr;
var
  iI: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: string;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  Expression := 'IntToStr(I)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(MAXINT);
    if Random > 0.5 then
    begin
      I := -I;
    end;

    iI.Value := I;

    Value := IntToStr(I);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating IntToStr.');
  end;
  Expression := 'IntToText(I)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(MAXINT);
    if Random > 0.5 then
    begin
      I := -I;
    end;

    iI.Value := I;

    Value := IntToStr(I);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating IntToText.');
  end;
end;

procedure TestTRbwParser.Test_InvalidExpression;
var
  InvalidExpression: string;
  ExceptionRaised: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  InvalidExpression := '1 2';
  ExceptionRaised := False;
  try
    FRbwParser.Compile(InvalidExpression);
  except on ERbwParserError do
    begin
      ExceptionRaised := True;
    end;
  end;
  Check(ExceptionRaised);
end;

procedure TestTRbwParser.Test_Frac;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Frac(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*MAXINT;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Frac(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Frac for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Arctanh;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Arctanh(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*2-1;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := ArcTanh(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Arctanh for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_StrToIntDef;
const
  Digits = '0123456789';
  Letters = 'abcdefghi0123456789';
var
  sS1: TStringVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  S1: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  Expression := 'StrToIntDef(S1, 0)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 8 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    S1 := S1 + Letters[Random(Length(Letters))+1];
    sS1.Value := S1;
    Value := StrToIntDef(S1, 0);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating StrToIntDef.');
  end;
  Expression := 'TextToIntDef(S1, 0)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 8 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    S1 := S1 + Letters[Random(Length(Letters))+1];
    sS1.Value := S1;
    Value := StrToIntDef(S1, 0);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating TextToIntDef.');
  end;
end;

procedure TestTRbwParser.Test_Pos;
var
  sS1: TStringVariable;
  sS2: TStringVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  S1, S2: string;
  CharIndex: integer;
  Position: integer;
  Len: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  Expression := 'Pos(S2, S1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
    end;
    Position := Random(30) + 1;
    Len := Random(15) + 1;
    S2 := Copy(S1, Position, Len);
    sS1.Value := S1;
    sS2.Value := S2;
    Value := Pos(S2, S1);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Pos.');
  end;
end;

procedure TestTRbwParser.Test_PosEx;
var
  sS1: TStringVariable;
  sS2: TStringVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  S1, S2: string;
  CharIndex: integer;
  Position: integer;
  Len: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  FRbwParser.CreateVariable('Offset', '', 31, '');
  Expression := 'PosEx(S2, S1, Offset)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
    end;
    Position := Random(30) + 1;
    Len := Random(15) + 1;
    S2 := Copy(S1, Position, Len);
    S1 := S1 + S1;
    sS1.Value := S1;
    sS2.Value := S2;
    Value := PosEx(S2, S1, 31);

    Check(Value >= 31, 'error checking value');
    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Pos.');
  end;
end;

procedure TestTRbwParser.Test_CaseS;
var
  iI: TIntegerVariable;
  sS1, sS2, sS3: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S1, S2, S3: string;
  I: integer;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  sS3 :=FRbwParser.CreateVariable('S3', '', '', '');
  Expression := 'CaseS(I, S1, S2, S3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    S1 := '';
    S2 := '';
    S3 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
      S2 := S2 + Char(Random(254)+1);
      S3 := S3 + Char(Random(254)+1);
    end;
    iI.Value := I;
    sS1.Value := S1;
    sS2.Value := S2;
    sS3.Value := S3;
    case I of
      1:
        begin
          Value := S1;
        end;
      2:
        begin
          Value := S2;
        end;
      3:
        begin
          Value := S3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating CaseS.');
  end;
end;

procedure TestTRbwParser.Test_RadToDeg;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'RadToDeg(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*MaxInt;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := RadToDeg(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating RadToDeg for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_IfDouble;
var
  bB: TBooleanVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2: double;
  B: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'IfR(B, R1, R2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    bB.Value := B;
    rR1.Value := R1;
    rR2.Value := R2;
    if B then
    begin
      Value := R1;
    end
    else
    begin
      Value := R2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating IfR.');
  end;
end;

procedure TestTRbwParser.Test_DegToRad;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'DegToRad(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*MaxInt;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := DegToRad(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating DegToRad for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Copy;
var
  sX: TStringVariable;
  iStartVar, iLengthVar: TIntegerVariable;
  iStart, ILength: integer;
  Index: integer;
  Expression: string;
  AString: string;
  i: integer;
  Value: string;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sX :=FRbwParser.CreateVariable('x', '', '', '');
  iStartVar :=FRbwParser.CreateVariable('Start', '', 0, '');
  iLengthVar :=FRbwParser.CreateVariable('StringLength', '', 0, '');
  Expression := 'Copy(x,Start,StringLength)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    AString := '';
    for i := 0 to 30 do
    begin
      AString := AString + Char(Random(254)+1);
    end;

    iStart := Random(30);
    iLength := Random(15);

    sX.Value := AString;
    iStartVar.Value := iStart;
    iLengthVar.Value := iLength;

    FRbwParser.CurrentExpression.Evaluate;
    Value := Copy(AString, iStart, iLength);
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error Copy(' + AString + ', ' + IntToStr(iStart) + ', '
      + IntToStr(iLength) + ')');
  end;
end;

procedure TestTRbwParser.Test_MaxR;
var
  rR1, rR2, rR3: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2, R3: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  rR3 :=FRbwParser.CreateVariable('R3', '', 0.0, '');
  Expression := 'MaxR(R1, R2, R3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    R3 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    if Random > 0.5 then
    begin
      R3 := -R3;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    rR3.Value := R3;
    value := Max(Max(R1,R2),R3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating MaxR.');
  end;
end;

procedure TestTRbwParser.Test_logN;
var
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  R1, R2, Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'LogN(R1, R2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*10;
    rR1.Value := R1;
    rR2.Value := R2;
    FRbwParser.CurrentExpression.Evaluate;
    Value := LogN(R1, R2);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating logN');
  end;
end;

procedure TestTRbwParser.Test_CaseI;
var
  iI: TIntegerVariable;
  iI1, iI2, iI3: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2, I3: integer;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  iI3 :=FRbwParser.CreateVariable('I3', '', 0, '');
  Expression := 'CaseI(I, I1, I2, I3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    I3 := Random(MAXINT);
    iI.Value := I;
    iI1.Value := I1;
    iI2.Value := I2;
    iI3.Value := I3;
    Value := 0;
    case I of
      1:
        begin
          Value := I1;
        end;
      2:
        begin
          Value := I2;
        end;
      3:
        begin
          Value := I3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating CaseI.');
  end;
end;

procedure TestTRbwParser.Test_Pi;
var
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  Expression := 'Pi';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  FRbwParser.CurrentExpression.Evaluate;
  Value := Pi;
  Check(FRbwParser.CurrentExpression.DoubleResult = Value,
    'Error calculating Power');
end;

procedure TestTRbwParser.Test_Trunc;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  rValue: double;
  Value: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Trunc(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    rValue := (Random*2-1)*Pi;
    rX.Value := rValue;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Trunc(rValue);
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Trunc for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Sin;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Sin(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*Pi;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sin(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Sin for the real number ' + FloatToStr(Value));
  end;
end;

Function FactorialR(const Int: integer): double;
var
  Index: integer;
begin
  result := 1;
  for Index := 2 to Int do
  begin
    result := result * Index;
  end;
end;

procedure TestTRbwParser.Test_FactorialR;
var
  iX: TIntegerVariable;
  Index: integer;
  Expression: string;
  iValue: integer;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iX :=FRbwParser.CreateVariable('x', '', 0, '');
  Expression := 'FactorialR(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 1 to 30 do
  begin
    iValue := Index;
    iX.Value := iValue;
    FRbwParser.CurrentExpression.Evaluate;
    Value := FactorialR(iValue);
    Check(Abs((FRbwParser.CurrentExpression.DoubleResult-Value)/Value) < 1E-15,
      'Error calculating FactorialR for the integer number ' + IntToStr(Index));
  end;
end;

procedure TestTRbwParser.Test_Interpolate;
var
  rPosition, rDistance1, rDistance2, rValue1, rValue2: TRealVariable;
  Expression: string;
  Expression2: string;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rPosition :=FRbwParser.CreateVariable('Position', '', 0.0, '');
  rDistance1 :=FRbwParser.CreateVariable('Distance1', '', 0.0, '');
  rDistance2 :=FRbwParser.CreateVariable('Distance2', '', 0.0, '');
  rValue1 :=FRbwParser.CreateVariable('Value1', '', 0.0, '');
  rValue2 :=FRbwParser.CreateVariable('Value2', '', 0.0, '');
  Expression := 'Interpolate(Position, Value1, Distance1, Value2, Distance2)';
  Expression2 := Expression;
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  Check(FRbwParser.CurrentExpression.Decompile = Expression2);

  rPosition.Value := 1;
  rDistance1.Value := 0;
  rValue1.Value := 2;
  rDistance2.Value := 2;
  rValue2.Value := 4;

  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 3,
    'Error calculating Interpolate.');

  rPosition.Value := 0;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 2,
    'Error calculating Interpolate.');

  rPosition.Value := 2;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 4,
    'Error calculating Interpolate.');

  rPosition.Value := -2;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 0,
    'Error calculating Interpolate.');

  rPosition.Value := 4;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 6,
    'Error calculating Interpolate.');

end;

procedure TestTRbwParser.Test_Sinh;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Sinh(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*Pi;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sinh(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Sinh for the real number ' + FloatToStr(Value));
  end;
end;

Type
  TMyExpression = class(TExpression)
  end;

function _SpecialResult(Values: array of pointer): Integer;
begin
  result := 1;
end;

function _SpecialResult2(Values: array of pointer): Integer;
begin
  Assert(Length(Values) = 1);
  result := PInteger(Values[0])^ + 1;
end;

procedure TestTRbwParser.Test_SpecialImplementor;
const
  SpecialFunctionName = 'FirstSpecial';
var
  SpecialImplementor1: TSpecialImplementor;
  MyFunction1: TFunctionClass;
  Formula: string;
  SpecialImplementor2: TSpecialImplementor;
  MyFunction2: TFunctionClass;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  FRbwParser.SpecialImplementorList.Clear;

  MyFunction1 := TFunctionClass.Create;
  try
    MyFunction1.InputDataCount := 0;
    MyFunction1.OptionalArguments := 0;
    MyFunction1.IFunctionAddr := _SpecialResult;
    MyFunction1.Name := SpecialFunctionName;
    MyFunction1.Prototype := '';
    MyFunction1.AllowConversionToConstant := False;

    SpecialImplementor1 := TSpecialImplementor.Create;
    try
      SpecialImplementor1.FunctionClass := MyFunction1;
      SpecialImplementor1.Implementor := TMyExpression;

      FRbwParser.SpecialImplementorList.Add(SpecialImplementor1);

      Formula := SpecialFunctionName;
      FRbwParser.Compile(Formula);
      Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.IntegerResult = 1,
        'Error calculating first special formula');

      Formula := SpecialFunctionName + '+1';
      FRbwParser.Compile(Formula);
      Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.IntegerResult = 2,
        'Error calculating first special formula + 1');
    finally
      FRbwParser.SpecialImplementorList.Clear;
      SpecialImplementor1.Free;
    end;

  finally
    MyFunction1.Free;
  end;

  MyFunction2 := TFunctionClass.Create;
  try
    MyFunction2.InputDataCount := 1;
    MyFunction2.OptionalArguments := 0;
    MyFunction2.IFunctionAddr := _SpecialResult2;
    MyFunction2.Name := SpecialFunctionName;
    MyFunction2.Prototype := '';
    MyFunction2.InputDataTypes[0] := rdtInteger;
    MyFunction2.AllowConversionToConstant := False;

    SpecialImplementor2 := TSpecialImplementor.Create;
    try
      SpecialImplementor2.FunctionClass := MyFunction2;
      SpecialImplementor2.Implementor := TMyExpression;

      FRbwParser.SpecialImplementorList.Add(SpecialImplementor2);

      Formula := SpecialFunctionName + '(1)';
      FRbwParser.Compile(Formula);
      Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.IntegerResult = 2,
        'Error calculating second special formula');

      Formula := SpecialFunctionName + '(1)+1';
      FRbwParser.Compile(Formula);
      Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.IntegerResult = 3,
        'Error calculating second special formula + 1');
    finally
      FRbwParser.SpecialImplementorList.Clear;
      SpecialImplementor2.Free;
    end;

  finally
    MyFunction2.Free;
  end;

end;

procedure TestTRbwParser.Test_Power;
var
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  R1, R2, Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'Power(R1, R2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*10;
    rR1.Value := R1;
    rR2.Value := R2;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Power(R1, R2);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Power');
  end;
end;

procedure TestTRbwParser.Test_Odd;
var
  iI1: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  I1: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  Expression := 'Odd(I1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtboolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    iI1.Value := I1;
    value := Odd(I1);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating Odd.');
  end;
end;

procedure TestTRbwParser.Test_SqrR;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'SqrR(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*MAXINT;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sqr(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Sqr for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Length;
var
  sX: TStringVariable;
  Index: integer;
  Expression: string;
  AString: string;
  i: integer;
  Value: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sX :=FRbwParser.CreateVariable('x', '', '', '');
  Expression := 'Length(x)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    AString := '';
    Value := Random(30);
    for i := 1 to Value do
    begin
      AString := AString + Char(Random(254)+1);
    end;

    sX.Value := AString;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error in length');
  end;
  sX.Value := '';
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.IntegerResult = 0,
    'Error in length');
end;

procedure TestTRbwParser.Test_IntPower;
var
  iI: TIntegerVariable;
  rR: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R: double;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  rR :=FRbwParser.CreateVariable('R', '', 0.0, '');
  Expression := 'IntPower(R, I)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(8) -4;
    R := Random*10;
    iI.Value := I;
    rR.Value := R;

    Value := IntPower(R,I);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating IntPower.');
  end;
end;

procedure TestTRbwParser.Test_CaseR;
var
  iI: TIntegerVariable;
  rR1, rR2, rR3: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2, R3: double;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  rR3 :=FRbwParser.CreateVariable('R3', '', 0.0, '');
  Expression := 'CaseR(I, R1, R2, R3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    R3 := Random*MAXINT;
    iI.Value := I;
    rR1.Value := R1;
    rR2.Value := R2;
    rR3.Value := R3;
    Value := 0;
    case I of
      1:
        begin
          Value := R1;
        end;
      2:
        begin
          Value := R2;
        end;
      3:
        begin
          Value := R3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating CaseR.');
  end;
end;

procedure TestTRbwParser.Test_MinR;
var
  rR1, rR2, rR3: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2, R3: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  rR3 :=FRbwParser.CreateVariable('R3', '', 0.0, '');
  Expression := 'MinR(R1, R2, R3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    R3 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    if Random > 0.5 then
    begin
      R3 := -R3;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    rR3.Value := R3;
    value := Min(Min(R1,R2),R3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating MinR.');
  end;
end;

procedure TestTRbwParser.Test_LowerCase;
const
  UpperCaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var
  sS: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS :=FRbwParser.CreateVariable('S', '', '', '');
  Expression := 'LowerCase(S)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S := '';
    for CharIndex := 1 to 30 do
    begin
      S := S + UpperCaseLetters[Random(26)+1];
    end;
    sS.Value := S;
    Value := LowerCase(S);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating LowerCase.');
  end;
end;

procedure TestTRbwParser.Test_MaxI;
var
  iI1, iI2, iI3: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2, I3: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  iI3 :=FRbwParser.CreateVariable('I3', '', 0, '');
  Expression := 'MaxI(I1, I2, I3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    I3 := Random(MAXINT);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    if Random > 0.5 then
    begin
      I3 := -I3;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    iI3.Value := I3;
    value := Max(Max(I1,I2),I3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating MaxI.');
  end;
end;

procedure TestTRbwParser.Test_Cos;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Cos(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*Pi;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Cos(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Cos for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Cosh;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Cosh(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*Pi;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Cosh(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Cosh for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Sqrt;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Sqrt(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*MAXINT;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sqrt(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Sqrt for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.CheckInvalidNumberOfArguments;
var
  Expression: string;
begin
  FRbwParser.ClearVariables;
  FRbwParser.CreateVariable('Position', '', 0.0, '');
  FRbwParser.CreateVariable('Distance1', '', 0.0, '');
  FRbwParser.CreateVariable('Value1', '', 0.0, '');
  FRbwParser.CreateVariable('Value2', '', 0.0, '');
  Expression := 'MultiInterpolate(Position, Value1, Distance1, Value2)';
  FRbwParser.Compile(Expression);
  FRbwParser.CurrentExpression.Evaluate;
end;


procedure TestTRbwParser.Test_MultiInterpolate;
var
  rPosition, rDistance1, rDistance2, rDistance3, rValue1, rValue2, rValue3: TRealVariable;
  Expression: string;

begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rPosition :=FRbwParser.CreateVariable('Position', '', 0.0, '');
  rDistance1 :=FRbwParser.CreateVariable('Distance1', '', 0.0, '');
  rDistance2 :=FRbwParser.CreateVariable('Distance2', '', 0.0, '');
  rDistance3 :=FRbwParser.CreateVariable('Distance3', '', 0.0, '');
  rValue1 :=FRbwParser.CreateVariable('Value1', '', 0.0, '');
  rValue2 :=FRbwParser.CreateVariable('Value2', '', 0.0, '');
  rValue3 :=FRbwParser.CreateVariable('Value3', '', 0.0, '');
  Expression := 'MultiInterpolate(Position, Value1, Distance1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');

  rDistance1.Value := 0;
  rPosition.Value := 1;
  rValue1.Value := 2;

  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 2,
    'Error calculating MultiInterpolate.');

  Expression := 'MultiInterpolate(Position, Value1, Distance1, Value2, Distance2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');

  rPosition.Value := 1;
  rDistance1.Value := 0;
  rValue1.Value := 2;
  rDistance2.Value := 2;
  rValue2.Value := 3;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 2.5,
    'Error calculating MultiInterpolate.');

  rPosition.Value := 1.5;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 2.75,
    'Error calculating MultiInterpolate.');

  Expression := 'MultiInterpolate(Position, Value1, Distance1, Value2, Distance2, Value3, Distance3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');

  rPosition.Value := 1;
  rDistance1.Value := 0;
  rValue1.Value := 1;
  rDistance2.Value := 2;
  rValue2.Value := 3;
  rDistance3.Value := 4;
  rValue3.Value := 5;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 2,
    'Error calculating MultiInterpolate.');

  rPosition.Value := 2;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 3,
    'Error calculating MultiInterpolate.');

  rPosition.Value := 3;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 4,
    'Error calculating MultiInterpolate.');

  rPosition.Value := 4;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 5,
    'Error calculating MultiInterpolate.');

  rPosition.Value := 5;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 5,
    'Error calculating MultiInterpolate.');

  rPosition.Value := 0;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 1,
    'Error calculating MultiInterpolate.');

  rPosition.Value := -1;
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 1,
    'Error calculating MultiInterpolate.');

  CheckException(CheckInvalidNumberOfArguments, ERbwParserError);

end;

Function FactorialI(const Int: integer): integer;
var
  Index: integer;
begin
  result := 1;
  for Index := 2 to Int do
  begin
    result := result * Index;
  end;
end;

procedure TestTRbwParser.Test_FactorialI;
var
  iX: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iX :=FRbwParser.CreateVariable('x', '', 0, '');
  Expression := 'FactorialI(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 1 to 12 do
  begin
    Value := Index;
    iX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := FactorialI(Value);
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating FactorialI for the integer number ' + IntToStr(Index));
  end;
end;

procedure TestTRbwParser.Test_Arcsin;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'ArcSin(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*2-1;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := ArcSin(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating ArcCos for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Diagram;
var
  Expression: string;
  Diagram: TStringList;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  FRbwParser.CreateVariable('x1', '', 0.0, '');
  FRbwParser.CreateVariable('x2', '', 0.0, '');
  FRbwParser.CreateVariable('y1', '', 0.0, '');
  FRbwParser.CreateVariable('y2', '', 0.0, '');
  FRbwParser.CreateVariable('A', '', 0, '');
  Expression := 'Distance(+x1, y1, x2, y2) * (-A + 1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  Diagram := TStringList.Create;
  try
    FRbwParser.CurrentExpression.Diagram(Diagram);
    Check(Diagram.Count = 11, 'Error creating diagram');
    if Diagram.Count < 11 then
    begin
      Exit;
    end;
    Check(Diagram[0] = '*' + #9 + 'Distance(+x1, y1, x2, y2) * (-A + 1)',
      'Error in first line of diagram');
    Check(Diagram[1] = #9'Distance  :: Distance(X1, Y1, X2, Y2)'#9'Distance(+x1, y1, x2, y2)  :: Distance(X1, Y1, X2, Y2)',
      'Error in second line of diagram');
    Check(Diagram[2] = #9#9'+'#9'+x1', 'Error in third line of diagram');
    Check(Diagram[3] = #9#9#9'x1'#9'x1', 'Error in fourth line of diagram');
    Check(Diagram[4] = #9#9 + 'y1' + #9 + 'y1', 'Error in fifth line of diagram');
    Check(Diagram[5] = #9#9 + 'x2' + #9 + 'x2', 'Error in sixth line of diagram');
    Check(Diagram[6] = #9#9 + 'y2' + #9 + 'y2', 'Error in seventh line of diagram');
    Check(Diagram[7] = #9 + '+' + #9 + '(-A + 1)', 'Error in eighth line of diagram');
    Check(Diagram[8] = #9#9 + '-' + #9 + '-A', 'Error in ninth line of diagram');
    Check(Diagram[9] = #9#9#9 + 'A' + #9 + 'A', 'Error in tenth line of diagram');
    Check(Diagram[10] = #9#9 + '1' + #9 + '1', 'Error in eleventh line of diagram');
  finally
    Diagram.Free;
  end;

end;

procedure TestTRbwParser.Test_Distance;
var
  rX1, rX2, rY1, RY2: TRealVariable;
  Index: integer;
  Expression: string;
  x1, x2, y1, y2: double;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX1 :=FRbwParser.CreateVariable('x1', '', 0.0, '');
  rX2 :=FRbwParser.CreateVariable('x2', '', 0.0, '');
  rY1 :=FRbwParser.CreateVariable('y1', '', 0.0, '');
  RY2 :=FRbwParser.CreateVariable('y2', '', 0.0, '');
  Expression := 'Distance(x1,y1, x2, y2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    x1 := Random*MAXINT;
    x2 := Random*MAXINT;
    y1 := Random*MAXINT;
    y2 := Random*MAXINT;
    rX1.Value := x1;
    rX2.Value := x2;
    rY1.Value := y1;
    RY2.Value := y2;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sqrt(Sqr(x1-x2) + Sqr(y1-y2));
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Distance.');
  end;
end;

procedure TestTRbwParser.Test_CaseB;
var
  iI: TIntegerVariable;
  bB1, bB2, bB3: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b1, b2, b3: boolean;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  bB1 :=FRbwParser.CreateVariable('B1', '', False, '');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  bB3 :=FRbwParser.CreateVariable('B3', '', False, '');
  Expression := 'CaseB(I, B1, B2, B3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    b1 := Random > 0.5;
    b2 := Random > 0.5;
    b3 := Random > 0.5;
    iI.Value := I;
    bB1.Value := b1;
    bB2.Value := b2;
    bB3.Value := b3;
    Value := False;
    case I of
      1:
        begin
          Value := b1;
        end;
      2:
        begin
          Value := b2;
        end;
      3:
        begin
          Value := b3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating CaseB.');
  end;
end;

procedure TestTRbwParser.Test_Arcsinh;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'ArcSinh(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random;
    if Value <> 0 then
    begin
      Value := 1/Value;
      rX.Value := Value;
      FRbwParser.CurrentExpression.Evaluate;
      Value := ArcSinh(Value);
      Check(FRbwParser.CurrentExpression.DoubleResult = Value,
        'Error calculating ArcCos for the real number ' + FloatToStr(Value));
    end;
  end;
end;

procedure TestTRbwParser.Test_StrToFloat;
const
  Digits = '0123456789';
var
  sS1: TStringVariable;
  Index: integer;
  Expression: string;
  Value: double;
  S1: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  Expression := 'StrTofloat(S1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 9 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    S1 := S1 + 'e';
    if Random > 0.5 then
    begin
      S1 := S1 + '-';
    end;
    S1 := S1 + Digits[Random(10)+1];

    sS1.Value := S1;
    Value := StrToFloat(S1);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating StrToFloat.');
  end;
  Expression := 'TextTofloat(S1)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    for CharIndex := 1 to 9 do
    begin
      S1 := S1 + Digits[Random(10)+1];
    end;
    S1 := S1 + 'e';
    if Random > 0.5 then
    begin
      S1 := S1 + '-';
    end;
    S1 := S1 + Digits[Random(10)+1];

    sS1.Value := S1;
    Value := StrToFloat(S1);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating TextToFloat.');
  end;

  sS1.Value := '.5';
  FRbwParser.CurrentExpression.Evaluate;
  Check(FRbwParser.CurrentExpression.DoubleResult = 0.5,
    'Error converting value with initial decimal.');

end;

procedure TestTRbwParser.Test_log10;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'log10(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*MAXINT;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := log10(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating log10 for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_ln;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'ln(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*MAXINT;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := ln(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating ln for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_FloatToStr;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  rValue: double;
  sValue: string;
  OldDecimalSeparator: Char;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'FloatToStr(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    rValue := Random*MAXINT;
    rX.Value := rValue;
    FRbwParser.CurrentExpression.Evaluate;
    OldDecimalSeparator := FormatSettings.DecimalSeparator;
    try
      FormatSettings.DecimalSeparator := '.';
      sValue := FloatToStr(rValue);
    finally
      FormatSettings.DecimalSeparator := OldDecimalSeparator;
    end;
    Check(FRbwParser.CurrentExpression.StringResult = sValue,
      'Error calculating FloatToStr for the real number ' + FloatToStr(rValue));
  end;
  Expression := 'FloatToText(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    rValue := Random*MAXINT;
    rX.Value := rValue;
    FRbwParser.CurrentExpression.Evaluate;
    OldDecimalSeparator := FormatSettings.DecimalSeparator;
    try
      FormatSettings.DecimalSeparator := '.';
      sValue := FloatToStr(rValue);
    finally
      FormatSettings.DecimalSeparator := OldDecimalSeparator;
    end;
    Check(FRbwParser.CurrentExpression.StringResult = sValue,
      'Error calculating FloatToText for the real number ' + FloatToStr(rValue));
  end;
end;

procedure TestTRbwParser.Test_Round;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  IntValue: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Round(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random*MaxInt;
    if Random > 0.5 then
    begin
      Value:= -Value;
    end;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    IntValue := Round(Value);
    Check(FRbwParser.CurrentExpression.IntegerResult = IntValue,
      'Error calculating Round for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Tan;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Tan(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*Pi;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Tan(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Tan for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_IfString;
var
  bB: TBooleanVariable;
  sS1, sS2: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S1, S2: string;
  B: boolean;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  Expression := 'IfS(B, S1, S2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    S1 := '';
    S2 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
      S2 := S2 + Char(Random(254)+1);
    end;
    bB.Value := B;
    sS1.Value := S1;
    sS2.Value := S2;
    if B then
    begin
      Value := S1;
    end
    else
    begin
      Value := S2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating IfS.');
  end;
end;

procedure TestTRbwParser.Test_Arctan2;
var
  rX: TRealVariable;
  rY: TRealVariable;
  Index: integer;
  Expression: string;
  ValueY, ValueX: double;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  rY :=FRbwParser.CreateVariable('Y', '', 0.0, '');
  Expression := 'Arctan2(Y,X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    ValueY := (Random - 0.5) * Random(MaxInt);
    ValueX := (Random - 0.5) * Random(MaxInt);
    if ValueX <> 0 then
    begin
      rX.Value := ValueX;
      rY.Value := ValueY;
      FRbwParser.CurrentExpression.Evaluate;
      Value := ArcTan2(ValueY,ValueX);
      Check(FRbwParser.CurrentExpression.DoubleResult = Value,
        'Error calculating Arctan2 for the real number ' + FloatToStr(Value));
    end;
  end;
end;

procedure TestTRbwParser.Test_Tanh;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Tanh(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*Pi;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Tanh(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Tanh for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_SqrI;
var
  iI: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  MaxRange: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('x', '', 0, '');
  Expression := 'SqrI(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  MaxRange := Trunc(Sqrt(MAXINT));
  for Index := 0 to 100 do
  begin
    Value := Random(MaxRange);
    iI.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sqr(Value);
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Sqri for the integer ' + IntToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_AbsI;
var
  iX: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iX :=FRbwParser.CreateVariable('x', '', 0, '');
  Expression := 'AbsI(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random(High(Integer));
    if Random > 0.5 then
    begin
      Value := -Value;
    end;
    iX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Abs(Value),
      'Error calculating Abs for the integer ' + IntToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_AbsR;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.1, '');
  Expression := 'AbsR(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := Random(High(Integer)) + Random;
    if Random > 0.5 then
    begin
      Value := -Value;
    end;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Abs(Value),
      'Error calculating Abs for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Case2;
var
  iI: TIntegerVariable;
  iI1, iI2, iI3: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2, I3: integer;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  iI3 :=FRbwParser.CreateVariable('I3', '', 0, '');
  Expression := 'Case(I, I1, I2, I3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    I3 := Random(MAXINT);
    iI.Value := I;
    iI1.Value := I1;
    iI2.Value := I2;
    iI3.Value := I3;
    Value := 0;
    case I of
      1:
        begin
          Value := I1;
        end;
      2:
        begin
          Value := I2;
        end;
      3:
        begin
          Value := I3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Case.');
  end;
end;

procedure TestTRbwParser.Test_Case3;
var
  iI: TIntegerVariable;
  rR1, rR2, rR3: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2, R3: double;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  rR3 :=FRbwParser.CreateVariable('R3', '', 0.0, '');
  Expression := 'Case(I, R1, R2, R3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    R3 := Random*MAXINT;
    iI.Value := I;
    rR1.Value := R1;
    rR2.Value := R2;
    rR3.Value := R3;
    Value := 0;
    case I of
      1:
        begin
          Value := R1;
        end;
      2:
        begin
          Value := R2;
        end;
      3:
        begin
          Value := R3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Case.');
  end;
end;

procedure TestTRbwParser.Test_Case1;
var
  iI: TIntegerVariable;
  bB1, bB2, bB3: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b1, b2, b3: boolean;
  I: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  bB1 :=FRbwParser.CreateVariable('B1', '', False, '');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  bB3 :=FRbwParser.CreateVariable('B3', '', False, '');
  Expression := 'Case(I, B1, B2, B3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    b1 := Random > 0.5;
    b2 := Random > 0.5;
    b3 := Random > 0.5;
    iI.Value := I;
    bB1.Value := b1;
    bB2.Value := b2;
    bB3.Value := b3;
    Value := false;
    case I of
      1:
        begin
          Value := b1;
        end;
      2:
        begin
          Value := b2;
        end;
      3:
        begin
          Value := b3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating Case.');
  end;
end;

procedure TestTRbwParser.Test_Case4;
var
  iI: TIntegerVariable;
  sS1, sS2, sS3: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S1, S2, S3: string;
  I: integer;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('I', '', 0, '');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  sS3 :=FRbwParser.CreateVariable('S3', '', '', '');
  Expression := 'Case(I, S1, S2, S3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I := Random(2) + 1;
    S1 := '';
    S2 := '';
    S3 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
      S2 := S2 + Char(Random(254)+1);
      S3 := S3 + Char(Random(254)+1);
    end;
    iI.Value := I;
    sS1.Value := S1;
    sS2.Value := S2;
    sS3.Value := S3;
    case I of
      1:
        begin
          Value := S1;
        end;
      2:
        begin
          Value := S2;
        end;
      3:
        begin
          Value := S3;
        end;
    else
      begin
        Assert(False);
      end;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating Case.');
  end;
end;

procedure TestTRbwParser.Test_IfBoolean;
var
  bB: TBooleanVariable;
  bB1, bB2: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b1, b2: boolean;
  B: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  bB1 :=FRbwParser.CreateVariable('B1', '', False, '');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  Expression := 'IfB(B, B1, B2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    b1 := Random > 0.5;
    b2 := Random > 0.5;
    bB.Value := B;
    bB1.Value := b1;
    bB2.Value := b2;
    if B then
    begin
      Value := b1;
    end
    else
    begin
      Value := b2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating IfB.');
  end;
end;

procedure TestTRbwParser.Test_If2;
var
  bB: TBooleanVariable;
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
  B: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'If(B, I1, I2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    bB.Value := B;
    iI1.Value := I1;
    iI2.Value := I2;
    if B then
    begin
      Value := I1;
    end
    else
    begin
      Value := I2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating If.');
  end;
end;

procedure TestTRbwParser.Test_If3;
var
  bB: TBooleanVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2: double;
  B: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'If(B, R1, R2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    bB.Value := B;
    rR1.Value := R1;
    rR2.Value := R2;
    if B then
    begin
      Value := R1;
    end
    else
    begin
      Value := R2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating If.');
  end;
end;

procedure TestTRbwParser.Test_If1;
var
  bB: TBooleanVariable;
  bB1, bB2: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b1, b2: boolean;
  B: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  bB1 :=FRbwParser.CreateVariable('B1', '', False, '');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  Expression := 'If(B, B1, B2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    b1 := Random > 0.5;
    b2 := Random > 0.5;
    bB.Value := B;
    bB1.Value := b1;
    bB2.Value := b2;
    if B then
    begin
      Value := b1;
    end
    else
    begin
      Value := b2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating If.');
  end;
end;

procedure TestTRbwParser.Test_If4;
var
  bB: TBooleanVariable;
  sS1, sS2: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S1, S2: string;
  B: boolean;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  Expression := 'If(B, S1, S2)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    B := Random > 0.5;
    S1 := '';
    S2 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
      S2 := S2 + Char(Random(254)+1);
    end;
    bB.Value := B;
    sS1.Value := S1;
    sS2.Value := S2;
    if B then
    begin
      Value := S1;
    end
    else
    begin
      Value := S2;
    end;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating If.');
  end;
end;

procedure TestTRbwParser.Test_Max2;
var
  rR1, rR2, rR3: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2, R3: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  rR3 :=FRbwParser.CreateVariable('R3', '', 0.0, '');
  Expression := 'Max(R1, R2, R3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    R3 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    if Random > 0.5 then
    begin
      R3 := -R3;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    rR3.Value := R3;
    value := Max(Max(R1,R2),R3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating MaX.');
  end;
end;

procedure TestTRbwParser.Test_Max1;
var
  iI1, iI2, iI3: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2, I3: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  iI3 :=FRbwParser.CreateVariable('I3', '', 0, '');
  Expression := 'Max(I1, I2, I3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    I3 := Random(MAXINT);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    if Random > 0.5 then
    begin
      I3 := -I3;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    iI3.Value := I3;
    value := Max(Max(I1,I2),I3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Max.');
  end;
end;

procedure TestTRbwParser.Test_Min2;
var
  rR1, rR2, rR3: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2, R3: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  rR3 :=FRbwParser.CreateVariable('R3', '', 0.0, '');
  Expression := 'Min(R1, R2, R3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    R3 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    if Random > 0.5 then
    begin
      R3 := -R3;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    rR3.Value := R3;
    value := Min(Min(R1,R2),R3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Min.');
  end;
end;

procedure TestTRbwParser.Test_Min1;
var
  iI1, iI2, iI3: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2, I3: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  iI3 :=FRbwParser.CreateVariable('I3', '', 0, '');
  Expression := 'Min(I1, I2, I3)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    I2 := Random(MAXINT);
    I3 := Random(MAXINT);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    if Random > 0.5 then
    begin
      I3 := -I3;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    iI3.Value := I3;
    value := Min(Min(I1,I2),I3);

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Min.');
  end;
end;

procedure TestTRbwParser.Test_Sqr2;
var
  iI: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  MaxRange: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI :=FRbwParser.CreateVariable('x', '', 0, '');
  Expression := 'Sqr(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  MaxRange := Trunc(Sqrt(MAXINT));
  for Index := 0 to 100 do
  begin
    Value := Random(MaxRange);
    iI.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sqr(Value);
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating Sqr for the integer ' + IntToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_Sqr1;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Sqr(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random*2-1)*MAXINT;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Sqr(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Sqr for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_PlusStringOperators;
var
  sS1, sS2: TStringVariable;
  Index: integer;
  Expression: string;
  Value: string;
  S1, S2: string;
  CharIndex: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  sS1 :=FRbwParser.CreateVariable('S1', '', '', '');
  sS2 :=FRbwParser.CreateVariable('S2', '', '', '');
  Expression := 'S1 + S2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtString, 'Error compiling');
  for Index := 0 to 100 do
  begin
    S1 := '';
    S2 := '';
    for CharIndex := 1 to 30 do
    begin
      S1 := S1 + Char(Random(254)+1);
      S2 := S2 + Char(Random(254)+1);
    end;
    sS1.Value := S1;
    sS2.Value := S2;
    Value := S1+S2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.StringResult = Value,
      'Error calculating +.');
  end;
end;


procedure TestTRbwParser.Test_AndOperator;
var
  bB2, bB3: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b2, b3: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  bB3 :=FRbwParser.CreateVariable('B3', '', False, '');

  Expression := 'B2 and B3';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    b2 := Random > 0.5;
    b3 := Random > 0.5;
    bB2.Value := b2;
    bB3.Value := b3;
    Value := b2 and b3;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating and.');
  end;
end;

procedure TestTRbwParser.Test_OrOperator;
var
  bB2, bB3: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b2, b3: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  bB3 :=FRbwParser.CreateVariable('B3', '', False, '');

  Expression := 'B2 or B3';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    b2 := Random > 0.5;
    b3 := Random > 0.5;
    bB2.Value := b2;
    bB3.Value := b3;
    Value := b2 or b3;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating or.');
  end;
end;

procedure TestTRbwParser.Test_NotOperator;
var
  bB1: TBooleanVariable;
  bB2: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b1: boolean;
  b2: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB1 :=FRbwParser.CreateVariable('B1', '', False, '');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');

  Expression := 'not B1';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    b1 := Random > 0.5;
    bB1.Value := b1;
    Value := not B1;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating not.');
  end;

  Expression := 'not B1 and not B2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    b1 := Random > 0.5;
    bB1.Value := b1;
    b2 := Random > 0.5;
    bB2.Value := b2;
    Value := not b1 and not b2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating not.');
  end;
end;

procedure TestTRbwParser.Test_GreaterThanOperator;
var
  iI1, iI2: TIntegerVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  i1, i2: integer;
  r1, r2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  Expression := 'I1 > I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 > I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >.');
  end;

  Expression := 'R1 > R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 > R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >.');
  end;

  Expression := 'I1 > R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 > r2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >.');
  end;

  Expression := 'R1 > I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 > I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >.');
  end;
end;

procedure TestTRbwParser.Test_LessThanOperator;
var
  iI1, iI2: TIntegerVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  i1, i2: integer;
  r1, r2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  Expression := 'I1 < I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 < I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <.');
  end;

  Expression := 'R1 < R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 < R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <.');
  end;

  Expression := 'I1 < R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 < r2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <.');
  end;

  Expression := 'R1 < I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(MAXINT);
    i2 := Random(MAXINT);
    r1 := Random*MAXINT;
    r2 := random*Maxint;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 < I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <.');
  end;
end;

procedure TestTRbwParser.Test_EqualOperator;
var
  iI1, iI2: TIntegerVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  i1, i2: integer;
  r1, r2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  Expression := 'I1 = I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    if Random > 0.5 then
    begin
      i2 := I1;
    end
    else
    begin
      i2 := Random(10);
    end;

    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 = I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating =.');
  end;

  Expression := 'R1 = R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    if Random > 0.5 then
    begin
      r2 := r1;
    end
    else
    begin
      r2 := random*10;
    end;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 = R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating =.');
  end;

  Expression := 'I1 = R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    if Random > 0.5 then
    begin
      r2 := i1;
    end
    else
    begin
      r2 := random*10;
    end;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 = r2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating =.');
  end;

  Expression := 'R1 = I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    //r1 := Random*10;
    r2 := random*10;
    if Random > 0.5 then
    begin
      r1 := i2;
    end
    else
    begin
      r1 := random*10;
    end;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 = I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating =.');
  end;
end;

procedure TestTRbwParser.Test_GreaterThanOrEqualOperator;
var
  iI1, iI2: TIntegerVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  i1, i2: integer;
  r1, r2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  Expression := 'I1 >= I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 >= I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >=.');
  end;

  Expression := 'R1 >= R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 >= R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >=.');
  end;

  Expression := 'I1 >= R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 >= r2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >=.');
  end;

  Expression := 'R1 >= I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 >= I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating >=.');
  end;
end;

procedure TestTRbwParser.Test_NotEqualOperator;
var
  iI1, iI2: TIntegerVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  i1, i2: integer;
  r1, r2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  Expression := 'I1 <> I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    if Random > 0.5 then
    begin
      i2 := I1;
    end
    else
    begin
      i2 := Random(10);
    end;

    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 <> I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <>.');
  end;

  Expression := 'R1 <> R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    if Random > 0.5 then
    begin
      r2 := r1;
    end
    else
    begin
      r2 := random*10;
    end;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 <> R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <>.');
  end;

  Expression := 'I1 <> R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    if Random > 0.5 then
    begin
      r2 := i1;
    end
    else
    begin
      r2 := random*10;
    end;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 <> r2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <>.');
  end;

  Expression := 'R1 <> I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    //r1 := Random*10;
    r2 := random*10;
    if Random > 0.5 then
    begin
      r1 := i2;
    end
    else
    begin
      r1 := random*10;
    end;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 <> I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <>.');
  end;
end;

procedure TestTRbwParser.Test_LessThanOrEqualOperator;
var
  iI1, iI2: TIntegerVariable;
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  i1, i2: integer;
  r1, r2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');

  Expression := 'I1 <= I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 <= I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <=.');
  end;

  Expression := 'R1 <= R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 <= R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <=.');
  end;

  Expression := 'I1 <= R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := i1 <= r2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <=.');
  end;

  Expression := 'R1 <= I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    i1 := Random(10);
    i2 := Random(10);
    r1 := Random*10;
    r2 := random*10;

    iI1.Value := i1;
    iI2.Value := i2;
    rR1.Value := r1;
    rR2.Value := r2;

    Value := R1 <= I2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating <=.');
  end;
end;

procedure TestTRbwParser.Test_DivIntegerOperator;
var
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'I1 div I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    I2 := Random(10);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    if I2 <> 0 then
    begin
      value := I1 DIV i2;

      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.IntegerResult = Value,
        'Error calculating DIV.');
    end;
  end;
end;

procedure TestTRbwParser.Test_PlusIntegerOperator;
var
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'I1+I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT div 2);
    I2 := Random(MAXINT div 2);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    value := I1+i2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating +.');
  end;
end;

{$IFDEF Delphi_XE_UP}
procedure TestTRbwParser.Test_InternationalChar;
var
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('变量', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('另一个变量', '', 0, '');
  Expression := '变量+另一个变量';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT div 2);
    I2 := Random(MAXINT div 2);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    value := I1+i2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating +.');
  end;
end;
{$ENDIF}

procedure TestTRbwParser.Test_ModIntegerOperator;
var
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'I1 MOD I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT);
    I2 := Random(10);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    if I2 <> 0 then
    begin
      value := I1 MOD i2;

      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.IntegerResult = Value,
        'Error calculating MOD.');
    end;
  end;
end;

procedure TestTRbwParser.Test_MultiplyIntegerOperator;
var
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
  MaxRange: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'I1*I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  MaxRange := Trunc(Sqrt(MAXINT));
  for Index := 0 to 100 do
  begin
    I1 := Random(MaxRange);
    I2 := Random(MaxRange);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    value := I1*i2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating *.');
  end;
end;

procedure TestTRbwParser.Test_MinusIntegerOperator;
var
  iI1, iI2: TIntegerVariable;
  Index: integer;
  Expression: string;
  Value: integer;
  I1, I2: integer;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  iI1 :=FRbwParser.CreateVariable('I1', '', 0, '');
  iI2 :=FRbwParser.CreateVariable('I2', '', 0, '');
  Expression := 'I1-I2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtInteger, 'Error compiling');
  for Index := 0 to 100 do
  begin
    I1 := Random(MAXINT div 2);
    I2 := Random(MAXINT div 2);
    if Random > 0.5 then
    begin
      I1 := -I1;
    end;
    if Random > 0.5 then
    begin
      I2 := -I2;
    end;
    iI1.Value := I1;
    iI2.Value := I2;
    value := I1-i2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.IntegerResult = Value,
      'Error calculating +.');
  end;
end;

procedure TestTRbwParser.Test_PlusRealOperator;
var
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'R1+R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    value := R1+R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating +.');
  end;
end;

procedure TestTRbwParser.Test_MultiplyRealOperator;
var
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'R1*R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    value := R1*R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating *.');
  end;
end;

procedure TestTRbwParser.Test_MinusRealOperator;
var
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'R1-R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    value := R1-R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating -.');
  end;
end;

procedure TestTRbwParser.Test_DivideRealOperator;
var
  rR1, rR2: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  R1, R2: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rR1 :=FRbwParser.CreateVariable('R1', '', 0.0, '');
  rR2 :=FRbwParser.CreateVariable('R2', '', 0.0, '');
  Expression := 'R1/R2';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    R1 := Random*MAXINT;
    R2 := Random*MAXINT;
    if Random > 0.5 then
    begin
      R1 := -R1;
    end;
    if Random > 0.5 then
    begin
      R2 := -R2;
    end;
    rR1.Value := R1;
    rR2.Value := R2;
    value := R1/R2;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating /.');
  end;
end;

procedure TestTRbwParser.Test_XorOperator;
var
  bB2, bB3: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  b2, b3: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bB2 :=FRbwParser.CreateVariable('B2', '', False, '');
  bB3 :=FRbwParser.CreateVariable('B3', '', False, '');

  Expression := 'B2 xor B3';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    b2 := Random > 0.5;
    b3 := Random > 0.5;
    bB2.Value := b2;
    bB3.Value := b3;
    Value := b2 xor b3;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating or.');
  end;
end;

procedure TestTRbwParser.Text_Exp;
var
  rX: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rX :=FRbwParser.CreateVariable('x', '', 0.0, '');
  Expression := 'Exp(X)';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtDouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    Value := (Random)*100;
    rX.Value := Value;
    FRbwParser.CurrentExpression.Evaluate;
    Value := Exp(Value);
    Check(FRbwParser.CurrentExpression.DoubleResult = Value,
      'Error calculating Exp for the real number ' + FloatToStr(Value));
  end;
end;

procedure TestTRbwParser.Test_ArithmeticOperatorPrecedence;
var
  rA, rB, rC, rD, rE: TRealVariable;
  Index: integer;
  Expression: string;
  Value: double;
  Value1, Value2, Value3, Value4: double;
  a,b,c,d,e: double;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  rA :=FRbwParser.CreateVariable('A', '', 0.0, '');
  rB :=FRbwParser.CreateVariable('B', '', 0.0, '');
  rC :=FRbwParser.CreateVariable('C', '', 0.0, '');
  rD :=FRbwParser.CreateVariable('D', '', 0.0, '');
  rE :=FRbwParser.CreateVariable('E', '', 0.0, '');
  Expression := 'A*B+C/D-E';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  for Index := 0 to 100 do
  begin
    a := Random*MAXINT;
    b := Random*MAXINT;
    c := Random*MAXINT;
    d := Random*MAXINT;
    e := Random*MAXINT;
    if Random > 0.5 then
    begin
      a := -a;
    end;
    if Random > 0.5 then
    begin
      b := -b;
    end;
    if Random > 0.5 then
    begin
      c := -c;
    end;
    if Random > 0.5 then
    begin
      d := -d;
    end;
    if Random > 0.5 then
    begin
      e := -e;
    end;
    rA.Value := a;
    rB.Value := b;
    rC.Value := c;
    rD.Value := d;
    rE.Value := e;
    if D <> 0 then
    begin
      value := A*B+C/D-E;
      Value1 := A*B;
      Value2 := C/D;
      Value3 := Value1+Value2;
      Value4 := Value3-E;
      Check((Abs(value-Value4)/Value) < 1e-15, 'precision error');

      FRbwParser.CurrentExpression.Evaluate;
      Check(FRbwParser.CurrentExpression.DoubleResult = Value4,
        'Error calculating precedence.');
    end;
  end;
end;

procedure TestTRbwParser.Test_BooleanOperatorPrecedence;
var
  bA, bB, bC, bD, bE, bF, bG: TBooleanVariable;
  Index: integer;
  Expression: string;
  Value: boolean;
  a,b,c,d,e,f,g: boolean;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  bA :=FRbwParser.CreateVariable('A', '', False, '');
  bB :=FRbwParser.CreateVariable('B', '', False, '');
  bC :=FRbwParser.CreateVariable('C', '', False, '');
  bD :=FRbwParser.CreateVariable('D', '', False, '');
  bE :=FRbwParser.CreateVariable('E', '', False, '');
  bF :=FRbwParser.CreateVariable('F', '', False, '');
  bG :=FRbwParser.CreateVariable('G', '', False, '');
  Expression := 'not A or f = g and not c xor not d and not e or not b';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtBoolean, 'Error compiling');
  for Index := 0 to 100 do
  begin
    a := Random>0.5;
    b := Random>0.5;
    c := Random>0.5;
    d := Random>0.5;
    e := Random>0.5;
    f := Random>0.5;
    g := Random>0.5;
    bA.Value := a;
    bB.Value := b;
    bC.Value := c;
    bD.Value := d;
    bE.Value := e;
    bF.Value := f;
    bG.Value := g;
    Value := not A or f = g and not c xor not d and not e or not b;

    FRbwParser.CurrentExpression.Evaluate;
    Check(FRbwParser.CurrentExpression.BooleanResult = Value,
      'Error calculating precedence ' + FRbwParser.CurrentExpression.Decompile);
  end;
end;

procedure TestTRbwParser.Test_CommaConversion;
var
  OldDecSep: char;
  ResultString: string;
  Expression: string;
begin
  OldDecSep := FormatSettings.DecimalSeparator;
  try
    FormatSettings.DecimalSeparator := '.';
    FRbwParser.ClearVariables;
    FRbwParser.ClearExpressions;
    FRbwParser.CreateVariable('R', '', 0.5, '');
    Expression := 'FloatToStr(R)';
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    ResultString := FRbwParser.CurrentExpression.StringResult;

    FormatSettings.DecimalSeparator := ',';
    FRbwParser.ClearVariables;
    FRbwParser.ClearExpressions;
    FRbwParser.CreateVariable('R', '', 0.5, '');
    Expression := 'FloatToStr(R)';
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    Check(ResultString = FRbwParser.CurrentExpression.StringResult, 'Conversion consistency failed');
  finally
    FormatSettings.DecimalSeparator := OldDecSep;
  end;
end;

procedure TestTRbwParser.Test_CommaConversion2;
var
  OldDecSep: char;
  ResultValue: double;
  Expression: string;
begin
  OldDecSep := FormatSettings.DecimalSeparator;
  try
    FormatSettings.DecimalSeparator := '.';
    FRbwParser.ClearVariables;
    FRbwParser.ClearExpressions;
    FRbwParser.CreateVariable('S', '', '0.5', '');
    Expression := 'StrToFloat(S)';
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    ResultValue := FRbwParser.CurrentExpression.DoubleResult;

    FormatSettings.DecimalSeparator := ',';
    FRbwParser.ClearVariables;
    FRbwParser.ClearExpressions;
    FRbwParser.CreateVariable('S', '', '0.5', '');
    Expression := 'StrToFloat(S)';
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    Check(ResultValue = FRbwParser.CurrentExpression.DoubleResult, 'Conversion consistency failed');
  finally
    FormatSettings.DecimalSeparator := OldDecSep;
  end;
end;

procedure TestTRbwParser.Test_SimpleDecompile;
var
  Expression: string;
begin
  FRbwParser.ClearVariables;
  Check(FRbwParser.ExpressionCount = 0, 'Error clearing variables');
  Check(FRbwParser.VariableCount = 0, 'Error clearing variables');
  FRbwParser.CreateVariable('A', '', 0.0, '');
  FRbwParser.CreateVariable('B', '', 0.0, '');
  FRbwParser.CreateVariable('C', '', 0.0, '');
  Expression := 'A*B';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  Check(FRbwParser.CurrentExpression.Decompile = 'A * B');
  Expression := 'A+B*C';
  FRbwParser.Compile(Expression);
  Check(FRbwParser.CurrentExpression.ResultType = rdtdouble, 'Error compiling');
  Check(FRbwParser.CurrentExpression.Decompile = 'A + (B * C)');
end;

procedure TestTRbwParser.Test_NoNumeralBeforeDecimal;
var
  ResultValue: double;
  Expression: string;
  DecompileResult: string;
begin
  Expression := '.5 + .5';
  try
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    ResultValue := FRbwParser.CurrentExpression.DoubleResult;
  except on ERbwParserError do
    begin
      Check(False, 'Initial decimals fails with Exception');
      Exit;
    end;
  end;
  Check(ResultValue = 1, 'Initial decimals fail');

  Expression := '.5';
  try
    FRbwParser.Compile(Expression);
    DecompileResult := FRbwParser.CurrentExpression.Decompile;
  except on ERbwParserError do
    begin
      Check(False, 'Initial decimals fails with Exception');
      Exit;
    end;
  end;
  Check(DecompileResult = '0.5', 'Initial decimals fail');
end;

procedure TestTRbwParser.Test_Trim;
var
  Expression: string;
  ResultValue: string;
begin
  Expression := 'Trim(" ")';
  try
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    ResultValue := FRbwParser.CurrentExpression.StringResult;
  except on ERbwParserError do
    begin
      Check(False, 'Trim fails with Exception');
      Exit;
    end;
  end;
  Check(ResultValue = '', 'Trim fails');
  Expression := 'Trim("'#9#10#13' ")';
  try
    FRbwParser.Compile(Expression);
    FRbwParser.CurrentExpression.Evaluate;
    ResultValue := FRbwParser.CurrentExpression.StringResult;
  except on ERbwParserError do
    begin
      Check(False, 'Trim fails with Exception');
      Exit;
    end;
  end;
  Check(ResultValue = '', 'Trim fails');
end;

function _TestPower(Values: array of pointer): double;
begin
  result := Power(PDouble(Values[0])^, PDouble(Values[1])^);
end;

function _And(Values: array of pointer): Boolean;
begin
  result := PBoolean(Values[0])^ and PBoolean(Values[1])^;
end;

function _Or(Values: array of pointer): Boolean;
begin
  result := PBoolean(Values[0])^ or PBoolean(Values[1])^;
end;

function _NotEquals(Values: array of pointer): Boolean;
begin
  result := PBoolean(Values[0])^ <> PBoolean(Values[1])^;
end;

{ TMyExpression }

initialization
  PowerOperator:= TFunctionClass.Create;
  PowerOperator.AllowConversionToConstant := True;
  PowerOperator.InputDataCount := 2;
  PowerOperator.InputDataTypes[0] := rdtDouble;
  PowerOperator.InputDataTypes[1] := rdtDouble;
  PowerOperator.Name := '**';
  PowerOperator.Prototype := '';
  PowerOperator.OptionalArguments := 0;
  PowerOperator.RFunctionAddr := _TestPower;

  AndOperator := TFunctionClass.Create;
  AndOperator.AllowConversionToConstant := True;
  AndOperator.InputDataCount := 2;
  AndOperator.InputDataTypes[0] := rdtBoolean;
  AndOperator.InputDataTypes[1] := rdtBoolean;
  AndOperator.Name := 'AND';
  AndOperator.Prototype := '';
  AndOperator.OptionalArguments := 0;
  AndOperator.BFunctionAddr := _And;

  OrOperator := TFunctionClass.Create;
  OrOperator.AllowConversionToConstant := True;
  OrOperator.InputDataCount := 2;
  OrOperator.InputDataTypes[0] := rdtBoolean;
  OrOperator.InputDataTypes[1] := rdtBoolean;
  OrOperator.Name := 'OR';
  OrOperator.Prototype := '';
  OrOperator.OptionalArguments := 0;
  OrOperator.BFunctionAddr := _Or;

  OtherNotEqualsOperator := TFunctionClass.Create;
  OtherNotEqualsOperator.AllowConversionToConstant := True;
  OtherNotEqualsOperator.InputDataCount := 2;
  OtherNotEqualsOperator.InputDataTypes[0] := rdtBoolean;
  OtherNotEqualsOperator.InputDataTypes[1] := rdtBoolean;
  OtherNotEqualsOperator.Name := '!=';
  OtherNotEqualsOperator.Prototype := '';
  OtherNotEqualsOperator.OptionalArguments := 0;
  OtherNotEqualsOperator.BFunctionAddr := _NotEquals;


  // Register any test cases with the test runner
  RegisterTest(TestTRbwParser.Suite);
  Randomize;

finalization
  PowerOperator.Free;
  AndOperator.Free;
  OrOperator.Free;
  OtherNotEqualsOperator.Free;

end.

